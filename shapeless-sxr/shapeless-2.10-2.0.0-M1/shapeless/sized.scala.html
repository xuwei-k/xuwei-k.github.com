<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>shapeless/sized.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (c) 2011-13 Miles Sabin 
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span class="keyword">package</span> shapeless

<span class="keyword">import</span> scala.collection.<span class="delimiter">{</span> GenTraversable, GenTraversableLike <span class="delimiter">}</span>
<span class="keyword">import</span> scala.collection.generic.<span class="delimiter">{</span> CanBuildFrom, IsTraversableLike <span class="delimiter">}</span>

<span class="comment">/**
 * Wrapper for a collection type witnessing that it has the statically specified length. Can be
 * applied to any type which can be viewed as a `GenTraversableLike`, ie. standard collections,
 * `Array`s, `String`s etc.
 * 
 * @author Miles Sabin
 */</span>
<span class="keyword">final</span> <span class="keyword">class</span> <a href="#shapeless;Sized.unsized" title="class Sized[+Repr, L &lt;: shapeless.Nat] extends AnyVal" id="shapeless;Sized.equals">Sized</a><span class="delimiter">[</span>+<a title="" id="shapeless;Sized;Repr">Repr</a>, <a title=" &lt;: shapeless.Nat" id="shapeless;Sized;L">L</a> &lt;: Nat<span class="delimiter">]</span><a href="#shapeless;Sized.equals" title="shapeless.Sized[Repr,L]" class="delimiter">(</a><span class="keyword">val</span> <a title="Repr" id="shapeless;Sized.unsized">unsized</a> : <a href="#shapeless;Sized;Repr" title="Repr">Repr</a><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="AnyVal">AnyVal</span>

<span class="comment">/**
 * Carrier for `Sized` operations.
 * 
 * These operations are implemented here as extension methods of the minimal `Sized` type to avoid issues that would
 * otherwise be caused by its covariance.
 * 
 * @author Miles Sabin
 */</span>
<span class="keyword">class</span> <a title="class SizedOps[A, Repr, L &lt;: shapeless.Nat] extends AnyRef" id="shapeless;SizedOps">SizedOps</a><span class="delimiter">[</span><a title="" id="shapeless;SizedOps;A">A</a>, <a title="" id="shapeless;SizedOps;Repr">Repr</a>, <a title=" &lt;: shapeless.Nat" id="shapeless;SizedOps;L">L</a> &lt;: Nat<span class="delimiter">]</span><a href="#shapeless;SizedOps" title="shapeless.SizedOps[A,Repr,L]" class="delimiter">(</a><a title="scala.collection.GenTraversableLike[A,Repr]" id="shapeless;SizedOps.r">r</a> : <span title="scala.collection.GenTraversableLike[A,Repr]">GenTraversableLike</span><span class="delimiter">[</span>A, Repr<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span> outer =&gt;
  <span class="keyword">import</span> <a href="package.scala.html#shapeless.package.nat" title="=&gt; shapeless.Nat.type">nat</a>._
  <span class="keyword">import</span> ops.<a href="ops/nat.scala.html#shapeless.ops.nat" title="shapeless.ops.nat.type">nat</a>._
  <span class="keyword">import</span> <a href="ops/nat.scala.html#shapeless.ops.nat.LT" title="shapeless.ops.nat.LT.type">LT</a>._
  <span class="keyword">import</span> <a href="#shapeless.Sized" title="shapeless.Sized.type">Sized</a>.wrap
  
  <span class="comment">/**
   * Returns the head of this collection. Available only if there is evidence that this collection has at least one
   * element.
   */</span>
  <span class="keyword">def</span> <a title="(implicit ev: shapeless.ops.nat.LT.&lt;[shapeless._0,L])A" id="shapeless;SizedOps.head">head</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.nat.LT.&lt;[shapeless._0,L]" id="shapeless;SizedOps.head.ev">ev</a> : _0 <a href="ops/nat.scala.html#shapeless.ops.nat;LT" title="shapeless.ops.nat.LT.&lt;[shapeless._0,L]">&lt;</a> L<span class="delimiter">)</span> : <a href="#shapeless;SizedOps;A" title="A">A</a> = <a href="#shapeless;SizedOps.r" title="scala.collection.GenTraversableLike[A,Repr]">r</a>.<span title="=&gt; A">head</span>
  
  <span class="comment">/**
   * Returns the tail of this collection. Available only if there is evidence that this collection has at least one
   * element.
   */</span>
  <span class="keyword">def</span> <a title="(implicit pred: shapeless.ops.nat.Pred[L])shapeless.Sized[Repr,pred.Out]" id="shapeless;SizedOps.tail">tail</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.nat.Pred[L]" id="shapeless;SizedOps.tail.pred">pred</a> : <a href="ops/nat.scala.html#shapeless.ops.nat;Pred" title="shapeless.ops.nat.Pred[L]">Pred</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Sized.wrap" title="[Repr, L &lt;: shapeless.Nat](r: Repr)shapeless.Sized[Repr,L]">wrap</a><span title="(r: Repr)shapeless.Sized[Repr,pred.Out]" class="delimiter">[</span><a href="#shapeless;SizedOps;Repr" title="Repr">Repr</a>, pred.<a href="ops/nat.scala.html#shapeless.ops.nat;Pred;Out" title="pred.Out">Out</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless;SizedOps.r" title="scala.collection.GenTraversableLike[A,Repr]">r</a>.<span title="=&gt; Repr">tail</span><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Returns the first ''m'' elements of this collection. An explicit type argument must be provided. Available only if
   * there is evidence that this collection has at least ''m'' elements. The resulting collection will be statically
   * known to have ''m'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[M &lt;: shapeless.Nat](implicit diff: shapeless.ops.nat.Diff[L,M], implicit ev: shapeless.ops.nat.ToInt[M])shapeless.Sized[Repr,M]" id="shapeless;SizedOps.take(ec3c6ecfa3)">take</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless;SizedOps.take(ec3c6ecfa3);M">M</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.nat.Diff[L,M]" id="shapeless;SizedOps.take(ec3c6ecfa3).diff">diff</a> : <a href="ops/nat.scala.html#shapeless.ops.nat;Diff" title="shapeless.ops.nat.Diff[L,M]">Diff</a><span class="delimiter">[</span>L, M<span class="delimiter">]</span>, <a title="shapeless.ops.nat.ToInt[M]" id="shapeless;SizedOps.take(ec3c6ecfa3).ev">ev</a> : <a href="ops/nat.scala.html#shapeless.ops.nat;ToInt" title="shapeless.ops.nat.ToInt[M]">ToInt</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Sized.wrap" title="[Repr, L &lt;: shapeless.Nat](r: Repr)shapeless.Sized[Repr,L]">wrap</a><span title="(r: Repr)shapeless.Sized[Repr,M]" class="delimiter">[</span><a href="#shapeless;SizedOps;Repr" title="Repr">Repr</a>, <a href="#shapeless;SizedOps.take(ec3c6ecfa3);M" title="M">M</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless;SizedOps.r" title="scala.collection.GenTraversableLike[A,Repr]">r</a>.<span title="(n: Int)Repr">take</span><span class="delimiter">(</span><a href="nat.scala.html#shapeless.Nat.toInt(23c8187052)" title="[N &lt;: shapeless.Nat](implicit toIntN: shapeless.ops.nat.ToInt[N])Int">toInt</a><a href="#shapeless;SizedOps.take(ec3c6ecfa3).ev" title="(implicit toIntN: shapeless.ops.nat.ToInt[M])Int" class="delimiter">[</a><a href="#shapeless;SizedOps.take(ec3c6ecfa3);M" title="M">M</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Returns the first ''m'' elements of this collection. Available only if there is evidence that this collection has
   * at least ''m'' elements. The resulting collection will be statically known to have ''m'' elements.
   */</span>
  <span class="keyword">def</span> <a title="(m: shapeless.Nat)(implicit diff: shapeless.ops.nat.Diff[L,m.N], implicit ev: shapeless.ops.nat.ToInt[m.N])shapeless.Sized[Repr,m.N]" id="shapeless;SizedOps.take(264bbd0b27)">take</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless;SizedOps.take(264bbd0b27).m">m</a> : <a href="nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.nat.Diff[L,m.N]" id="shapeless;SizedOps.take(264bbd0b27).diff">diff</a> : <a href="ops/nat.scala.html#shapeless.ops.nat;Diff" title="shapeless.ops.nat.Diff[L,m.N]">Diff</a><span class="delimiter">[</span>L, m.N<span class="delimiter">]</span>, <a title="shapeless.ops.nat.ToInt[m.N]" id="shapeless;SizedOps.take(264bbd0b27).ev">ev</a> : <a href="ops/nat.scala.html#shapeless.ops.nat;ToInt" title="shapeless.ops.nat.ToInt[m.N]">ToInt</a><span class="delimiter">[</span>m.N<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Sized.wrap" title="[Repr, L &lt;: shapeless.Nat](r: Repr)shapeless.Sized[Repr,L]">wrap</a><span title="(r: Repr)shapeless.Sized[Repr,m.N]" class="delimiter">[</span><a href="#shapeless;SizedOps;Repr" title="Repr">Repr</a>, m.<a href="nat.scala.html#shapeless;Nat;N" title="m.N">N</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless;SizedOps.r" title="scala.collection.GenTraversableLike[A,Repr]">r</a>.<span title="(n: Int)Repr">take</span><span class="delimiter">(</span><a href="nat.scala.html#shapeless.Nat.toInt(23c8187052)" title="[N &lt;: shapeless.Nat](implicit toIntN: shapeless.ops.nat.ToInt[N])Int">toInt</a><a href="#shapeless;SizedOps.take(264bbd0b27).ev" title="(implicit toIntN: shapeless.ops.nat.ToInt[m.N])Int" class="delimiter">[</a>m.<a href="nat.scala.html#shapeless;Nat;N" title="m.N">N</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns all but the  first ''m'' elements of this collection. An explicit type argument must be provided. Available
   * only if there is evidence that this collection has at least ''m'' elements. The resulting collection will be 
   * statically known to have ''m'' less elements than this collection.
   */</span>
  <span class="keyword">def</span> <a title="[M &lt;: shapeless.Nat](implicit diff: shapeless.ops.nat.Diff[L,M], implicit ev: shapeless.ops.nat.ToInt[M])shapeless.Sized[Repr,diff.Out]" id="shapeless;SizedOps.drop(b0bdb88380)">drop</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless;SizedOps.drop(b0bdb88380);M">M</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.nat.Diff[L,M]" id="shapeless;SizedOps.drop(b0bdb88380).diff">diff</a> : <a href="ops/nat.scala.html#shapeless.ops.nat;Diff" title="shapeless.ops.nat.Diff[L,M]">Diff</a><span class="delimiter">[</span>L, M<span class="delimiter">]</span>, <a title="shapeless.ops.nat.ToInt[M]" id="shapeless;SizedOps.drop(b0bdb88380).ev">ev</a> : <a href="ops/nat.scala.html#shapeless.ops.nat;ToInt" title="shapeless.ops.nat.ToInt[M]">ToInt</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Sized.wrap" title="[Repr, L &lt;: shapeless.Nat](r: Repr)shapeless.Sized[Repr,L]">wrap</a><span title="(r: Repr)shapeless.Sized[Repr,diff.Out]" class="delimiter">[</span><a href="#shapeless;SizedOps;Repr" title="Repr">Repr</a>, diff.<a href="ops/nat.scala.html#shapeless.ops.nat;Diff;Out" title="diff.Out">Out</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless;SizedOps.r" title="scala.collection.GenTraversableLike[A,Repr]">r</a>.<span title="(n: Int)Repr">drop</span><span class="delimiter">(</span><a href="nat.scala.html#shapeless.Nat.toInt(23c8187052)" title="[N &lt;: shapeless.Nat](implicit toIntN: shapeless.ops.nat.ToInt[N])Int">toInt</a><a href="#shapeless;SizedOps.drop(b0bdb88380).ev" title="(implicit toIntN: shapeless.ops.nat.ToInt[M])Int" class="delimiter">[</a><a href="#shapeless;SizedOps.drop(b0bdb88380);M" title="M">M</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Returns all but the  first ''m'' elements of this collection. Available only if there is evidence that this
   * collection has at least ''m'' elements. The resulting collection will be statically known to have ''m'' less
   * elements than this collection.
   */</span>
  <span class="keyword">def</span> <a title="(m: shapeless.Nat)(implicit diff: shapeless.ops.nat.Diff[L,m.N], implicit ev: shapeless.ops.nat.ToInt[m.N])shapeless.Sized[Repr,diff.Out]" id="shapeless;SizedOps.drop(83db873e9d)">drop</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless;SizedOps.drop(83db873e9d).m">m</a> : <a href="nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.nat.Diff[L,m.N]" id="shapeless;SizedOps.drop(83db873e9d).diff">diff</a> : <a href="ops/nat.scala.html#shapeless.ops.nat;Diff" title="shapeless.ops.nat.Diff[L,m.N]">Diff</a><span class="delimiter">[</span>L, m.N<span class="delimiter">]</span>, <a title="shapeless.ops.nat.ToInt[m.N]" id="shapeless;SizedOps.drop(83db873e9d).ev">ev</a> : <a href="ops/nat.scala.html#shapeless.ops.nat;ToInt" title="shapeless.ops.nat.ToInt[m.N]">ToInt</a><span class="delimiter">[</span>m.N<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Sized.wrap" title="[Repr, L &lt;: shapeless.Nat](r: Repr)shapeless.Sized[Repr,L]">wrap</a><span title="(r: Repr)shapeless.Sized[Repr,diff.Out]" class="delimiter">[</span><a href="#shapeless;SizedOps;Repr" title="Repr">Repr</a>, diff.<a href="ops/nat.scala.html#shapeless.ops.nat;Diff;Out" title="diff.Out">Out</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless;SizedOps.r" title="scala.collection.GenTraversableLike[A,Repr]">r</a>.<span title="(n: Int)Repr">drop</span><span class="delimiter">(</span><a href="nat.scala.html#shapeless.Nat.toInt(23c8187052)" title="[N &lt;: shapeless.Nat](implicit toIntN: shapeless.ops.nat.ToInt[N])Int">toInt</a><a href="#shapeless;SizedOps.drop(83db873e9d).ev" title="(implicit toIntN: shapeless.ops.nat.ToInt[m.N])Int" class="delimiter">[</a>m.<a href="nat.scala.html#shapeless;Nat;N" title="m.N">N</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Splits this collection at the ''mth'' element, returning the prefix and suffix as a pair. An explicit type argument
   * must be provided. Available only if there is evidence that this collection has at least ''m'' elements. The
   * resulting collections will be statically know to have ''m'' and ''n-m'' elements respectively.
   */</span>
  <span class="keyword">def</span> <a title="[M &lt;: shapeless.Nat](implicit diff: shapeless.ops.nat.Diff[L,M], implicit ev: shapeless.ops.nat.ToInt[M])(shapeless.Sized[Repr,M], shapeless.Sized[Repr,diff.Out])" id="shapeless;SizedOps.splitAt(38a80a0455)">splitAt</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless;SizedOps.splitAt(38a80a0455);M">M</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.nat.Diff[L,M]" id="shapeless;SizedOps.splitAt(38a80a0455).diff">diff</a> : <a href="ops/nat.scala.html#shapeless.ops.nat;Diff" title="shapeless.ops.nat.Diff[L,M]">Diff</a><span class="delimiter">[</span>L, M<span class="delimiter">]</span>, <a title="shapeless.ops.nat.ToInt[M]" id="shapeless;SizedOps.splitAt(38a80a0455).ev">ev</a> : <a href="ops/nat.scala.html#shapeless.ops.nat;ToInt" title="shapeless.ops.nat.ToInt[M]">ToInt</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="(_1: shapeless.Sized[Repr,M], _2: shapeless.Sized[Repr,diff.Out])(shapeless.Sized[Repr,M], shapeless.Sized[Repr,diff.Out])" class="delimiter">(</span><a href="#shapeless;SizedOps.take(ec3c6ecfa3)" title="[M &lt;: shapeless.Nat](implicit diff: shapeless.ops.nat.Diff[L,M], implicit ev: shapeless.ops.nat.ToInt[M])shapeless.Sized[Repr,M]">take</a><a href="#shapeless;SizedOps.splitAt(38a80a0455).diff" title="(implicit diff: shapeless.ops.nat.Diff[L,M], implicit ev: shapeless.ops.nat.ToInt[M])shapeless.Sized[Repr,M]" class="delimiter">[</a><a href="#shapeless;SizedOps.splitAt(38a80a0455);M" title="M">M</a><span class="delimiter">]</span>, <a href="#shapeless;SizedOps.drop(b0bdb88380)" title="[M &lt;: shapeless.Nat](implicit diff: shapeless.ops.nat.Diff[L,M], implicit ev: shapeless.ops.nat.ToInt[M])shapeless.Sized[Repr,diff.Out]">drop</a><a href="#shapeless;SizedOps.splitAt(38a80a0455).diff" title="(implicit diff: shapeless.ops.nat.Diff[L,M], implicit ev: shapeless.ops.nat.ToInt[M])shapeless.Sized[Repr,diff.Out]" class="delimiter">[</a><a href="#shapeless;SizedOps.splitAt(38a80a0455);M" title="M">M</a><span class="delimiter">]</span><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Splits this collection at the ''mth'' element, returning the prefix and suffix as a pair. Available only if there
   * is evidence that this collection has at least ''m'' elements. The resulting collections will be statically know to
   * have ''m'' and ''n-m'' elements respectively.
   */</span>
  <span class="keyword">def</span> <a title="(m: shapeless.Nat)(implicit diff: shapeless.ops.nat.Diff[L,m.N], implicit ev: shapeless.ops.nat.ToInt[m.N])(shapeless.Sized[Repr,m.N], shapeless.Sized[Repr,diff.Out])" id="shapeless;SizedOps.splitAt(e11db829e8)">splitAt</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless;SizedOps.splitAt(e11db829e8).m">m</a> : <a href="nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.nat.Diff[L,m.N]" id="shapeless;SizedOps.splitAt(e11db829e8).diff">diff</a> : <a href="ops/nat.scala.html#shapeless.ops.nat;Diff" title="shapeless.ops.nat.Diff[L,m.N]">Diff</a><span class="delimiter">[</span>L, m.N<span class="delimiter">]</span>, <a title="shapeless.ops.nat.ToInt[m.N]" id="shapeless;SizedOps.splitAt(e11db829e8).ev">ev</a> : <a href="ops/nat.scala.html#shapeless.ops.nat;ToInt" title="shapeless.ops.nat.ToInt[m.N]">ToInt</a><span class="delimiter">[</span>m.N<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="(_1: shapeless.Sized[Repr,m.N], _2: shapeless.Sized[Repr,diff.Out])(shapeless.Sized[Repr,m.N], shapeless.Sized[Repr,diff.Out])" class="delimiter">(</span><a href="#shapeless;SizedOps.take(ec3c6ecfa3)" title="[M &lt;: shapeless.Nat](implicit diff: shapeless.ops.nat.Diff[L,M], implicit ev: shapeless.ops.nat.ToInt[M])shapeless.Sized[Repr,M]">take</a><a href="#shapeless;SizedOps.splitAt(e11db829e8).diff" title="(implicit diff: shapeless.ops.nat.Diff[L,m.N], implicit ev: shapeless.ops.nat.ToInt[m.N])shapeless.Sized[Repr,m.N]" class="delimiter">[</a>m.<a href="nat.scala.html#shapeless;Nat;N" title="m.N">N</a><span class="delimiter">]</span>, <a href="#shapeless;SizedOps.drop(b0bdb88380)" title="[M &lt;: shapeless.Nat](implicit diff: shapeless.ops.nat.Diff[L,M], implicit ev: shapeless.ops.nat.ToInt[M])shapeless.Sized[Repr,diff.Out]">drop</a><a href="#shapeless;SizedOps.splitAt(e11db829e8).diff" title="(implicit diff: shapeless.ops.nat.Diff[L,m.N], implicit ev: shapeless.ops.nat.ToInt[m.N])shapeless.Sized[Repr,diff.Out]" class="delimiter">[</a>m.<a href="nat.scala.html#shapeless;Nat;N" title="m.N">N</a><span class="delimiter">]</span><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Prepend the argument element to this collection. The resulting collection will be statically known to have a size
   * one greater than this collection.
   */</span>
  <span class="keyword">def</span> <a title="(elem: A)(implicit cbf: scala.collection.generic.CanBuildFrom[Repr,A,Repr])shapeless.Sized[Repr,shapeless.Succ[L]]" id="shapeless;SizedOps.+:">+:</a><span class="delimiter">(</span><a title="A" id="shapeless;SizedOps.+:.elem">elem</a> : <a href="#shapeless;SizedOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scala.collection.generic.CanBuildFrom[Repr,A,Repr]" id="shapeless;SizedOps.+:.cbf">cbf</a> : <span title="scala.collection.generic.CanBuildFrom[Repr,A,Repr]">CanBuildFrom</span><span class="delimiter">[</span>Repr, A, Repr<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="scala.collection.mutable.Builder[A,Repr]" id="shapeless;SizedOps.+:.builder">builder</a> = <a href="#shapeless;SizedOps.+:.cbf" title="scala.collection.generic.CanBuildFrom[Repr,A,Repr]">cbf</a>.<span title="(from: Repr)scala.collection.mutable.Builder[A,Repr]">apply</span><span class="delimiter">(</span><a href="#shapeless;SizedOps.r" title="scala.collection.GenTraversableLike[A,Repr]">r</a>.<span title="=&gt; Repr">repr</span><span class="delimiter">)</span>
    <a href="#shapeless;SizedOps.+:.builder" title="scala.collection.mutable.Builder[A,Repr]">builder</a> <span title="(elem: A)builder.type">+=</span> <a href="#shapeless;SizedOps.+:.elem" title="A">elem</a>
    <a href="#shapeless;SizedOps.+:.builder" title="scala.collection.mutable.Builder[A,Repr]">builder</a> <span title="(xs: scala.collection.TraversableOnce[A])builder.type">++=</span> <a href="#shapeless;SizedOps.r" title="scala.collection.GenTraversableLike[A,Repr]">r</a>.<span title="=&gt; Iterator[A]">toIterator</span>
    <a href="#shapeless.Sized.wrap" title="[Repr, L &lt;: shapeless.Nat](r: Repr)shapeless.Sized[Repr,L]">wrap</a><span title="(r: Repr)shapeless.Sized[Repr,shapeless.Succ[L]]" class="delimiter">[</span><a href="#shapeless;SizedOps;Repr" title="Repr">Repr</a>, <a href="nat.scala.html#shapeless;Succ" title="shapeless.Succ[L]">Succ</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless;SizedOps.+:.builder" title="scala.collection.mutable.Builder[A,Repr]">builder</a>.<span title="()Repr">result</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Append the argument element to this collection. The resulting collection will be statically known to have a size
   * one greater than this collection.
   */</span>
   <span class="keyword">def</span> <a title="(elem: A)(implicit cbf: scala.collection.generic.CanBuildFrom[Repr,A,Repr])shapeless.Sized[Repr,shapeless.Succ[L]]" id="shapeless;SizedOps.:+">:+</a><span class="delimiter">(</span><a title="A" id="shapeless;SizedOps.:+.elem">elem</a> : <a href="#shapeless;SizedOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scala.collection.generic.CanBuildFrom[Repr,A,Repr]" id="shapeless;SizedOps.:+.cbf">cbf</a> : <span title="scala.collection.generic.CanBuildFrom[Repr,A,Repr]">CanBuildFrom</span><span class="delimiter">[</span>Repr, A, Repr<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="scala.collection.mutable.Builder[A,Repr]" id="shapeless;SizedOps.:+.builder">builder</a> = <a href="#shapeless;SizedOps.:+.cbf" title="scala.collection.generic.CanBuildFrom[Repr,A,Repr]">cbf</a>.<span title="(from: Repr)scala.collection.mutable.Builder[A,Repr]">apply</span><span class="delimiter">(</span><a href="#shapeless;SizedOps.r" title="scala.collection.GenTraversableLike[A,Repr]">r</a>.<span title="=&gt; Repr">repr</span><span class="delimiter">)</span>
    <a href="#shapeless;SizedOps.:+.builder" title="scala.collection.mutable.Builder[A,Repr]">builder</a> <span title="(xs: scala.collection.TraversableOnce[A])builder.type">++=</span> <a href="#shapeless;SizedOps.r" title="scala.collection.GenTraversableLike[A,Repr]">r</a>.<span title="=&gt; Iterator[A]">toIterator</span>
    <a href="#shapeless;SizedOps.:+.builder" title="scala.collection.mutable.Builder[A,Repr]">builder</a> <span title="(elem: A)builder.type">+=</span> <a href="#shapeless;SizedOps.:+.elem" title="A">elem</a>
    <a href="#shapeless.Sized.wrap" title="[Repr, L &lt;: shapeless.Nat](r: Repr)shapeless.Sized[Repr,L]">wrap</a><span title="(r: Repr)shapeless.Sized[Repr,shapeless.Succ[L]]" class="delimiter">[</span><a href="#shapeless;SizedOps;Repr" title="Repr">Repr</a>, <a href="nat.scala.html#shapeless;Succ" title="shapeless.Succ[L]">Succ</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless;SizedOps.:+.builder" title="scala.collection.mutable.Builder[A,Repr]">builder</a>.<span title="()Repr">result</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Append the argument collection to this collection. The resulting collection will be statically known to have
   * ''m+n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[B &gt;: A, That, M &lt;: shapeless.Nat](that: shapeless.Sized[That,M])(implicit sum: shapeless.ops.nat.Sum[L,M], implicit cbf: scala.collection.generic.CanBuildFrom[Repr,B,That], implicit convThat: That =&gt; scala.collection.GenTraversableLike[B,That])shapeless.Sized[That,sum.Out]" id="shapeless;SizedOps.++">++</a><span class="delimiter">[</span><a title=" &gt;: A" id="shapeless;SizedOps.++;B">B</a> &gt;: A, <a title="" id="shapeless;SizedOps.++;That">That</a>, <a title=" &lt;: shapeless.Nat" id="shapeless;SizedOps.++;M">M</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><a title="shapeless.Sized[That,M]" id="shapeless;SizedOps.++.that">that</a> : <a href="#shapeless;Sized.equals" title="shapeless.Sized[That,M]">Sized</a><span class="delimiter">[</span>That, M<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="delimiter">(</span><span class="keyword">implicit</span>
      <a title="shapeless.ops.nat.Sum[L,M]" id="shapeless;SizedOps.++.sum">sum</a> : <a href="ops/nat.scala.html#shapeless.ops.nat;Sum" title="shapeless.ops.nat.Sum[L,M]">Sum</a><span class="delimiter">[</span>L, M<span class="delimiter">]</span>,
      <a title="scala.collection.generic.CanBuildFrom[Repr,B,That]" id="shapeless;SizedOps.++.cbf">cbf</a> : <span title="scala.collection.generic.CanBuildFrom[Repr,B,That]">CanBuildFrom</span><span class="delimiter">[</span>Repr, B, That<span class="delimiter">]</span>,
      <a title="That =&gt; scala.collection.GenTraversableLike[B,That]" id="shapeless;SizedOps.++.convThat">convThat</a> : That =&gt; GenTraversableLike<span class="delimiter">[</span>B, That<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Sized.wrap" title="[Repr, L &lt;: shapeless.Nat](r: Repr)shapeless.Sized[Repr,L]">wrap</a><span title="(r: That)shapeless.Sized[That,sum.Out]" class="delimiter">[</span><a href="#shapeless;SizedOps.++;That" title="That">That</a>, sum.<a href="ops/nat.scala.html#shapeless.ops.nat;Sum;Out" title="sum.Out">Out</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless;SizedOps.r" title="scala.collection.GenTraversableLike[A,Repr]">r</a> <a href="#shapeless;SizedOps.++.cbf" title="(that: scala.collection.GenTraversableOnce[B])(implicit bf: scala.collection.generic.CanBuildFrom[Repr,B,That])That">++</a> <a href="#shapeless;SizedOps.++.that" title="shapeless.Sized[That,M]">that</a>.<a href="#shapeless;SizedOps.++.convThat" title="(v1: That)scala.collection.GenTraversableLike[B,That]">unsized</a><span class="delimiter">)</span>
    
  <span class="comment">/**
   * Map across this collection. The resulting collection will be statically known to have the same number of elements
   * as this collection.
   */</span>
  <span class="keyword">def</span> <a title="[B, That](f: A =&gt; B)(implicit cbf: scala.collection.generic.CanBuildFrom[Repr,B,That])shapeless.Sized[That,L]" id="shapeless;SizedOps.map">map</a><span class="delimiter">[</span><a title="" id="shapeless;SizedOps.map;B">B</a>, <a title="" id="shapeless;SizedOps.map;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="shapeless;SizedOps.map.f">f</a> : A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scala.collection.generic.CanBuildFrom[Repr,B,That]" id="shapeless;SizedOps.map.cbf">cbf</a> : <span title="scala.collection.generic.CanBuildFrom[Repr,B,That]">CanBuildFrom</span><span class="delimiter">[</span>Repr, B, That<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Sized.wrap" title="[Repr, L &lt;: shapeless.Nat](r: Repr)shapeless.Sized[Repr,L]">wrap</a><span title="(r: That)shapeless.Sized[That,L]" class="delimiter">[</span><a href="#shapeless;SizedOps.map;That" title="That">That</a>, <a href="#shapeless;SizedOps;L" title="L">L</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless;SizedOps.r" title="scala.collection.GenTraversableLike[A,Repr]">r</a> <a href="#shapeless;SizedOps.map.cbf" title="(f: A =&gt; B)(implicit bf: scala.collection.generic.CanBuildFrom[Repr,B,That])That">map</a> <a href="#shapeless;SizedOps.map.f" title="A =&gt; B">f</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait LowPrioritySized extends AnyRef" id="shapeless;LowPrioritySized">LowPrioritySized</a> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[Repr](s: shapeless.Sized[Repr, _])Repr" id="shapeless;LowPrioritySized.sizedToRepr">sizedToRepr</a><span class="delimiter">[</span><a title="" id="shapeless;LowPrioritySized.sizedToRepr;Repr">Repr</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="shapeless.Sized[Repr, _]" id="shapeless;LowPrioritySized.sizedToRepr.s">s</a> : <a href="#shapeless;Sized.equals" title="shapeless.Sized[Repr, _]">Sized</a><span class="delimiter">[</span>Repr, _<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#shapeless;LowPrioritySized.sizedToRepr;Repr" title="Repr">Repr</a> = <a href="#shapeless;LowPrioritySized.sizedToRepr.s" title="shapeless.Sized[Repr, _]">s</a>.<a href="#shapeless;Sized.unsized" title="=&gt; Repr">unsized</a>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="shapeless.Sized.type" id="shapeless.Sized">Sized</a> <a href="#shapeless.Sized" title="shapeless.Sized.type" class="keyword">extends</a> <a href="#shapeless;LowPrioritySized" title="shapeless.LowPrioritySized">LowPrioritySized</a> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[Repr, L &lt;: shapeless.Nat](s: shapeless.Sized[Repr,L])(implicit itl: scala.collection.generic.IsTraversableLike[Repr])shapeless.SizedOps[itl.A,Repr,L]" id="shapeless.Sized.sizedOps">sizedOps</a><span class="delimiter">[</span><a title="" id="shapeless.Sized.sizedOps;Repr">Repr</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.Sized.sizedOps;L">L</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><a title="shapeless.Sized[Repr,L]" id="shapeless.Sized.sizedOps.s">s</a> : <a href="#shapeless;Sized.equals" title="shapeless.Sized[Repr,L]">Sized</a><span class="delimiter">[</span>Repr, L<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scala.collection.generic.IsTraversableLike[Repr]" id="shapeless.Sized.sizedOps.itl">itl</a>: <span title="scala.collection.generic.IsTraversableLike[Repr]">IsTraversableLike</span><span class="delimiter">[</span>Repr<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless;SizedOps" title="shapeless.SizedOps[itl.A,Repr,L]">SizedOps</a><span class="delimiter">[</span>itl.A, Repr, L<span class="delimiter">]</span> =
      <span title="shapeless.SizedOps[itl.A,Repr,L]" class="keyword">new</span> <a href="#shapeless;SizedOps" title="shapeless.SizedOps[itl.A,Repr,L]">SizedOps</a><span class="delimiter">[</span>itl.A, Repr, L<span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless.Sized.sizedOps.itl" title="scala.collection.generic.IsTraversableLike[Repr]">itl</a>.<span title="(v1: Repr)scala.collection.GenTraversableLike[itl.A,Repr]">conversion</span><span class="delimiter">(</span><a href="#shapeless.Sized.sizedOps.s" title="shapeless.Sized[Repr,L]">s</a>.<a href="#shapeless;Sized.unsized" title="=&gt; Repr">unsized</a><span class="delimiter">)</span><span class="delimiter">)</span>
  
  <span class="keyword">def</span> <a title="[CC[_]]=&gt; shapeless.SizedBuilder[CC]" id="shapeless.Sized.apply(8c4e448c58)">apply</a><span class="delimiter">[</span><a title="[_]" id="shapeless.Sized.apply(8c4e448c58);CC">CC</a><span class="delimiter">[</span><a title="" id="shapeless.Sized.apply(8c4e448c58);CC;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="shapeless.SizedBuilder[CC]" class="keyword">new</span> <a href="../sizedbuilder.scala.html#shapeless;SizedBuilder" title="shapeless.SizedBuilder[CC]">SizedBuilder</a><span class="delimiter">[</span>CC<span class="delimiter">]</span>
  
  <span class="keyword">def</span> <a title="[CC[_]]()(implicit cbf: scala.collection.generic.CanBuildFrom[Nothing,Nothing,CC[Nothing]])shapeless.Sized[CC[Nothing],shapeless._0]" id="shapeless.Sized.apply(41fc22ddb9)">apply</a><span class="delimiter">[</span><a title="[_]" id="shapeless.Sized.apply(41fc22ddb9);CC">CC</a><span class="delimiter">[</span><a title="" id="shapeless.Sized.apply(41fc22ddb9);CC;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scala.collection.generic.CanBuildFrom[Nothing,Nothing,CC[Nothing]]" id="shapeless.Sized.apply(41fc22ddb9).cbf">cbf</a> : <span title="scala.collection.generic.CanBuildFrom[Nothing,Nothing,CC[Nothing]]">CanBuildFrom</span><span class="delimiter">[</span>Nothing, Nothing, CC<span class="delimiter">[</span>Nothing<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> =
      <span title="shapeless.Sized[CC[Nothing],shapeless._0]" class="keyword">new</span> <a href="#shapeless;Sized.equals" title="shapeless.Sized[CC[Nothing],shapeless._0]">Sized</a><span class="delimiter">[</span>CC<span class="delimiter">[</span>Nothing<span class="delimiter">]</span>, _0<span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless.Sized.apply(41fc22ddb9).cbf" title="()scala.collection.mutable.Builder[Nothing,CC[Nothing]]">cbf</a><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="()CC[Nothing]">result</span><span class="delimiter">)</span>
  
  <span class="keyword">def</span> <a title="[Repr, L &lt;: shapeless.Nat](r: Repr)shapeless.Sized[Repr,L]" id="shapeless.Sized.wrap">wrap</a><span class="delimiter">[</span><a title="" id="shapeless.Sized.wrap;Repr">Repr</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.Sized.wrap;L">L</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><a title="Repr" id="shapeless.Sized.wrap.r">r</a> : <a href="#shapeless.Sized.wrap;Repr" title="Repr">Repr</a><span class="delimiter">)</span> = <span title="shapeless.Sized[Repr,L]" class="keyword">new</span> <a href="#shapeless;Sized.equals" title="shapeless.Sized[Repr,L]">Sized</a><span class="delimiter">[</span>Repr, L<span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless.Sized.wrap.r" title="Repr">r</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[Repr, L &lt;: shapeless.Nat](x: shapeless.Sized[Repr,L])Some[Repr]" id="shapeless.Sized.unapplySeq">unapplySeq</a><span class="delimiter">[</span><a title="" id="shapeless.Sized.unapplySeq;Repr">Repr</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.Sized.unapplySeq;L">L</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><a title="shapeless.Sized[Repr,L]" id="shapeless.Sized.unapplySeq.x">x</a> : <a href="#shapeless;Sized.equals" title="shapeless.Sized[Repr,L]">Sized</a><span class="delimiter">[</span>Repr, L<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="(x: Repr)Some[Repr]">Some</span><span class="delimiter">(</span><a href="#shapeless.Sized.unapplySeq.x" title="shapeless.Sized[Repr,L]">x</a>.<a href="#shapeless;Sized.unsized" title="=&gt; Repr">unsized</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
