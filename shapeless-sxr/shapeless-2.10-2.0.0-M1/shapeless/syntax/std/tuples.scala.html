<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>shapeless/syntax/std/tuples.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (c) 2013 Miles Sabin 
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span class="keyword">package</span> shapeless
<span class="keyword">package</span> syntax
<span class="keyword">package</span> std

<span class="keyword">trait</span> <a title="trait LowPriorityTuple extends AnyRef" id="shapeless.syntax.std;LowPriorityTuple">LowPriorityTuple</a> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[P &lt;: Product](p: P)shapeless.syntax.std.TupleOps[P]" id="shapeless.syntax.std;LowPriorityTuple.productTupleOps">productTupleOps</a><span class="delimiter">[</span><a title=" &lt;: Product" id="shapeless.syntax.std;LowPriorityTuple.productTupleOps;P">P</a> &lt;: Product<span class="delimiter">]</span><span class="delimiter">(</span><a title="P" id="shapeless.syntax.std;LowPriorityTuple.productTupleOps.p">p</a>: <a href="#shapeless.syntax.std;LowPriorityTuple.productTupleOps;P" title="P">P</a><span class="delimiter">)</span>: <a href="#shapeless.syntax.std;TupleOps" title="shapeless.syntax.std.TupleOps[P]">TupleOps</a><span class="delimiter">[</span>P<span class="delimiter">]</span> = <span title="shapeless.syntax.std.TupleOps[P]" class="keyword">new</span> <a href="#shapeless.syntax.std;TupleOps" title="shapeless.syntax.std.TupleOps[P]">TupleOps</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;LowPriorityTuple.productTupleOps.p" title="P">p</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="shapeless.syntax.std.tuple.type" id="shapeless.syntax.std.tuple">tuple</a> <a href="#shapeless.syntax.std.tuple" title="shapeless.syntax.std.tuple.type" class="keyword">extends</a> <a href="#shapeless.syntax.std;LowPriorityTuple" title="shapeless.syntax.std.LowPriorityTuple">LowPriorityTuple</a> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit shapeless.syntax.std.tuple.unitTupleOps : (u: Unit)shapeless.syntax.std.TupleOps[Unit]" id="shapeless.syntax.std.tuple.unitTupleOps">unitTupleOps</a><span class="delimiter">(</span><a title="Unit" id="shapeless.syntax.std.tuple.unitTupleOps.u">u</a>: <span title="Unit">Unit</span><span class="delimiter">)</span>: <a href="#shapeless.syntax.std;TupleOps" title="shapeless.syntax.std.TupleOps[Unit]">TupleOps</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <span title="shapeless.syntax.std.TupleOps[Unit]" class="keyword">new</span> <a href="#shapeless.syntax.std;TupleOps" title="shapeless.syntax.std.TupleOps[Unit]">TupleOps</a><span class="delimiter">(</span><a href="#shapeless.syntax.std.tuple.unitTupleOps.u" title="Unit">u</a><span class="delimiter">)</span>

  <span class="comment">// Duplicated here from shapeless.HList so that explicit imports of tuple._ don't</span>
  <span class="comment">// clobber the conversion to HListOps.</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[L &lt;: shapeless.HList](l: L)shapeless.syntax.HListOps[L]" id="shapeless.syntax.std.tuple.hlistOps">hlistOps</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.syntax.std.tuple.hlistOps;L">L</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="L" id="shapeless.syntax.std.tuple.hlistOps.l">l</a> : <a href="#shapeless.syntax.std.tuple.hlistOps;L" title="L">L</a><span class="delimiter">)</span> : <a href="../hlists.scala.html#shapeless.syntax;HListOps" title="shapeless.syntax.HListOps[L]">HListOps</a><span class="delimiter">[</span>L<span class="delimiter">]</span> = <span title="shapeless.syntax.HListOps[L]" class="keyword">new</span> <a href="../hlists.scala.html#shapeless.syntax;HListOps" title="shapeless.syntax.HListOps[L]">HListOps</a><span class="delimiter">(</span><a href="#shapeless.syntax.std.tuple.hlistOps.l" title="L">l</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">final</span> <span class="keyword">class</span> <a title="class TupleOps[T] extends AnyRef" id="shapeless.syntax.std;TupleOps">TupleOps</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps;T">T</a><span class="delimiter">]</span><a href="#shapeless.syntax.std;TupleOps" title="shapeless.syntax.std.TupleOps[T]" class="delimiter">(</a><a title="T" id="shapeless.syntax.std;TupleOps.t">t</a>: <a href="#shapeless.syntax.std;TupleOps;T" title="T">T</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="keyword">import</span> ops.<a href="../../ops/tuples.scala.html#shapeless.ops.tuple" title="shapeless.ops.tuple.type">tuple</a>._

  <span class="comment">/**
   * Returns an `HList` containing the elements of this tuple.
   */</span>
  <span class="keyword">def</span> <a title="(implicit gen: shapeless.Generic[T])gen.Repr" id="shapeless.syntax.std;TupleOps.productElements">productElements</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic[T]" id="shapeless.syntax.std;TupleOps.productElements.gen">gen</a>: <a href="../../generic.scala.html#shapeless;Generic" title="shapeless.Generic[T]">Generic</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: gen.<a href="../../generic.scala.html#shapeless;Generic;Repr" title="gen.Repr">Repr</a> = <a href="#shapeless.syntax.std;TupleOps.productElements.gen" title="shapeless.Generic[T]">gen</a>.<a href="../../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the first element of this tuple.
   */</span>
  <span class="keyword">def</span> <a title="(implicit c: shapeless.ops.tuple.IsComposite[T])c.H" id="shapeless.syntax.std;TupleOps.head">head</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.IsComposite[T]" id="shapeless.syntax.std;TupleOps.head.c">c</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;IsComposite" title="shapeless.ops.tuple.IsComposite[T]">IsComposite</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: c.<a href="../../ops/tuples.scala.html#shapeless.ops.tuple;IsComposite;H" title="c.H">H</a> = <a href="#shapeless.syntax.std;TupleOps.head.c" title="shapeless.ops.tuple.IsComposite[T]">c</a>.<a href="../../ops/tuples.scala.html#shapeless.ops.tuple;IsComposite.head" title="(p: T)c.H">head</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns that tail of this tuple. Available only if there is evidence that this tuple is composite.
   */</span>
  <span class="keyword">def</span> <a title="(implicit c: shapeless.ops.tuple.IsComposite[T])c.T" id="shapeless.syntax.std;TupleOps.tail">tail</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.IsComposite[T]" id="shapeless.syntax.std;TupleOps.tail.c">c</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;IsComposite" title="shapeless.ops.tuple.IsComposite[T]">IsComposite</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: c.<a href="../../ops/tuples.scala.html#shapeless.ops.tuple;IsComposite;T" title="c.T">T</a> = <a href="#shapeless.syntax.std;TupleOps.tail.c" title="shapeless.ops.tuple.IsComposite[T]">c</a>.<a href="../../ops/tuples.scala.html#shapeless.ops.tuple;IsComposite.tail" title="(p: T)c.T">tail</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Prepend the argument element to this tuple.
   */</span>
  <span class="keyword">def</span> <a title="[E](e: E)(implicit prepend: shapeless.ops.tuple.Prepend[(E,),T])prepend.Out" id="shapeless.syntax.std;TupleOps.+:">+:</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.+:;E">E</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="E" id="shapeless.syntax.std;TupleOps.+:.e">e</a>: <a href="#shapeless.syntax.std;TupleOps.+:;E" title="E">E</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Prepend[(E,),T]" id="shapeless.syntax.std;TupleOps.+:.prepend">prepend</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Prepend" title="shapeless.ops.tuple.Prepend[(E,),T]">Prepend</a><span class="delimiter">[</span>Tuple1<span class="delimiter">[</span>E<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: prepend.<a href="../../package.scala.html#shapeless.package;DepFn2;Out" title="prepend.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: (E,), u: T)prepend.Out">prepend</a><span class="delimiter">(</span><span title="(_1: E)(E,)">Tuple1</span><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.+:.e" title="E">e</a><span class="delimiter">)</span>, <a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Append the argument element to this tuple.
   */</span>
  <span class="keyword">def</span> <a title="[E](e: E)(implicit prepend: shapeless.ops.tuple.Prepend[T,(E,)])prepend.Out" id="shapeless.syntax.std;TupleOps.:+">:+</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.:+;E">E</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="E" id="shapeless.syntax.std;TupleOps.:+.e">e</a>: <a href="#shapeless.syntax.std;TupleOps.:+;E" title="E">E</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Prepend[T,(E,)]" id="shapeless.syntax.std;TupleOps.:+.prepend">prepend</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Prepend" title="shapeless.ops.tuple.Prepend[T,(E,)]">Prepend</a><span class="delimiter">[</span>T, Tuple1<span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: prepend.<a href="../../package.scala.html#shapeless.package;DepFn2;Out" title="prepend.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: T, u: (E,))prepend.Out">prepend</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <span title="(_1: E)(E,)">Tuple1</span><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.:+.e" title="E">e</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Append the argument tuple to this tuple.
   */</span>
  <span class="keyword">def</span> <a title="[U](u: U)(implicit prepend: shapeless.ops.tuple.Prepend[T,U])prepend.Out" id="shapeless.syntax.std;TupleOps.++">++</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.++;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="U" id="shapeless.syntax.std;TupleOps.++.u">u</a>: <a href="#shapeless.syntax.std;TupleOps.++;U" title="U">U</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Prepend[T,U]" id="shapeless.syntax.std;TupleOps.++.prepend">prepend</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Prepend" title="shapeless.ops.tuple.Prepend[T,U]">Prepend</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">)</span>: prepend.<a href="../../package.scala.html#shapeless.package;DepFn2;Out" title="prepend.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: T, u: U)prepend.Out">prepend</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <a href="#shapeless.syntax.std;TupleOps.++.u" title="U">u</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Prepend the argument tuple to this tuple.
   */</span>
  <span class="keyword">def</span> <a title="[U](u: U)(implicit prepend: shapeless.ops.tuple.Prepend[U,T])prepend.Out" id="shapeless.syntax.std;TupleOps.++:">++:</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.++:;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="U" id="shapeless.syntax.std;TupleOps.++:.u">u</a>: <a href="#shapeless.syntax.std;TupleOps.++:;U" title="U">U</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Prepend[U,T]" id="shapeless.syntax.std;TupleOps.++:.prepend">prepend</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Prepend" title="shapeless.ops.tuple.Prepend[U,T]">Prepend</a><span class="delimiter">[</span>U, T<span class="delimiter">]</span><span class="delimiter">)</span>: prepend.<a href="../../package.scala.html#shapeless.package;DepFn2;Out" title="prepend.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: U, u: T)prepend.Out">prepend</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.++:.u" title="U">u</a>, <a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Prepend the argument tuple to this tuple.
   */</span>
  <span class="keyword">def</span> <a title="[U](u: U)(implicit prepend: shapeless.ops.tuple.Prepend[U,T])prepend.Out" id="shapeless.syntax.std;TupleOps.:::">:::</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.:::;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="U" id="shapeless.syntax.std;TupleOps.:::.u">u</a>: <a href="#shapeless.syntax.std;TupleOps.:::;U" title="U">U</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Prepend[U,T]" id="shapeless.syntax.std;TupleOps.:::.prepend">prepend</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Prepend" title="shapeless.ops.tuple.Prepend[U,T]">Prepend</a><span class="delimiter">[</span>U, T<span class="delimiter">]</span><span class="delimiter">)</span>: prepend.<a href="../../package.scala.html#shapeless.package;DepFn2;Out" title="prepend.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: U, u: T)prepend.Out">prepend</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.:::.u" title="U">u</a>, <a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Prepend the reverse of the argument tuple to this tuple.
   */</span>
  <span class="keyword">def</span> <a title="[U](u: U)(implicit prepend: shapeless.ops.tuple.ReversePrepend[U,T])prepend.Out" id="shapeless.syntax.std;TupleOps.reverse_:::">reverse_:::</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.reverse_:::;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="U" id="shapeless.syntax.std;TupleOps.reverse_:::.u">u</a>: <a href="#shapeless.syntax.std;TupleOps.reverse_:::;U" title="U">U</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.ReversePrepend[U,T]" id="shapeless.syntax.std;TupleOps.reverse_:::.prepend">prepend</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;ReversePrepend" title="shapeless.ops.tuple.ReversePrepend[U,T]">ReversePrepend</a><span class="delimiter">[</span>U, T<span class="delimiter">]</span><span class="delimiter">)</span>: prepend.<a href="../../package.scala.html#shapeless.package;DepFn2;Out" title="prepend.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: U, u: T)prepend.Out">prepend</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.reverse_:::.u" title="U">u</a>, <a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the ''nth'' element of this tuple. An explicit type argument must be provided. Available only if there is
   * evidence that this tuple has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat](implicit at: shapeless.ops.tuple.At[T,N])at.Out" id="shapeless.syntax.std;TupleOps.apply(372e6a660c)">apply</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax.std;TupleOps.apply(372e6a660c);N">N</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.At[T,N]" id="shapeless.syntax.std;TupleOps.apply(372e6a660c).at">at</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;At" title="shapeless.ops.tuple.At[T,N]">At</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span><span class="delimiter">)</span>: at.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="at.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)at.Out">at</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the ''nth'' element of this tuple. Available only if there is evidence that this tuple has at least ''n''
   * elements.
   */</span>
  <span class="keyword">def</span> <a title="(n: shapeless.Nat)(implicit at: shapeless.ops.tuple.At[T,n.N])at.Out" id="shapeless.syntax.std;TupleOps.apply(0e12cd8db1)">apply</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless.syntax.std;TupleOps.apply(0e12cd8db1).n">n</a>: <a href="../../nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.At[T,n.N]" id="shapeless.syntax.std;TupleOps.apply(0e12cd8db1).at">at</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;At" title="shapeless.ops.tuple.At[T,n.N]">At</a><span class="delimiter">[</span>T, n.N<span class="delimiter">]</span><span class="delimiter">)</span>: at.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="at.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)at.Out">at</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Returns the ''nth'' element of this tuple. An explicit type argument must be provided. Available only if there is
   * evidence that this tuple has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat](implicit at: shapeless.ops.tuple.At[T,N])at.Out" id="shapeless.syntax.std;TupleOps.at(372e6a660c)">at</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax.std;TupleOps.at(372e6a660c);N">N</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.At[T,N]" id="shapeless.syntax.std;TupleOps.at(372e6a660c).at">at</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;At" title="shapeless.ops.tuple.At[T,N]">At</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span><span class="delimiter">)</span>: at.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="at.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)at.Out">at</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the ''nth'' element of this tuple. Available only if there is evidence that this tuple has at least ''n''
   * elements.
   */</span>
  <span class="keyword">def</span> <a title="(n: shapeless.Nat)(implicit at: shapeless.ops.tuple.At[T,n.N])at.Out" id="shapeless.syntax.std;TupleOps.at(0e12cd8db1)">at</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless.syntax.std;TupleOps.at(0e12cd8db1).n">n</a>: <a href="../../nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.At[T,n.N]" id="shapeless.syntax.std;TupleOps.at(0e12cd8db1).at">at</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;At" title="shapeless.ops.tuple.At[T,n.N]">At</a><span class="delimiter">[</span>T, n.N<span class="delimiter">]</span><span class="delimiter">)</span>: at.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="at.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)at.Out">at</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Returns the last element of this tuple. Available only if there is evidence that this tuple is composite.
   */</span>
  <span class="keyword">def</span> <a title="(implicit last: shapeless.ops.tuple.Last[T])last.Out" id="shapeless.syntax.std;TupleOps.last">last</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Last[T]" id="shapeless.syntax.std;TupleOps.last.last">last</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Last" title="shapeless.ops.tuple.Last[T]">Last</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: last.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="last.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)last.Out">last</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns a tuple consisting of all the elements of this tuple except the last. Available only if there is
   * evidence that this tuple is composite.
   */</span>
  <span class="keyword">def</span> <a title="(implicit init: shapeless.ops.tuple.Init[T])init.Out" id="shapeless.syntax.std;TupleOps.init">init</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Init[T]" id="shapeless.syntax.std;TupleOps.init.init">init</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Init" title="shapeless.ops.tuple.Init[T]">Init</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: init.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="init.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)init.Out">init</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the first element of type `U` of this tuple. An explicit type argument must be provided. Available only
   * if there is evidence that this tuple has an element of type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit selector: shapeless.ops.tuple.Selector[T,U])selector.Out" id="shapeless.syntax.std;TupleOps.select">select</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.select;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Selector[T,U]" id="shapeless.syntax.std;TupleOps.select.selector">selector</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Selector" title="shapeless.ops.tuple.Selector[T,U]">Selector</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">)</span>: selector.<a href="#shapeless.syntax.std;TupleOps.select;U" title="selector.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)selector.Out">selector</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns all elements of type `U` of this tuple. An explicit type argument must be provided.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit filter: shapeless.ops.tuple.Filter[T,U])filter.Out" id="shapeless.syntax.std;TupleOps.filter">filter</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.filter;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Filter[T,U]" id="shapeless.syntax.std;TupleOps.filter.filter">filter</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Filter" title="shapeless.ops.tuple.Filter[T,U]">Filter</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">)</span>: filter.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="filter.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)filter.Out">filter</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns all elements of type different than `U` of this tuple. An explicit type argument must be provided.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit filterNot: shapeless.ops.tuple.FilterNot[T,U])filterNot.Out" id="shapeless.syntax.std;TupleOps.filterNot">filterNot</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.filterNot;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.FilterNot[T,U]" id="shapeless.syntax.std;TupleOps.filterNot.filterNot">filterNot</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;FilterNot" title="shapeless.ops.tuple.FilterNot[T,U]">FilterNot</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">)</span>: filterNot.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="filterNot.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)filterNot.Out">filterNot</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Returns the first element of type `U` of this tuple plus the remainder of the tuple. An explicit type argument
   * must be provided. Available only if there is evidence that this tuple has an element of type `U`.
   * 
   * The `Elem` suffix is here for consistency with the corresponding method name for `HList` and should be
   * removed when the latter is removed.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit remove: shapeless.ops.tuple.Remove[T,U])remove.Out" id="shapeless.syntax.std;TupleOps.removeElem">removeElem</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.removeElem;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Remove[T,U]" id="shapeless.syntax.std;TupleOps.removeElem.remove">remove</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Remove" title="shapeless.ops.tuple.Remove[T,U]">Remove</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">)</span>: remove.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="remove.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)remove.Out">remove</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Returns the first elements of this tuple that have types in `S` plus the remainder of the tuple. An expicit
   * type argument must be provided. Available only if there is evidence that this tuple contains elements with
   * types in `S`.
   */</span>
  <span class="keyword">def</span> <a title="[S](implicit removeAll: shapeless.ops.tuple.RemoveAll[T,S])removeAll.Out" id="shapeless.syntax.std;TupleOps.removeAll">removeAll</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.removeAll;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.RemoveAll[T,S]" id="shapeless.syntax.std;TupleOps.removeAll.removeAll">removeAll</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;RemoveAll" title="shapeless.ops.tuple.RemoveAll[T,S]">RemoveAll</a><span class="delimiter">[</span>T, S<span class="delimiter">]</span><span class="delimiter">)</span>: removeAll.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="removeAll.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)removeAll.Out">removeAll</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Replaces the first element of type `U` of this tuple with the supplied value, also of type `U` returning both
   * the replaced element and the updated tuple. Available only if there is evidence that this tuple has an element
   * of type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U](u: U)(implicit replacer: shapeless.ops.tuple.Replacer[T,U,U])replacer.Out" id="shapeless.syntax.std;TupleOps.replace">replace</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.replace;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="U" id="shapeless.syntax.std;TupleOps.replace.u">u</a>: <a href="#shapeless.syntax.std;TupleOps.replace;U" title="U">U</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Replacer[T,U,U]" id="shapeless.syntax.std;TupleOps.replace.replacer">replacer</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Replacer" title="shapeless.ops.tuple.Replacer[T,U,U]">Replacer</a><span class="delimiter">[</span>T, U, U<span class="delimiter">]</span><span class="delimiter">)</span>: replacer.<a href="../../package.scala.html#shapeless.package;DepFn2;Out" title="replacer.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: T, u: U)replacer.Out">replacer</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <a href="#shapeless.syntax.std;TupleOps.replace.u" title="U">u</a><span class="delimiter">)</span>
  
  <span class="keyword">class</span> <a title="class ReplaceTypeAux[U] extends AnyRef" id="shapeless.syntax.std;TupleOps;ReplaceTypeAux">ReplaceTypeAux</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps;ReplaceTypeAux;U">U</a><span class="delimiter">]</span> <a href="#shapeless.syntax.std;TupleOps;ReplaceTypeAux" title="TupleOps.this.ReplaceTypeAux[U]" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="[V](v: V)(implicit replacer: shapeless.ops.tuple.Replacer[T,V,U])replacer.Out" id="shapeless.syntax.std;TupleOps;ReplaceTypeAux.apply">apply</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps;ReplaceTypeAux.apply;V">V</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="V" id="shapeless.syntax.std;TupleOps;ReplaceTypeAux.apply.v">v</a>: <a href="#shapeless.syntax.std;TupleOps;ReplaceTypeAux.apply;V" title="V">V</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Replacer[T,V,U]" id="shapeless.syntax.std;TupleOps;ReplaceTypeAux.apply.replacer">replacer</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Replacer" title="shapeless.ops.tuple.Replacer[T,V,U]">Replacer</a><span class="delimiter">[</span>T, V, U<span class="delimiter">]</span><span class="delimiter">)</span>: replacer.<a href="../../package.scala.html#shapeless.package;DepFn2;Out" title="replacer.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: T, u: V)replacer.Out">replacer</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <a href="#shapeless.syntax.std;TupleOps;ReplaceTypeAux.apply.v" title="V">v</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Replaces the first element of type `U` of this tuple with the supplied value of type `V`, returning both the
   * replaced element and the updated tuple. An explicit type argument must be provided for `U`. Available only if
   * there is evidence that this tuple has an element of type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U]=&gt; TupleOps.this.ReplaceTypeAux[U]" id="shapeless.syntax.std;TupleOps.replaceType">replaceType</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.replaceType;U">U</a><span class="delimiter">]</span> = <span title="TupleOps.this.ReplaceTypeAux[U]" class="keyword">new</span> <a href="#shapeless.syntax.std;TupleOps;ReplaceTypeAux" title="TupleOps.this.ReplaceTypeAux[U]">ReplaceTypeAux</a><span class="delimiter">[</span>U<span class="delimiter">]</span>
  
  <span class="comment">/**
   * Replaces the first element of type `U` of this tuple with the supplied value, also of type `U`. Available only
   * if there is evidence that this tuple has an element of type `U`.
   * 
   * The `Elem` suffix is here for consistency with the corresponding method name for `HList` and should be
   * removed when the latter is removed.
   */</span>
  <span class="keyword">def</span> <a title="[U, R](u: U)(implicit replacer: shapeless.ops.tuple.Replacer.Aux[T,U,U,(U, R)])R" id="shapeless.syntax.std;TupleOps.updatedElem">updatedElem</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.updatedElem;U">U</a>, <a title="" id="shapeless.syntax.std;TupleOps.updatedElem;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="U" id="shapeless.syntax.std;TupleOps.updatedElem.u">u</a>: <a href="#shapeless.syntax.std;TupleOps.updatedElem;U" title="U">U</a><span class="delimiter">)</span>
    <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Replacer.Aux[T,U,U,(U, R)]" id="shapeless.syntax.std;TupleOps.updatedElem.replacer">replacer</a>: Replacer.<a href="../../ops/tuples.scala.html#shapeless.ops.tuple.Replacer;<refinement>" title="shapeless.ops.tuple.Replacer.Aux[T,U,U,(U, R)]">Aux</a><span class="delimiter">[</span>T, U, U, <span class="delimiter">(</span>U, R<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.syntax.std;TupleOps.updatedElem;R" title="R">R</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: T, u: U)(U, R)">replacer</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <a href="#shapeless.syntax.std;TupleOps.updatedElem.u" title="U">u</a><span class="delimiter">)</span>.<span title="=&gt; R">_2</span>
  
  <span class="keyword">class</span> <a title="class UpdatedTypeAux[U] extends AnyRef" id="shapeless.syntax.std;TupleOps;UpdatedTypeAux">UpdatedTypeAux</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps;UpdatedTypeAux;U">U</a><span class="delimiter">]</span> <a href="#shapeless.syntax.std;TupleOps;UpdatedTypeAux" title="TupleOps.this.UpdatedTypeAux[U]" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="[V, R](v: V)(implicit replacer: shapeless.ops.tuple.Replacer.Aux[T,V,U,(U, R)])R" id="shapeless.syntax.std;TupleOps;UpdatedTypeAux.apply">apply</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps;UpdatedTypeAux.apply;V">V</a>, <a title="" id="shapeless.syntax.std;TupleOps;UpdatedTypeAux.apply;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="V" id="shapeless.syntax.std;TupleOps;UpdatedTypeAux.apply.v">v</a>: <a href="#shapeless.syntax.std;TupleOps;UpdatedTypeAux.apply;V" title="V">V</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Replacer.Aux[T,V,U,(U, R)]" id="shapeless.syntax.std;TupleOps;UpdatedTypeAux.apply.replacer">replacer</a>: Replacer.<a href="../../ops/tuples.scala.html#shapeless.ops.tuple.Replacer;<refinement>" title="shapeless.ops.tuple.Replacer.Aux[T,V,U,(U, R)]">Aux</a><span class="delimiter">[</span>T, V, U, <span class="delimiter">(</span>U, R<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.syntax.std;TupleOps;UpdatedTypeAux.apply;R" title="R">R</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: T, u: V)(U, R)">replacer</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <a href="#shapeless.syntax.std;TupleOps;UpdatedTypeAux.apply.v" title="V">v</a><span class="delimiter">)</span>.<span title="=&gt; R">_2</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Replaces the first element of type `U` of this tuple with the supplied value of type `V`. An explicit type
   * argument must be provided for `U`. Available only if there is evidence that this tuple has an element of
   * type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U]=&gt; TupleOps.this.UpdatedTypeAux[U]" id="shapeless.syntax.std;TupleOps.updatedType">updatedType</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.updatedType;U">U</a><span class="delimiter">]</span> = <span title="TupleOps.this.UpdatedTypeAux[U]" class="keyword">new</span> <a href="#shapeless.syntax.std;TupleOps;UpdatedTypeAux" title="TupleOps.this.UpdatedTypeAux[U]">UpdatedTypeAux</a><span class="delimiter">[</span>U<span class="delimiter">]</span>

  <span class="keyword">class</span> <a title="class UpdatedAtAux[N &lt;: shapeless.Nat] extends AnyRef" id="shapeless.syntax.std;TupleOps;UpdatedAtAux">UpdatedAtAux</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax.std;TupleOps;UpdatedAtAux;N">N</a> &lt;: Nat<span class="delimiter">]</span> <a href="#shapeless.syntax.std;TupleOps;UpdatedAtAux" title="TupleOps.this.UpdatedAtAux[N]" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="[U, V, R](u: U)(implicit replacer: shapeless.ops.tuple.ReplaceAt.Aux[T,N,U,(V, R)])R" id="shapeless.syntax.std;TupleOps;UpdatedAtAux.apply">apply</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps;UpdatedAtAux.apply;U">U</a>, <a title="" id="shapeless.syntax.std;TupleOps;UpdatedAtAux.apply;V">V</a>, <a title="" id="shapeless.syntax.std;TupleOps;UpdatedAtAux.apply;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="U" id="shapeless.syntax.std;TupleOps;UpdatedAtAux.apply.u">u</a>: <a href="#shapeless.syntax.std;TupleOps;UpdatedAtAux.apply;U" title="U">U</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.ReplaceAt.Aux[T,N,U,(V, R)]" id="shapeless.syntax.std;TupleOps;UpdatedAtAux.apply.replacer">replacer</a>: ReplaceAt.<a href="../../ops/tuples.scala.html#shapeless.ops.tuple.ReplaceAt;<refinement>" title="shapeless.ops.tuple.ReplaceAt.Aux[T,N,U,(V, R)]">Aux</a><span class="delimiter">[</span>T, N, U, <span class="delimiter">(</span>V, R<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.syntax.std;TupleOps;UpdatedAtAux.apply;R" title="R">R</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: T, u: U)(V, R)">replacer</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <a href="#shapeless.syntax.std;TupleOps;UpdatedAtAux.apply.u" title="U">u</a><span class="delimiter">)</span>.<span title="=&gt; R">_2</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Replaces the ''nth' element of this tuple with the supplied value of type `U`. An explicit type argument
   * must be provided for `N`. Available only if there is evidence that this tuple has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat]=&gt; TupleOps.this.UpdatedAtAux[N]" id="shapeless.syntax.std;TupleOps.updatedAt(b684c5acb6)">updatedAt</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax.std;TupleOps.updatedAt(b684c5acb6);N">N</a> &lt;: Nat<span class="delimiter">]</span> = <span title="TupleOps.this.UpdatedAtAux[N]" class="keyword">new</span> <a href="#shapeless.syntax.std;TupleOps;UpdatedAtAux" title="TupleOps.this.UpdatedAtAux[N]">UpdatedAtAux</a><span class="delimiter">[</span>N<span class="delimiter">]</span>
  
  <span class="comment">/**
   * Replaces the ''nth' element of this tuple with the supplied value of type `U`. Available only if there is
   * evidence that this tuple has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[U, V, R](n: shapeless.Nat, u: U)(implicit replacer: shapeless.ops.tuple.ReplaceAt.Aux[T,n.N,U,(V, R)])R" id="shapeless.syntax.std;TupleOps.updatedAt(7617958525)">updatedAt</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.updatedAt(7617958525);U">U</a>, <a title="" id="shapeless.syntax.std;TupleOps.updatedAt(7617958525);V">V</a>, <a title="" id="shapeless.syntax.std;TupleOps.updatedAt(7617958525);R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless.syntax.std;TupleOps.updatedAt(7617958525).n">n</a>: <a href="../../nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a>, <a title="U" id="shapeless.syntax.std;TupleOps.updatedAt(7617958525).u">u</a>: <a href="#shapeless.syntax.std;TupleOps.updatedAt(7617958525);U" title="U">U</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.ReplaceAt.Aux[T,n.N,U,(V, R)]" id="shapeless.syntax.std;TupleOps.updatedAt(7617958525).replacer">replacer</a>: ReplaceAt.<a href="../../ops/tuples.scala.html#shapeless.ops.tuple.ReplaceAt;<refinement>" title="shapeless.ops.tuple.ReplaceAt.Aux[T,n.N,U,(V, R)]">Aux</a><span class="delimiter">[</span>T, n.N, U, <span class="delimiter">(</span>V, R<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.syntax.std;TupleOps.updatedAt(7617958525);R" title="R">R</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: T, u: U)(V, R)">replacer</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <a href="#shapeless.syntax.std;TupleOps.updatedAt(7617958525).u" title="U">u</a><span class="delimiter">)</span>.<span title="=&gt; R">_2</span>

  <span class="comment">/**
   * Returns the first ''n'' elements of this tuple. An explicit type argument must be provided. Available only if
   * there is evidence that this tuple has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat](implicit take: shapeless.ops.tuple.Take[T,N])take.Out" id="shapeless.syntax.std;TupleOps.take(f71e1ec7f9)">take</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax.std;TupleOps.take(f71e1ec7f9);N">N</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Take[T,N]" id="shapeless.syntax.std;TupleOps.take(f71e1ec7f9).take">take</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Take" title="shapeless.ops.tuple.Take[T,N]">Take</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span><span class="delimiter">)</span>: take.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="take.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)take.Out">take</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the first ''n'' elements of this tuple. Available only if there is evidence that this tuple has at
   * least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="(n: shapeless.Nat)(implicit take: shapeless.ops.tuple.Take[T,n.N])take.Out" id="shapeless.syntax.std;TupleOps.take(39bc10290b)">take</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless.syntax.std;TupleOps.take(39bc10290b).n">n</a>: <a href="../../nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Take[T,n.N]" id="shapeless.syntax.std;TupleOps.take(39bc10290b).take">take</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Take" title="shapeless.ops.tuple.Take[T,n.N]">Take</a><span class="delimiter">[</span>T, n.N<span class="delimiter">]</span><span class="delimiter">)</span>: take.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="take.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)take.Out">take</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Returns all but the  first ''n'' elements of this tuple. An explicit type argument must be provided. Available
   * only if there is evidence that this tuple has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat](implicit drop: shapeless.ops.tuple.Drop[T,N])drop.Out" id="shapeless.syntax.std;TupleOps.drop(5cd05dd91f)">drop</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax.std;TupleOps.drop(5cd05dd91f);N">N</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Drop[T,N]" id="shapeless.syntax.std;TupleOps.drop(5cd05dd91f).drop">drop</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Drop" title="shapeless.ops.tuple.Drop[T,N]">Drop</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span><span class="delimiter">)</span>: drop.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="drop.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)drop.Out">drop</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns all but the  first ''n'' elements of this tuple. Available only if there is evidence that this tuple
   * has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="(n: shapeless.Nat)(implicit drop: shapeless.ops.tuple.Drop[T,n.N])drop.Out" id="shapeless.syntax.std;TupleOps.drop(6579fd2189)">drop</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless.syntax.std;TupleOps.drop(6579fd2189).n">n</a>: <a href="../../nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Drop[T,n.N]" id="shapeless.syntax.std;TupleOps.drop(6579fd2189).drop">drop</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Drop" title="shapeless.ops.tuple.Drop[T,n.N]">Drop</a><span class="delimiter">[</span>T, n.N<span class="delimiter">]</span><span class="delimiter">)</span>: drop.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="drop.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)drop.Out">drop</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Splits this tuple at the ''nth'' element, returning the prefix and suffix as a pair. An explicit type argument
   * must be provided. Available only if there is evidence that this tuple has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat](implicit split: shapeless.ops.tuple.Split[T,N])split.Out" id="shapeless.syntax.std;TupleOps.split(d1e0a0d247)">split</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax.std;TupleOps.split(d1e0a0d247);N">N</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Split[T,N]" id="shapeless.syntax.std;TupleOps.split(d1e0a0d247).split">split</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Split" title="shapeless.ops.tuple.Split[T,N]">Split</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span><span class="delimiter">)</span>: split.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="split.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)split.Out">split</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Splits this tuple at the ''nth'' element, returning the prefix and suffix as a pair. Available only if there is
   * evidence that this tuple has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="(n: shapeless.Nat)(implicit split: shapeless.ops.tuple.Split[T,n.N])split.Out" id="shapeless.syntax.std;TupleOps.split(91d74033cd)">split</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless.syntax.std;TupleOps.split(91d74033cd).n">n</a>: <a href="../../nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Split[T,n.N]" id="shapeless.syntax.std;TupleOps.split(91d74033cd).split">split</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Split" title="shapeless.ops.tuple.Split[T,n.N]">Split</a><span class="delimiter">[</span>T, n.N<span class="delimiter">]</span><span class="delimiter">)</span>: split.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="split.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)split.Out">split</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Splits this tuple at the ''nth'' element, returning the reverse of the prefix and suffix as a pair. An explicit
   * type argument must be provided. Available only if there is evidence that this tuple has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat](implicit split: shapeless.ops.tuple.ReverseSplit[T,N])split.Out" id="shapeless.syntax.std;TupleOps.reverse_split(b228ce406e)">reverse_split</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax.std;TupleOps.reverse_split(b228ce406e);N">N</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.ReverseSplit[T,N]" id="shapeless.syntax.std;TupleOps.reverse_split(b228ce406e).split">split</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;ReverseSplit" title="shapeless.ops.tuple.ReverseSplit[T,N]">ReverseSplit</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span><span class="delimiter">)</span>: split.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="split.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)split.Out">split</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Splits this tuple at the ''nth'' element, returning the reverse of the prefix and suffix as a pair. Available
   * only if there is evidence that this tuple has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="(n: shapeless.Nat)(implicit split: shapeless.ops.tuple.ReverseSplit[T,n.N])split.Out" id="shapeless.syntax.std;TupleOps.reverse_split(8e99845d32)">reverse_split</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless.syntax.std;TupleOps.reverse_split(8e99845d32).n">n</a>: <a href="../../nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.ReverseSplit[T,n.N]" id="shapeless.syntax.std;TupleOps.reverse_split(8e99845d32).split">split</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;ReverseSplit" title="shapeless.ops.tuple.ReverseSplit[T,n.N]">ReverseSplit</a><span class="delimiter">[</span>T, n.N<span class="delimiter">]</span><span class="delimiter">)</span>: split.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="split.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)split.Out">split</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Splits this tuple at the first occurrence of an element of type `U`, returning the prefix and suffix as a pair.
   * An explicit type argument must be provided. Available only if there is evidence that this tuple has an element
   * of type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit splitLeft: shapeless.ops.tuple.SplitLeft[T,U])splitLeft.Out" id="shapeless.syntax.std;TupleOps.splitLeft">splitLeft</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.splitLeft;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.SplitLeft[T,U]" id="shapeless.syntax.std;TupleOps.splitLeft.splitLeft">splitLeft</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;SplitLeft" title="shapeless.ops.tuple.SplitLeft[T,U]">SplitLeft</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">)</span>: splitLeft.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="splitLeft.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)splitLeft.Out">splitLeft</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Splits this tuple at the first occurrence of an element of type `U`, returning reverse of the prefix and suffix
   * as a pair. An explicit type argument must be provided. Available only if there is evidence that this tuple has
   * an element of type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit splitLeft: shapeless.ops.tuple.ReverseSplitLeft[T,U])splitLeft.Out" id="shapeless.syntax.std;TupleOps.reverse_splitLeft">reverse_splitLeft</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.reverse_splitLeft;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.ReverseSplitLeft[T,U]" id="shapeless.syntax.std;TupleOps.reverse_splitLeft.splitLeft">splitLeft</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;ReverseSplitLeft" title="shapeless.ops.tuple.ReverseSplitLeft[T,U]">ReverseSplitLeft</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">)</span>: splitLeft.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="splitLeft.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)splitLeft.Out">splitLeft</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Splits this tuple at the last occurrence of an element of type `U`, returning the prefix and suffix as a pair.
   * An explicit type argument must be provided. Available only if there is evidence that this tuple has an element
   * of type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit splitRight: shapeless.ops.tuple.SplitRight[T,U])splitRight.Out" id="shapeless.syntax.std;TupleOps.splitRight">splitRight</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.splitRight;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.SplitRight[T,U]" id="shapeless.syntax.std;TupleOps.splitRight.splitRight">splitRight</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;SplitRight" title="shapeless.ops.tuple.SplitRight[T,U]">SplitRight</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">)</span>: splitRight.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="splitRight.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)splitRight.Out">splitRight</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Splits this tuple at the last occurrence of an element of type `U`, returning reverse of the prefix and suffix
   * as a pair. An explicit type argument must be provided. Available only if there is evidence that this tuple has
   * an element of type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit splitRight: shapeless.ops.tuple.ReverseSplitRight[T,U])splitRight.Out" id="shapeless.syntax.std;TupleOps.reverse_splitRight">reverse_splitRight</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.reverse_splitRight;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.ReverseSplitRight[T,U]" id="shapeless.syntax.std;TupleOps.reverse_splitRight.splitRight">splitRight</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;ReverseSplitRight" title="shapeless.ops.tuple.ReverseSplitRight[T,U]">ReverseSplitRight</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">)</span>: splitRight.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="splitRight.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)splitRight.Out">splitRight</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Reverses this tuple.
   */</span>
  <span class="keyword">def</span> <a title="(implicit reverse: shapeless.ops.tuple.Reverse[T])reverse.Out" id="shapeless.syntax.std;TupleOps.reverse">reverse</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Reverse[T]" id="shapeless.syntax.std;TupleOps.reverse.reverse">reverse</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Reverse" title="shapeless.ops.tuple.Reverse[T]">Reverse</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: reverse.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="reverse.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)reverse.Out">reverse</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Maps a higher rank function across this tuple.
   */</span>
  <span class="keyword">def</span> <a title="(f: shapeless.Poly)(implicit mapper: shapeless.ops.tuple.Mapper[T,f.type])mapper.Out" id="shapeless.syntax.std;TupleOps.map">map</a><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless.syntax.std;TupleOps.map.f">f</a>: <a href="../../poly.scala.html#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Mapper[T,f.type]" id="shapeless.syntax.std;TupleOps.map.mapper">mapper</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Mapper" title="shapeless.ops.tuple.Mapper[T,f.type]">Mapper</a><span class="delimiter">[</span>T, f.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>: mapper.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="mapper.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)mapper.Out">mapper</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Flatmaps a higher rank function across this tuple.
   */</span>
  <span class="keyword">def</span> <a title="(f: shapeless.Poly)(implicit mapper: shapeless.ops.tuple.FlatMapper[T,f.type])mapper.Out" id="shapeless.syntax.std;TupleOps.flatMap">flatMap</a><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless.syntax.std;TupleOps.flatMap.f">f</a>: <a href="../../poly.scala.html#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.FlatMapper[T,f.type]" id="shapeless.syntax.std;TupleOps.flatMap.mapper">mapper</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;FlatMapper" title="shapeless.ops.tuple.FlatMapper[T,f.type]">FlatMapper</a><span class="delimiter">[</span>T, f.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>: mapper.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="mapper.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)mapper.Out">mapper</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Replaces each element of this tuple with a constant value.
   */</span>
  <span class="keyword">def</span> <a title="[C](c: C)(implicit mapper: shapeless.ops.tuple.ConstMapper[T,C])mapper.Out" id="shapeless.syntax.std;TupleOps.mapConst">mapConst</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.mapConst;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="C" id="shapeless.syntax.std;TupleOps.mapConst.c">c</a>: <a href="#shapeless.syntax.std;TupleOps.mapConst;C" title="C">C</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.ConstMapper[T,C]" id="shapeless.syntax.std;TupleOps.mapConst.mapper">mapper</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;ConstMapper" title="shapeless.ops.tuple.ConstMapper[T,C]">ConstMapper</a><span class="delimiter">[</span>T, C<span class="delimiter">]</span><span class="delimiter">)</span>: mapper.<a href="../../package.scala.html#shapeless.package;DepFn2;Out" title="mapper.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: T, u: C)mapper.Out">mapper</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <a href="#shapeless.syntax.std;TupleOps.mapConst.c" title="C">c</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Maps a higher rank function ''f'' across this tuple and folds the result using monomorphic combining operator
   * `op`. Available only if there is evidence that the result type of `f` at each element conforms to the argument
   * type of ''op''.
   */</span>
  <span class="keyword">def</span> <a title="[R](z: R)(f: shapeless.Poly)(op: (R, R) =&gt; R)(implicit folder: shapeless.ops.tuple.MapFolder[T,R,f.type])R" id="shapeless.syntax.std;TupleOps.foldMap">foldMap</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.foldMap;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="R" id="shapeless.syntax.std;TupleOps.foldMap.z">z</a>: <a href="#shapeless.syntax.std;TupleOps.foldMap;R" title="R">R</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless.syntax.std;TupleOps.foldMap.f">f</a>: <a href="../../poly.scala.html#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(R, R) =&gt; R" id="shapeless.syntax.std;TupleOps.foldMap.op">op</a>: <span class="delimiter">(</span>R, R<span class="delimiter">)</span> =&gt; R<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.MapFolder[T,R,f.type]" id="shapeless.syntax.std;TupleOps.foldMap.folder">folder</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;MapFolder" title="shapeless.ops.tuple.MapFolder[T,R,f.type]">MapFolder</a><span class="delimiter">[</span>T, R, f.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.syntax.std;TupleOps.foldMap;R" title="R">R</a> = <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;MapFolder.apply" title="(t: T, in: R, op: (R, R) =&gt; R)R">folder</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <a href="#shapeless.syntax.std;TupleOps.foldMap.z" title="R">z</a>, <a href="#shapeless.syntax.std;TupleOps.foldMap.op" title="(R, R) =&gt; R">op</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Computes a left fold over this tuple using the polymorphic binary combining operator `op`. Available only if
   * there is evidence `op` can consume/produce all the partial results of the appropriate types.
   */</span>
  <span class="keyword">def</span> <a title="[R](z: R)(op: shapeless.Poly)(implicit folder: shapeless.ops.tuple.LeftFolder[T,R,op.type])folder.Out" id="shapeless.syntax.std;TupleOps.foldLeft">foldLeft</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.foldLeft;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="R" id="shapeless.syntax.std;TupleOps.foldLeft.z">z</a>: <a href="#shapeless.syntax.std;TupleOps.foldLeft;R" title="R">R</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless.syntax.std;TupleOps.foldLeft.op">op</a>: <a href="../../poly.scala.html#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.LeftFolder[T,R,op.type]" id="shapeless.syntax.std;TupleOps.foldLeft.folder">folder</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;LeftFolder" title="shapeless.ops.tuple.LeftFolder[T,R,op.type]">LeftFolder</a><span class="delimiter">[</span>T, R, op.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>: folder.<a href="../../package.scala.html#shapeless.package;DepFn2;Out" title="folder.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: T, u: R)folder.Out">folder</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <a href="#shapeless.syntax.std;TupleOps.foldLeft.z" title="R">z</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Computes a right fold over this tuple using the polymorphic binary combining operator `op`. Available only if
   * there is evidence `op` can consume/produce all the partial results of the appropriate types.
   */</span>
  <span class="keyword">def</span> <a title="[R](z: R)(op: shapeless.Poly)(implicit folder: shapeless.ops.tuple.RightFolder[T,R,op.type])folder.Out" id="shapeless.syntax.std;TupleOps.foldRight">foldRight</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.foldRight;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="R" id="shapeless.syntax.std;TupleOps.foldRight.z">z</a>: <a href="#shapeless.syntax.std;TupleOps.foldRight;R" title="R">R</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless.syntax.std;TupleOps.foldRight.op">op</a>: <a href="../../poly.scala.html#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.RightFolder[T,R,op.type]" id="shapeless.syntax.std;TupleOps.foldRight.folder">folder</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;RightFolder" title="shapeless.ops.tuple.RightFolder[T,R,op.type]">RightFolder</a><span class="delimiter">[</span>T, R, op.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>: folder.<a href="../../package.scala.html#shapeless.package;DepFn2;Out" title="folder.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: T, u: R)folder.Out">folder</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <a href="#shapeless.syntax.std;TupleOps.foldRight.z" title="R">z</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Computes a left reduce over this tuple using the polymorphic binary combining operator `op`. Available only if
   * there is evidence that this tuple has at least one element and that `op` can consume/produce all the partial
   * results of the appropriate types.
   */</span>
  <span class="keyword">def</span> <a title="(op: shapeless.Poly)(implicit reducer: shapeless.ops.tuple.LeftReducer[T,op.type])reducer.Out" id="shapeless.syntax.std;TupleOps.reduceLeft">reduceLeft</a><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless.syntax.std;TupleOps.reduceLeft.op">op</a>: <a href="../../poly.scala.html#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.LeftReducer[T,op.type]" id="shapeless.syntax.std;TupleOps.reduceLeft.reducer">reducer</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;LeftReducer" title="shapeless.ops.tuple.LeftReducer[T,op.type]">LeftReducer</a><span class="delimiter">[</span>T, op.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>: reducer.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="reducer.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)reducer.Out">reducer</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Computes a right reduce over this tuple using the polymorphic binary combining operator `op`. Available only if
   * there is evidence that this tuple has at least one element and that `op` can consume/produce all the partial
   * results of the appropriate types.
   */</span>
  <span class="keyword">def</span> <a title="(op: shapeless.Poly)(implicit reducer: shapeless.ops.tuple.RightReducer[T,op.type])reducer.Out" id="shapeless.syntax.std;TupleOps.reduceRight">reduceRight</a><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless.syntax.std;TupleOps.reduceRight.op">op</a>: <a href="../../poly.scala.html#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.RightReducer[T,op.type]" id="shapeless.syntax.std;TupleOps.reduceRight.reducer">reducer</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;RightReducer" title="shapeless.ops.tuple.RightReducer[T,op.type]">RightReducer</a><span class="delimiter">[</span>T, op.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>: reducer.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="reducer.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)reducer.Out">reducer</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Zips this tuple with its argument tuple returning a tuple of pairs.
   */</span>
  <span class="keyword">def</span> <a title="[R](r: R)(implicit transpose: shapeless.ops.tuple.Transposer[(T, R)])transpose.Out" id="shapeless.syntax.std;TupleOps.zip(2f1bc74de6)">zip</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.zip(2f1bc74de6);R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="R" id="shapeless.syntax.std;TupleOps.zip(2f1bc74de6).r">r</a>: <a href="#shapeless.syntax.std;TupleOps.zip(2f1bc74de6);R" title="R">R</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Transposer[(T, R)]" id="shapeless.syntax.std;TupleOps.zip(2f1bc74de6).transpose">transpose</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Transposer" title="shapeless.ops.tuple.Transposer[(T, R)]">Transposer</a><span class="delimiter">[</span><span class="delimiter">(</span>T, R<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: transpose.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="transpose.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: (T, R))transpose.Out">transpose</a><span class="delimiter">(</span><span title="(_1: T, _2: R)(T, R)" class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <a href="#shapeless.syntax.std;TupleOps.zip(2f1bc74de6).r" title="R">r</a><span class="delimiter">)</span><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Zips this tuple of monomorphic function values with its argument tuple of correspondingly typed function
   * arguments returning the result of each application as a tuple. Available only if there is evidence that the
   * corresponding function and argument elements have compatible types.
   */</span>
  <span class="keyword">def</span> <a title="[A](a: A)(implicit zipper: shapeless.ops.tuple.ZipApply[T,A])zipper.Out" id="shapeless.syntax.std;TupleOps.zipApply">zipApply</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.zipApply;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="shapeless.syntax.std;TupleOps.zipApply.a">a</a>: <a href="#shapeless.syntax.std;TupleOps.zipApply;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.ZipApply[T,A]" id="shapeless.syntax.std;TupleOps.zipApply.zipper">zipper</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;ZipApply" title="shapeless.ops.tuple.ZipApply[T,A]">ZipApply</a><span class="delimiter">[</span>T, A<span class="delimiter">]</span><span class="delimiter">)</span>: zipper.<a href="../../package.scala.html#shapeless.package;DepFn2;Out" title="zipper.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: T, u: A)zipper.Out">zipper</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <a href="#shapeless.syntax.std;TupleOps.zipApply.a" title="A">a</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Zips this tuple of tuples returning a tuple of tuples. Available only if there is evidence that this
   * tuple has tuple elements.
   */</span>
  <span class="keyword">def</span> <a title="(implicit transpose: shapeless.ops.tuple.Transposer[T])transpose.Out" id="shapeless.syntax.std;TupleOps.zip(63ea017c64)">zip</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Transposer[T]" id="shapeless.syntax.std;TupleOps.zip(63ea017c64).transpose">transpose</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Transposer" title="shapeless.ops.tuple.Transposer[T]">Transposer</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: transpose.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="transpose.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)transpose.Out">transpose</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Unzips this tuple of tuples returning a tuple of tuples. Available only if there is evidence that this
   * tuple has tuple elements.
   */</span>
  <span class="keyword">def</span> <a title="(implicit transpose: shapeless.ops.tuple.Transposer[T])transpose.Out" id="shapeless.syntax.std;TupleOps.unzip">unzip</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Transposer[T]" id="shapeless.syntax.std;TupleOps.unzip.transpose">transpose</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Transposer" title="shapeless.ops.tuple.Transposer[T]">Transposer</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: transpose.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="transpose.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)transpose.Out">transpose</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Zips this tuple with its argument tuple of tuples, returning a tuple of tuples with each element of
   * this tuple prepended to the corresponding tuple element of the argument tuple.
   */</span>
  <span class="keyword">def</span> <a title="[R](r: R)(implicit zipOne: shapeless.ops.tuple.ZipOne[T,R])zipOne.Out" id="shapeless.syntax.std;TupleOps.zipOne">zipOne</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.zipOne;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="R" id="shapeless.syntax.std;TupleOps.zipOne.r">r</a>: <a href="#shapeless.syntax.std;TupleOps.zipOne;R" title="R">R</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.ZipOne[T,R]" id="shapeless.syntax.std;TupleOps.zipOne.zipOne">zipOne</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;ZipOne" title="shapeless.ops.tuple.ZipOne[T,R]">ZipOne</a><span class="delimiter">[</span>T, R<span class="delimiter">]</span><span class="delimiter">)</span>: zipOne.<a href="../../package.scala.html#shapeless.package;DepFn2;Out" title="zipOne.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: T, u: R)zipOne.Out">zipOne</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <a href="#shapeless.syntax.std;TupleOps.zipOne.r" title="R">r</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Zips this tuple with a constant, resulting in a tuple of tuples, with each element being of the form
   * ({element from original tuple}, {supplied constant})
   */</span>
  <span class="keyword">def</span> <a title="[C](c: C)(implicit zipper: shapeless.ops.tuple.ZipConst[T,C])zipper.Out" id="shapeless.syntax.std;TupleOps.zipConst">zipConst</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.zipConst;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="C" id="shapeless.syntax.std;TupleOps.zipConst.c">c</a>: <a href="#shapeless.syntax.std;TupleOps.zipConst;C" title="C">C</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.ZipConst[T,C]" id="shapeless.syntax.std;TupleOps.zipConst.zipper">zipper</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;ZipConst" title="shapeless.ops.tuple.ZipConst[T,C]">ZipConst</a><span class="delimiter">[</span>T, C<span class="delimiter">]</span><span class="delimiter">)</span>: zipper.<a href="../../package.scala.html#shapeless.package;DepFn2;Out" title="zipper.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn2.apply" title="(t: T, u: C)zipper.Out">zipper</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a>, <a href="#shapeless.syntax.std;TupleOps.zipConst.c" title="C">c</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Transposes this tuple.
   */</span>
  <span class="keyword">def</span> <a title="(implicit transpose: shapeless.ops.tuple.Transposer[T])transpose.Out" id="shapeless.syntax.std;TupleOps.transpose">transpose</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Transposer[T]" id="shapeless.syntax.std;TupleOps.transpose.transpose">transpose</a>: <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Transposer" title="shapeless.ops.tuple.Transposer[T]">Transposer</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: transpose.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="transpose.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)transpose.Out">transpose</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns a tuple typed as a repetition of the least upper bound of the types of the elements of this tuple.
   */</span>
  <span class="keyword">def</span> <a title="(implicit unifier: shapeless.ops.tuple.Unifier[T])unifier.Out" id="shapeless.syntax.std;TupleOps.unify">unify</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Unifier[T]" id="shapeless.syntax.std;TupleOps.unify.unifier">unifier</a> : <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Unifier" title="shapeless.ops.tuple.Unifier[T]">Unifier</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> : unifier.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="unifier.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)unifier.Out">unifier</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns a tuple with all elements that are subtypes of `B` typed as `B`.
   */</span>
  <span class="keyword">def</span> <a title="[B](implicit subtypeUnifier: shapeless.ops.tuple.SubtypeUnifier[T,B])subtypeUnifier.Out" id="shapeless.syntax.std;TupleOps.unifySubtypes">unifySubtypes</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.unifySubtypes;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.SubtypeUnifier[T,B]" id="shapeless.syntax.std;TupleOps.unifySubtypes.subtypeUnifier">subtypeUnifier</a> : <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;SubtypeUnifier" title="shapeless.ops.tuple.SubtypeUnifier[T,B]">SubtypeUnifier</a><span class="delimiter">[</span>T, B<span class="delimiter">]</span><span class="delimiter">)</span> : subtypeUnifier.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="subtypeUnifier.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)subtypeUnifier.Out">subtypeUnifier</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Compute the length of this tuple.
   */</span>
  <span class="keyword">def</span> <a title="(implicit length: shapeless.ops.tuple.Length[T])length.Out" id="shapeless.syntax.std;TupleOps.length">length</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.Length[T]" id="shapeless.syntax.std;TupleOps.length.length">length</a> : <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;Length" title="shapeless.ops.tuple.Length[T]">Length</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> : length.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="length.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)length.Out">length</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Converts this tuple to a `List` of elements typed as the least upper bound of the types of the elements
   * of this tuple.
   */</span>
  <span class="keyword">def</span> <a title="[Lub](implicit toList: shapeless.ops.tuple.ToList[T,Lub])toList.Out" id="shapeless.syntax.std;TupleOps.toList">toList</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.toList;Lub">Lub</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.ToList[T,Lub]" id="shapeless.syntax.std;TupleOps.toList.toList">toList</a> : <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;ToList" title="shapeless.ops.tuple.ToList[T,Lub]">ToList</a><span class="delimiter">[</span>T, Lub<span class="delimiter">]</span><span class="delimiter">)</span> : toList.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="toList.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)toList.Out">toList</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Converts this tuple to an `Array` of elements typed as the least upper bound of the types of the elements
   * of this tuple.
   * 
   * It is advisable to specify the type parameter explicitly, because for many reference types, case classes in
   * particular, the inferred type will be too precise (ie. `Product with Serializable with CC` for a typical case class
   * `CC`) which interacts badly with the invariance of `Array`s.
   */</span>
  <span class="keyword">def</span> <a title="[Lub](implicit toArray: shapeless.ops.tuple.ToArray[T,Lub])toArray.Out" id="shapeless.syntax.std;TupleOps.toArray">toArray</a><span class="delimiter">[</span><a title="" id="shapeless.syntax.std;TupleOps.toArray;Lub">Lub</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.tuple.ToArray[T,Lub]" id="shapeless.syntax.std;TupleOps.toArray.toArray">toArray</a> : <a href="../../ops/tuples.scala.html#shapeless.ops.tuple;ToArray" title="shapeless.ops.tuple.ToArray[T,Lub]">ToArray</a><span class="delimiter">[</span>T, Lub<span class="delimiter">]</span><span class="delimiter">)</span> : toArray.<a href="../../package.scala.html#shapeless.package;DepFn1;Out" title="toArray.Out">Out</a> = <a href="../../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)toArray.Out">toArray</a><span class="delimiter">(</span><a href="#shapeless.syntax.std;TupleOps.t" title="T">t</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
