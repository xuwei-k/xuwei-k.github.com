<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>shapeless/syntax/hlists.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (c) 2011-13 Miles Sabin 
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span class="keyword">package</span> shapeless
<span class="keyword">package</span> syntax

<span class="keyword">import</span> scala.annotation.tailrec

<span class="comment">/**
 * Carrier for `HList` operations.
 * 
 * These methods are implemented here and pimped onto the minimal `HList` types to avoid issues that would otherwise be
 * caused by the covariance of `::[H, T]`.
 * 
 * @author Miles Sabin
 */</span>
<span class="keyword">final</span> <span class="keyword">class</span> <a title="class HListOps[L &lt;: shapeless.HList] extends AnyRef" id="shapeless.syntax;HListOps">HListOps</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.syntax;HListOps;L">L</a> &lt;: HList<span class="delimiter">]</span><a href="#shapeless.syntax;HListOps" title="shapeless.syntax.HListOps[L]" class="delimiter">(</a><a title="L" id="shapeless.syntax;HListOps.l">l</a> : <a href="#shapeless.syntax;HListOps;L" title="L">L</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="keyword">import</span> ops.<a href="../ops/hlists.scala.html#shapeless.ops.hlist" title="shapeless.ops.hlist.type">hlist</a>._

  <span class="comment">/**
   * Returns the head of this `HList`. Available only if there is evidence that this `HList` is composite.
   */</span>
  <span class="keyword">def</span> <a title="(implicit c: shapeless.ops.hlist.IsHCons[L])c.H" id="shapeless.syntax;HListOps.head">head</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.IsHCons[L]" id="shapeless.syntax;HListOps.head.c">c</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;IsHCons" title="shapeless.ops.hlist.IsHCons[L]">IsHCons</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> : c.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;IsHCons;H" title="c.H">H</a> = <a href="#shapeless.syntax;HListOps.head.c" title="shapeless.ops.hlist.IsHCons[L]">c</a>.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;IsHCons.head" title="(l: L)c.H">head</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span> 

  <span class="comment">/**
   * Returns the tail of this `HList`. Available only if there is evidence that this `HList` is composite.
   */</span>
  <span class="keyword">def</span> <a title="(implicit c: shapeless.ops.hlist.IsHCons[L])c.T" id="shapeless.syntax;HListOps.tail">tail</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.IsHCons[L]" id="shapeless.syntax;HListOps.tail.c">c</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;IsHCons" title="shapeless.ops.hlist.IsHCons[L]">IsHCons</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> : c.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;IsHCons;T" title="c.T">T</a> = <a href="#shapeless.syntax;HListOps.tail.c" title="shapeless.ops.hlist.IsHCons[L]">c</a>.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;IsHCons.tail" title="(l: L)c.T">tail</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Prepend the argument element to this `HList`.
   */</span>
  <span class="keyword">def</span> <a title="[H](h: H)shapeless.::[H,L]" id="shapeless.syntax;HListOps.::">::</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.::;H">H</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="H" id="shapeless.syntax;HListOps.::.h">h</a> : <a href="#shapeless.syntax;HListOps.::;H" title="H">H</a><span class="delimiter">)</span> : H <a href="../hlists.scala.html#shapeless;::" title="shapeless.::[H,L]">::</a> L = shapeless.<a href="../hlists.scala.html#shapeless;::" title="(head: H, tail: L)shapeless.::[H,L]">::</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.::.h" title="H">h</a>, <a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Prepend the argument element to this `HList`.
   */</span>
  <span class="keyword">def</span> <a title="[H](h: H)shapeless.::[H,L]" id="shapeless.syntax;HListOps.+:">+:</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.+:;H">H</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="H" id="shapeless.syntax;HListOps.+:.h">h</a> : <a href="#shapeless.syntax;HListOps.+:;H" title="H">H</a><span class="delimiter">)</span> : H <a href="../hlists.scala.html#shapeless;::" title="shapeless.::[H,L]">::</a> L = shapeless.<a href="../hlists.scala.html#shapeless;::" title="(head: H, tail: L)shapeless.::[H,L]">::</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.+:.h" title="H">h</a>, <a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Append the argument element to this `HList`.
   */</span>
  <span class="keyword">def</span> <a title="[T](t: T)(implicit prepend: shapeless.ops.hlist.Prepend[L,shapeless.::[T,shapeless.HNil]])prepend.Out" id="shapeless.syntax;HListOps.:+">:+</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.:+;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="shapeless.syntax;HListOps.:+.t">t</a> : <a href="#shapeless.syntax;HListOps.:+;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Prepend[L,shapeless.::[T,shapeless.HNil]]" id="shapeless.syntax;HListOps.:+.prepend">prepend</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Prepend" title="shapeless.ops.hlist.Prepend[L,shapeless.::[T,shapeless.HNil]]">Prepend</a><span class="delimiter">[</span>L, T :: HNil<span class="delimiter">]</span><span class="delimiter">)</span> : prepend.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Prepend;Out" title="prepend.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L, u: shapeless.::[T,shapeless.HNil])prepend.Out">prepend</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a>, <a href="#shapeless.syntax;HListOps.:+.t" title="T">t</a> <a href="../hlists.scala.html#shapeless;HNil.::" title="(h: T)shapeless.::[T,shapeless.HNil]">::</a> <a href="../hlists.scala.html#shapeless.HNil" title="shapeless.HNil.type">HNil</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Append the argument `HList` to this `HList`.
   */</span>
  <span class="keyword">def</span> <a title="[S &lt;: shapeless.HList](suffix: S)(implicit prepend: shapeless.ops.hlist.Prepend[L,S])prepend.Out" id="shapeless.syntax;HListOps.++">++</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.syntax;HListOps.++;S">S</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="shapeless.syntax;HListOps.++.suffix">suffix</a> : <a href="#shapeless.syntax;HListOps.++;S" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Prepend[L,S]" id="shapeless.syntax;HListOps.++.prepend">prepend</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Prepend" title="shapeless.ops.hlist.Prepend[L,S]">Prepend</a><span class="delimiter">[</span>L, S<span class="delimiter">]</span><span class="delimiter">)</span> : prepend.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Prepend;Out" title="prepend.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L, u: S)prepend.Out">prepend</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a>, <a href="#shapeless.syntax;HListOps.++.suffix" title="S">suffix</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Prepend the argument `HList` to this `HList`.
   */</span>
  <span class="keyword">def</span> <a title="[P &lt;: shapeless.HList](prefix: P)(implicit prepend: shapeless.ops.hlist.Prepend[P,L])prepend.Out" id="shapeless.syntax;HListOps.++:">++:</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.syntax;HListOps.++:;P">P</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="P" id="shapeless.syntax;HListOps.++:.prefix">prefix</a> : <a href="#shapeless.syntax;HListOps.++:;P" title="P">P</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Prepend[P,L]" id="shapeless.syntax;HListOps.++:.prepend">prepend</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Prepend" title="shapeless.ops.hlist.Prepend[P,L]">Prepend</a><span class="delimiter">[</span>P, L<span class="delimiter">]</span><span class="delimiter">)</span> : prepend.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Prepend;Out" title="prepend.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: P, u: L)prepend.Out">prepend</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.++:.prefix" title="P">prefix</a>, <a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Prepend the argument `HList` to this `HList`.
   */</span>
  <span class="keyword">def</span> <a title="[P &lt;: shapeless.HList](prefix: P)(implicit prepend: shapeless.ops.hlist.Prepend[P,L])prepend.Out" id="shapeless.syntax;HListOps.:::">:::</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.syntax;HListOps.:::;P">P</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="P" id="shapeless.syntax;HListOps.:::.prefix">prefix</a> : <a href="#shapeless.syntax;HListOps.:::;P" title="P">P</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Prepend[P,L]" id="shapeless.syntax;HListOps.:::.prepend">prepend</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Prepend" title="shapeless.ops.hlist.Prepend[P,L]">Prepend</a><span class="delimiter">[</span>P, L<span class="delimiter">]</span><span class="delimiter">)</span> : prepend.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Prepend;Out" title="prepend.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: P, u: L)prepend.Out">prepend</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.:::.prefix" title="P">prefix</a>, <a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Prepend the reverse of the argument `HList` to this `HList`.
   */</span>
  <span class="keyword">def</span> <a title="[P &lt;: shapeless.HList](prefix: P)(implicit prepend: shapeless.ops.hlist.ReversePrepend[P,L])prepend.Out" id="shapeless.syntax;HListOps.reverse_:::">reverse_:::</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.syntax;HListOps.reverse_:::;P">P</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="P" id="shapeless.syntax;HListOps.reverse_:::.prefix">prefix</a> : <a href="#shapeless.syntax;HListOps.reverse_:::;P" title="P">P</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ReversePrepend[P,L]" id="shapeless.syntax;HListOps.reverse_:::.prepend">prepend</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;ReversePrepend" title="shapeless.ops.hlist.ReversePrepend[P,L]">ReversePrepend</a><span class="delimiter">[</span>P, L<span class="delimiter">]</span><span class="delimiter">)</span> : prepend.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;ReversePrepend;Out" title="prepend.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: P, u: L)prepend.Out">prepend</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.reverse_:::.prefix" title="P">prefix</a>, <a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the ''nth'' element of this `HList`. An explicit type argument must be provided. Available only if there is
   * evidence that this `HList` has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat](implicit at: shapeless.ops.hlist.At[L,N])at.Out" id="shapeless.syntax;HListOps.apply(807dde980f)">apply</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax;HListOps.apply(807dde980f);N">N</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.At[L,N]" id="shapeless.syntax;HListOps.apply(807dde980f).at">at</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;At" title="shapeless.ops.hlist.At[L,N]">At</a><span class="delimiter">[</span>L, N<span class="delimiter">]</span><span class="delimiter">)</span> : at.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="at.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)at.Out">at</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the ''nth'' element of this `HList`. Available only if there is evidence that this `HList` has at least ''n''
   * elements.
   */</span>
  <span class="keyword">def</span> <a title="(n: shapeless.Nat)(implicit at: shapeless.ops.hlist.At[L,n.N])at.Out" id="shapeless.syntax;HListOps.apply(c58168ebaf)">apply</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless.syntax;HListOps.apply(c58168ebaf).n">n</a> : <a href="../nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.At[L,n.N]" id="shapeless.syntax;HListOps.apply(c58168ebaf).at">at</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;At" title="shapeless.ops.hlist.At[L,n.N]">At</a><span class="delimiter">[</span>L, n.N<span class="delimiter">]</span><span class="delimiter">)</span> : at.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="at.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)at.Out">at</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Returns the ''nth'' element of this `HList`. An explicit type argument must be provided. Available only if there is
   * evidence that this `HList` has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat](implicit at: shapeless.ops.hlist.At[L,N])at.Out" id="shapeless.syntax;HListOps.at(807dde980f)">at</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax;HListOps.at(807dde980f);N">N</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.At[L,N]" id="shapeless.syntax;HListOps.at(807dde980f).at">at</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;At" title="shapeless.ops.hlist.At[L,N]">At</a><span class="delimiter">[</span>L, N<span class="delimiter">]</span><span class="delimiter">)</span> : at.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="at.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)at.Out">at</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the ''nth'' element of this `HList`. Available only if there is evidence that this `HList` has at least ''n''
   * elements.
   */</span>
  <span class="keyword">def</span> <a title="(n: shapeless.Nat)(implicit at: shapeless.ops.hlist.At[L,n.N])at.Out" id="shapeless.syntax;HListOps.at(c58168ebaf)">at</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless.syntax;HListOps.at(c58168ebaf).n">n</a> : <a href="../nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.At[L,n.N]" id="shapeless.syntax;HListOps.at(c58168ebaf).at">at</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;At" title="shapeless.ops.hlist.At[L,n.N]">At</a><span class="delimiter">[</span>L, n.N<span class="delimiter">]</span><span class="delimiter">)</span> : at.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="at.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)at.Out">at</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Returns the last element of this `HList`. Available only if there is evidence that this `HList` is composite.
   */</span>
  <span class="keyword">def</span> <a title="(implicit last: shapeless.ops.hlist.Last[L])last.Out" id="shapeless.syntax;HListOps.last">last</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Last[L]" id="shapeless.syntax;HListOps.last.last">last</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Last" title="shapeless.ops.hlist.Last[L]">Last</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> : last.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="last.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)last.Out">last</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns an `HList` consisting of all the elements of this `HList` except the last. Available only if there is
   * evidence that this `HList` is composite.
   */</span>
  <span class="keyword">def</span> <a title="(implicit init: shapeless.ops.hlist.Init[L])init.Out" id="shapeless.syntax;HListOps.init">init</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Init[L]" id="shapeless.syntax;HListOps.init.init">init</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Init" title="shapeless.ops.hlist.Init[L]">Init</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> : init.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Init;Out" title="init.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)init.Out">init</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Returns the first element of type `U` of this `HList`. An explicit type argument must be provided. Available only
   * if there is evidence that this `HList` has an element of type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit selector: shapeless.ops.hlist.Selector[L,U])U" id="shapeless.syntax;HListOps.select">select</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.select;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Selector[L,U]" id="shapeless.syntax;HListOps.select.selector">selector</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Selector" title="shapeless.ops.hlist.Selector[L,U]">Selector</a><span class="delimiter">[</span>L, U<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#shapeless.syntax;HListOps.select;U" title="U">U</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)selector.Out">selector</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns all elements of type `U` of this `HList`. An explicit type argument must be provided.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit filter: shapeless.ops.hlist.Filter[L,U])filter.Out" id="shapeless.syntax;HListOps.filter">filter</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.filter;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Filter[L,U]" id="shapeless.syntax;HListOps.filter.filter">filter</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Filter" title="shapeless.ops.hlist.Filter[L,U]">Filter</a><span class="delimiter">[</span>L, U<span class="delimiter">]</span><span class="delimiter">)</span> : filter.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Filter;Out" title="filter.Out">Out</a>  = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)filter.Out">filter</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns all elements of type different than `U` of this `HList`. An explicit type argument must be provided.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit filter: shapeless.ops.hlist.FilterNot[L,U])filter.Out" id="shapeless.syntax;HListOps.filterNot">filterNot</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.filterNot;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.FilterNot[L,U]" id="shapeless.syntax;HListOps.filterNot.filter">filter</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;FilterNot" title="shapeless.ops.hlist.FilterNot[L,U]">FilterNot</a><span class="delimiter">[</span>L, U<span class="delimiter">]</span><span class="delimiter">)</span> : filter.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;FilterNot;Out" title="filter.Out">Out</a>  = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)filter.Out">filter</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Returns the first element of type `U` of this `HList` plus the remainder of the `HList`. An explicit type argument
   * must be provided. Available only if there is evidence that this `HList` has an element of type `U`.
   * 
   * The `Elem` suffix is here to avoid creating an ambiguity with RecordOps#remove and should be removed if
   * SI-5414 is resolved in a way which eliminates the ambiguity.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit remove: shapeless.ops.hlist.Remove[L,U])remove.Out" id="shapeless.syntax;HListOps.removeElem">removeElem</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.removeElem;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Remove[L,U]" id="shapeless.syntax;HListOps.removeElem.remove">remove</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Remove" title="shapeless.ops.hlist.Remove[L,U]">Remove</a><span class="delimiter">[</span>L, U<span class="delimiter">]</span><span class="delimiter">)</span>: remove.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="remove.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)remove.Out">remove</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Returns the first elements of this `HList` that have types in `SL` plus the remainder of the `HList`. An expicit
   * type argument must be provided. Available only if there is evidence that this `HList` contains elements with
   * types in `SL`.
   */</span>
  <span class="keyword">def</span> <a title="[SL &lt;: shapeless.HList](implicit removeAll: shapeless.ops.hlist.RemoveAll[L,SL])removeAll.Out" id="shapeless.syntax;HListOps.removeAll">removeAll</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.syntax;HListOps.removeAll;SL">SL</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.RemoveAll[L,SL]" id="shapeless.syntax;HListOps.removeAll.removeAll">removeAll</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;RemoveAll" title="shapeless.ops.hlist.RemoveAll[L,SL]">RemoveAll</a><span class="delimiter">[</span>L, SL<span class="delimiter">]</span><span class="delimiter">)</span>: removeAll.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="removeAll.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)removeAll.Out">removeAll</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Replaces the first element of type `U` of this `HList` with the supplied value, also of type `U` returning both
   * the replaced element and the updated `HList`. Available only if there is evidence that this `HList` has an element
   * of type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U](u: U)(implicit replacer: shapeless.ops.hlist.Replacer[L,U,U])replacer.Out" id="shapeless.syntax;HListOps.replace">replace</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.replace;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="U" id="shapeless.syntax;HListOps.replace.u">u</a> : <a href="#shapeless.syntax;HListOps.replace;U" title="U">U</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Replacer[L,U,U]" id="shapeless.syntax;HListOps.replace.replacer">replacer</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Replacer" title="shapeless.ops.hlist.Replacer[L,U,U]">Replacer</a><span class="delimiter">[</span>L, U, U<span class="delimiter">]</span><span class="delimiter">)</span>: replacer.<a href="../package.scala.html#shapeless.package;DepFn2;Out" title="replacer.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L, u: U)replacer.Out">replacer</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a>, <a href="#shapeless.syntax;HListOps.replace.u" title="U">u</a><span class="delimiter">)</span>
  
  <span class="keyword">class</span> <a title="class ReplaceTypeAux[U] extends AnyRef" id="shapeless.syntax;HListOps;ReplaceTypeAux">ReplaceTypeAux</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps;ReplaceTypeAux;U">U</a><span class="delimiter">]</span> <a href="#shapeless.syntax;HListOps;ReplaceTypeAux" title="HListOps.this.ReplaceTypeAux[U]" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="[V](v: V)(implicit replacer: shapeless.ops.hlist.Replacer[L,U,V])replacer.Out" id="shapeless.syntax;HListOps;ReplaceTypeAux.apply">apply</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps;ReplaceTypeAux.apply;V">V</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="V" id="shapeless.syntax;HListOps;ReplaceTypeAux.apply.v">v</a> : <a href="#shapeless.syntax;HListOps;ReplaceTypeAux.apply;V" title="V">V</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Replacer[L,U,V]" id="shapeless.syntax;HListOps;ReplaceTypeAux.apply.replacer">replacer</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Replacer" title="shapeless.ops.hlist.Replacer[L,U,V]">Replacer</a><span class="delimiter">[</span>L, U, V<span class="delimiter">]</span><span class="delimiter">)</span>: replacer.<a href="../package.scala.html#shapeless.package;DepFn2;Out" title="replacer.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L, u: V)replacer.Out">replacer</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a>, <a href="#shapeless.syntax;HListOps;ReplaceTypeAux.apply.v" title="V">v</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Replaces the first element of type `U` of this `HList` with the supplied value of type `V`, returning both the
   * replaced element and the updated `HList`. An explicit type argument must be provided for `U`. Available only if
   * there is evidence that this `HList` has an element of type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U]=&gt; HListOps.this.ReplaceTypeAux[U]" id="shapeless.syntax;HListOps.replaceType">replaceType</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.replaceType;U">U</a><span class="delimiter">]</span> = <span title="HListOps.this.ReplaceTypeAux[U]" class="keyword">new</span> <a href="#shapeless.syntax;HListOps;ReplaceTypeAux" title="HListOps.this.ReplaceTypeAux[U]">ReplaceTypeAux</a><span class="delimiter">[</span>U<span class="delimiter">]</span>
  
  <span class="comment">/**
   * Replaces the first element of type `U` of this `HList` with the supplied value, also of type `U`. Available only
   * if there is evidence that this `HList` has an element of type `U`.
   * 
   * The `Elem` suffix is here to avoid creating an ambiguity with RecordOps#updated and should be removed if
   * SI-5414 is resolved in a way which eliminates the ambiguity.
   */</span>
  <span class="keyword">def</span> <a title="[U, Out &lt;: shapeless.HList](u: U)(implicit replacer: shapeless.ops.hlist.Replacer.Aux[L,U,U,(U, Out)])Out" id="shapeless.syntax;HListOps.updatedElem">updatedElem</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.updatedElem;U">U</a>, <a title=" &lt;: shapeless.HList" id="shapeless.syntax;HListOps.updatedElem;Out">Out</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="U" id="shapeless.syntax;HListOps.updatedElem.u">u</a> : <a href="#shapeless.syntax;HListOps.updatedElem;U" title="U">U</a><span class="delimiter">)</span>
    <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Replacer.Aux[L,U,U,(U, Out)]" id="shapeless.syntax;HListOps.updatedElem.replacer">replacer</a> : Replacer.<a href="../ops/hlists.scala.html#shapeless.ops.hlist.Replacer;<refinement>" title="shapeless.ops.hlist.Replacer.Aux[L,U,U,(U, Out)]">Aux</a><span class="delimiter">[</span>L, U, U, <span class="delimiter">(</span>U, Out<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#shapeless.syntax;HListOps.updatedElem;Out" title="Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L, u: U)(U, Out)">replacer</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a>, <a href="#shapeless.syntax;HListOps.updatedElem.u" title="U">u</a><span class="delimiter">)</span>.<span title="=&gt; Out">_2</span>
  
  <span class="keyword">class</span> <a title="class UpdatedTypeAux[U] extends AnyRef" id="shapeless.syntax;HListOps;UpdatedTypeAux">UpdatedTypeAux</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps;UpdatedTypeAux;U">U</a><span class="delimiter">]</span> <a href="#shapeless.syntax;HListOps;UpdatedTypeAux" title="HListOps.this.UpdatedTypeAux[U]" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="[V, Out &lt;: shapeless.HList](v: V)(implicit replacer: shapeless.ops.hlist.Replacer.Aux[L,U,V,(U, Out)])Out" id="shapeless.syntax;HListOps;UpdatedTypeAux.apply">apply</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps;UpdatedTypeAux.apply;V">V</a>, <a title=" &lt;: shapeless.HList" id="shapeless.syntax;HListOps;UpdatedTypeAux.apply;Out">Out</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="V" id="shapeless.syntax;HListOps;UpdatedTypeAux.apply.v">v</a> : <a href="#shapeless.syntax;HListOps;UpdatedTypeAux.apply;V" title="V">V</a><span class="delimiter">)</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Replacer.Aux[L,U,V,(U, Out)]" id="shapeless.syntax;HListOps;UpdatedTypeAux.apply.replacer">replacer</a> : Replacer.<a href="../ops/hlists.scala.html#shapeless.ops.hlist.Replacer;<refinement>" title="shapeless.ops.hlist.Replacer.Aux[L,U,V,(U, Out)]">Aux</a><span class="delimiter">[</span>L, U, V, <span class="delimiter">(</span>U, Out<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#shapeless.syntax;HListOps;UpdatedTypeAux.apply;Out" title="Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L, u: V)(U, Out)">replacer</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a>, <a href="#shapeless.syntax;HListOps;UpdatedTypeAux.apply.v" title="V">v</a><span class="delimiter">)</span>.<span title="=&gt; Out">_2</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Replaces the first element of type `U` of this `HList` with the supplied value of type `V`. An explicit type
   * argument must be provided for `U`. Available only if there is evidence that this `HList` has an element of
   * type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U]=&gt; HListOps.this.UpdatedTypeAux[U]" id="shapeless.syntax;HListOps.updatedType">updatedType</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.updatedType;U">U</a><span class="delimiter">]</span> = <span title="HListOps.this.UpdatedTypeAux[U]" class="keyword">new</span> <a href="#shapeless.syntax;HListOps;UpdatedTypeAux" title="HListOps.this.UpdatedTypeAux[U]">UpdatedTypeAux</a><span class="delimiter">[</span>U<span class="delimiter">]</span>
  
  <span class="keyword">class</span> <a title="class UpdatedAtAux[N &lt;: shapeless.Nat] extends AnyRef" id="shapeless.syntax;HListOps;UpdatedAtAux">UpdatedAtAux</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax;HListOps;UpdatedAtAux;N">N</a> &lt;: Nat<span class="delimiter">]</span> <a href="#shapeless.syntax;HListOps;UpdatedAtAux" title="HListOps.this.UpdatedAtAux[N]" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="[U, V, Out &lt;: shapeless.HList](u: U)(implicit replacer: shapeless.ops.hlist.ReplaceAt.Aux[L,N,U,(V, Out)])Out" id="shapeless.syntax;HListOps;UpdatedAtAux.apply">apply</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps;UpdatedAtAux.apply;U">U</a>, <a title="" id="shapeless.syntax;HListOps;UpdatedAtAux.apply;V">V</a>, <a title=" &lt;: shapeless.HList" id="shapeless.syntax;HListOps;UpdatedAtAux.apply;Out">Out</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="U" id="shapeless.syntax;HListOps;UpdatedAtAux.apply.u">u</a> : <a href="#shapeless.syntax;HListOps;UpdatedAtAux.apply;U" title="U">U</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ReplaceAt.Aux[L,N,U,(V, Out)]" id="shapeless.syntax;HListOps;UpdatedAtAux.apply.replacer">replacer</a> : ReplaceAt.<a href="../ops/hlists.scala.html#shapeless.ops.hlist.ReplaceAt;<refinement>" title="shapeless.ops.hlist.ReplaceAt.Aux[L,N,U,(V, Out)]">Aux</a><span class="delimiter">[</span>L, N, U, <span class="delimiter">(</span>V, Out<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#shapeless.syntax;HListOps;UpdatedAtAux.apply;Out" title="Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L, u: U)(V, Out)">replacer</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a>, <a href="#shapeless.syntax;HListOps;UpdatedAtAux.apply.u" title="U">u</a><span class="delimiter">)</span>.<span title="=&gt; Out">_2</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Replaces the ''nth' element of this `HList` with the supplied value of type `U`. An explicit type argument
   * must be provided for `N`. Available only if there is evidence that this `HList` has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat]=&gt; HListOps.this.UpdatedAtAux[N]" id="shapeless.syntax;HListOps.updatedAt(08ea60a64d)">updatedAt</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax;HListOps.updatedAt(08ea60a64d);N">N</a> &lt;: Nat<span class="delimiter">]</span> = <span title="HListOps.this.UpdatedAtAux[N]" class="keyword">new</span> <a href="#shapeless.syntax;HListOps;UpdatedAtAux" title="HListOps.this.UpdatedAtAux[N]">UpdatedAtAux</a><span class="delimiter">[</span>N<span class="delimiter">]</span>
  
  <span class="comment">/**
   * Replaces the ''nth' element of this `HList` with the supplied value of type `U`. Available only if there is
   * evidence that this `HList` has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[U, V, Out &lt;: shapeless.HList](n: shapeless.Nat, u: U)(implicit replacer: shapeless.ops.hlist.ReplaceAt.Aux[L,n.N,U,(V, Out)])Out" id="shapeless.syntax;HListOps.updatedAt(40ffcb2899)">updatedAt</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.updatedAt(40ffcb2899);U">U</a>, <a title="" id="shapeless.syntax;HListOps.updatedAt(40ffcb2899);V">V</a>, <a title=" &lt;: shapeless.HList" id="shapeless.syntax;HListOps.updatedAt(40ffcb2899);Out">Out</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless.syntax;HListOps.updatedAt(40ffcb2899).n">n</a>: <a href="../nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a>, <a title="U" id="shapeless.syntax;HListOps.updatedAt(40ffcb2899).u">u</a> : <a href="#shapeless.syntax;HListOps.updatedAt(40ffcb2899);U" title="U">U</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ReplaceAt.Aux[L,n.N,U,(V, Out)]" id="shapeless.syntax;HListOps.updatedAt(40ffcb2899).replacer">replacer</a> : ReplaceAt.<a href="../ops/hlists.scala.html#shapeless.ops.hlist.ReplaceAt;<refinement>" title="shapeless.ops.hlist.ReplaceAt.Aux[L,n.N,U,(V, Out)]">Aux</a><span class="delimiter">[</span>L, n.N, U, <span class="delimiter">(</span>V, Out<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#shapeless.syntax;HListOps.updatedAt(40ffcb2899);Out" title="Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L, u: U)(V, Out)">replacer</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a>, <a href="#shapeless.syntax;HListOps.updatedAt(40ffcb2899).u" title="U">u</a><span class="delimiter">)</span>.<span title="=&gt; Out">_2</span>

  <span class="comment">/**
   * Returns the first ''n'' elements of this `HList`. An explicit type argument must be provided. Available only if
   * there is evidence that this `HList` has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat](implicit take: shapeless.ops.hlist.Take[L,N])take.Out" id="shapeless.syntax;HListOps.take(4df1c72ecb)">take</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax;HListOps.take(4df1c72ecb);N">N</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Take[L,N]" id="shapeless.syntax;HListOps.take(4df1c72ecb).take">take</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Take" title="shapeless.ops.hlist.Take[L,N]">Take</a><span class="delimiter">[</span>L, N<span class="delimiter">]</span><span class="delimiter">)</span> : take.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Take;Out" title="take.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)take.Out">take</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the first ''n'' elements of this `HList`. Available only if there is evidence that this `HList` has at
   * least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="(n: shapeless.Nat)(implicit take: shapeless.ops.hlist.Take[L,n.N])take.Out" id="shapeless.syntax;HListOps.take(6e79710c87)">take</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless.syntax;HListOps.take(6e79710c87).n">n</a> : <a href="../nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Take[L,n.N]" id="shapeless.syntax;HListOps.take(6e79710c87).take">take</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Take" title="shapeless.ops.hlist.Take[L,n.N]">Take</a><span class="delimiter">[</span>L, n.N<span class="delimiter">]</span><span class="delimiter">)</span> : take.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Take;Out" title="take.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)take.Out">take</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Returns all but the  first ''n'' elements of this `HList`. An explicit type argument must be provided. Available
   * only if there is evidence that this `HList` has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat](implicit drop: shapeless.ops.hlist.Drop[L,N])drop.Out" id="shapeless.syntax;HListOps.drop(8a05be86e0)">drop</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax;HListOps.drop(8a05be86e0);N">N</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Drop[L,N]" id="shapeless.syntax;HListOps.drop(8a05be86e0).drop">drop</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Drop" title="shapeless.ops.hlist.Drop[L,N]">Drop</a><span class="delimiter">[</span>L, N<span class="delimiter">]</span><span class="delimiter">)</span> : drop.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Drop;Out" title="drop.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)drop.Out">drop</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns all but the  first ''n'' elements of this `HList`. Available only if there is evidence that this `HList`
   * has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="(n: shapeless.Nat)(implicit drop: shapeless.ops.hlist.Drop[L,n.N])drop.Out" id="shapeless.syntax;HListOps.drop(ff87b9810f)">drop</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless.syntax;HListOps.drop(ff87b9810f).n">n</a> : <a href="../nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Drop[L,n.N]" id="shapeless.syntax;HListOps.drop(ff87b9810f).drop">drop</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Drop" title="shapeless.ops.hlist.Drop[L,n.N]">Drop</a><span class="delimiter">[</span>L, n.N<span class="delimiter">]</span><span class="delimiter">)</span> : drop.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Drop;Out" title="drop.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)drop.Out">drop</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Splits this `HList` at the ''nth'' element, returning the prefix and suffix as a pair. An explicit type argument
   * must be provided. Available only if there is evidence that this `HList` has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat](implicit split: shapeless.ops.hlist.Split[L,N])split.Out" id="shapeless.syntax;HListOps.split(eaf573334c)">split</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax;HListOps.split(eaf573334c);N">N</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Split[L,N]" id="shapeless.syntax;HListOps.split(eaf573334c).split">split</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Split" title="shapeless.ops.hlist.Split[L,N]">Split</a><span class="delimiter">[</span>L, N<span class="delimiter">]</span><span class="delimiter">)</span> : split.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="split.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)split.Out">split</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Splits this `HList` at the ''nth'' element, returning the prefix and suffix as a pair. Available only if there is
   * evidence that this `HList` has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="(n: shapeless.Nat)(implicit split: shapeless.ops.hlist.Split[L,n.N])split.Out" id="shapeless.syntax;HListOps.split(f8cad8becf)">split</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless.syntax;HListOps.split(f8cad8becf).n">n</a> : <a href="../nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Split[L,n.N]" id="shapeless.syntax;HListOps.split(f8cad8becf).split">split</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Split" title="shapeless.ops.hlist.Split[L,n.N]">Split</a><span class="delimiter">[</span>L, n.N<span class="delimiter">]</span><span class="delimiter">)</span> : split.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="split.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)split.Out">split</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Splits this `HList` at the ''nth'' element, returning the reverse of the prefix and suffix as a pair. An explicit
   * type argument must be provided. Available only if there is evidence that this `HList` has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat](implicit split: shapeless.ops.hlist.ReverseSplit[L,N])split.Out" id="shapeless.syntax;HListOps.reverse_split(481d33013a)">reverse_split</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless.syntax;HListOps.reverse_split(481d33013a);N">N</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ReverseSplit[L,N]" id="shapeless.syntax;HListOps.reverse_split(481d33013a).split">split</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;ReverseSplit" title="shapeless.ops.hlist.ReverseSplit[L,N]">ReverseSplit</a><span class="delimiter">[</span>L, N<span class="delimiter">]</span><span class="delimiter">)</span> : split.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="split.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)split.Out">split</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Splits this `HList` at the ''nth'' element, returning the reverse of the prefix and suffix as a pair. Available
   * only if there is evidence that this `HList` has at least ''n'' elements.
   */</span>
  <span class="keyword">def</span> <a title="(n: shapeless.Nat)(implicit split: shapeless.ops.hlist.ReverseSplit[L,n.N])split.Out" id="shapeless.syntax;HListOps.reverse_split(517adf9349)">reverse_split</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless.syntax;HListOps.reverse_split(517adf9349).n">n</a> : <a href="../nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ReverseSplit[L,n.N]" id="shapeless.syntax;HListOps.reverse_split(517adf9349).split">split</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;ReverseSplit" title="shapeless.ops.hlist.ReverseSplit[L,n.N]">ReverseSplit</a><span class="delimiter">[</span>L, n.N<span class="delimiter">]</span><span class="delimiter">)</span> : split.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="split.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)split.Out">split</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Splits this `HList` at the first occurrence of an element of type `U`, returning the prefix and suffix as a pair.
   * An explicit type argument must be provided. Available only if there is evidence that this `HList` has an element
   * of type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit splitLeft: shapeless.ops.hlist.SplitLeft[L,U])splitLeft.Out" id="shapeless.syntax;HListOps.splitLeft">splitLeft</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.splitLeft;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.SplitLeft[L,U]" id="shapeless.syntax;HListOps.splitLeft.splitLeft">splitLeft</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;SplitLeft" title="shapeless.ops.hlist.SplitLeft[L,U]">SplitLeft</a><span class="delimiter">[</span>L, U<span class="delimiter">]</span><span class="delimiter">)</span> : splitLeft.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="splitLeft.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)splitLeft.Out">splitLeft</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Splits this `HList` at the first occurrence of an element of type `U`, returning reverse of the prefix and suffix
   * as a pair. An explicit type argument must be provided. Available only if there is evidence that this `HList` has
   * an element of type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit splitLeft: shapeless.ops.hlist.ReverseSplitLeft[L,U])splitLeft.Out" id="shapeless.syntax;HListOps.reverse_splitLeft">reverse_splitLeft</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.reverse_splitLeft;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ReverseSplitLeft[L,U]" id="shapeless.syntax;HListOps.reverse_splitLeft.splitLeft">splitLeft</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;ReverseSplitLeft" title="shapeless.ops.hlist.ReverseSplitLeft[L,U]">ReverseSplitLeft</a><span class="delimiter">[</span>L, U<span class="delimiter">]</span><span class="delimiter">)</span> : splitLeft.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="splitLeft.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)splitLeft.Out">splitLeft</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Splits this `HList` at the last occurrence of an element of type `U`, returning the prefix and suffix as a pair.
   * An explicit type argument must be provided. Available only if there is evidence that this `HList` has an element
   * of type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit splitRight: shapeless.ops.hlist.SplitRight[L,U])splitRight.Out" id="shapeless.syntax;HListOps.splitRight">splitRight</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.splitRight;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.SplitRight[L,U]" id="shapeless.syntax;HListOps.splitRight.splitRight">splitRight</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;SplitRight" title="shapeless.ops.hlist.SplitRight[L,U]">SplitRight</a><span class="delimiter">[</span>L, U<span class="delimiter">]</span><span class="delimiter">)</span> : splitRight.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="splitRight.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)splitRight.Out">splitRight</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Splits this `HList` at the last occurrence of an element of type `U`, returning reverse of the prefix and suffix
   * as a pair. An explicit type argument must be provided. Available only if there is evidence that this `HList` has
   * an element of type `U`.
   */</span>
  <span class="keyword">def</span> <a title="[U](implicit splitRight: shapeless.ops.hlist.ReverseSplitRight[L,U])splitRight.Out" id="shapeless.syntax;HListOps.reverse_splitRight">reverse_splitRight</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.reverse_splitRight;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ReverseSplitRight[L,U]" id="shapeless.syntax;HListOps.reverse_splitRight.splitRight">splitRight</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;ReverseSplitRight" title="shapeless.ops.hlist.ReverseSplitRight[L,U]">ReverseSplitRight</a><span class="delimiter">[</span>L, U<span class="delimiter">]</span><span class="delimiter">)</span> : splitRight.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="splitRight.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)splitRight.Out">splitRight</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Reverses this `HList`.
   */</span>
  <span class="keyword">def</span> <a title="(implicit reverse: shapeless.ops.hlist.Reverse[L])reverse.Out" id="shapeless.syntax;HListOps.reverse">reverse</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Reverse[L]" id="shapeless.syntax;HListOps.reverse.reverse">reverse</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Reverse" title="shapeless.ops.hlist.Reverse[L]">Reverse</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> : reverse.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Reverse;Out" title="reverse.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)reverse.Out">reverse</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Maps a higher rank function across this `HList`.
   */</span>
  <span class="keyword">def</span> <a title="(f: shapeless.Poly)(implicit mapper: shapeless.ops.hlist.Mapper[f.type,L])mapper.Out" id="shapeless.syntax;HListOps.map">map</a><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless.syntax;HListOps.map.f">f</a> : <a href="../poly.scala.html#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Mapper[f.type,L]" id="shapeless.syntax;HListOps.map.mapper">mapper</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Mapper" title="shapeless.ops.hlist.Mapper[f.type,L]">Mapper</a><span class="delimiter">[</span>f.<span class="keyword">type</span>, L<span class="delimiter">]</span><span class="delimiter">)</span> : mapper.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Mapper;Out" title="mapper.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)mapper.Out">mapper</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Flatmaps a higher rank function across this `HList`.
   */</span>
  <span class="keyword">def</span> <a title="(f: shapeless.Poly)(implicit mapper: shapeless.ops.hlist.FlatMapper[f.type,L])mapper.Out" id="shapeless.syntax;HListOps.flatMap">flatMap</a><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless.syntax;HListOps.flatMap.f">f</a> : <a href="../poly.scala.html#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.FlatMapper[f.type,L]" id="shapeless.syntax;HListOps.flatMap.mapper">mapper</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;FlatMapper" title="shapeless.ops.hlist.FlatMapper[f.type,L]">FlatMapper</a><span class="delimiter">[</span>f.<span class="keyword">type</span>, L<span class="delimiter">]</span><span class="delimiter">)</span> : mapper.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;FlatMapper;Out" title="mapper.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)mapper.Out">mapper</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Replaces each element of this `HList` with a constant value.
   */</span>
  <span class="keyword">def</span> <a title="[C](c: C)(implicit mapper: shapeless.ops.hlist.ConstMapper[C,L])mapper.Out" id="shapeless.syntax;HListOps.mapConst">mapConst</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.mapConst;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="C" id="shapeless.syntax;HListOps.mapConst.c">c</a> : <a href="#shapeless.syntax;HListOps.mapConst;C" title="C">C</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ConstMapper[C,L]" id="shapeless.syntax;HListOps.mapConst.mapper">mapper</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;ConstMapper" title="shapeless.ops.hlist.ConstMapper[C,L]">ConstMapper</a><span class="delimiter">[</span>C, L<span class="delimiter">]</span><span class="delimiter">)</span> : mapper.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;ConstMapper;Out" title="mapper.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: C, u: L)mapper.Out">mapper</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.mapConst.c" title="C">c</a>, <a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Maps a higher rank function ''f'' across this `HList` and folds the result using monomorphic combining operator
   * `op`. Available only if there is evidence that the result type of `f` at each element conforms to the argument
   * type of ''op''.
   */</span>
  <span class="keyword">def</span> <a title="[R](z: R)(f: shapeless.Poly)(op: (R, R) =&gt; R)(implicit folder: shapeless.ops.hlist.MapFolder[L,R,f.type])R" id="shapeless.syntax;HListOps.foldMap">foldMap</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.foldMap;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="R" id="shapeless.syntax;HListOps.foldMap.z">z</a> : <a href="#shapeless.syntax;HListOps.foldMap;R" title="R">R</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless.syntax;HListOps.foldMap.f">f</a> : <a href="../poly.scala.html#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(R, R) =&gt; R" id="shapeless.syntax;HListOps.foldMap.op">op</a> : <span class="delimiter">(</span>R, R<span class="delimiter">)</span> =&gt; R<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.MapFolder[L,R,f.type]" id="shapeless.syntax;HListOps.foldMap.folder">folder</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;MapFolder" title="shapeless.ops.hlist.MapFolder[L,R,f.type]">MapFolder</a><span class="delimiter">[</span>L, R, f.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#shapeless.syntax;HListOps.foldMap;R" title="R">R</a> = <a href="../ops/hlists.scala.html#shapeless.ops.hlist;MapFolder.apply" title="(l: L, in: R, op: (R, R) =&gt; R)R">folder</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a>, <a href="#shapeless.syntax;HListOps.foldMap.z" title="R">z</a>, <a href="#shapeless.syntax;HListOps.foldMap.op" title="(R, R) =&gt; R">op</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Computes a left fold over this `HList` using the polymorphic binary combining operator `op`. Available only if
   * there is evidence `op` can consume/produce all the partial results of the appropriate types.
   */</span>
  <span class="keyword">def</span> <a title="[R](z: R)(op: shapeless.Poly)(implicit folder: shapeless.ops.hlist.LeftFolder[L,R,op.type])folder.Out" id="shapeless.syntax;HListOps.foldLeft">foldLeft</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.foldLeft;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="R" id="shapeless.syntax;HListOps.foldLeft.z">z</a> : <a href="#shapeless.syntax;HListOps.foldLeft;R" title="R">R</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless.syntax;HListOps.foldLeft.op">op</a> : <a href="../poly.scala.html#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.LeftFolder[L,R,op.type]" id="shapeless.syntax;HListOps.foldLeft.folder">folder</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;LeftFolder" title="shapeless.ops.hlist.LeftFolder[L,R,op.type]">LeftFolder</a><span class="delimiter">[</span>L, R, op.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span> : folder.<a href="../package.scala.html#shapeless.package;DepFn2;Out" title="folder.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L, u: R)folder.Out">folder</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a>, <a href="#shapeless.syntax;HListOps.foldLeft.z" title="R">z</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Computes a right fold over this `HList` using the polymorphic binary combining operator `op`. Available only if
   * there is evidence `op` can consume/produce all the partial results of the appropriate types.
   */</span>
  <span class="keyword">def</span> <a title="[R](z: R)(op: shapeless.Poly)(implicit folder: shapeless.ops.hlist.RightFolder[L,R,op.type])folder.Out" id="shapeless.syntax;HListOps.foldRight">foldRight</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.foldRight;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="R" id="shapeless.syntax;HListOps.foldRight.z">z</a> : <a href="#shapeless.syntax;HListOps.foldRight;R" title="R">R</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless.syntax;HListOps.foldRight.op">op</a> : <a href="../poly.scala.html#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.RightFolder[L,R,op.type]" id="shapeless.syntax;HListOps.foldRight.folder">folder</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;RightFolder" title="shapeless.ops.hlist.RightFolder[L,R,op.type]">RightFolder</a><span class="delimiter">[</span>L, R, op.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span> : folder.<a href="../package.scala.html#shapeless.package;DepFn2;Out" title="folder.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L, u: R)folder.Out">folder</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a>, <a href="#shapeless.syntax;HListOps.foldRight.z" title="R">z</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Computes a left reduce over this `HList` using the polymorphic binary combining operator `op`. Available only if
   * there is evidence that this `HList` has at least one element and that `op` can consume/produce all the partial
   * results of the appropriate types.
   */</span>
  <span class="keyword">def</span> <a title="(op: shapeless.Poly)(implicit reducer: shapeless.ops.hlist.LeftReducer[L,op.type])reducer.Out" id="shapeless.syntax;HListOps.reduceLeft">reduceLeft</a><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless.syntax;HListOps.reduceLeft.op">op</a> : <a href="../poly.scala.html#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.LeftReducer[L,op.type]" id="shapeless.syntax;HListOps.reduceLeft.reducer">reducer</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;LeftReducer" title="shapeless.ops.hlist.LeftReducer[L,op.type]">LeftReducer</a><span class="delimiter">[</span>L, op.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span> : reducer.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="reducer.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)reducer.Out">reducer</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Computes a right reduce over this `HList` using the polymorphic binary combining operator `op`. Available only if
   * there is evidence that this `HList` has at least one element and that `op` can consume/produce all the partial
   * results of the appropriate types.
   */</span>
  <span class="keyword">def</span> <a title="(op: shapeless.Poly)(implicit reducer: shapeless.ops.hlist.RightReducer[L,op.type])reducer.Out" id="shapeless.syntax;HListOps.reduceRight">reduceRight</a><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless.syntax;HListOps.reduceRight.op">op</a> : <a href="../poly.scala.html#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.RightReducer[L,op.type]" id="shapeless.syntax;HListOps.reduceRight.reducer">reducer</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;RightReducer" title="shapeless.ops.hlist.RightReducer[L,op.type]">RightReducer</a><span class="delimiter">[</span>L, op.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span> : reducer.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="reducer.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)reducer.Out">reducer</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Zips this `HList` with its argument `HList` returning an `HList` of pairs.
   */</span>
  <span class="keyword">def</span> <a title="[R &lt;: shapeless.HList](r: R)(implicit zipper: shapeless.ops.hlist.Zip[shapeless.::[L,shapeless.::[R,shapeless.HNil]]])zipper.Out" id="shapeless.syntax;HListOps.zip(0b5e50e345)">zip</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.syntax;HListOps.zip(0b5e50e345);R">R</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="R" id="shapeless.syntax;HListOps.zip(0b5e50e345).r">r</a> : <a href="#shapeless.syntax;HListOps.zip(0b5e50e345);R" title="R">R</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Zip[shapeless.::[L,shapeless.::[R,shapeless.HNil]]]" id="shapeless.syntax;HListOps.zip(0b5e50e345).zipper">zipper</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Zip" title="shapeless.ops.hlist.Zip[shapeless.::[L,shapeless.::[R,shapeless.HNil]]]">Zip</a><span class="delimiter">[</span>L :: R :: HNil<span class="delimiter">]</span><span class="delimiter">)</span> : zipper.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Zip;Out" title="zipper.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: shapeless.::[L,shapeless.::[R,shapeless.HNil]])zipper.Out">zipper</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a> <a href="#shapeless.syntax;HListOps.::" title="(h: L)shapeless.::[L,shapeless.::[R,shapeless.HNil]]">::</a> <a href="#shapeless.syntax;HListOps.zip(0b5e50e345).r" title="R">r</a> <a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: shapeless.::[R,shapeless.HNil])shapeless.syntax.HListOps[shapeless.::[R,shapeless.HNil]]">::</a> <a href="../hlists.scala.html#shapeless.HNil" title="shapeless.HNil.type">HNil</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Zips this `HList` of monomorphic function values with its argument `HList` of correspondingly typed function
   * arguments returning the result of each application as an `HList`. Available only if there is evidence that the
   * corresponding function and argument elements have compatible types.
   */</span>
  <span class="keyword">def</span> <a title="[A &lt;: shapeless.HList](a: A)(implicit zipper: shapeless.ops.hlist.ZipApply[L,A])zipper.Out" id="shapeless.syntax;HListOps.zipApply">zipApply</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.syntax;HListOps.zipApply;A">A</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="shapeless.syntax;HListOps.zipApply.a">a</a> : <a href="#shapeless.syntax;HListOps.zipApply;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ZipApply[L,A]" id="shapeless.syntax;HListOps.zipApply.zipper">zipper</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;ZipApply" title="shapeless.ops.hlist.ZipApply[L,A]">ZipApply</a><span class="delimiter">[</span>L, A<span class="delimiter">]</span><span class="delimiter">)</span> : zipper.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;ZipApply;Out" title="zipper.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L, u: A)zipper.Out">zipper</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a>, <a href="#shapeless.syntax;HListOps.zipApply.a" title="A">a</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Zips this `HList` of `HList`s returning an `HList` of tuples. Available only if there is evidence that this
   * `HList` has `HList` elements.
   */</span>
  <span class="keyword">def</span> <a title="(implicit zipper: shapeless.ops.hlist.Zip[L])zipper.Out" id="shapeless.syntax;HListOps.zip(74c91d110a)">zip</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Zip[L]" id="shapeless.syntax;HListOps.zip(74c91d110a).zipper">zipper</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Zip" title="shapeless.ops.hlist.Zip[L]">Zip</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> : zipper.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Zip;Out" title="zipper.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)zipper.Out">zipper</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Zips this `HList` of `HList`s returning an `HList` of tuples. Available only if there is evidence that this
   * `HList` has `HList` elements.
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use zip instead&quot;</span>, <span class="string">&quot;2.0.0&quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(implicit zipper: shapeless.ops.hlist.Zip[L])zipper.Out" id="shapeless.syntax;HListOps.zipped">zipped</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Zip[L]" id="shapeless.syntax;HListOps.zipped.zipper">zipper</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Zip" title="shapeless.ops.hlist.Zip[L]">Zip</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> : zipper.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Zip;Out" title="zipper.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)zipper.Out">zipper</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Unzips this `HList` of tuples returning a tuple of `HList`s. Available only if there is evidence that this
   * `HList` has tuple elements.
   */</span>
  <span class="keyword">def</span> <a title="(implicit unzipper: shapeless.ops.hlist.Unzip[L])unzipper.Out" id="shapeless.syntax;HListOps.unzip">unzip</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Unzip[L]" id="shapeless.syntax;HListOps.unzip.unzipper">unzipper</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Unzip" title="shapeless.ops.hlist.Unzip[L]">Unzip</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> : unzipper.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="unzipper.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)unzipper.Out">unzipper</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Unzips this `HList` of tuples returning a tuple of `HList`s. Available only if there is evidence that this
   * `HList` has tuple elements.
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use unzip instead&quot;</span>, <span class="string">&quot;2.0.0&quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(implicit unzipper: shapeless.ops.hlist.Unzip[L])unzipper.Out" id="shapeless.syntax;HListOps.unzipped">unzipped</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Unzip[L]" id="shapeless.syntax;HListOps.unzipped.unzipper">unzipper</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Unzip" title="shapeless.ops.hlist.Unzip[L]">Unzip</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> : unzipper.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="unzipper.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)unzipper.Out">unzipper</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Zips this `HList` with its argument `HList` of `HList`s, returning an `HList` of `HList`s with each element of
   * this `HList` prepended to the corresponding `HList` element of the argument `HList`.
   */</span>
  <span class="keyword">def</span> <a title="[T &lt;: shapeless.HList](t: T)(implicit zipOne: shapeless.ops.hlist.ZipOne[L,T])zipOne.Out" id="shapeless.syntax;HListOps.zipOne">zipOne</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.syntax;HListOps.zipOne;T">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="shapeless.syntax;HListOps.zipOne.t">t</a> : <a href="#shapeless.syntax;HListOps.zipOne;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ZipOne[L,T]" id="shapeless.syntax;HListOps.zipOne.zipOne">zipOne</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;ZipOne" title="shapeless.ops.hlist.ZipOne[L,T]">ZipOne</a><span class="delimiter">[</span>L, T<span class="delimiter">]</span><span class="delimiter">)</span> : zipOne.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;ZipOne;Out" title="zipOne.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L, u: T)zipOne.Out">zipOne</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a>, <a href="#shapeless.syntax;HListOps.zipOne.t" title="T">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Zips this `HList` with a constant, resulting in an `HList` of tuples of the form
   * ({element from this `HList`}, {supplied constant})
   */</span>
  <span class="keyword">def</span> <a title="[C](c: C)(implicit zipConst: shapeless.ops.hlist.ZipConst[C,L])zipConst.Out" id="shapeless.syntax;HListOps.zipConst">zipConst</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.zipConst;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="C" id="shapeless.syntax;HListOps.zipConst.c">c</a>: <a href="#shapeless.syntax;HListOps.zipConst;C" title="C">C</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ZipConst[C,L]" id="shapeless.syntax;HListOps.zipConst.zipConst">zipConst</a>: <a href="../ops/hlists.scala.html#shapeless.ops.hlist;ZipConst" title="shapeless.ops.hlist.ZipConst[C,L]">ZipConst</a><span class="delimiter">[</span>C, L<span class="delimiter">]</span><span class="delimiter">)</span>: zipConst.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;ZipConst;Out" title="zipConst.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: C, u: L)zipConst.Out">zipConst</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.zipConst.c" title="C">c</a>, <a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Transposes this `HList`.
   */</span>
  <span class="keyword">def</span> <a title="(implicit transpose: shapeless.ops.hlist.Transposer[L])transpose.Out" id="shapeless.syntax;HListOps.transpose">transpose</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Transposer[L]" id="shapeless.syntax;HListOps.transpose.transpose">transpose</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Transposer" title="shapeless.ops.hlist.Transposer[L]">Transposer</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> : transpose.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Transposer;Out" title="transpose.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)transpose.Out">transpose</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns an `HList` typed as a repetition of the least upper bound of the types of the elements of this `HList`.
   */</span>
  <span class="keyword">def</span> <a title="(implicit unifier: shapeless.ops.hlist.Unifier[L])unifier.Out" id="shapeless.syntax;HListOps.unify">unify</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Unifier[L]" id="shapeless.syntax;HListOps.unify.unifier">unifier</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Unifier" title="shapeless.ops.hlist.Unifier[L]">Unifier</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> : unifier.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Unifier;Out" title="unifier.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)unifier.Out">unifier</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns an `HList` with all elements that are subtypes of `B` typed as `B`.
   */</span>
  <span class="keyword">def</span> <a title="[B](implicit subtypeUnifier: shapeless.ops.hlist.SubtypeUnifier[L,B])subtypeUnifier.Out" id="shapeless.syntax;HListOps.unifySubtypes">unifySubtypes</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.unifySubtypes;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.SubtypeUnifier[L,B]" id="shapeless.syntax;HListOps.unifySubtypes.subtypeUnifier">subtypeUnifier</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;SubtypeUnifier" title="shapeless.ops.hlist.SubtypeUnifier[L,B]">SubtypeUnifier</a><span class="delimiter">[</span>L, B<span class="delimiter">]</span><span class="delimiter">)</span> : subtypeUnifier.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;SubtypeUnifier;Out" title="subtypeUnifier.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)subtypeUnifier.Out">subtypeUnifier</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Converts this `HList` to a correspondingly typed tuple.
   */</span>
  <span class="keyword">def</span> <a title="(implicit tupler: shapeless.ops.hlist.Tupler[L])tupler.Out" id="shapeless.syntax;HListOps.tupled">tupled</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Tupler[L]" id="shapeless.syntax;HListOps.tupled.tupler">tupler</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L]">Tupler</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> : tupler.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tupler.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)tupler.Out">tupler</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Compute the length of this `HList`.
   */</span>
  <span class="keyword">def</span> <a title="(implicit length: shapeless.ops.hlist.Length[L])length.Out" id="shapeless.syntax;HListOps.length">length</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Length[L]" id="shapeless.syntax;HListOps.length.length">length</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;Length" title="shapeless.ops.hlist.Length[L]">Length</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> : length.<a href="../ops/hlists.scala.html#shapeless.ops.hlist;Length;Out" title="length.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn0.apply" title="()length.Out">length</a><span class="delimiter">(</span><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Compute the length of this `HList` as a runtime Int value.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; Int" id="shapeless.syntax;HListOps.runtimeLength">runtimeLength</a>: <span title="Int">Int</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(l: shapeless.HList, acc: Int)Int" id="shapeless.syntax;HListOps.runtimeLength.loop">loop</a><span class="delimiter">(</span><a title="shapeless.HList" id="shapeless.syntax;HListOps.runtimeLength.loop.l">l</a>: <a href="../hlists.scala.html#shapeless;HList" title="shapeless.HList">HList</a>, <a title="Int" id="shapeless.syntax;HListOps.runtimeLength.loop.acc">acc</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#shapeless.syntax;HListOps.runtimeLength.loop.l" title="shapeless.HList">l</a> <span title="Int" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="../hlists.scala.html#shapeless.HNil" title="shapeless.HNil.type">HNil</a> =&gt; <a href="#shapeless.syntax;HListOps.runtimeLength.loop.acc" title="Int">acc</a>
      <span class="keyword">case</span> <a title="Any" id="shapeless.syntax;HListOps.runtimeLength.loop.hd">hd</a> :: <a title="shapeless.HList" id="shapeless.syntax;HListOps.runtimeLength.loop.tl">tl</a> =&gt; <a href="#shapeless.syntax;HListOps.runtimeLength.loop" title="(l: shapeless.HList, acc: Int)Int">loop</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.runtimeLength.loop.tl" title="shapeless.HList">tl</a>, <a href="#shapeless.syntax;HListOps.runtimeLength.loop.acc" title="Int">acc</a><span title="(x: Int)Int">+</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#shapeless.syntax;HListOps.runtimeLength.loop" title="(l: shapeless.HList, acc: Int)Int">loop</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Converts this `HList` to an ordinary `List` of elements typed as the least upper bound of the types of the elements
   * of this `HList`.
   */</span>
  <span class="keyword">def</span> <a title="[Lub](implicit toList: shapeless.ops.hlist.ToList[L,Lub])List[Lub]" id="shapeless.syntax;HListOps.toList">toList</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.toList;Lub">Lub</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ToList[L,Lub]" id="shapeless.syntax;HListOps.toList.toList">toList</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;ToList" title="shapeless.ops.hlist.ToList[L,Lub]">ToList</a><span class="delimiter">[</span>L, Lub<span class="delimiter">]</span><span class="delimiter">)</span> : <span title="List[Lub]">List</span><span class="delimiter">[</span>Lub<span class="delimiter">]</span> = <a href="../ops/hlists.scala.html#shapeless.ops.hlist;ToList.apply" title="(l: L)List[Lub]">toList</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.l" title="L">l</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Converts this `HList` to an `Array` of elements typed as the least upper bound of the types of the elements
   * of this `HList`.
   * 
   * It is advisable to specify the type parameter explicitly, because for many reference types, case classes in
   * particular, the inferred type will be too precise (ie. `Product with Serializable with CC` for a typical case class
   * `CC`) which interacts badly with the invariance of `Array`s.
   */</span>
  <span class="keyword">def</span> <a title="[Lub](implicit toArray: shapeless.ops.hlist.ToArray[L,Lub])Array[Lub]" id="shapeless.syntax;HListOps.toArray">toArray</a><span class="delimiter">[</span><a title="" id="shapeless.syntax;HListOps.toArray;Lub">Lub</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ToArray[L,Lub]" id="shapeless.syntax;HListOps.toArray.toArray">toArray</a> : <a href="../ops/hlists.scala.html#shapeless.ops.hlist;ToArray" title="shapeless.ops.hlist.ToArray[L,Lub]">ToArray</a><span class="delimiter">[</span>L, Lub<span class="delimiter">]</span><span class="delimiter">)</span> : <span title="Array[Lub]">Array</span><span class="delimiter">[</span>Lub<span class="delimiter">]</span> = <a href="../ops/hlists.scala.html#shapeless.ops.hlist;ToArray.apply" title="(len: Int, l: L, i: Int)Array[Lub]">toArray</a><span class="delimiter">(</span><a href="#shapeless.syntax;HListOps.runtimeLength" title="=&gt; Int">runtimeLength</a>, <a href="#shapeless.syntax;HListOps.l" title="L">l</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
