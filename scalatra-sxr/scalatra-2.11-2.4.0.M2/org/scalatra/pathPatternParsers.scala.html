<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>org/scalatra/pathPatternParsers.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package org.scalatra

import scala.util.matching.Regex
import scala.util.parsing.combinator.RegexParsers

<span class="comment">/**
 * A path pattern optionally matches a request path and extracts path
 * parameters.
 */</span>
case class <a title="class PathPattern extends AnyRef with Product with Serializable" id="org.scalatra.PathPattern.readResolve">PathPattern</a><a href="#org.scalatra.PathPattern.readResolve" title="Product" class="delimiter">(</a><a title="scala.util.matching.Regex" id="org.scalatra;PathPattern.regex">regex</a>: <span title="scala.util.matching.Regex">Regex</span>, <a title="List[String]" id="org.scalatra.PathPattern.apply$default$2">captureGroupNames</a>: <span title="List[String]">List</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(path: String)Option[org.scalatra.MultiParams]" id="org.scalatra;PathPattern.apply">apply</a><span class="delimiter">(</span><a title="String" id="org.scalatra;PathPattern.apply.path">path</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Option[org.scalatra.MultiParams]">Option</span><span class="delimiter">[</span>MultiParams<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">// This is a performance hotspot.  Hideous mutatations ahead.</span>
    val <a title="java.util.regex.Matcher" id="org.scalatra;PathPattern.apply.m">m</a> = <a href="#org.scalatra;PathPattern.regex" title="=&gt; scala.util.matching.Regex">regex</a>.<span title="=&gt; java.util.regex.Pattern">pattern</span>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#org.scalatra;PathPattern.apply.path" title="String">path</a><span class="delimiter">)</span>
    var <a title="scala.collection.immutable.Map[String,Seq[String]]" id="org.scalatra;PathPattern.apply.multiParams">multiParams</a> = <span title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</span><span title="(elems: (String, Seq[String])*)scala.collection.immutable.Map[String,Seq[String]]" class="delimiter">[</span><span title="String">String</span>, <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#org.scalatra;PathPattern.apply.m" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">matches</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      var <a title="Int" id="org.scalatra;PathPattern.apply.i">i</a> = <span title="Int(0)" class="int">0</span>
      <a href="#org.scalatra.PathPattern.apply$default$2" title="=&gt; List[String]">captureGroupNames</a> <span title="(f: String =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="String" id="org.scalatra;PathPattern.apply.$anonfun.name">name</a> =&gt;
        <a href="#org.scalatra;PathPattern.apply.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
        val <a title="String" id="org.scalatra;PathPattern.apply.$anonfun.value">value</a> = <a href="#org.scalatra;PathPattern.apply.m" title="java.util.regex.Matcher">m</a>.<span title="(x$1: Int)String">group</span><span class="delimiter">(</span><a href="#org.scalatra;PathPattern.apply.i" title="Int">i</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#org.scalatra;PathPattern.apply.$anonfun.value" title="String">value</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <span class="delimiter">{</span>
          val values = <a href="#org.scalatra;PathPattern.apply.multiParams" title="scala.collection.immutable.Map[String,Seq[String]]">multiParams</a>.<span title="(key: String, default: =&gt; Seq[String])Seq[String]">getOrElse</span><span class="delimiter">(</span><a href="#org.scalatra;PathPattern.apply.$anonfun.name" title="String">name</a>, <span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <a title="Seq[String]" id="org.scalatra;PathPattern.apply.$anonfun.values">:+</a> <a href="#org.scalatra;PathPattern.apply.$anonfun.value" title="String">value</a>
          <a href="#org.scalatra;PathPattern.apply.multiParams" title="scala.collection.immutable.Map[String,Seq[String]]">multiParams</a> = <a href="#org.scalatra;PathPattern.apply.multiParams" title="scala.collection.immutable.Map[String,Seq[String]]">multiParams</a>.<span title="(key: String, value: Seq[String])scala.collection.immutable.Map[String,Seq[String]]">updated</span><span class="delimiter">(</span><a href="#org.scalatra;PathPattern.apply.$anonfun.name" title="String">name</a>, <a href="#org.scalatra;PathPattern.apply.$anonfun.values" title="Seq[String]">values</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span title="(x: org.scalatra.util.MultiMap)Some[org.scalatra.util.MultiMap]">Some</span><span class="delimiter">(</span><a href="util/MultiMap.scala.html#org.scalatra.util.MultiMap.map2MultiMap" title="implicit org.scalatra.util.MultiMap.map2MultiMap : (map: scala.collection.immutable.Map[String,Seq[String]])org.scalatra.util.MultiMap">multiParams</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span title="None.type">None</span>
  <span class="delimiter">}</span>

  def <a title="(pathPattern: org.scalatra.PathPattern)org.scalatra.PathPattern" id="org.scalatra;PathPattern.+">+</a><span class="delimiter">(</span><a title="org.scalatra.PathPattern" id="org.scalatra;PathPattern.+.pathPattern">pathPattern</a>: <a href="#org.scalatra.PathPattern.readResolve" title="org.scalatra.PathPattern">PathPattern</a><span class="delimiter">)</span>: <a href="#org.scalatra.PathPattern.readResolve" title="org.scalatra.PathPattern">PathPattern</a> = <a href="#org.scalatra.PathPattern.readResolve" title="(regex: scala.util.matching.Regex, captureGroupNames: List[String])org.scalatra.PathPattern">PathPattern</a><span class="delimiter">(</span>
    new <span title="scala.util.matching.Regex">Regex</span><span class="delimiter">(</span>this.<a href="#org.scalatra;PathPattern.regex" title="=&gt; scala.util.matching.Regex">regex</a>.<span title="()String">toString</span> <span title="(x$1: Any)String">+</span> <a href="#org.scalatra;PathPattern.+.pathPattern" title="org.scalatra.PathPattern">pathPattern</a>.<a href="#org.scalatra;PathPattern.regex" title="=&gt; scala.util.matching.Regex">regex</a>.<span title="()String">toString</span><span class="delimiter">)</span>,
    this.<a href="#org.scalatra.PathPattern.apply$default$2" title="=&gt; List[String]">captureGroupNames</a> <a href="#org.scalatra;PathPattern.+.x$1" title="(prefix: List[String])List[String]">:::</a> <a href="#org.scalatra;PathPattern.+.pathPattern" title="org.scalatra.PathPattern">pathPattern</a>.<a href="#org.scalatra.PathPattern.apply$default$2" title="=&gt; List[String]">captureGroupNames</a>
  <span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Parses a string into a path pattern for routing.
 */</span>
trait <a title="trait PathPatternParser extends AnyRef" id="org.scalatra;PathPatternParser">PathPatternParser</a> <span class="delimiter">{</span>
  def <a title="(pattern: String)org.scalatra.PathPattern" id="org.scalatra;PathPatternParser.apply">apply</a><span class="delimiter">(</span><a title="String" id="org.scalatra;PathPatternParser.apply.pattern">pattern</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#org.scalatra.PathPattern.readResolve" title="org.scalatra.PathPattern">PathPattern</a>
<span class="delimiter">}</span>

object <a title="org.scalatra.PathPatternParser.type" id="org.scalatra.PathPatternParser">PathPatternParser</a> <a href="#org.scalatra.PathPatternParser" title="org.scalatra.PathPatternParser.type" class="delimiter">{</a>
  val <a title="String" id="org.scalatra.PathPatternParser.PathReservedCharacters">PathReservedCharacters</a> = <span title="String(&quot;/?#&quot;)" class="string">&quot;/?#&quot;</span>
<span class="delimiter">}</span>

trait <a title="trait RegexPathPatternParser extends AnyRef with org.scalatra.PathPatternParser with scala.util.parsing.combinator.RegexParsers" id="org.scalatra;RegexPathPatternParser">RegexPathPatternParser</a> extends <a href="#org.scalatra;PathPatternParser" title="org.scalatra.PathPatternParser">PathPatternParser</a> with <span title="scala.util.parsing.combinator.RegexParsers">RegexParsers</span> <span class="delimiter">{</span>
  <span class="comment">/**
   * This parser gradually builds a regular expression.  Some intermediate
   * strings are not valid regexes, so we wait to compile until the end.
   */</span>
  protected case class <a title="class PartialPathPattern extends AnyRef with Product with Serializable" id="org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve">PartialPathPattern</a><a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve" title="Product" class="delimiter">(</a><a title="String" id="org.scalatra;RegexPathPatternParser;PartialPathPattern.regex">regex</a>: <span title="String">String</span>, <a title="List[String]" id="org.scalatra;RegexPathPatternParser.PartialPathPattern.apply$default$2">captureGroupNames</a>: <span title="List[String]">List</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
  <span class="delimiter">{</span>
    def <a title="=&gt; org.scalatra.PathPattern" id="org.scalatra;RegexPathPatternParser;PartialPathPattern.toPathPattern">toPathPattern</a>: <a href="#org.scalatra.PathPattern.readResolve" title="org.scalatra.PathPattern">PathPattern</a> = <a href="#org.scalatra.PathPattern.readResolve" title="(regex: scala.util.matching.Regex, captureGroupNames: List[String])org.scalatra.PathPattern">PathPattern</a><span class="delimiter">(</span><a href="#org.scalatra;RegexPathPatternParser;PartialPathPattern.regex" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">regex</a>.<span title="=&gt; scala.util.matching.Regex">r</span>, <a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.apply$default$2" title="=&gt; List[String]">captureGroupNames</a><span class="delimiter">)</span>

    def <a title="(other: RegexPathPatternParser.this.PartialPathPattern)RegexPathPatternParser.this.PartialPathPattern" id="org.scalatra;RegexPathPatternParser;PartialPathPattern.+">+</a><span class="delimiter">(</span><a title="RegexPathPatternParser.this.PartialPathPattern" id="org.scalatra;RegexPathPatternParser;PartialPathPattern.+.other">other</a>: <a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve" title="RegexPathPatternParser.this.PartialPathPattern">PartialPathPattern</a><span class="delimiter">)</span>: <a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve" title="RegexPathPatternParser.this.PartialPathPattern">PartialPathPattern</a> = <a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve" title="(regex: String, captureGroupNames: List[String])RegexPathPatternParser.this.PartialPathPattern">PartialPathPattern</a><span class="delimiter">(</span>
      this.<a href="#org.scalatra;RegexPathPatternParser;PartialPathPattern.regex" title="=&gt; String">regex</a> <span title="(x$1: Any)String">+</span> <a href="#org.scalatra;RegexPathPatternParser;PartialPathPattern.+.other" title="RegexPathPatternParser.this.PartialPathPattern">other</a>.<a href="#org.scalatra;RegexPathPatternParser;PartialPathPattern.regex" title="=&gt; String">regex</a>,
      this.<a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.apply$default$2" title="=&gt; List[String]">captureGroupNames</a> <a href="#org.scalatra;RegexPathPatternParser;PartialPathPattern.+.x$2" title="(prefix: List[String])List[String]">:::</a> <a href="#org.scalatra;RegexPathPatternParser;PartialPathPattern.+.other" title="RegexPathPatternParser.this.PartialPathPattern">other</a>.<a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.apply$default$2" title="=&gt; List[String]">captureGroupNames</a>
    <span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * A Sinatra-compatible route path pattern parser.
 */</span>
class <a title="class SinatraPathPatternParser extends AnyRef with org.scalatra.RegexPathPatternParser" id="org.scalatra;SinatraPathPatternParser">SinatraPathPatternParser</a> extends <a href="#org.scalatra;RegexPathPatternParser" title="org.scalatra.RegexPathPatternParser">RegexPathPatternParser</a> <span class="delimiter">{</span>
  def <a title="(pattern: String)org.scalatra.PathPattern" id="org.scalatra;SinatraPathPatternParser.apply">apply</a><span class="delimiter">(</span><a title="String" id="org.scalatra;SinatraPathPatternParser.apply.pattern">pattern</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#org.scalatra.PathPattern.readResolve" title="org.scalatra.PathPattern">PathPattern</a> =
    <a href="#org.scalatra;SinatraPathPatternParser" title="(p: SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern], in: CharSequence)SinatraPathPatternParser.this.ParseResult[SinatraPathPatternParser.this.PartialPathPattern]">parseAll</a><span class="delimiter">(</span><a href="#org.scalatra;SinatraPathPatternParser.pathPattern" title="=&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]">pathPattern</a>, <a href="#org.scalatra;SinatraPathPatternParser.apply.pattern" title="String">pattern</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case Success<span class="delimiter">(</span><a title="SinatraPathPatternParser.this.PartialPathPattern" id="org.scalatra;SinatraPathPatternParser.apply.pathPattern">pathPattern</a>, _<span class="delimiter">)</span> =&gt;
        <span class="delimiter">(</span><a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve" title="(regex: String, captureGroupNames: List[String])SinatraPathPatternParser.this.PartialPathPattern">PartialPathPattern</a><span class="delimiter">(</span><span title="String(&quot;^&quot;)" class="string">&quot;^&quot;</span><span class="delimiter">)</span> <a href="#org.scalatra;RegexPathPatternParser;PartialPathPattern.+" title="(other: SinatraPathPatternParser.this.PartialPathPattern)SinatraPathPatternParser.this.PartialPathPattern">+</a> <a href="#org.scalatra;SinatraPathPatternParser.apply.pathPattern" title="SinatraPathPatternParser.this.PartialPathPattern">pathPattern</a> <a href="#org.scalatra;RegexPathPatternParser;PartialPathPattern.+" title="(other: SinatraPathPatternParser.this.PartialPathPattern)SinatraPathPatternParser.this.PartialPathPattern">+</a> <a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve" title="(regex: String, captureGroupNames: List[String])SinatraPathPatternParser.this.PartialPathPattern">PartialPathPattern</a><span class="delimiter">(</span><span title="String(&quot;$&quot;)" class="string">&quot;$&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#org.scalatra;RegexPathPatternParser;PartialPathPattern.toPathPattern" title="=&gt; org.scalatra.PathPattern">toPathPattern</a>
      case _ =&gt;
        throw new <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="String(&quot;Invalid path pattern: &quot;)" class="string">&quot;Invalid path pattern: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#org.scalatra;SinatraPathPatternParser.apply.pattern" title="String">pattern</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  private def <a title="=&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]" id="org.scalatra;SinatraPathPatternParser.pathPattern">pathPattern</a> = <a href="#org.scalatra;SinatraPathPatternParser" title="(p: =&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern])SinatraPathPatternParser.this.Parser[List[SinatraPathPatternParser.this.PartialPathPattern]]">rep</a><span class="delimiter">(</span><a href="#org.scalatra;SinatraPathPatternParser.token" title="=&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]">token</a><span class="delimiter">)</span> <span title="(f: List[SinatraPathPatternParser.this.PartialPathPattern] =&gt; SinatraPathPatternParser.this.PartialPathPattern)SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]">^^</span> <span class="delimiter">{</span> <a href="#org.scalatra;SinatraPathPatternParser.pathPattern.$anonfun.x$3" title="List[SinatraPathPatternParser.this.PartialPathPattern]">_</a>.<span title="(f: (SinatraPathPatternParser.this.PartialPathPattern, SinatraPathPatternParser.this.PartialPathPattern) =&gt; SinatraPathPatternParser.this.PartialPathPattern)SinatraPathPatternParser.this.PartialPathPattern">reduceLeft</span> <span class="delimiter">{</span> <a href="#org.scalatra;SinatraPathPatternParser.pathPattern.$anonfun.$anonfun.x$4" title="SinatraPathPatternParser.this.PartialPathPattern">_</a><a href="#org.scalatra;RegexPathPatternParser;PartialPathPattern.+" title="(other: SinatraPathPatternParser.this.PartialPathPattern)SinatraPathPatternParser.this.PartialPathPattern">+</a><a href="#org.scalatra;SinatraPathPatternParser.pathPattern.$anonfun.$anonfun.x$5" title="SinatraPathPatternParser.this.PartialPathPattern">_</a> <span class="delimiter">}</span> <span class="delimiter">}</span>

  private def <a title="=&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]" id="org.scalatra;SinatraPathPatternParser.token">token</a> = <a href="#org.scalatra;SinatraPathPatternParser.splat" title="=&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]">splat</a> <span title="(q: =&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern])SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]">|</span> <a href="#org.scalatra;SinatraPathPatternParser.namedGroup" title="=&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]">namedGroup</a> <span title="(q: =&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern])SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]">|</span> <a href="#org.scalatra;SinatraPathPatternParser.literal(a050b6e665)" title="=&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]">literal</a>

  private def <a title="=&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]" id="org.scalatra;SinatraPathPatternParser.splat">splat</a> = <a href="#org.scalatra;SinatraPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.literal : (s: String)SinatraPathPatternParser.this.Parser[String]" class="string">&quot;*&quot;</a> <span title="(v: =&gt; SinatraPathPatternParser.this.PartialPathPattern)SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]">^^^</span> <a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve" title="(regex: String, captureGroupNames: List[String])SinatraPathPatternParser.this.PartialPathPattern">PartialPathPattern</a><span class="delimiter">(</span><span title="String(&quot;(.*?)&quot;)" class="string">&quot;(.*?)&quot;</span>, <span title="(xs: String*)List[String]">List</span><span class="delimiter">(</span><span title="String(&quot;splat&quot;)" class="string">&quot;splat&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

  private def <a title="=&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]" id="org.scalatra;SinatraPathPatternParser.namedGroup">namedGroup</a> = <a href="#org.scalatra;SinatraPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.literal : (s: String)SinatraPathPatternParser.this.Parser[String]" class="string">&quot;:&quot;</a> <span title="(q: =&gt; SinatraPathPatternParser.this.Parser[String])SinatraPathPatternParser.this.Parser[String]">~&gt;</span> <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;&quot;&quot;\w+&quot;&quot;&quot;</span>.<a href="#org.scalatra;SinatraPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.regex : (r: scala.util.matching.Regex)SinatraPathPatternParser.this.Parser[String]">r</a> <span title="(f: String =&gt; SinatraPathPatternParser.this.PartialPathPattern)SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]">^^</span>
    <span class="delimiter">{</span> <a title="String" id="org.scalatra;SinatraPathPatternParser.namedGroup.$anonfun.groupName">groupName</a> =&gt; <a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve" title="(regex: String, captureGroupNames: List[String])SinatraPathPatternParser.this.PartialPathPattern">PartialPathPattern</a><span class="delimiter">(</span><span title="String(&quot;([^/?#]+)&quot;)" class="string">&quot;([^/?#]+)&quot;</span>, <span title="(xs: String*)List[String]">List</span><span class="delimiter">(</span><a href="#org.scalatra;SinatraPathPatternParser.namedGroup.$anonfun.groupName" title="String">groupName</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>

  private def <a title="=&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]" id="org.scalatra;SinatraPathPatternParser.literal(a050b6e665)">literal</a> = <a href="#org.scalatra;SinatraPathPatternParser.metaChar" title="=&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]">metaChar</a> <span title="(q: =&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern])SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]">|</span> <a href="#org.scalatra;SinatraPathPatternParser.normalChar" title="=&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]">normalChar</a>

  private def <a title="=&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]" id="org.scalatra;SinatraPathPatternParser.metaChar">metaChar</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;&quot;&quot;[\.\+\(\)\$]&quot;&quot;&quot;</span>.<a href="#org.scalatra;SinatraPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.regex : (r: scala.util.matching.Regex)SinatraPathPatternParser.this.Parser[String]">r</a> <span title="(f: String =&gt; SinatraPathPatternParser.this.PartialPathPattern)SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]">^^</span>
    <span class="delimiter">{</span> <a title="String" id="org.scalatra;SinatraPathPatternParser.metaChar.$anonfun.c">c</a> =&gt; <a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve" title="(regex: String, captureGroupNames: List[String])SinatraPathPatternParser.this.PartialPathPattern">PartialPathPattern</a><span class="delimiter">(</span><span title="String(&quot;\\&quot;)" class="string">&quot;\\&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#org.scalatra;SinatraPathPatternParser.metaChar.$anonfun.c" title="String">c</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  private def <a title="=&gt; SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]" id="org.scalatra;SinatraPathPatternParser.normalChar">normalChar</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;.&quot;</span>.<a href="#org.scalatra;SinatraPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.regex : (r: scala.util.matching.Regex)SinatraPathPatternParser.this.Parser[String]">r</a> <span title="(f: String =&gt; SinatraPathPatternParser.this.PartialPathPattern)SinatraPathPatternParser.this.Parser[SinatraPathPatternParser.this.PartialPathPattern]">^^</span> <span class="delimiter">{</span> <a title="String" id="org.scalatra;SinatraPathPatternParser.normalChar.$anonfun.c">c</a> =&gt; <a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve" title="(regex: String, captureGroupNames: List[String])SinatraPathPatternParser.this.PartialPathPattern">PartialPathPattern</a><span class="delimiter">(</span><a href="#org.scalatra;SinatraPathPatternParser.normalChar.$anonfun.c" title="String">c</a><span class="delimiter">)</span> <span class="delimiter">}</span>
<span class="delimiter">}</span>

object <a title="org.scalatra.SinatraPathPatternParser.type" id="org.scalatra.SinatraPathPatternParser">SinatraPathPatternParser</a> <a href="#org.scalatra.SinatraPathPatternParser" title="org.scalatra.SinatraPathPatternParser.type" class="delimiter">{</a>
  def <a title="(pattern: String)org.scalatra.PathPattern" id="org.scalatra.SinatraPathPatternParser.apply">apply</a><span class="delimiter">(</span><a title="String" id="org.scalatra.SinatraPathPatternParser.apply.pattern">pattern</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#org.scalatra.PathPattern.readResolve" title="org.scalatra.PathPattern">PathPattern</a> = new <a href="#org.scalatra;SinatraPathPatternParser" title="org.scalatra.SinatraPathPatternParser">SinatraPathPatternParser</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="#org.scalatra;SinatraPathPatternParser.apply" title="(pattern: String)org.scalatra.PathPattern">apply</a><span class="delimiter">(</span><a href="#org.scalatra.SinatraPathPatternParser.apply.pattern" title="String">pattern</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Path pattern parser based on Rack::Mount::Strexp, which is used by Rails.
 */</span>
class <a title="class RailsPathPatternParser extends AnyRef with org.scalatra.RegexPathPatternParser" id="org.scalatra;RailsPathPatternParser">RailsPathPatternParser</a> extends <a href="#org.scalatra;RegexPathPatternParser" title="org.scalatra.RegexPathPatternParser">RegexPathPatternParser</a> <span class="delimiter">{</span>
  def <a title="(pattern: String)org.scalatra.PathPattern" id="org.scalatra;RailsPathPatternParser.apply">apply</a><span class="delimiter">(</span><a title="String" id="org.scalatra;RailsPathPatternParser.apply.pattern">pattern</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#org.scalatra.PathPattern.readResolve" title="org.scalatra.PathPattern">PathPattern</a> =
    <a href="#org.scalatra;RailsPathPatternParser" title="(p: RailsPathPatternParser.this.Parser[org.scalatra.PathPattern], in: CharSequence)RailsPathPatternParser.this.ParseResult[org.scalatra.PathPattern]">parseAll</a><span class="delimiter">(</span><a href="#org.scalatra;RailsPathPatternParser.target" title="=&gt; RailsPathPatternParser.this.Parser[org.scalatra.PathPattern]">target</a>, <a href="#org.scalatra;RailsPathPatternParser.apply.pattern" title="String">pattern</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case Success<span class="delimiter">(</span><a title="org.scalatra.PathPattern" id="org.scalatra;RailsPathPatternParser.apply.target">target</a>, _<span class="delimiter">)</span> =&gt; <a href="#org.scalatra;RailsPathPatternParser.apply.target" title="org.scalatra.PathPattern">target</a>
      case _ =&gt;
        throw new <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="String(&quot;Invalid path pattern: &quot;)" class="string">&quot;Invalid path pattern: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#org.scalatra;RailsPathPatternParser.apply.pattern" title="String">pattern</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  private def <a title="=&gt; RailsPathPatternParser.this.Parser[org.scalatra.PathPattern]" id="org.scalatra;RailsPathPatternParser.target">target</a> = <a href="#org.scalatra;RailsPathPatternParser.expr" title="=&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">expr</a> <span title="(f: RailsPathPatternParser.this.PartialPathPattern =&gt; org.scalatra.PathPattern)RailsPathPatternParser.this.Parser[org.scalatra.PathPattern]">^^</span>
    <span class="delimiter">{</span> <a title="RailsPathPatternParser.this.PartialPathPattern" id="org.scalatra;RailsPathPatternParser.target.$anonfun.e">e</a> =&gt; <a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve" title="(regex: String, captureGroupNames: List[String])RailsPathPatternParser.this.PartialPathPattern">PartialPathPattern</a><span class="delimiter">(</span><span title="String(&quot;\\A&quot;)" class="string">&quot;\\A&quot;</span><span title="(x$1: Any)String">+</span><a href="#org.scalatra;RailsPathPatternParser.target.$anonfun.e" title="RailsPathPatternParser.this.PartialPathPattern">e</a>.<a href="#org.scalatra;RegexPathPatternParser;PartialPathPattern.regex" title="=&gt; String">regex</a><span title="(x$1: Any)String">+</span><span title="String(&quot;\\Z&quot;)" class="string">&quot;\\Z&quot;</span>, <a href="#org.scalatra;RailsPathPatternParser.target.$anonfun.e" title="RailsPathPatternParser.this.PartialPathPattern">e</a>.<a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.apply$default$2" title="=&gt; List[String]">captureGroupNames</a><span class="delimiter">)</span>.<a href="#org.scalatra;RegexPathPatternParser;PartialPathPattern.toPathPattern" title="=&gt; org.scalatra.PathPattern">toPathPattern</a> <span class="delimiter">}</span>

  private def <a title="=&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]" id="org.scalatra;RailsPathPatternParser.expr">expr</a> = <a href="#org.scalatra;RailsPathPatternParser" title="(p: =&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern])RailsPathPatternParser.this.Parser[List[RailsPathPatternParser.this.PartialPathPattern]]">rep1</a><span class="delimiter">(</span><a href="#org.scalatra;RailsPathPatternParser.token" title="=&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">token</a><span class="delimiter">)</span> <span title="(f: List[RailsPathPatternParser.this.PartialPathPattern] =&gt; RailsPathPatternParser.this.PartialPathPattern)RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">^^</span>
    <span class="delimiter">{</span> <a href="#org.scalatra;RailsPathPatternParser.expr.$anonfun.x$6" title="List[RailsPathPatternParser.this.PartialPathPattern]">_</a>.<span title="(f: (RailsPathPatternParser.this.PartialPathPattern, RailsPathPatternParser.this.PartialPathPattern) =&gt; RailsPathPatternParser.this.PartialPathPattern)RailsPathPatternParser.this.PartialPathPattern">reduceLeft</span> <span class="delimiter">{</span> <a href="#org.scalatra;RailsPathPatternParser.expr.$anonfun.$anonfun.x$7" title="RailsPathPatternParser.this.PartialPathPattern">_</a><a href="#org.scalatra;RegexPathPatternParser;PartialPathPattern.+" title="(other: RailsPathPatternParser.this.PartialPathPattern)RailsPathPatternParser.this.PartialPathPattern">+</a><a href="#org.scalatra;RailsPathPatternParser.expr.$anonfun.$anonfun.x$8" title="RailsPathPatternParser.this.PartialPathPattern">_</a> <span class="delimiter">}</span> <span class="delimiter">}</span>

  private def <a title="=&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]" id="org.scalatra;RailsPathPatternParser.token">token</a> = <a href="#org.scalatra;RailsPathPatternParser.param" title="=&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">param</a> <span title="(q: =&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern])RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">|</span> <a href="#org.scalatra;RailsPathPatternParser.glob" title="=&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">glob</a> <span title="(q: =&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern])RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">|</span> <a href="#org.scalatra;RailsPathPatternParser.optional" title="=&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">optional</a> <span title="(q: =&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern])RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">|</span> <a href="#org.scalatra;RailsPathPatternParser.static" title="=&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">static</a>

  private def <a title="=&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]" id="org.scalatra;RailsPathPatternParser.param">param</a> = <a href="#org.scalatra;RailsPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.literal : (s: String)RailsPathPatternParser.this.Parser[String]" class="string">&quot;:&quot;</a> <span title="(q: =&gt; RailsPathPatternParser.this.Parser[String])RailsPathPatternParser.this.Parser[String]">~&gt;</span> <a href="#org.scalatra;RailsPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.regex : (r: scala.util.matching.Regex)RailsPathPatternParser.this.Parser[String]">identifier</a> <span title="(f: String =&gt; RailsPathPatternParser.this.PartialPathPattern)RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">^^</span>
    <span class="delimiter">{</span> <a title="String" id="org.scalatra;RailsPathPatternParser.param.$anonfun.name">name</a> =&gt; <a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve" title="(regex: String, captureGroupNames: List[String])RailsPathPatternParser.this.PartialPathPattern">PartialPathPattern</a><span class="delimiter">(</span><span title="String(&quot;([^#/.?]+)&quot;)" class="string">&quot;([^#/.?]+)&quot;</span>, <span title="(xs: String*)List[String]">List</span><span class="delimiter">(</span><a href="#org.scalatra;RailsPathPatternParser.param.$anonfun.name" title="String">name</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>

  private def <a title="=&gt; scala.util.matching.Regex" id="org.scalatra;RailsPathPatternParser.identifier">identifier</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;&quot;&quot;[a-zA-Z_]\w*&quot;&quot;&quot;</span>.<span title="=&gt; scala.util.matching.Regex">r</span>

  private def <a title="=&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]" id="org.scalatra;RailsPathPatternParser.glob">glob</a> = <a href="#org.scalatra;RailsPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.literal : (s: String)RailsPathPatternParser.this.Parser[String]" class="string">&quot;*&quot;</a> <span title="(q: =&gt; RailsPathPatternParser.this.Parser[String])RailsPathPatternParser.this.Parser[String]">~&gt;</span> <a href="#org.scalatra;RailsPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.regex : (r: scala.util.matching.Regex)RailsPathPatternParser.this.Parser[String]">identifier</a> <span title="(f: String =&gt; RailsPathPatternParser.this.PartialPathPattern)RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">^^</span>
    <span class="delimiter">{</span> <a title="String" id="org.scalatra;RailsPathPatternParser.glob.$anonfun.name">name</a> =&gt; <a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve" title="(regex: String, captureGroupNames: List[String])RailsPathPatternParser.this.PartialPathPattern">PartialPathPattern</a><span class="delimiter">(</span><span title="String(&quot;(.+)&quot;)" class="string">&quot;(.+)&quot;</span>, <span title="(xs: String*)List[String]">List</span><span class="delimiter">(</span><a href="#org.scalatra;RailsPathPatternParser.glob.$anonfun.name" title="String">name</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>

  private def <a title="=&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]" id="org.scalatra;RailsPathPatternParser.optional">optional</a>: <span title="RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">Parser</span><span class="delimiter">[</span>PartialPathPattern<span class="delimiter">]</span> = <a href="#org.scalatra;RailsPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.literal : (s: String)RailsPathPatternParser.this.Parser[String]" class="string">&quot;(&quot;</a> <span title="(q: =&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern])RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">~&gt;</span> <a href="#org.scalatra;RailsPathPatternParser.expr" title="=&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">expr</a> <span title="(q: =&gt; RailsPathPatternParser.this.Parser[String])RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">&lt;~</span> <a href="#org.scalatra;RailsPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.literal : (s: String)RailsPathPatternParser.this.Parser[String]" class="string">&quot;)&quot;</a> <span title="(f: RailsPathPatternParser.this.PartialPathPattern =&gt; RailsPathPatternParser.this.PartialPathPattern)RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">^^</span>
    <span class="delimiter">{</span> <a title="RailsPathPatternParser.this.PartialPathPattern" id="org.scalatra;RailsPathPatternParser.optional.$anonfun.e">e</a> =&gt; <a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve" title="(regex: String, captureGroupNames: List[String])RailsPathPatternParser.this.PartialPathPattern">PartialPathPattern</a><span class="delimiter">(</span><span title="String(&quot;(?:&quot;)" class="string">&quot;(?:&quot;</span><span title="(x$1: Any)String">+</span><a href="#org.scalatra;RailsPathPatternParser.optional.$anonfun.e" title="RailsPathPatternParser.this.PartialPathPattern">e</a>.<a href="#org.scalatra;RegexPathPatternParser;PartialPathPattern.regex" title="=&gt; String">regex</a><span title="(x$1: Any)String">+</span><span title="String(&quot;)?&quot;)" class="string">&quot;)?&quot;</span>, <a href="#org.scalatra;RailsPathPatternParser.optional.$anonfun.e" title="RailsPathPatternParser.this.PartialPathPattern">e</a>.<a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.apply$default$2" title="=&gt; List[String]">captureGroupNames</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  private def <a title="=&gt; RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]" id="org.scalatra;RailsPathPatternParser.static">static</a> = <span class="delimiter">(</span><a href="#org.scalatra;RailsPathPatternParser.escaped" title="=&gt; RailsPathPatternParser.this.Parser[String]">escaped</a> <span title="(q: =&gt; RailsPathPatternParser.this.Parser[String])RailsPathPatternParser.this.Parser[String]">|</span> <a href="#org.scalatra;RailsPathPatternParser.char" title="=&gt; RailsPathPatternParser.this.Parser[String]">char</a><span class="delimiter">)</span> <span title="(f: String =&gt; RailsPathPatternParser.this.PartialPathPattern)RailsPathPatternParser.this.Parser[RailsPathPatternParser.this.PartialPathPattern]">^^</span>
    <span class="delimiter">{</span> <a title="String" id="org.scalatra;RailsPathPatternParser.static.$anonfun.str">str</a> =&gt; <a href="#org.scalatra;RegexPathPatternParser.PartialPathPattern.readResolve" title="(regex: String, captureGroupNames: List[String])RailsPathPatternParser.this.PartialPathPattern">PartialPathPattern</a><span class="delimiter">(</span><a href="#org.scalatra;RailsPathPatternParser.static.$anonfun.str" title="String">str</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  private def <a title="=&gt; RailsPathPatternParser.this.Parser[String]" id="org.scalatra;RailsPathPatternParser.escaped">escaped</a> = <a href="#org.scalatra;RailsPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.literal : (s: String)RailsPathPatternParser.this.Parser[String]">literal</a><span class="delimiter">(</span><span title="String(&quot;\\&quot;)" class="string">&quot;\\&quot;</span><span class="delimiter">)</span> <span title="(q: =&gt; RailsPathPatternParser.this.Parser[String])RailsPathPatternParser.this.Parser[String]">~&gt;</span> <span class="delimiter">(</span><a href="#org.scalatra;RailsPathPatternParser.char" title="=&gt; RailsPathPatternParser.this.Parser[String]">char</a> <span title="(q: =&gt; RailsPathPatternParser.this.Parser[String])RailsPathPatternParser.this.Parser[String]">|</span> <a href="#org.scalatra;RailsPathPatternParser.paren" title="=&gt; RailsPathPatternParser.this.Parser[String]">paren</a><span class="delimiter">)</span>

  private def <a title="=&gt; RailsPathPatternParser.this.Parser[String]" id="org.scalatra;RailsPathPatternParser.char">char</a> = <a href="#org.scalatra;RailsPathPatternParser.metachar" title="=&gt; RailsPathPatternParser.this.Parser[String]">metachar</a> <span title="(q: =&gt; RailsPathPatternParser.this.Parser[String])RailsPathPatternParser.this.Parser[String]">|</span> <a href="#org.scalatra;RailsPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.regex : (r: scala.util.matching.Regex)RailsPathPatternParser.this.Parser[String]">stdchar</a>

  private def <a title="=&gt; RailsPathPatternParser.this.Parser[String]" id="org.scalatra;RailsPathPatternParser.metachar">metachar</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;&quot;&quot;[.^$|?+*{}\\\[\]-]&quot;&quot;&quot;</span>.<a href="#org.scalatra;RailsPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.regex : (r: scala.util.matching.Regex)RailsPathPatternParser.this.Parser[String]">r</a> <span title="(f: String =&gt; String)RailsPathPatternParser.this.Parser[String]">^^</span> <span class="delimiter">{</span> <span title="String(&quot;\\&quot;)" class="string">&quot;\\&quot;</span><span title="(x$1: Any)String">+</span><a href="#org.scalatra;RailsPathPatternParser.metachar.$anonfun.x$9" title="String">_</a> <span class="delimiter">}</span>

  private def <a title="=&gt; scala.util.matching.Regex" id="org.scalatra;RailsPathPatternParser.stdchar">stdchar</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;&quot;&quot;[^()]&quot;&quot;&quot;</span>.<span title="=&gt; scala.util.matching.Regex">r</span>

  private def <a title="=&gt; RailsPathPatternParser.this.Parser[String]" id="org.scalatra;RailsPathPatternParser.paren">paren</a> = <span class="delimiter">(</span><a href="#org.scalatra;RailsPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.literal : (s: String)RailsPathPatternParser.this.Parser[String]" class="string">&quot;(&quot;</a> <span title="(q: =&gt; RailsPathPatternParser.this.Parser[String])RailsPathPatternParser.this.Parser[String]">|</span> <a href="#org.scalatra;RailsPathPatternParser" title="implicit scala.util.parsing.combinator.RegexParsers.literal : (s: String)RailsPathPatternParser.this.Parser[String]" class="string">&quot;)&quot;</a><span class="delimiter">)</span> <span title="(f: String =&gt; String)RailsPathPatternParser.this.Parser[String]">^^</span> <span class="delimiter">{</span> <span title="String(&quot;\\&quot;)" class="string">&quot;\\&quot;</span><span title="(x$1: Any)String">+</span><a href="#org.scalatra;RailsPathPatternParser.paren.$anonfun.x$10" title="String">_</a> <span class="delimiter">}</span>
<span class="delimiter">}</span>

object <a title="org.scalatra.RailsPathPatternParser.type" id="org.scalatra.RailsPathPatternParser">RailsPathPatternParser</a> <a href="#org.scalatra.RailsPathPatternParser" title="org.scalatra.RailsPathPatternParser.type" class="delimiter">{</a>
  def <a title="(pattern: String)org.scalatra.PathPattern" id="org.scalatra.RailsPathPatternParser.apply">apply</a><span class="delimiter">(</span><a title="String" id="org.scalatra.RailsPathPatternParser.apply.pattern">pattern</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#org.scalatra.PathPattern.readResolve" title="org.scalatra.PathPattern">PathPattern</a> = new <a href="#org.scalatra;RailsPathPatternParser" title="org.scalatra.RailsPathPatternParser">RailsPathPatternParser</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="#org.scalatra;RailsPathPatternParser.apply" title="(pattern: String)org.scalatra.PathPattern">apply</a><span class="delimiter">(</span><a href="#org.scalatra.RailsPathPatternParser.apply.pattern" title="String">pattern</a><span class="delimiter">)</span>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>
