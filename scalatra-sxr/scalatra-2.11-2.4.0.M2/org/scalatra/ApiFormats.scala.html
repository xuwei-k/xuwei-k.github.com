<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>org/scalatra/ApiFormats.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package org.scalatra

import collection.<span title="scala.collection.JavaConverters.type">JavaConverters</span>._
import java.util.concurrent.ConcurrentHashMap
import org.scalatra.util.<a href="util/RicherString.scala.html#org.scalatra.util.RicherString" title="org.scalatra.util.RicherString.type">RicherString</a>._
import java.util.<span title="java.util.Locale.type">Locale</span>.ENGLISH
import scala.collection.concurrent
import collection.mutable
import javax.servlet.http.<span class="delimiter">{</span>HttpServletResponse, HttpServletRequest<span class="delimiter">}</span>

object <a title="org.scalatra.ApiFormats.type" id="org.scalatra.ApiFormats">ApiFormats</a> <a href="#org.scalatra.ApiFormats" title="org.scalatra.ApiFormats.type" class="delimiter">{</a>
  <span class="comment">/**
   * The request attribute key in which the format is stored.
   */</span>
  val <a title="String" id="org.scalatra.ApiFormats.FormatKey">FormatKey</a> = <span title="String(&quot;org.scalatra.FormatKey&quot;)" class="string">&quot;org.scalatra.FormatKey&quot;</span>

<span class="delimiter">}</span>

<span class="comment">//trait ApiFormatsContext {</span>
<span class="comment">//  def formats: mutable.ConcurrentMap[String, String]</span>
<span class="comment">//  def mimeTypes: mutable.ConcurrentMap[String, String]</span>
<span class="comment">//  def format: String</span>
<span class="comment">//  def responseFormat: String</span>
<span class="comment">//}</span>

<span class="comment">/**
 * Adds support for mapping and inferring formats to content types.
 *
 * $ - Provides a request-scoped format variable
 * $ - Maps formats to content types and vice versa
 * $ - Augments the content-type inferrer to use the format
 */</span>
trait <a title="trait ApiFormats extends AnyRef with org.scalatra.ScalatraBase" id="org.scalatra;ApiFormats">ApiFormats</a> extends <a href="ScalatraBase.scala.html#org.scalatra;ScalatraBase" title="org.scalatra.ScalatraBase">ScalatraBase</a> <span class="delimiter">{</span>
  <span class="comment">/**
   * A map of suffixes to content types.
   */</span>
  val <a title="scala.collection.concurrent.Map[String,String]" id="org.scalatra;ApiFormats.formats">formats</a>: concurrent.<span title="scala.collection.concurrent.Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span> = new <span title="java.util.concurrent.ConcurrentHashMap[String,String]">ConcurrentHashMap</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span><span class="delimiter">(</span><span title="(elems: (String, String)*)scala.collection.immutable.Map[String,String]">Map</span><span title="(m: scala.collection.Map[String,String])scala.collection.convert.Decorators.AsJava[java.util.Map[String,String]]" class="delimiter">(</span>
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;atom&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;application/atom+xml&quot;)" class="string">&quot;application/atom+xml&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;css&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;text/css&quot;)" class="string">&quot;text/css&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;flv&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;video/x-flv&quot;)" class="string">&quot;video/x-flv&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;html&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;text/html&quot;)" class="string">&quot;text/html&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;html5&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;text/html&quot;)" class="string">&quot;text/html&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;js&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;text/javascript&quot;)" class="string">&quot;text/javascript&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;json&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;application/json&quot;)" class="string">&quot;application/json&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;pdf&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;application/pdf&quot;)" class="string">&quot;application/pdf&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;rss&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;application/rss+xml&quot;)" class="string">&quot;application/rss+xml&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;svg&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;application/svg+xml&quot;)" class="string">&quot;application/svg+xml&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;swf&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;application/x-shockwave-flash&quot;)" class="string">&quot;application/x-shockwave-flash&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;txt&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;text/plain&quot;)" class="string">&quot;text/plain&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;xhtml&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;application/xhtml+xml&quot;)" class="string">&quot;application/xhtml+xml&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;xml&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;application/xml&quot;)" class="string">&quot;application/xml&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;xslt&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;application/xslt+xml&quot;)" class="string">&quot;application/xslt+xml&quot;</span>
  <span class="delimiter">)</span>.<span title="=&gt; java.util.Map[String,String]">asJava</span><span class="delimiter">)</span>.<span title="=&gt; scala.collection.concurrent.Map[String,String]">asScala</span>

  <span class="comment">/**
   * A map of content types to suffixes.  Not strictly a reverse of `formats`.
   */</span>
  val <a title="scala.collection.concurrent.Map[String,String]" id="org.scalatra;ApiFormats.mimeTypes">mimeTypes</a>: concurrent.<span title="scala.collection.concurrent.Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span> = new <span title="java.util.concurrent.ConcurrentHashMap[String,String]">ConcurrentHashMap</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span><span class="delimiter">(</span><span title="(elems: (String, String)*)scala.collection.immutable.Map[String,String]">Map</span><span title="(m: scala.collection.Map[String,String])scala.collection.convert.Decorators.AsJava[java.util.Map[String,String]]" class="delimiter">(</span>
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;application/atom+xml&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;atom&quot;)" class="string">&quot;atom&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;application/ecmascript&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;json&quot;)" class="string">&quot;json&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;application/javascript&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;json&quot;)" class="string">&quot;json&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;application/json&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;json&quot;)" class="string">&quot;json&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;application/pdf&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;pdf&quot;)" class="string">&quot;pdf&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;application/rss+xml&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;rss&quot;)" class="string">&quot;rss&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;application/svg+xml&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;svg&quot;)" class="string">&quot;svg&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;application/x-ecmascript&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;json&quot;)" class="string">&quot;json&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;application/x-shockwave-flash&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;swf&quot;)" class="string">&quot;swf&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;application/x-www-form-urlencoded&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;html&quot;)" class="string">&quot;html&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;application/xhtml+xml&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;html&quot;)" class="string">&quot;html&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;application/xml&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;xml&quot;)" class="string">&quot;xml&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;application/xslt+xml&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;xslt&quot;)" class="string">&quot;xslt&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;multipart/form-data&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;html&quot;)" class="string">&quot;html&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;text/html&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;html&quot;)" class="string">&quot;html&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;text/javascript&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;json&quot;)" class="string">&quot;json&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;text/plain&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;txt&quot;)" class="string">&quot;txt&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;text/css&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;css&quot;)" class="string">&quot;css&quot;</span>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;video/x-flv&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;flv&quot;)" class="string">&quot;flv&quot;</span>
  <span class="delimiter">)</span>.<span title="=&gt; java.util.Map[String,String]">asJava</span><span class="delimiter">)</span>.<span title="=&gt; scala.collection.concurrent.Map[String,String]">asScala</span>

  protected def <a title="(mime: String, extension: String)Unit" id="org.scalatra;ApiFormats.addMimeMapping">addMimeMapping</a><span class="delimiter">(</span><a title="String" id="org.scalatra;ApiFormats.addMimeMapping.mime">mime</a>: <span title="String">String</span>, <a title="String" id="org.scalatra;ApiFormats.addMimeMapping.extension">extension</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#org.scalatra;ApiFormats.mimeTypes" title="=&gt; scala.collection.concurrent.Map[String,String]">mimeTypes</a> <span title="(kv: (String, String))ApiFormats.this.mimeTypes.type">+=</span> <a href="#org.scalatra;ApiFormats.addMimeMapping.mime" title="(self: String)ArrowAssoc[String]">mime</a> <span title="(y: String)(String, String)">-&gt;</span> <a href="#org.scalatra;ApiFormats.addMimeMapping.extension" title="String">extension</a>
    <a href="#org.scalatra;ApiFormats.formats" title="=&gt; scala.collection.concurrent.Map[String,String]">formats</a> <span title="(kv: (String, String))ApiFormats.this.formats.type">+=</span> <a href="#org.scalatra;ApiFormats.addMimeMapping.extension" title="(self: String)ArrowAssoc[String]">extension</a> <span title="(y: String)(String, String)">-&gt;</span> <a href="#org.scalatra;ApiFormats.addMimeMapping.mime" title="String">mime</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * The default format.
   */</span>
  def <a title="=&gt; Symbol" id="org.scalatra;ApiFormats.defaultFormat">defaultFormat</a>: <span title="Symbol">Symbol</span> = <span title="(name: String)Symbol" class="symbol">'html</span>

  <span class="comment">/**
   * A list of formats accepted by default.
   */</span>
  def <a title="=&gt; List[Symbol]" id="org.scalatra;ApiFormats.defaultAcceptedFormats">defaultAcceptedFormats</a>: <span title="List[Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span title="scala.collection.immutable.List.type">List</span>.<span title="List[Nothing]">empty</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;`format` now means the same as `responseFormat`, `responseFormat` will be removed eventually&quot;</span>, <span class="string">&quot;2.3&quot;</span><span class="delimiter">)</span>
  def <a title="(implicit request: javax.servlet.http.HttpServletRequest, implicit response: javax.servlet.http.HttpServletResponse)String" id="org.scalatra;ApiFormats.responseFormat">responseFormat</a><span class="delimiter">(</span>implicit <a title="javax.servlet.http.HttpServletRequest" id="org.scalatra;ApiFormats.responseFormat.request">request</a>: <span title="javax.servlet.http.HttpServletRequest">HttpServletRequest</span>, <a title="javax.servlet.http.HttpServletResponse" id="org.scalatra;ApiFormats.responseFormat.response">response</a>: <span title="javax.servlet.http.HttpServletResponse">HttpServletResponse</span><span class="delimiter">)</span>: <span title="String">String</span> = <a href="#org.scalatra;ApiFormats.format" title="(implicit request: javax.servlet.http.HttpServletRequest, implicit response: javax.servlet.http.HttpServletResponse)String">format</a>

  <span class="comment">/**
   * The list of media types accepted by the current request.  Parsed from the
   * `Accept` header.
   */</span>
  def <a title="(implicit request: javax.servlet.http.HttpServletRequest)List[String]" id="org.scalatra;ApiFormats.acceptHeader">acceptHeader</a><span class="delimiter">(</span>implicit <a title="javax.servlet.http.HttpServletRequest" id="org.scalatra;ApiFormats.acceptHeader.request">request</a>: <span title="javax.servlet.http.HttpServletRequest">HttpServletRequest</span><span class="delimiter">)</span>: <span title="List[String]">List</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#org.scalatra;ApiFormats.parseAcceptHeader" title="(implicit request: javax.servlet.http.HttpServletRequest)List[String]">parseAcceptHeader</a>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> def <a title="(implicit request: javax.servlet.http.HttpServletRequest)Option[String]" id="org.scalatra;ApiFormats.getFromParams">getFromParams</a><span class="delimiter">(</span>implicit <a title="javax.servlet.http.HttpServletRequest" id="org.scalatra;ApiFormats.getFromParams.request">request</a>: <span title="javax.servlet.http.HttpServletRequest">HttpServletRequest</span><span class="delimiter">)</span>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="ScalatraBase.scala.html#org.scalatra;ScalatraBase.params(253444d747)" title="(implicit request: javax.servlet.http.HttpServletRequest)org.scalatra.Params">params</a>.<a href="util/MultiMapHeadView.scala.html#org.scalatra.util;MultiMapHeadView.get" title="(key: String)Option[String]">get</a><span title="(xo: Option[String])Iterable[String]" class="delimiter">(</span><span title="String(&quot;format&quot;)" class="string">&quot;format&quot;</span><span class="delimiter">)</span>.<span title="(p: String =&gt; Boolean)Option[String]">find</span><span class="delimiter">(</span><a title="String" id="org.scalatra;ApiFormats.getFromParams.$anonfun.p">p</a> â‡’ <a href="#org.scalatra;ApiFormats.formats" title="=&gt; scala.collection.concurrent.Map[String,String]">formats</a>.<span title="(key: String)Boolean">contains</span><span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.getFromParams.$anonfun.p" title="String">p</a>.<span title="(x$1: java.util.Locale)String">toLowerCase</span><span class="delimiter">(</span><span title="java.util.Locale">ENGLISH</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> def <a title="(implicit request: javax.servlet.http.HttpServletRequest)Option[String]" id="org.scalatra;ApiFormats.getFromAcceptHeader">getFromAcceptHeader</a><span class="delimiter">(</span>implicit <a title="javax.servlet.http.HttpServletRequest" id="org.scalatra;ApiFormats.getFromAcceptHeader.request">request</a>: <span title="javax.servlet.http.HttpServletRequest">HttpServletRequest</span><span class="delimiter">)</span>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="List[String]" id="org.scalatra;ApiFormats.getFromAcceptHeader.hdrs">hdrs</a> = <a href="servlet/ServletApiImplicits.scala.html#org.scalatra.servlet;ServletApiImplicits.enrichRequest" title="implicit org.scalatra.servlet.ServletApiImplicits.enrichRequest : (request: javax.servlet.http.HttpServletRequest)org.scalatra.servlet.RichRequest">request</a>.<a href="servlet/RichRequest.scala.html#org.scalatra.servlet;RichRequest.contentType" title="=&gt; Option[String]">contentType</a>.<span title="(ifEmpty: =&gt; List[String])(f: String =&gt; List[String])List[String]">fold</span><span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.acceptHeader" title="(implicit request: javax.servlet.http.HttpServletRequest)List[String]">acceptHeader</a><span class="delimiter">)</span><span class="delimiter">(</span> <a title="String" id="org.scalatra;ApiFormats.getFromAcceptHeader.hdrs.$anonfun.contentType">contentType</a> =&gt;
      <span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.acceptHeader" title="(implicit request: javax.servlet.http.HttpServletRequest)List[String]">acceptHeader</a> <a href="#org.scalatra;ApiFormats.getFromAcceptHeader.hdrs.$anonfun.x$1" title="(prefix: List[String])List[String]">:::</a> <span title="(xs: String*)List[String]">List</span><span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.getFromAcceptHeader.hdrs.$anonfun.contentType" title="String">contentType</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; List[String]">distinct</span>
    <span class="delimiter">)</span>
    <a href="#org.scalatra;ApiFormats.formatForMimeTypes" title="(mimeTypes: String*)Option[String]">formatForMimeTypes</a><span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.getFromAcceptHeader.hdrs" title="List[String]">hdrs</a>: _*<span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> def <a title="(implicit response: javax.servlet.http.HttpServletResponse)Option[String]" id="org.scalatra;ApiFormats.getFromResponseHeader">getFromResponseHeader</a><span class="delimiter">(</span>implicit <a title="javax.servlet.http.HttpServletResponse" id="org.scalatra;ApiFormats.getFromResponseHeader.response">response</a>: <span title="javax.servlet.http.HttpServletResponse">HttpServletResponse</span><span class="delimiter">)</span>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="servlet/ServletApiImplicits.scala.html#org.scalatra.servlet;ServletApiImplicits.enrichResponse" title="implicit org.scalatra.servlet.ServletApiImplicits.enrichResponse : (response: javax.servlet.http.HttpServletResponse)org.scalatra.servlet.RichResponse">response</a>.<a href="servlet/RichResponse.scala.html#org.scalatra.servlet;RichResponse.contentType" title="=&gt; Option[String]">contentType</a> <span title="(f: String =&gt; Option[String])Option[String]">flatMap</span> <span class="delimiter">(</span> <a title="String" id="org.scalatra;ApiFormats.getFromResponseHeader.$anonfun.ctt">ctt</a> =&gt; <a href="#org.scalatra;ApiFormats.getFromResponseHeader.$anonfun.ctt" title="String">ctt</a>.<span title="(x$1: String)Array[String]">split</span><span title="(xs: Array[String])scala.collection.mutable.ArrayOps[String]" class="delimiter">(</span><span title="String(&quot;;&quot;)" class="string">&quot;;&quot;</span><span class="delimiter">)</span>.<span title="=&gt; Option[String]">headOption</span> <span title="(f: String =&gt; Option[String])Option[String]">flatMap</span> <a href="#org.scalatra;ApiFormats.mimeTypes" title="=&gt; scala.collection.concurrent.Map[String,String]">mimeTypes</a>.<a href="#org.scalatra;ApiFormats.getFromResponseHeader.$anonfun.$anonfun.key" title="(key: String)Option[String]">get</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private def <a title="(implicit request: javax.servlet.http.HttpServletRequest)List[String]" id="org.scalatra;ApiFormats.parseAcceptHeader">parseAcceptHeader</a><span class="delimiter">(</span>implicit <a title="javax.servlet.http.HttpServletRequest" id="org.scalatra;ApiFormats.parseAcceptHeader.request">request</a>: <span title="javax.servlet.http.HttpServletRequest">HttpServletRequest</span><span class="delimiter">)</span>: <span title="List[String]">List</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(a: Array[String])Boolean" id="org.scalatra;ApiFormats.parseAcceptHeader.isValidQPair">isValidQPair</a> <span class="delimiter">(</span><a title="Array[String]" id="org.scalatra;ApiFormats.parseAcceptHeader.isValidQPair.a">a</a>:<span title="Array[String]">Array</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      val <a title="scala.collection.immutable.NumericRange[Double]" id="org.scalatra;ApiFormats.parseAcceptHeader.isValidQPair.validRange">validRange</a> = <span title="=&gt; collection.immutable.Range.type">Range</span>.<span title="Range.Double.type">Double</span>.<span title="(start: Double, end: Double, step: Double)scala.collection.immutable.NumericRange[Double]">inclusive</span><span class="delimiter">(</span><span title="Double(0.0)" class="int">0</span>, <span title="Double(1.0)" class="int">1</span>, <span title="Double(0.1)" class="double">0.1</span><span class="delimiter">)</span>
      <a href="#org.scalatra;ApiFormats.parseAcceptHeader.isValidQPair.a" title="Array[String]">a</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">==</span> <span title="Int(2)" class="int">2</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#org.scalatra;ApiFormats.parseAcceptHeader.isValidQPair.a" title="(i: Int)String">a</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x$1: Any)Boolean">==</span> <span title="String(&quot;q&quot;)" class="string">&quot;q&quot;</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#org.scalatra;ApiFormats.parseAcceptHeader.isValidQPair.validRange" title="scala.collection.immutable.NumericRange[Double]">validRange</a>.<span title="(x: Double)Boolean">contains</span><span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.parseAcceptHeader.isValidQPair.a" title="(i: Int)String">a</a><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>.<span title="=&gt; Double">toDouble</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="servlet/ServletApiImplicits.scala.html#org.scalatra.servlet;ServletApiImplicits.enrichRequest" title="implicit org.scalatra.servlet.ServletApiImplicits.enrichRequest : (request: javax.servlet.http.HttpServletRequest)org.scalatra.servlet.RichRequest">request</a>.<a href="servlet/RichRequest.scala.html#org.scalatra.servlet;RichRequest.headers" title="org.scalatra.servlet.RichRequest#headers.type">headers</a>.<a href="servlet/RichRequest.scala.html#org.scalatra.servlet;RichRequest.headers.get" title="(name: String)Option[String]">get</a><span class="delimiter">(</span><span title="String(&quot;Accept&quot;)" class="string">&quot;Accept&quot;</span><span class="delimiter">)</span> <span title="(f: String =&gt; List[String])Option[List[String]]">map</span> <span class="delimiter">{</span> <a title="String" id="org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.s">s</a> =&gt;
      val <a title="Array[String]" id="org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.fmts">fmts</a> = <a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.s" title="String">s</a>.<span title="(x$1: String)Array[String]">split</span><span title="(xs: Array[String])scala.collection.mutable.ArrayOps[String]" class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>.<span title="(f: String =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Array[String],String,Array[String]])Array[String]">map</span><span title="(implicit t: scala.reflect.ClassTag[String])scala.collection.generic.CanBuildFrom[Array[_],String,Array[String]]" class="delimiter">(</span><a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.fmts.$anonfun.x$2" title="String">_</a>.<span title="()String">trim</span><span class="delimiter">)</span>
      val <a title="scala.collection.immutable.Map[Int,List[String]]" id="org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted">accepted</a> = <a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.fmts" title="(xs: Array[String])scala.collection.mutable.ArrayOps[String]">fmts</a>.<span title="(z: scala.collection.immutable.Map[Int,List[String]])(op: (scala.collection.immutable.Map[Int,List[String]], String) =&gt; scala.collection.immutable.Map[Int,List[String]])scala.collection.immutable.Map[Int,List[String]]">foldLeft</span><span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[Int,List[String]]" class="delimiter">[</span><span title="Int">Int</span>, <span title="List[String]">List</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="scala.collection.immutable.Map[Int,List[String]]" id="org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.acc">acc</a>, <a title="String" id="org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.f">f</a><span class="delimiter">)</span> =&gt;
        val <a title="Array[String]" id="org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.parts">parts</a> = <a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.f" title="String">f</a>.<span title="(x$1: String)Array[String]">split</span><span title="(xs: Array[String])scala.collection.mutable.ArrayOps[String]" class="delimiter">(</span><span title="String(&quot;;&quot;)" class="string">&quot;;&quot;</span><span class="delimiter">)</span>.<span title="(f: String =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Array[String],String,Array[String]])Array[String]">map</span><span title="(implicit t: scala.reflect.ClassTag[String])scala.collection.generic.CanBuildFrom[Array[_],String,Array[String]]" class="delimiter">(</span><a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.parts.$anonfun.x$3" title="String">_</a>.<span title="()String">trim</span><span class="delimiter">)</span>
        val <a title="Int" id="org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.i">i</a> = if <span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.parts" title="(xs: Array[String])scala.collection.mutable.ArrayOps[String]">parts</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          val <a title="Array[String]" id="org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.i.pars">pars</a> = <a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.parts" title="(i: Int)String">parts</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>.<span title="(x$1: String)Array[String]">split</span><span title="(xs: Array[String])scala.collection.mutable.ArrayOps[String]" class="delimiter">(</span><span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span><span class="delimiter">)</span>.<span title="(f: String =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Array[String],String,Array[String]])Array[String]">map</span><span title="(xs: Array[String])scala.collection.mutable.ArrayOps[String]" class="delimiter">(</span><a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.i.pars.$anonfun.x$4" title="String">_</a>.<span title="()String">trim</span><span class="delimiter">)</span>.<span title="(size: Int)Iterator[Array[String]]">grouped</span><span class="delimiter">(</span><span title="Int(2)" class="int">2</span><span class="delimiter">)</span>.<span title="(p: Array[String] =&gt; Boolean)Option[Array[String]]">find</span><span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.parseAcceptHeader.isValidQPair" title="(a: Array[String])Boolean">isValidQPair</a><span class="delimiter">)</span>.<span title="(default: =&gt; Array[String])Array[String]">getOrElse</span><span class="delimiter">(</span><span title="(xs: String*)(implicit evidence$2: scala.reflect.ClassTag[String])Array[String]">Array</span><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[String]" class="delimiter">(</span><span title="String(&quot;q&quot;)" class="string">&quot;q&quot;</span>, <span title="String(&quot;0&quot;)" class="string">&quot;0&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.i.pars" title="(i: Int)String">pars</a><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>.<span title="=&gt; Double">toDouble</span> <span title="implicit scala.LowPriorityImplicits.doubleWrapper : (x: Double)scala.runtime.RichDouble">*</span> <span title="Int(10)" class="int">10</span><span class="delimiter">)</span>.<span title="=&gt; Double">ceil</span>.<span title="=&gt; Int">toInt</span>
        <span class="delimiter">}</span> else <span title="Int(10)" class="int">10</span>
        <a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.acc" title="scala.collection.immutable.Map[Int,List[String]]">acc</a> <span title="(kv: (Int, List[String]))scala.collection.immutable.Map[Int,List[String]]">+</span> <span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.i" title="(self: Int)ArrowAssoc[Int]">i</a> <span title="(y: List[String])(Int, List[String])">-&gt;</span> <span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.parts" title="(i: Int)String">parts</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.x$5" title="(x: String)List[String]">::</a> <a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.acc" title="scala.collection.immutable.Map[Int,List[String]]">acc</a>.<span title="(key: Int)Option[List[String]]">get</span><span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted.$anonfun.i" title="Int">i</a><span class="delimiter">)</span>.<span title="(default: =&gt; List[String])List[String]">getOrElse</span><span class="delimiter">(</span><span title="scala.collection.immutable.List.type">List</span>.<span title="List[Nothing]">empty</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.accepted" title="scala.collection.immutable.Map[Int,List[String]]">accepted</a>.<span title="=&gt; List[(Int, List[String])]">toList</span>.<span title="(lt: ((Int, List[String]), (Int, List[String])) =&gt; Boolean)List[(Int, List[String])]">sortWith</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="(Int, List[String])" id="org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.$anonfun.kv1">kv1</a>, <a title="(Int, List[String])" id="org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.$anonfun.kv2">kv2</a><span class="delimiter">)</span> =&gt; <a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.$anonfun.kv1" title="(Int, List[String])">kv1</a>.<span title="=&gt; Int">_1</span> <span title="(x: Int)Boolean">&gt;</span> <a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.$anonfun.kv2" title="(Int, List[String])">kv2</a>.<span title="=&gt; Int">_1</span><span class="delimiter">)</span>.<span title="(f: ((Int, List[String])) =&gt; scala.collection.GenTraversableOnce[String])(implicit bf: scala.collection.generic.CanBuildFrom[List[(Int, List[String])],String,List[String]])List[String]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,String,List[String]]" class="delimiter">(</span><a href="#org.scalatra;ApiFormats.parseAcceptHeader.$anonfun.$anonfun.x$6" title="(Int, List[String])">_</a>.<span title="=&gt; List[String]">_2</span>.<span title="=&gt; List[String]">reverse</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span title="(default: =&gt; List[String])List[String]">getOrElse</span> <span title="scala.collection.immutable.Nil.type">Nil</span>
  <span class="delimiter">}</span>

  protected def <a title="(mimeTypes: String*)Option[String]" id="org.scalatra;ApiFormats.formatForMimeTypes">formatForMimeTypes</a><span class="delimiter">(</span><a title="String*" id="org.scalatra;ApiFormats.formatForMimeTypes.mimeTypes">mimeTypes</a>: <span title="String*">String</span>*<span class="delimiter">)</span>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="String" id="org.scalatra;ApiFormats.formatForMimeTypes.defaultMimeType">defaultMimeType</a> = <a href="#org.scalatra;ApiFormats.formats" title="(key: String)String">formats</a><span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.defaultFormat" title="=&gt; Symbol">defaultFormat</a>.<span title="=&gt; String">name</span><span class="delimiter">)</span>
    def <a title="(tm: String, f: String)Boolean" id="org.scalatra;ApiFormats.formatForMimeTypes.matchMimeType">matchMimeType</a><span class="delimiter">(</span><a title="String" id="org.scalatra;ApiFormats.formatForMimeTypes.matchMimeType.tm">tm</a>: <span title="String">String</span>, <a title="String" id="org.scalatra;ApiFormats.formatForMimeTypes.matchMimeType.f">f</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#org.scalatra;ApiFormats.formatForMimeTypes.matchMimeType.tm" title="String">tm</a>.<span title="(x$1: java.util.Locale)String">toLowerCase</span><span class="delimiter">(</span><span title="java.util.Locale">ENGLISH</span><span class="delimiter">)</span>.<span title="(x$1: String)Boolean">startsWith</span><span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.formatForMimeTypes.matchMimeType.f" title="String">f</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.formatForMimeTypes.defaultMimeType" title="String">defaultMimeType</a> <span title="(x$1: Any)Boolean">==</span> <a href="#org.scalatra;ApiFormats.formatForMimeTypes.matchMimeType.f" title="String">f</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#org.scalatra;ApiFormats.formatForMimeTypes.matchMimeType.tm" title="String">tm</a>.<span title="(x$1: CharSequence)Boolean">contains</span><span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.formatForMimeTypes.defaultMimeType" title="String">defaultMimeType</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#org.scalatra;ApiFormats.formatForMimeTypes.mimeTypes" title="String*">mimeTypes</a> <span title="(p: String =&gt; Boolean)Option[String]">find</span> <span class="delimiter">{</span> <span title="String">hdr</span> =&gt;
      <a href="#org.scalatra;ApiFormats.formats" title="=&gt; scala.collection.concurrent.Map[String,String]">formats</a> <span title="(p: ((String, String)) =&gt; Boolean)Boolean">exists</span> <a href="#org.scalatra;ApiFormats.formatForMimeTypes.$anonfun.$anonfun.x0$1" title="Boolean" class="delimiter">{</a> case <span class="delimiter">(</span><span title="String">k</span>, <span title="String">v</span><span class="delimiter">)</span> =&gt; <a href="#org.scalatra;ApiFormats.formatForMimeTypes.matchMimeType" title="(tm: String, f: String)Boolean">matchMimeType</a><span class="delimiter">(</span><span title="String">hdr</span>, <span title="String">v</span><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="delimiter">}</span> <span title="(f: String =&gt; Option[String])Option[String]">flatMap</span> <span class="delimiter">{</span> <span title="String">hdr</span> =&gt;
      <a href="#org.scalatra;ApiFormats.formats" title="=&gt; scala.collection.concurrent.Map[String,String]">formats</a> <span title="(p: ((String, String)) =&gt; Boolean)Option[(String, String)]">find</span> <a href="#org.scalatra;ApiFormats.formatForMimeTypes.$anonfun.$anonfun.x0$2" title="Boolean" class="delimiter">{</a> case <span class="delimiter">(</span><span title="String">k</span>, <span title="String">v</span><span class="delimiter">)</span> =&gt; <a href="#org.scalatra;ApiFormats.formatForMimeTypes.matchMimeType" title="(tm: String, f: String)Boolean">matchMimeType</a><span class="delimiter">(</span><span title="String">hdr</span>, <span title="String">v</span><span class="delimiter">)</span> <span class="delimiter">}</span> <span title="(f: ((String, String)) =&gt; String)Option[String]">map</span> <span class="delimiter">{</span> <a href="#org.scalatra;ApiFormats.formatForMimeTypes.$anonfun.$anonfun.x$7" title="(String, String)">_</a>.<span title="=&gt; String">_1</span> <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A content type inferrer based on the `format` variable.  Looks up the media
   * type from the `formats` map.  If not found, returns
   * `application/octet-stream`.  This inferrer is prepended to the inherited
   * one.
   */</span>
  protected def <a title="=&gt; org.scalatra.ContentTypeInferrer" id="org.scalatra;ApiFormats.inferFromFormats">inferFromFormats</a>: <span title="org.scalatra.ContentTypeInferrer">ContentTypeInferrer</span> = <a title="&lt;$anon: Any =&gt; String&gt; extends scala.runtime.AbstractPartialFunction[Any,String] with Serializable" id="org.scalatra;ApiFormats.inferFromFormats;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
    case _ if <a href="util/RicherString.scala.html#org.scalatra.util.RicherString.stringToRicherString" title="implicit org.scalatra.util.RicherString.stringToRicherString : (s: String)org.scalatra.util.RicherString">format</a>.<a href="util/RicherString.scala.html#org.scalatra.util;RicherString.nonBlank" title="=&gt; Boolean">nonBlank</a> =&gt; <a href="#org.scalatra;ApiFormats.formats" title="=&gt; scala.collection.concurrent.Map[String,String]">formats</a>.<span title="(key: String)Option[String]">get</span><span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.format" title="(implicit request: javax.servlet.http.HttpServletRequest, implicit response: javax.servlet.http.HttpServletResponse)String">format</a><span class="delimiter">)</span> <span title="(default: =&gt; String)String">getOrElse</span> <span title="String(&quot;application/octet-stream&quot;)" class="string">&quot;application/octet-stream&quot;</span>
  <span class="delimiter">}</span>

  override protected def <a title="=&gt; org.scalatra.ContentTypeInferrer" id="org.scalatra;ApiFormats.contentTypeInferrer">contentTypeInferrer</a>: <span title="org.scalatra.ContentTypeInferrer">ContentTypeInferrer</span> = <a href="#org.scalatra;ApiFormats.inferFromFormats" title="=&gt; org.scalatra.ContentTypeInferrer">inferFromFormats</a> <span title="(that: PartialFunction[Any,String])PartialFunction[Any,String]">orElse</span> super.<a href="ScalatraBase.scala.html#org.scalatra;ScalatraBase.contentTypeInferrer" title="=&gt; org.scalatra.ContentTypeInferrer">contentTypeInferrer</a>

  protected def <a title="(accepted: Symbol*)Boolean" id="org.scalatra;ApiFormats.acceptedFormats">acceptedFormats</a><span class="delimiter">(</span><a title="Symbol*" id="org.scalatra;ApiFormats.acceptedFormats.accepted">accepted</a>: <span title="Symbol*">Symbol</span>*<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    val <a title="List[String]" id="org.scalatra;ApiFormats.acceptedFormats.conditions">conditions</a> = if <span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.acceptedFormats.accepted" title="Symbol*">accepted</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#org.scalatra;ApiFormats.defaultAcceptedFormats" title="=&gt; List[Symbol]">defaultAcceptedFormats</a>.<span title="(f: Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Symbol],String,List[String]])List[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,String,List[String]]" class="delimiter">(</span><a href="#org.scalatra;ApiFormats.acceptedFormats.conditions.$anonfun.x$8" title="Symbol">_</a>.<span title="=&gt; String">name</span><span class="delimiter">)</span> else <a href="#org.scalatra;ApiFormats.acceptedFormats.accepted" title="Symbol*">accepted</a>.<span title="(f: Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Symbol],String,Seq[String]])Seq[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a href="#org.scalatra;ApiFormats.acceptedFormats.conditions.$anonfun.x$9" title="Symbol">_</a>.<span title="=&gt; String">name</span><span class="delimiter">)</span>.<span title="=&gt; List[String]">toList</span>
    <a href="#org.scalatra;ApiFormats.acceptedFormats.conditions" title="List[String]">conditions</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.acceptedFormats.conditions" title="List[String]">conditions</a> <span title="(p: String =&gt; Boolean)List[String]">filter</span> <span class="delimiter">{</span> <a title="String" id="org.scalatra;ApiFormats.acceptedFormats.$anonfun.s">s</a> =&gt; <a href="#org.scalatra;ApiFormats.formats" title="=&gt; scala.collection.concurrent.Map[String,String]">formats</a>.<span title="(key: String)Option[String]">get</span><span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.acceptedFormats.$anonfun.s" title="String">s</a><span class="delimiter">)</span>.<span title="=&gt; Boolean">isDefined</span> <span class="delimiter">}</span> <span title="(elem: String)Boolean">contains</span> <a href="ScalatraContext.scala.html#org.scalatra;ScalatraContext.contentType" title="=&gt; String">contentType</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private def <a title="(implicit request: javax.servlet.http.HttpServletRequest, implicit response: javax.servlet.http.HttpServletResponse)String" id="org.scalatra;ApiFormats.getFormat">getFormat</a><span class="delimiter">(</span>implicit <a title="javax.servlet.http.HttpServletRequest" id="org.scalatra;ApiFormats.getFormat.request">request</a>: <span title="javax.servlet.http.HttpServletRequest">HttpServletRequest</span>, <a title="javax.servlet.http.HttpServletResponse" id="org.scalatra;ApiFormats.getFormat.response">response</a>: <span title="javax.servlet.http.HttpServletResponse">HttpServletResponse</span><span class="delimiter">)</span>: <span title="String">String</span> =
    <a href="#org.scalatra;ApiFormats.getFromResponseHeader" title="(implicit response: javax.servlet.http.HttpServletResponse)Option[String]">getFromResponseHeader</a> <span title="(alternative: =&gt; Option[String])Option[String]">orElse</span> <a href="#org.scalatra;ApiFormats.getFromParams" title="(implicit request: javax.servlet.http.HttpServletRequest)Option[String]">getFromParams</a> <span title="(alternative: =&gt; Option[String])Option[String]">orElse</span> <a href="#org.scalatra;ApiFormats.getFromAcceptHeader" title="(implicit request: javax.servlet.http.HttpServletRequest)Option[String]">getFromAcceptHeader</a> <span title="(default: =&gt; String)String">getOrElse</span> <a href="#org.scalatra;ApiFormats.defaultFormat" title="=&gt; Symbol">defaultFormat</a>.<span title="=&gt; String">name</span>

  import <a href="#org.scalatra.ApiFormats" title="org.scalatra.ApiFormats.type">ApiFormats</a>.FormatKey

  protected override def <a title="[S](matchedRoute: Option[org.scalatra.MatchedRoute])(thunk: =&gt; S)S" id="org.scalatra;ApiFormats.withRouteMultiParams">withRouteMultiParams</a><span class="delimiter">[</span><a title="" id="org.scalatra;ApiFormats.withRouteMultiParams;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Option[org.scalatra.MatchedRoute]" id="org.scalatra;ApiFormats.withRouteMultiParams.matchedRoute">matchedRoute</a>: <span title="Option[org.scalatra.MatchedRoute]">Option</span><span class="delimiter">[</span>MatchedRoute<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; S" id="org.scalatra;ApiFormats.withRouteMultiParams.thunk">thunk</a>: =&gt; S<span class="delimiter">)</span>: <a href="#org.scalatra;ApiFormats.withRouteMultiParams;S" title="S">S</a> = <span class="delimiter">{</span>
    val <a title="org.scalatra.MultiParams" id="org.scalatra;ApiFormats.withRouteMultiParams.originalParams">originalParams</a> = <a href="ScalatraBase.scala.html#org.scalatra;ScalatraBase.multiParams(53d1ef321f)" title="(implicit request: javax.servlet.http.HttpServletRequest)org.scalatra.MultiParams">multiParams</a>
    val <a title="Map[String,Seq[String]]" id="org.scalatra;ApiFormats.withRouteMultiParams.routeParams">routeParams</a>: <span title="Map[String,Seq[String]]">Map</span><span class="delimiter">[</span>String, Seq<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#org.scalatra;ApiFormats.withRouteMultiParams.matchedRoute" title="Option[org.scalatra.MatchedRoute]">matchedRoute</a>.<span title="(f: org.scalatra.MatchedRoute =&gt; org.scalatra.MultiParams)Option[org.scalatra.MultiParams]">map</span><span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.withRouteMultiParams.routeParams.$anonfun.x$10" title="org.scalatra.MatchedRoute">_</a>.<a href="route.scala.html#org.scalatra;MatchedRoute.multiParams" title="=&gt; org.scalatra.MultiParams">multiParams</a><span class="delimiter">)</span>.<span title="(default: =&gt; scala.collection.immutable.Map[_ &lt;: String, Seq[String]])scala.collection.immutable.Map[_ &lt;: String, Seq[String]]">getOrElse</span><span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="scala.collection.immutable.Map[Nothing,Nothing]">empty</span><span class="delimiter">)</span>.<span title="(f: ((_3, Seq[String])) =&gt; (_3, Seq[String]))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[_3,Seq[String]],(_3, Seq[String]),Map[String,Seq[String]]])Map[String,Seq[String]]">map</span> <a href="#org.scalatra;ApiFormats.withRouteMultiParams.routeParams.$anonfun.x0$3" title="(_3, Seq[String])" class="delimiter">{</a>
      case <span class="delimiter">(</span><a title="_3" id="org.scalatra;ApiFormats.withRouteMultiParams.routeParams.$anonfun.key">key</a>, <a title="Seq[String]" id="org.scalatra;ApiFormats.withRouteMultiParams.routeParams.$anonfun.values">values</a><span class="delimiter">)</span> =&gt;
        <a href="#org.scalatra;ApiFormats.withRouteMultiParams.routeParams.$anonfun.key" title="(self: _3)ArrowAssoc[_3]">key</a> <span title="(y: Seq[String])(_3, Seq[String])">-&gt;</span> <a href="#org.scalatra;ApiFormats.withRouteMultiParams.routeParams.$anonfun.values" title="Seq[String]">values</a>.<span title="(f: String =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],String,Seq[String]])Seq[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a title="String" id="org.scalatra;ApiFormats.withRouteMultiParams.routeParams.$anonfun.$anonfun.s">s</a> =&gt; if <span class="delimiter">(</span><a href="util/RicherString.scala.html#org.scalatra.util.RicherString.stringToRicherString" title="implicit org.scalatra.util.RicherString.stringToRicherString : (s: String)org.scalatra.util.RicherString">s</a>.<a href="util/RicherString.scala.html#org.scalatra.util;RicherString.nonBlank" title="=&gt; Boolean">nonBlank</a><span class="delimiter">)</span> <a href="ScalatraBase.scala.html#org.scalatra.UriDecoder" title="org.scalatra.UriDecoder.type">UriDecoder</a>.<a href="ScalatraBase.scala.html#org.scalatra.UriDecoder.secondStep" title="(uri: String)String">secondStep</a><span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.withRouteMultiParams.routeParams.$anonfun.$anonfun.s" title="String">s</a><span class="delimiter">)</span> else <a href="#org.scalatra;ApiFormats.withRouteMultiParams.routeParams.$anonfun.$anonfun.s" title="String">s</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    if <span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.withRouteMultiParams.routeParams" title="Map[String,Seq[String]]">routeParams</a>.<span title="(key: String)Boolean">contains</span><span class="delimiter">(</span><span title="String(&quot;format&quot;)" class="string">&quot;format&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="servlet/ServletApiImplicits.scala.html#org.scalatra.servlet;ServletApiImplicits.enrichRequest" title="(key: String, value: Any)Unit">request</a><span class="delimiter">(</span><a href="#org.scalatra.ApiFormats.FormatKey" title="=&gt; String">FormatKey</a><span class="delimiter">)</span> = <a href="#org.scalatra;ApiFormats.withRouteMultiParams.routeParams" title="Map[String,Seq[String]]">routeParams</a>.<span title="(key: String)Seq[String]">apply</span><span class="delimiter">(</span><span title="String(&quot;format&quot;)" class="string">&quot;format&quot;</span><span class="delimiter">)</span>.<span title="=&gt; String">head</span>
    <a href="servlet/ServletApiImplicits.scala.html#org.scalatra.servlet;ServletApiImplicits.enrichRequest" title="(key: String, value: Any)Unit">request</a><span class="delimiter">(</span><a href="package.scala.html#org.scalatra.package.MultiParamsKey" title="=&gt; String">MultiParamsKey</a><span class="delimiter">)</span> = <a href="#org.scalatra;ApiFormats.withRouteMultiParams.originalParams" title="org.scalatra.MultiParams">originalParams</a> <span title="(xs: scala.collection.GenTraversableOnce[(String, Seq[String])])scala.collection.immutable.Map[String,Seq[String]]">++</span> <a href="#org.scalatra;ApiFormats.withRouteMultiParams.routeParams" title="Map[String,Seq[String]]">routeParams</a>
    try <span class="delimiter">{</span>
      <a href="#org.scalatra;ApiFormats.withRouteMultiParams.thunk" title="=&gt; S">thunk</a>
    <span class="delimiter">}</span> finally <span class="delimiter">{</span>
      <a href="servlet/ServletApiImplicits.scala.html#org.scalatra.servlet;ServletApiImplicits.enrichRequest" title="(key: String, value: Any)Unit">request</a><span class="delimiter">(</span><a href="package.scala.html#org.scalatra.package.MultiParamsKey" title="=&gt; String">MultiParamsKey</a><span class="delimiter">)</span> = <a href="#org.scalatra;ApiFormats.withRouteMultiParams.originalParams" title="org.scalatra.MultiParams">originalParams</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  def <a title="(implicit request: javax.servlet.http.HttpServletRequest)String" id="org.scalatra;ApiFormats.requestFormat">requestFormat</a><span class="delimiter">(</span>implicit <a title="javax.servlet.http.HttpServletRequest" id="org.scalatra;ApiFormats.requestFormat.request">request</a>: <span title="javax.servlet.http.HttpServletRequest">HttpServletRequest</span><span class="delimiter">)</span>: <span title="String">String</span> =
    <a href="servlet/ServletApiImplicits.scala.html#org.scalatra.servlet;ServletApiImplicits.enrichRequest" title="implicit org.scalatra.servlet.ServletApiImplicits.enrichRequest : (request: javax.servlet.http.HttpServletRequest)org.scalatra.servlet.RichRequest">request</a>.<a href="servlet/RichRequest.scala.html#org.scalatra.servlet;RichRequest.contentType" title="=&gt; Option[String]">contentType</a> <span title="(f: String =&gt; Option[String])Option[String]">flatMap</span> <span class="delimiter">(</span> <a title="String" id="org.scalatra;ApiFormats.requestFormat.$anonfun.t">t</a> =&gt; <a href="#org.scalatra;ApiFormats.requestFormat.$anonfun.t" title="String">t</a>.<span title="(x$1: String)Array[String]">split</span><span title="(xs: Array[String])scala.collection.mutable.ArrayOps[String]" class="delimiter">(</span><span title="String(&quot;;&quot;)" class="string">&quot;;&quot;</span><span class="delimiter">)</span>.<span title="=&gt; Option[String]">headOption</span> <span title="(f: String =&gt; Option[String])Option[String]">flatMap</span> <a href="#org.scalatra;ApiFormats.mimeTypes" title="=&gt; scala.collection.concurrent.Map[String,String]">mimeTypes</a>.<a href="#org.scalatra;ApiFormats.requestFormat.$anonfun.$anonfun.key" title="(key: String)Option[String]">get</a><span class="delimiter">)</span> <span title="(default: =&gt; String)String">getOrElse</span> <a href="#org.scalatra;ApiFormats.format" title="(implicit request: javax.servlet.http.HttpServletRequest, implicit response: javax.servlet.http.HttpServletResponse)String">format</a>

  <span class="comment">/**
   * Returns the request-scoped format.  If not explicitly set, the format is:
   * $ - the `format` request parameter, if present in `formatParams`
   * $ - the first match from `Accept` header, looked up in `mimeTypes`
   * $ - the format from the `Content-Type` header, as looked up in `mimeTypes`
   * $ - the default format
   */</span>
  def <a title="(implicit request: javax.servlet.http.HttpServletRequest, implicit response: javax.servlet.http.HttpServletResponse)String" id="org.scalatra;ApiFormats.format">format</a><span class="delimiter">(</span>implicit <a title="javax.servlet.http.HttpServletRequest" id="org.scalatra;ApiFormats.format.request">request</a>: <span title="javax.servlet.http.HttpServletRequest">HttpServletRequest</span>, <a title="javax.servlet.http.HttpServletResponse" id="org.scalatra;ApiFormats.format.response">response</a>: <span title="javax.servlet.http.HttpServletResponse">HttpServletResponse</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    <a href="servlet/ServletApiImplicits.scala.html#org.scalatra.servlet;ServletApiImplicits.enrichRequest" title="implicit org.scalatra.servlet.ServletApiImplicits.enrichRequest : (request: javax.servlet.http.HttpServletRequest)org.scalatra.servlet.RichRequest">request</a>.<a href="servlet/AttributesMap.scala.html#org.scalatra.servlet;AttributesMap.get(adc3586498)" title="(key: String)Option[Any]">get</a><span class="delimiter">(</span><a href="#org.scalatra.ApiFormats.FormatKey" title="=&gt; String">FormatKey</a><span class="delimiter">)</span>.<span title="(ifEmpty: =&gt; String)(f: Any =&gt; String)String">fold</span><span class="delimiter">(</span><span class="delimiter">{</span>
      val <a title="String" id="org.scalatra;ApiFormats.format.fmt">fmt</a> = <a href="#org.scalatra;ApiFormats.getFormat" title="(implicit request: javax.servlet.http.HttpServletRequest, implicit response: javax.servlet.http.HttpServletResponse)String">getFormat</a>
      <a href="servlet/ServletApiImplicits.scala.html#org.scalatra.servlet;ServletApiImplicits.enrichRequest" title="(key: String, value: Any)Unit">request</a><span class="delimiter">(</span><a href="#org.scalatra.ApiFormats.FormatKey" title="=&gt; String">FormatKey</a><span class="delimiter">)</span> = <a href="#org.scalatra;ApiFormats.format.fmt" title="String">fmt</a>
      <a href="#org.scalatra;ApiFormats.format.fmt" title="String">fmt</a>
    <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#org.scalatra;ApiFormats.format.$anonfun.x$11" title="Any">_</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="String" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>


<span class="delimiter">}</span>

        </pre>
    </body>
</html>
