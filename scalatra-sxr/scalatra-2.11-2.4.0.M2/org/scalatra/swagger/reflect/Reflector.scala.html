<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>org/scalatra/swagger/reflect/Reflector.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package org.scalatra.swagger.reflect

import java.<span class="delimiter">{</span>util =&gt; jutil<span class="delimiter">}</span>
import java.lang.reflect._
import scala.util.control.<span title="scala.util.control.Exception.type">Exception</span>._
import java.util.Date
import java.sql.Timestamp
import collection.mutable.ArrayBuffer

object <a title="org.scalatra.swagger.reflect.Reflector.type" id="org.scalatra.swagger.reflect.Reflector">Reflector</a> <a href="#org.scalatra.swagger.reflect.Reflector" title="org.scalatra.swagger.reflect.Reflector.type" class="delimiter">{</a>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> val <a title="org.scalatra.swagger.reflect.Memo[java.lang.reflect.Type,Class[_]]" id="org.scalatra.swagger.reflect.Reflector.rawClasses">rawClasses</a> = new <a href="package.scala.html#org.scalatra.swagger.reflect.package;Memo" title="org.scalatra.swagger.reflect.Memo[java.lang.reflect.Type,Class[_]]">Memo</a><span class="delimiter">[</span>Type, Class<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>
  private<span class="delimiter">[</span>this<span class="delimiter">]</span> val <a title="org.scalatra.swagger.reflect.Memo[String,String]" id="org.scalatra.swagger.reflect.Reflector.unmangledNames">unmangledNames</a> = new <a href="package.scala.html#org.scalatra.swagger.reflect.package;Memo" title="org.scalatra.swagger.reflect.Memo[String,String]">Memo</a><span class="delimiter">[</span>String, String<span class="delimiter">]</span>
  private<span class="delimiter">[</span>this<span class="delimiter">]</span> val <a title="org.scalatra.swagger.reflect.Memo[org.scalatra.swagger.reflect.ScalaType,org.scalatra.swagger.reflect.ObjectDescriptor]" id="org.scalatra.swagger.reflect.Reflector.descriptors">descriptors</a> = new <a href="package.scala.html#org.scalatra.swagger.reflect.package;Memo" title="org.scalatra.swagger.reflect.Memo[org.scalatra.swagger.reflect.ScalaType,org.scalatra.swagger.reflect.ObjectDescriptor]">Memo</a><span class="delimiter">[</span>ScalaType, ObjectDescriptor<span class="delimiter">]</span>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> val <a title="scala.collection.immutable.Set[java.lang.reflect.Type]" id="org.scalatra.swagger.reflect.Reflector.primitives">primitives</a> = <span class="delimiter">{</span>
      <span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: java.lang.reflect.Type*)scala.collection.immutable.Set[java.lang.reflect.Type]" class="delimiter">[</span><span title="java.lang.reflect.Type">Type</span><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>String<span class="delimiter">]</span>, classOf<span title="Class[Char](classOf[scala.Char])" class="delimiter">[</span>Char<span class="delimiter">]</span>, classOf<span title="Class[Int](classOf[scala.Int])" class="delimiter">[</span>Int<span class="delimiter">]</span>, classOf<span title="Class[Long](classOf[scala.Long])" class="delimiter">[</span>Long<span class="delimiter">]</span>, classOf<span title="Class[Double](classOf[scala.Double])" class="delimiter">[</span>Double<span class="delimiter">]</span>,
        classOf<span title="Class[Float](classOf[scala.Float])" class="delimiter">[</span>Float<span class="delimiter">]</span>, classOf<span title="Class[Byte](classOf[scala.Byte])" class="delimiter">[</span>Byte<span class="delimiter">]</span>, classOf<span title="Class[BigInt](classOf[scala.math.BigInt])" class="delimiter">[</span>BigInt<span class="delimiter">]</span>, classOf<span title="Class[Boolean](classOf[scala.Boolean])" class="delimiter">[</span>Boolean<span class="delimiter">]</span>,
        classOf<span title="Class[Short](classOf[scala.Short])" class="delimiter">[</span>Short<span class="delimiter">]</span>, classOf<span title="Class[Integer](classOf[java.lang.Integer])" class="delimiter">[</span>java.lang.Integer<span class="delimiter">]</span>, classOf<span title="Class[Long](classOf[java.lang.Long])" class="delimiter">[</span>java.lang.Long<span class="delimiter">]</span>,
        classOf<span title="Class[Double](classOf[java.lang.Double])" class="delimiter">[</span>java.lang.Double<span class="delimiter">]</span>, classOf<span title="Class[Float](classOf[java.lang.Float])" class="delimiter">[</span>java.lang.Float<span class="delimiter">]</span>, classOf<span title="Class[Character](classOf[java.lang.Character])" class="delimiter">[</span>java.lang.Character<span class="delimiter">]</span>,
        classOf<span title="Class[Byte](classOf[java.lang.Byte])" class="delimiter">[</span>java.lang.Byte<span class="delimiter">]</span>, classOf<span title="Class[Boolean](classOf[java.lang.Boolean])" class="delimiter">[</span>java.lang.Boolean<span class="delimiter">]</span>, classOf<span title="Class[Number](classOf[java.lang.Number])" class="delimiter">[</span>Number<span class="delimiter">]</span>,
        classOf<span title="Class[Short](classOf[java.lang.Short])" class="delimiter">[</span>java.lang.Short<span class="delimiter">]</span>, classOf<span title="Class[java.util.Date](classOf[java.util.Date])" class="delimiter">[</span>Date<span class="delimiter">]</span>, classOf<span title="Class[java.sql.Timestamp](classOf[java.sql.Timestamp])" class="delimiter">[</span>Timestamp<span class="delimiter">]</span>, classOf<span title="Class[Symbol](classOf[scala.Symbol])" class="delimiter">[</span>Symbol<span class="delimiter">]</span>, classOf<span title="Class[Unit](classOf[scala.Unit])" class="delimiter">[</span>Unit<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> val <a title="scala.collection.immutable.Set[Class[_ &lt;: Null]]" id="org.scalatra.swagger.reflect.Reflector.defaultExcluded">defaultExcluded</a> = <span title="(elems: Class[_ &lt;: Null]*)scala.collection.immutable.Set[Class[_ &lt;: Null]]">Set</span><span class="delimiter">(</span>classOf<span title="Class[Nothing](classOf[scala.Nothing])" class="delimiter">[</span>Nothing<span class="delimiter">]</span>, classOf<span title="Class[Null](classOf[scala.Null])" class="delimiter">[</span>Null<span class="delimiter">]</span><span class="delimiter">)</span>

  def <a title="(t: java.lang.reflect.Type)Boolean" id="org.scalatra.swagger.reflect.Reflector.isPrimitive">isPrimitive</a><span class="delimiter">(</span><a title="java.lang.reflect.Type" id="org.scalatra.swagger.reflect.Reflector.isPrimitive.t">t</a>: <span title="java.lang.reflect.Type">Type</span><span class="delimiter">)</span> = <a href="#org.scalatra.swagger.reflect.Reflector.primitives" title="scala.collection.immutable.Set[java.lang.reflect.Type]">primitives</a> <span title="(elem: java.lang.reflect.Type)Boolean">contains</span> <a href="#org.scalatra.swagger.reflect.Reflector.isPrimitive.t" title="java.lang.reflect.Type">t</a>

  def <a title="(t: java.lang.reflect.Type, excludes: Seq[java.lang.reflect.Type])Boolean" id="org.scalatra.swagger.reflect.Reflector.isExcluded">isExcluded</a><span class="delimiter">(</span><a title="java.lang.reflect.Type" id="org.scalatra.swagger.reflect.Reflector.isExcluded.t">t</a>: <span title="java.lang.reflect.Type">Type</span>, <a title="Seq[java.lang.reflect.Type]" id="org.scalatra.swagger.reflect.Reflector.isExcluded$default$2">excludes</a>: <span title="Seq[java.lang.reflect.Type]">Seq</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.defaultExcluded" title="scala.collection.immutable.Set[Class[_ &lt;: Null]]">defaultExcluded</a> <span title="(that: scala.collection.GenTraversableOnce[java.lang.reflect.Type])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[Class[_ &lt;: Null]],java.lang.reflect.Type,scala.collection.immutable.Set[java.lang.reflect.Type]])scala.collection.immutable.Set[java.lang.reflect.Type]">++</span> <a href="#org.scalatra.swagger.reflect.Reflector.isExcluded$default$2" title="Seq[java.lang.reflect.Type]">excludes</a><span class="delimiter">)</span> <span title="(elem: java.lang.reflect.Type)Boolean">contains</span> <a href="#org.scalatra.swagger.reflect.Reflector.isExcluded.t" title="java.lang.reflect.Type">t</a>

  def <a title="[T](implicit mf: Manifest[T])org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.Reflector.scalaTypeOf(dc1d6d5194)">scalaTypeOf</a><span class="delimiter">[</span><a title="" id="org.scalatra.swagger.reflect.Reflector.scalaTypeOf(dc1d6d5194);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="Manifest[T]" id="org.scalatra.swagger.reflect.Reflector.scalaTypeOf(dc1d6d5194).mf">mf</a>: <span title="Manifest[T]">Manifest</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = <a href="descriptors.scala.html#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c)" title="(mf: Manifest[T])org.scalatra.swagger.reflect.ScalaType">ManifestScalaType</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(dc1d6d5194).mf" title="Manifest[T]">mf</a><span class="delimiter">)</span>
  def <a title="(clazz: Class[_])org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.Reflector.scalaTypeOf(2a95cce7f8)">scalaTypeOf</a><span class="delimiter">(</span><a title="Class[_]" id="org.scalatra.swagger.reflect.Reflector.scalaTypeOf(2a95cce7f8).clazz">clazz</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = <a href="descriptors.scala.html#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c)" title="(mf: Manifest[_$1])org.scalatra.swagger.reflect.ScalaType">ManifestScalaType</a><span class="delimiter">(</span><a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory" title="org.scalatra.swagger.reflect.ManifestFactory.type">ManifestFactory</a>.<a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory.manifestOf(0ea6e85782)" title="(t: java.lang.reflect.Type)scala.reflect.Manifest[_]">manifestOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(2a95cce7f8).clazz" title="Class[_]">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
  def <a title="(t: java.lang.reflect.Type)org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.Reflector.scalaTypeOf(920132f9bf)">scalaTypeOf</a><span class="delimiter">(</span><a title="java.lang.reflect.Type" id="org.scalatra.swagger.reflect.Reflector.scalaTypeOf(920132f9bf).t">t</a>: <span title="java.lang.reflect.Type">Type</span><span class="delimiter">)</span>: <a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = <a href="descriptors.scala.html#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c)" title="(mf: Manifest[_$1])org.scalatra.swagger.reflect.ScalaType">ManifestScalaType</a><span class="delimiter">(</span><a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory" title="org.scalatra.swagger.reflect.ManifestFactory.type">ManifestFactory</a>.<a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory.manifestOf(0ea6e85782)" title="(t: java.lang.reflect.Type)scala.reflect.Manifest[_]">manifestOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(920132f9bf).t" title="java.lang.reflect.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> val <a title="org.scalatra.swagger.reflect.Memo[String,Option[org.scalatra.swagger.reflect.ScalaType]]" id="org.scalatra.swagger.reflect.Reflector.stringTypes">stringTypes</a> = new <a href="package.scala.html#org.scalatra.swagger.reflect.package;Memo" title="org.scalatra.swagger.reflect.Memo[String,Option[org.scalatra.swagger.reflect.ScalaType]]">Memo</a><span class="delimiter">[</span>String, Option<span class="delimiter">[</span>ScalaType<span class="delimiter">]</span><span class="delimiter">]</span>
  def <a title="(name: String)Option[org.scalatra.swagger.reflect.ScalaType]" id="org.scalatra.swagger.reflect.Reflector.scalaTypeOf(57506199de)">scalaTypeOf</a><span class="delimiter">(</span><a title="String" id="org.scalatra.swagger.reflect.Reflector.scalaTypeOf(57506199de).name">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Option[org.scalatra.swagger.reflect.ScalaType]">Option</span><span class="delimiter">[</span>ScalaType<span class="delimiter">]</span> =
    <a href="package.scala.html#org.scalatra.swagger.reflect.package;Memo.apply" title="(x: String, f: String =&gt; Option[org.scalatra.swagger.reflect.ScalaType])Option[org.scalatra.swagger.reflect.ScalaType]">stringTypes</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(57506199de).name" title="String">name</a>, <a href="#org.scalatra.swagger.reflect.Reflector.resolveClass" title="[X &lt;: AnyRef](c: String, classLoaders: Iterable[ClassLoader])Option[Class[X]]">resolveClass</a><span title="(c: String, classLoaders: Iterable[ClassLoader])Option[Class[AnyRef]]" class="delimiter">[</span><span title="AnyRef">AnyRef</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(57506199de).$anonfun.x$1" title="String">_</a>, <a href="package.scala.html#org.scalatra.swagger.reflect.package.ClassLoaders" title="=&gt; scala.collection.immutable.Vector[ClassLoader]">ClassLoaders</a><span class="delimiter">)</span> <span title="(f: Class[AnyRef] =&gt; org.scalatra.swagger.reflect.ScalaType)Option[org.scalatra.swagger.reflect.ScalaType]">map</span> <span class="delimiter">(</span><a title="Class[AnyRef]" id="org.scalatra.swagger.reflect.Reflector.scalaTypeOf(57506199de).$anonfun.$anonfun.c">c</a> =&gt; <a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(2a95cce7f8)" title="(clazz: Class[_])org.scalatra.swagger.reflect.ScalaType">scalaTypeOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(57506199de).$anonfun.$anonfun.c" title="Class[AnyRef]">c</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="[T](implicit mf: Manifest[T])org.scalatra.swagger.reflect.ObjectDescriptor" id="org.scalatra.swagger.reflect.Reflector.describe(75515ee8c9)">describe</a><span class="delimiter">[</span><a title="" id="org.scalatra.swagger.reflect.Reflector.describe(75515ee8c9);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="Manifest[T]" id="org.scalatra.swagger.reflect.Reflector.describe(75515ee8c9).mf">mf</a>: <span title="Manifest[T]">Manifest</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="descriptors.scala.html#org.scalatra.swagger.reflect;ObjectDescriptor" title="org.scalatra.swagger.reflect.ObjectDescriptor">ObjectDescriptor</a> = <a href="#org.scalatra.swagger.reflect.Reflector.describe(bfc50c08d5)" title="(st: org.scalatra.swagger.reflect.ScalaType, paranamer: org.scalatra.swagger.reflect.ParameterNameReader)org.scalatra.swagger.reflect.ObjectDescriptor">describe</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(dc1d6d5194)" title="[T](implicit mf: Manifest[T])org.scalatra.swagger.reflect.ScalaType">scalaTypeOf</a><a href="#org.scalatra.swagger.reflect.Reflector.describe(75515ee8c9).mf" title="(implicit mf: Manifest[T])org.scalatra.swagger.reflect.ScalaType" class="delimiter">[</a><a href="#org.scalatra.swagger.reflect.Reflector.describe(75515ee8c9);T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">)</span>
  def <a title="(clazz: Class[_])org.scalatra.swagger.reflect.ObjectDescriptor" id="org.scalatra.swagger.reflect.Reflector.describe(2867d624c0)">describe</a><span class="delimiter">(</span><a title="Class[_]" id="org.scalatra.swagger.reflect.Reflector.describe(2867d624c0).clazz">clazz</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="descriptors.scala.html#org.scalatra.swagger.reflect;ObjectDescriptor" title="org.scalatra.swagger.reflect.ObjectDescriptor">ObjectDescriptor</a> = <a href="#org.scalatra.swagger.reflect.Reflector.describe(bfc50c08d5)" title="(st: org.scalatra.swagger.reflect.ScalaType, paranamer: org.scalatra.swagger.reflect.ParameterNameReader)org.scalatra.swagger.reflect.ObjectDescriptor">describe</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(2a95cce7f8)" title="(clazz: Class[_])org.scalatra.swagger.reflect.ScalaType">scalaTypeOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.describe(2867d624c0).clazz" title="Class[_]">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
  def <a title="(fqn: String)Option[org.scalatra.swagger.reflect.ObjectDescriptor]" id="org.scalatra.swagger.reflect.Reflector.describe(78942e2f7a)">describe</a><span class="delimiter">(</span><a title="String" id="org.scalatra.swagger.reflect.Reflector.describe(78942e2f7a).fqn">fqn</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Option[org.scalatra.swagger.reflect.ObjectDescriptor]">Option</span><span class="delimiter">[</span>ObjectDescriptor<span class="delimiter">]</span> =
    <a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(57506199de)" title="(name: String)Option[org.scalatra.swagger.reflect.ScalaType]">scalaTypeOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.describe(78942e2f7a).fqn" title="String">fqn</a><span class="delimiter">)</span> <span title="(f: org.scalatra.swagger.reflect.ScalaType =&gt; org.scalatra.swagger.reflect.ObjectDescriptor)Option[org.scalatra.swagger.reflect.ObjectDescriptor]">map</span> <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.describe(bfc50c08d5)" title="(st: org.scalatra.swagger.reflect.ScalaType, paranamer: org.scalatra.swagger.reflect.ParameterNameReader)org.scalatra.swagger.reflect.ObjectDescriptor">describe</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.describe(78942e2f7a).$anonfun.x$2" title="org.scalatra.swagger.reflect.ScalaType">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
  def <a title="(st: org.scalatra.swagger.reflect.ScalaType, paranamer: org.scalatra.swagger.reflect.ParameterNameReader)org.scalatra.swagger.reflect.ObjectDescriptor" id="org.scalatra.swagger.reflect.Reflector.describe(bfc50c08d5)">describe</a><span class="delimiter">(</span><a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.Reflector.describe(bfc50c08d5).st">st</a>: <a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a>, <a title="org.scalatra.swagger.reflect.ParameterNameReader" id="org.scalatra.swagger.reflect.Reflector.describe$default$2">paranamer</a>: <a href="package.scala.html#org.scalatra.swagger.reflect.package;ParameterNameReader" title="org.scalatra.swagger.reflect.ParameterNameReader">ParameterNameReader</a> = <a href="package.scala.html#org.scalatra.swagger.reflect.package.ParanamerReader" title="org.scalatra.swagger.reflect.ParanamerReader.type">ParanamerReader</a><span class="delimiter">)</span>: <a href="descriptors.scala.html#org.scalatra.swagger.reflect;ObjectDescriptor" title="org.scalatra.swagger.reflect.ObjectDescriptor">ObjectDescriptor</a> =
    <a href="package.scala.html#org.scalatra.swagger.reflect.package;Memo.apply" title="(x: org.scalatra.swagger.reflect.ScalaType, f: org.scalatra.swagger.reflect.ScalaType =&gt; org.scalatra.swagger.reflect.ObjectDescriptor)org.scalatra.swagger.reflect.ObjectDescriptor">descriptors</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.describe(bfc50c08d5).st" title="org.scalatra.swagger.reflect.ScalaType">st</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor" title="(tpe: org.scalatra.swagger.reflect.ScalaType, paramNameReader: org.scalatra.swagger.reflect.ParameterNameReader)org.scalatra.swagger.reflect.ObjectDescriptor">createDescriptor</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.describe(bfc50c08d5).$anonfun.x$3" title="org.scalatra.swagger.reflect.ScalaType">_</a>, <a href="#org.scalatra.swagger.reflect.Reflector.describe$default$2" title="org.scalatra.swagger.reflect.ParameterNameReader">paranamer</a><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="[X &lt;: AnyRef](c: String, classLoaders: Iterable[ClassLoader])Option[Class[X]]" id="org.scalatra.swagger.reflect.Reflector.resolveClass">resolveClass</a><span class="delimiter">[</span><a title=" &lt;: AnyRef" id="org.scalatra.swagger.reflect.Reflector.resolveClass;X">X</a> &lt;: AnyRef<span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="org.scalatra.swagger.reflect.Reflector.resolveClass.c">c</a>: <span title="String">String</span>, <a title="Iterable[ClassLoader]" id="org.scalatra.swagger.reflect.Reflector.resolveClass.classLoaders">classLoaders</a>: <span title="Iterable[ClassLoader]">Iterable</span><span class="delimiter">[</span>ClassLoader<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[Class[X]]">Option</span><span class="delimiter">[</span>Class<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#org.scalatra.swagger.reflect.Reflector.resolveClass.classLoaders" title="Iterable[ClassLoader]">classLoaders</a> match <span class="delimiter">{</span>
    case <span title="scala.collection.immutable.Nil.type">Nil</span> =&gt; sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;resolveClass: expected 1+ classloaders but received empty list&quot;)" class="string">&quot;resolveClass: expected 1+ classloaders but received empty list&quot;</span><span class="delimiter">)</span>
    case <a href="#org.scalatra.swagger.reflect.Reflector.resolveClass.<unapply-selector>" title="(x: List[A])Some[List[A]]">List</a><span class="delimiter">(</span><a title="ClassLoader" id="org.scalatra.swagger.reflect.Reflector.resolveClass.cl">cl</a><span class="delimiter">)</span> =&gt; <span title="(x: Class[X])Some[Class[X]]">Some</span><span class="delimiter">(</span><span title="Class.type">Class</span>.<span title="(x$1: String, x$2: Boolean, x$3: ClassLoader)Class[_]">forName</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.resolveClass.c" title="String">c</a>, true, <a href="#org.scalatra.swagger.reflect.Reflector.resolveClass.cl" title="ClassLoader">cl</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Class[X]" class="delimiter">[</span><span title="Class[X]">Class</span><span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
    case <a title="Iterable[ClassLoader]" id="org.scalatra.swagger.reflect.Reflector.resolveClass.many">many</a> =&gt; <span class="delimiter">{</span>
      try <span class="delimiter">{</span>
        var <a title="Class[_]" id="org.scalatra.swagger.reflect.Reflector.resolveClass.clazz">clazz</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span> = null
        val <a title="Iterator[ClassLoader]" id="org.scalatra.swagger.reflect.Reflector.resolveClass.iter">iter</a> = <a href="#org.scalatra.swagger.reflect.Reflector.resolveClass.many" title="Iterable[ClassLoader]">many</a>.<span title="=&gt; Iterator[ClassLoader]">iterator</span>
        while <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.resolveClass.clazz" title="Class[_]">clazz</a> <span title="(x$1: Any)Boolean">==</span> null <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#org.scalatra.swagger.reflect.Reflector.resolveClass.iter" title="Iterator[ClassLoader]">iter</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          try <span class="delimiter">{</span>
            <a href="#org.scalatra.swagger.reflect.Reflector.resolveClass.clazz" title="Class[_]">clazz</a> = <span title="Class.type">Class</span>.<span title="(x$1: String, x$2: Boolean, x$3: ClassLoader)Class[_]">forName</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.resolveClass.c" title="String">c</a>, true, <a href="#org.scalatra.swagger.reflect.Reflector.resolveClass.iter" title="Iterator[ClassLoader]">iter</a>.<span title="()ClassLoader">next</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          catch <span class="delimiter">{</span>
            case <a title="ClassNotFoundException" id="org.scalatra.swagger.reflect.Reflector.resolveClass.e">e</a>: <span title="ClassNotFoundException">ClassNotFoundException</span> =&gt; <span class="comment">// keep going, maybe it's in the next one</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.resolveClass.clazz" title="Class[_]">clazz</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <span title="(x: Class[X])Some[Class[X]]">Some</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.resolveClass.clazz" title="Class[_]">clazz</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Class[X]" class="delimiter">[</span><span title="Class[X]">Class</span><span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> else <span title="None.type">None</span>
      <span class="delimiter">}</span>
      catch <span class="delimiter">{</span>
        case _: <span title="Throwable">Throwable</span> =&gt; <span title="None.type">None</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  private<span class="delimiter">[</span>reflect<span class="delimiter">]</span> def <a title="(tpe: org.scalatra.swagger.reflect.ScalaType, paramNameReader: org.scalatra.swagger.reflect.ParameterNameReader)org.scalatra.swagger.reflect.ObjectDescriptor" id="org.scalatra.swagger.reflect.Reflector.createDescriptor">createDescriptor</a><span class="delimiter">(</span><a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.tpe">tpe</a>: <a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a>, <a title="org.scalatra.swagger.reflect.ParameterNameReader" id="org.scalatra.swagger.reflect.Reflector.createDescriptor$default$2">paramNameReader</a>: <a href="package.scala.html#org.scalatra.swagger.reflect.package;ParameterNameReader" title="org.scalatra.swagger.reflect.ParameterNameReader">ParameterNameReader</a> = <a href="package.scala.html#org.scalatra.swagger.reflect.package.ParanamerReader" title="org.scalatra.swagger.reflect.ParanamerReader.type">ParanamerReader</a><span class="delimiter">)</span>: <a href="descriptors.scala.html#org.scalatra.swagger.reflect;ObjectDescriptor" title="org.scalatra.swagger.reflect.ObjectDescriptor">ObjectDescriptor</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.tpe" title="org.scalatra.swagger.reflect.ScalaType">tpe</a>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType.isPrimitive" title="=&gt; Boolean">isPrimitive</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="descriptors.scala.html#org.scalatra.swagger.reflect;PrimitiveDescriptor" title="(simpleName: String, fullName: String, erasure: org.scalatra.swagger.reflect.ScalaType)org.scalatra.swagger.reflect.PrimitiveDescriptor">PrimitiveDescriptor</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.tpe" title="org.scalatra.swagger.reflect.ScalaType">tpe</a>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType.simpleName" title="=&gt; String">simpleName</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.tpe" title="org.scalatra.swagger.reflect.ScalaType">tpe</a>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType.fullName" title="=&gt; String">fullName</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.tpe" title="org.scalatra.swagger.reflect.ScalaType">tpe</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>

      val <a title="String" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.path">path</a> = if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.tpe" title="org.scalatra.swagger.reflect.ScalaType">tpe</a>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType.rawFullName" title="=&gt; String">rawFullName</a>.<span title="(x$1: String)Boolean">endsWith</span><span class="delimiter">(</span><span title="String(&quot;$&quot;)" class="string">&quot;$&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.tpe" title="org.scalatra.swagger.reflect.ScalaType">tpe</a>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType.rawFullName" title="=&gt; String">rawFullName</a> else <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%s$&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.tpe" title="org.scalatra.swagger.reflect.ScalaType">tpe</a>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType.rawFullName" title="=&gt; String">rawFullName</a><span class="delimiter">)</span>
      val <a title="Option[Class[Nothing]]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.c">c</a> = <a href="#org.scalatra.swagger.reflect.Reflector.resolveClass" title="(c: String, classLoaders: Iterable[ClassLoader])Option[Class[Nothing]]">resolveClass</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.path" title="String">path</a>, <span title="(elems: ClassLoader*)scala.collection.immutable.Vector[ClassLoader]">Vector</span><span class="delimiter">(</span><span title="()Class[_]">getClass</span>.<span title="()ClassLoader">getClassLoader</span><span class="delimiter">)</span><span class="delimiter">)</span>
      val companion = <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.c" title="Option[Class[Nothing]]">c</a> <a title="Option[org.scalatra.swagger.reflect.SingletonDescriptor]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.companion">flatMap</a> <span class="delimiter">{</span> <a title="Class[Nothing]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.companion.$anonfun.cl">cl</a> =&gt;
          <span title="util.control.Exception.Catch[Nothing]">allCatch</span> <span title="(body: =&gt; org.scalatra.swagger.reflect.SingletonDescriptor)Option[org.scalatra.swagger.reflect.SingletonDescriptor]">opt</span> <span class="delimiter">{</span>
            <a href="descriptors.scala.html#org.scalatra.swagger.reflect;SingletonDescriptor" title="(simpleName: String, fullName: String, erasure: org.scalatra.swagger.reflect.ScalaType, instance: AnyRef, properties: Seq[org.scalatra.swagger.reflect.PropertyDescriptor])org.scalatra.swagger.reflect.SingletonDescriptor">SingletonDescriptor</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.companion.$anonfun.cl" title="Class[Nothing]">cl</a>.<span title="()String">getSimpleName</span>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.companion.$anonfun.cl" title="Class[Nothing]">cl</a>.<span title="()String">getName</span>, <a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(2a95cce7f8)" title="(clazz: Class[_])org.scalatra.swagger.reflect.ScalaType">scalaTypeOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.companion.$anonfun.cl" title="Class[Nothing]">cl</a><span class="delimiter">)</span>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.companion.$anonfun.cl" title="Class[Nothing]">cl</a>.<span title="(x$1: String)java.lang.reflect.Field">getField</span><span class="delimiter">(</span><a href="package.scala.html#org.scalatra.swagger.reflect.package.ModuleFieldName" title="=&gt; String">ModuleFieldName</a><span class="delimiter">)</span>.<span title="(x$1: Any)Object">get</span><span class="delimiter">(</span>null<span class="delimiter">)</span>, <span title="scala.collection.Seq.type">Seq</span>.<span title="Seq[Nothing]">empty</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      def <a title="=&gt; Seq[org.scalatra.swagger.reflect.PropertyDescriptor]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.properties">properties</a>: <span title="Seq[org.scalatra.swagger.reflect.PropertyDescriptor]">Seq</span><span class="delimiter">[</span>PropertyDescriptor<span class="delimiter">]</span> = <span class="delimiter">{</span>
        def <a title="(clazz: Class[_])List[org.scalatra.swagger.reflect.PropertyDescriptor]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields">fields</a><span class="delimiter">(</span><a title="Class[_]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.clazz">clazz</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[org.scalatra.swagger.reflect.PropertyDescriptor]">List</span><span class="delimiter">[</span>PropertyDescriptor<span class="delimiter">]</span> = <span class="delimiter">{</span>
          val <a title="scala.collection.mutable.ArrayBuffer[org.scalatra.swagger.reflect.PropertyDescriptor]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.lb">lb</a> = new <span title="scala.collection.mutable.ArrayBuffer[org.scalatra.swagger.reflect.PropertyDescriptor]">ArrayBuffer</span><span class="delimiter">[</span>PropertyDescriptor<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
          val <a title="Iterator[java.lang.reflect.Field]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.ls">ls</a> = <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.clazz" title="Class[_]">clazz</a>.<span title="(xs: Array[java.lang.reflect.Field])scala.collection.mutable.ArrayOps[java.lang.reflect.Field]">getDeclaredFields</span>.<span title="=&gt; Iterator[java.lang.reflect.Field]">toIterator</span>
          while <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.ls" title="Iterator[java.lang.reflect.Field]">ls</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.while$2" title="()Unit" class="delimiter">{</a>
            val <a title="java.lang.reflect.Field" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.f">f</a> = <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.ls" title="Iterator[java.lang.reflect.Field]">ls</a>.<span title="()java.lang.reflect.Field">next</span><span class="delimiter">(</span><span class="delimiter">)</span>
            val <a title="Int" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.mod">mod</a> = <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.f" title="java.lang.reflect.Field">f</a>.<span title="()Int">getModifiers</span>
            if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><span title="java.lang.reflect.Modifier.type">Modifier</span>.<span title="(x$1: Int)Boolean">isStatic</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.mod" title="Int">mod</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="java.lang.reflect.Modifier.type">Modifier</span>.<span title="(x$1: Int)Boolean">isTransient</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.mod" title="Int">mod</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="java.lang.reflect.Modifier.type">Modifier</span>.<span title="(x$1: Int)Boolean">isVolatile</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.mod" title="Int">mod</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.f" title="java.lang.reflect.Field">f</a>.<span title="()Boolean">isSynthetic</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.st">st</a> = <a href="descriptors.scala.html#org.scalatra.swagger.reflect.ManifestScalaType.apply(8ae5cd933c)" title="(erasure: Class[_], typeArgs: Seq[org.scalatra.swagger.reflect.ScalaType])org.scalatra.swagger.reflect.ScalaType">ManifestScalaType</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.f" title="java.lang.reflect.Field">f</a>.<span title="()Class[_]">getType</span>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.f" title="java.lang.reflect.Field">f</a>.<span title="()java.lang.reflect.Type">getGenericType</span> match <span class="delimiter">{</span>
                case <a title="java.lang.reflect.ParameterizedType" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.st.p">p</a>: <span title="java.lang.reflect.ParameterizedType">ParameterizedType</span> =&gt; <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.st.p" title="java.lang.reflect.ParameterizedType">p</a>.<span title="(xs: Array[java.lang.reflect.Type])scala.collection.mutable.ArrayOps[java.lang.reflect.Type]">getActualTypeArguments</span>.<span title="=&gt; Seq[java.lang.reflect.Type]">toSeq</span>.<span title="(implicit bf: scala.collection.generic.CanBuildFrom[Seq[java.lang.reflect.Type],(java.lang.reflect.Type, Int),Seq[(java.lang.reflect.Type, Int)]])Seq[(java.lang.reflect.Type, Int)]">zipWithIndex</span> <span title="(f: ((java.lang.reflect.Type, Int)) =&gt; org.scalatra.swagger.reflect.ScalaType)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(java.lang.reflect.Type, Int)],org.scalatra.swagger.reflect.ScalaType,Seq[org.scalatra.swagger.reflect.ScalaType]])Seq[org.scalatra.swagger.reflect.ScalaType]">map</span> <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.st.$anonfun.x0$1" title="org.scalatra.swagger.reflect.ScalaType" class="delimiter">{</a> case <span class="delimiter">(</span><a title="java.lang.reflect.Type" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.st.$anonfun.cc">cc</a>, <a title="Int" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.st.$anonfun.i">i</a><span class="delimiter">)</span> =&gt;
                  if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.st.$anonfun.cc" title="java.lang.reflect.Type">cc</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Object](classOf[java.lang.Object])" class="delimiter">[</span>java.lang.Object<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.Reflector" title="org.scalatra.swagger.reflect.Reflector.type">Reflector</a>.<a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(2a95cce7f8)" title="(clazz: Class[_])org.scalatra.swagger.reflect.ScalaType">scalaTypeOf</a><span class="delimiter">(</span><a href="ScalaSigReader.scala.html#org.scalatra.swagger.reflect.ScalaSigReader" title="org.scalatra.swagger.reflect.ScalaSigReader.type">ScalaSigReader</a>.<a href="ScalaSigReader.scala.html#org.scalatra.swagger.reflect.ScalaSigReader.readField" title="(name: String, clazz: Class[_], typeArgIndex: Int)Class[_]">readField</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.f" title="java.lang.reflect.Field">f</a>.<span title="()String">getName</span>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.clazz" title="Class[_]">clazz</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.st.$anonfun.i" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  else <a href="#org.scalatra.swagger.reflect.Reflector" title="org.scalatra.swagger.reflect.Reflector.type">Reflector</a>.<a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(920132f9bf)" title="(t: java.lang.reflect.Type)org.scalatra.swagger.reflect.ScalaType">scalaTypeOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.st.$anonfun.cc" title="java.lang.reflect.Type">cc</a><span class="delimiter">)</span>
                <span class="delimiter">}</span>
                case _ =&gt; <span title="scala.collection.immutable.Nil.type">Nil</span>
              <span class="delimiter">}</span><span class="delimiter">)</span>
              val <a title="String" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.decoded">decoded</a> = <a href="#org.scalatra.swagger.reflect.Reflector.unmangleName" title="(name: String)String">unmangleName</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.f" title="java.lang.reflect.Field">f</a>.<span title="()String">getName</span><span class="delimiter">)</span>
              <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.f" title="java.lang.reflect.Field">f</a>.<span title="(x$1: Boolean)Unit">setAccessible</span><span class="delimiter">(</span>true<span class="delimiter">)</span>
              <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.lb" title="scala.collection.mutable.ArrayBuffer[org.scalatra.swagger.reflect.PropertyDescriptor]">lb</a> <span title="(elem: org.scalatra.swagger.reflect.PropertyDescriptor)lb.type">+=</span> <a href="descriptors.scala.html#org.scalatra.swagger.reflect;PropertyDescriptor" title="(name: String, mangledName: String, returnType: org.scalatra.swagger.reflect.ScalaType, field: java.lang.reflect.Field)org.scalatra.swagger.reflect.PropertyDescriptor">PropertyDescriptor</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.decoded" title="String">decoded</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.f" title="java.lang.reflect.Field">f</a>.<span title="()String">getName</span>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.st" title="org.scalatra.swagger.reflect.ScalaType">st</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.f" title="java.lang.reflect.Field">f</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.clazz" title="Class[_]">clazz</a>.<span title="()Class[_ &gt;: _$5]">getSuperclass</span> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.lb" title="scala.collection.mutable.ArrayBuffer[org.scalatra.swagger.reflect.PropertyDescriptor]">lb</a> <span title="(xs: scala.collection.TraversableOnce[org.scalatra.swagger.reflect.PropertyDescriptor])lb.type">++=</span> <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields" title="(clazz: Class[_])List[org.scalatra.swagger.reflect.PropertyDescriptor]">fields</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.clazz" title="Class[_]">clazz</a>.<span title="()Class[_ &gt;: _$5]">getSuperclass</span><span class="delimiter">)</span>
          <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields.lb" title="scala.collection.mutable.ArrayBuffer[org.scalatra.swagger.reflect.PropertyDescriptor]">lb</a>.<span title="=&gt; List[org.scalatra.swagger.reflect.PropertyDescriptor]">toList</span>
        <span class="delimiter">}</span>
        <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties.fields" title="(clazz: Class[_])List[org.scalatra.swagger.reflect.PropertyDescriptor]">fields</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.tpe" title="org.scalatra.swagger.reflect.ScalaType">tpe</a>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType.erasure" title="=&gt; Class[_]">erasure</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      def <a title="(name: String, index: Int, owner: org.scalatra.swagger.reflect.ScalaType, ctorParameterNames: List[String], t: java.lang.reflect.Type, container: Option[(org.scalatra.swagger.reflect.ScalaType, List[Int])])org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType">ctorParamType</a><span class="delimiter">(</span><a title="String" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.name">name</a>: <span title="String">String</span>, <a title="Int" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.index">index</a>: <span title="Int">Int</span>, <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.owner">owner</a>: <a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a>, <a title="List[String]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.ctorParameterNames">ctorParameterNames</a>: <span title="List[String]">List</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="java.lang.reflect.Type" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.t">t</a>: <span title="java.lang.reflect.Type">Type</span>, <a title="Option[(org.scalatra.swagger.reflect.ScalaType, List[Int])]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType$default$6">container</a>: <span title="Option[(org.scalatra.swagger.reflect.ScalaType, List[Int])]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>ScalaType, List<span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <span title="None.type">None</span><span class="delimiter">)</span>: <a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = <span class="delimiter">{</span>
        val <a title="Option[List[Int]]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.idxes">idxes</a> = <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType$default$6" title="Option[(org.scalatra.swagger.reflect.ScalaType, List[Int])]">container</a>.<span title="(f: ((org.scalatra.swagger.reflect.ScalaType, List[Int])) =&gt; List[Int])Option[List[Int]]">map</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.idxes.$anonfun.x$4" title="(org.scalatra.swagger.reflect.ScalaType, List[Int])">_</a>.<span title="=&gt; List[Int]">_2</span>.<span title="=&gt; List[Int]">reverse</span><span class="delimiter">)</span>
        <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.t" title="java.lang.reflect.Type">t</a>  match <span class="delimiter">{</span>
          case <span title="java.lang.reflect.TypeVariable[_]">v</span>: <span title="java.lang.reflect.TypeVariable[_]">TypeVariable</span><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt;
            val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.a">a</a> = <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.owner" title="org.scalatra.swagger.reflect.ScalaType">owner</a>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType.typeVars" title="=&gt; Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">typeVars</a>.<span title="(key: java.lang.reflect.TypeVariable[_], default: =&gt; org.scalatra.swagger.reflect.ScalaType)org.scalatra.swagger.reflect.ScalaType">getOrElse</span><span class="delimiter">(</span><span title="java.lang.reflect.TypeVariable[_]">v</span>, <a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(920132f9bf)" title="(t: java.lang.reflect.Type)org.scalatra.swagger.reflect.ScalaType">scalaTypeOf</a><span class="delimiter">(</span><span title="java.lang.reflect.TypeVariable[_]">v</span><span class="delimiter">)</span><span class="delimiter">)</span>
            if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.a" title="org.scalatra.swagger.reflect.ScalaType">a</a>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType.erasure" title="=&gt; Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Object](classOf[java.lang.Object])" class="delimiter">[</span>java.lang.Object<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              val <a title="Class[_]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.r">r</a> = <a href="ScalaSigReader.scala.html#org.scalatra.swagger.reflect.ScalaSigReader" title="org.scalatra.swagger.reflect.ScalaSigReader.type">ScalaSigReader</a>.<a href="ScalaSigReader.scala.html#org.scalatra.swagger.reflect.ScalaSigReader.readConstructor(ac85b6cd7d)" title="(argName: String, clazz: org.scalatra.swagger.reflect.ScalaType, typeArgIndex: Int, argNames: List[String])Class[_]">readConstructor</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.name" title="String">name</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.owner" title="org.scalatra.swagger.reflect.ScalaType">owner</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.index" title="Int">index</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.ctorParameterNames" title="List[String]">ctorParameterNames</a><span class="delimiter">)</span>
              <a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(2a95cce7f8)" title="(clazz: Class[_])org.scalatra.swagger.reflect.ScalaType">scalaTypeOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.r" title="Class[_]">r</a><span class="delimiter">)</span>
            <span class="delimiter">}</span> else <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.a" title="org.scalatra.swagger.reflect.ScalaType">a</a>
          case <span title="java.lang.reflect.ParameterizedType">v</span>: <span title="java.lang.reflect.ParameterizedType">ParameterizedType</span> =&gt;
            val <span title="org.scalatra.swagger.reflect.ScalaType">st</span> = <a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(920132f9bf)" title="(t: java.lang.reflect.Type)org.scalatra.swagger.reflect.ScalaType">scalaTypeOf</a><span class="delimiter">(</span><span title="java.lang.reflect.ParameterizedType">v</span><span class="delimiter">)</span>
            val actualArgs = <span title="java.lang.reflect.ParameterizedType">v</span>.<span title="(xs: Array[java.lang.reflect.Type])scala.collection.mutable.ArrayOps[java.lang.reflect.Type]">getActualTypeArguments</span>.<span title="=&gt; List[java.lang.reflect.Type]">toList</span>.<span title="(implicit bf: scala.collection.generic.CanBuildFrom[List[java.lang.reflect.Type],(java.lang.reflect.Type, Int),List[(java.lang.reflect.Type, Int)]])List[(java.lang.reflect.Type, Int)]">zipWithIndex</span> <a title="List[org.scalatra.swagger.reflect.ScalaType]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.actualArgs">map</a> <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.actualArgs.$anonfun.x0$2" title="org.scalatra.swagger.reflect.ScalaType" class="delimiter">{</a>
              case <span class="delimiter">(</span><a title="java.lang.reflect.Type" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.actualArgs.$anonfun.ct">ct</a>, <a title="Int" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.actualArgs.$anonfun.idx">idx</a><span class="delimiter">)</span> =&gt;
                val <a title="List[Int]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.actualArgs.$anonfun.prev">prev</a> = <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType$default$6" title="Option[(org.scalatra.swagger.reflect.ScalaType, List[Int])]">container</a>.<span title="(f: ((org.scalatra.swagger.reflect.ScalaType, List[Int])) =&gt; List[Int])Option[List[Int]]">map</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.actualArgs.$anonfun.prev.$anonfun.x$5" title="(org.scalatra.swagger.reflect.ScalaType, List[Int])">_</a>.<span title="=&gt; List[Int]">_2</span><span class="delimiter">)</span>.<span title="(default: =&gt; List[Int])List[Int]">getOrElse</span><span class="delimiter">(</span><span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
                <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType" title="(name: String, index: Int, owner: org.scalatra.swagger.reflect.ScalaType, ctorParameterNames: List[String], t: java.lang.reflect.Type, container: Option[(org.scalatra.swagger.reflect.ScalaType, List[Int])])org.scalatra.swagger.reflect.ScalaType">ctorParamType</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.name" title="String">name</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.index" title="Int">index</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.owner" title="org.scalatra.swagger.reflect.ScalaType">owner</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.ctorParameterNames" title="List[String]">ctorParameterNames</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.actualArgs.$anonfun.ct" title="java.lang.reflect.Type">ct</a>, <span title="(x: (org.scalatra.swagger.reflect.ScalaType, List[Int]))Some[(org.scalatra.swagger.reflect.ScalaType, List[Int])]">Some</span><span class="delimiter">(</span><span title="(_1: org.scalatra.swagger.reflect.ScalaType, _2: List[Int])(org.scalatra.swagger.reflect.ScalaType, List[Int])" class="delimiter">(</span><span title="org.scalatra.swagger.reflect.ScalaType">st</span>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.actualArgs.$anonfun.idx" title="Int">idx</a> <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.actualArgs.$anonfun.x$6" title="(x: Int)List[Int]">::</a> <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.actualArgs.$anonfun.prev" title="List[Int]">prev</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <span title="org.scalatra.swagger.reflect.ScalaType">st</span>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType.copy$default$1" title="Class[_$10] @scala.reflect.internal.annotations.uncheckedBounds" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.x$11">copy</a><span class="delimiter">(</span>typeArgs = <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.actualArgs" title="List[org.scalatra.swagger.reflect.ScalaType] @scala.reflect.internal.annotations.uncheckedBounds" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.x$9">actualArgs</a><span class="delimiter">)</span>
          case <span title="java.lang.reflect.WildcardType">v</span>: <span title="java.lang.reflect.WildcardType">WildcardType</span> =&gt;
            val <a title="Array[java.lang.reflect.Type]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.upper">upper</a> = <span title="java.lang.reflect.WildcardType">v</span>.<span title="()Array[java.lang.reflect.Type]">getUpperBounds</span>
            if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.upper" title="Array[java.lang.reflect.Type]">upper</a> <span title="(x$1: Any)Boolean">!=</span> null <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.upper" title="(xs: Array[java.lang.reflect.Type])scala.collection.mutable.ArrayOps[java.lang.reflect.Type]">upper</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(920132f9bf)" title="(t: java.lang.reflect.Type)org.scalatra.swagger.reflect.ScalaType">scalaTypeOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.upper" title="(i: Int)java.lang.reflect.Type">upper</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span>
            else <a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(dc1d6d5194)" title="[T](implicit mf: Manifest[T])org.scalatra.swagger.reflect.ScalaType">scalaTypeOf</a><span title="(implicit mf: Manifest[AnyRef])org.scalatra.swagger.reflect.ScalaType" class="delimiter">[</span><span title="AnyRef">AnyRef</span><span class="delimiter">]</span>
          case <a title="java.lang.reflect.Type" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.x">x</a> =&gt;
            val <span title="org.scalatra.swagger.reflect.ScalaType">st</span> = <a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(920132f9bf)" title="(t: java.lang.reflect.Type)org.scalatra.swagger.reflect.ScalaType">scalaTypeOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.x" title="java.lang.reflect.Type">x</a><span class="delimiter">)</span>
            if <span class="delimiter">(</span><span title="org.scalatra.swagger.reflect.ScalaType">st</span>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType.erasure" title="=&gt; Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Object](classOf[java.lang.Object])" class="delimiter">[</span>java.lang.Object<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(2a95cce7f8)" title="(clazz: Class[_])org.scalatra.swagger.reflect.ScalaType">scalaTypeOf</a><span class="delimiter">(</span><a href="ScalaSigReader.scala.html#org.scalatra.swagger.reflect.ScalaSigReader" title="org.scalatra.swagger.reflect.ScalaSigReader.type">ScalaSigReader</a>.<a href="ScalaSigReader.scala.html#org.scalatra.swagger.reflect.ScalaSigReader.readConstructor(32a372f1bd)" title="(argName: String, clazz: org.scalatra.swagger.reflect.ScalaType, typeArgIndexes: List[Int], argNames: List[String])Class[_]">readConstructor</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.name" title="String">name</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.owner" title="org.scalatra.swagger.reflect.ScalaType">owner</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.idxes" title="Option[List[Int]]">idxes</a> <span title="(default: =&gt; List[Int])List[Int]">getOrElse</span> <span title="(xs: Int*)List[Int]">List</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.index" title="Int">index</a><span class="delimiter">)</span>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType.ctorParameterNames" title="List[String]">ctorParameterNames</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span> else <span title="org.scalatra.swagger.reflect.ScalaType">st</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      def <a title="=&gt; Seq[org.scalatra.swagger.reflect.ConstructorDescriptor]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors">constructors</a>: <span title="Seq[org.scalatra.swagger.reflect.ConstructorDescriptor]">Seq</span><span class="delimiter">[</span>ConstructorDescriptor<span class="delimiter">]</span> = <span class="delimiter">{</span>
        <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.tpe" title="org.scalatra.swagger.reflect.ScalaType">tpe</a>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType.erasure" title="=&gt; Class[_]">erasure</a>.<span title="(xs: Array[java.lang.reflect.Constructor[_]])scala.collection.mutable.ArrayOps[java.lang.reflect.Constructor[_]]">getConstructors</span>.<span title="=&gt; Seq[java.lang.reflect.Constructor[_]]">toSeq</span> <span title="(f: java.lang.reflect.Constructor[_] =&gt; org.scalatra.swagger.reflect.ConstructorDescriptor)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[java.lang.reflect.Constructor[_]],org.scalatra.swagger.reflect.ConstructorDescriptor,Seq[org.scalatra.swagger.reflect.ConstructorDescriptor]])Seq[org.scalatra.swagger.reflect.ConstructorDescriptor]">map</span> <span class="delimiter">{</span>
          <a title="java.lang.reflect.Constructor[_]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctor">ctor</a> =&gt;
            val <a title="Seq[String]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParameterNames">ctorParameterNames</a> = if <span class="delimiter">(</span><span title="java.lang.reflect.Modifier.type">Modifier</span>.<span title="(x$1: Int)Boolean">isPublic</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctor" title="java.lang.reflect.Constructor[_]">ctor</a>.<span title="()Int">getModifiers</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctor" title="java.lang.reflect.Constructor[_]">ctor</a>.<span title="()Array[Class[_]]">getParameterTypes</span>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
              <span title="util.control.Exception.Catch[Nothing]">allCatch</span> <span title="(body: =&gt; Seq[String])Option[Seq[String]]">opt</span> <span class="delimiter">{</span> <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor$default$2" title="org.scalatra.swagger.reflect.ParameterNameReader">paramNameReader</a>.<a href="package.scala.html#org.scalatra.swagger.reflect.package;ParameterNameReader.lookupParameterNames" title="(constructor: java.lang.reflect.Constructor[_])Seq[String]">lookupParameterNames</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctor" title="java.lang.reflect.Constructor[_]">ctor</a><span class="delimiter">)</span> <span class="delimiter">}</span> <span title="(default: =&gt; Seq[String])Seq[String]">getOrElse</span> <span title="scala.collection.immutable.Nil.type">Nil</span>
            else
              <span title="scala.collection.immutable.Nil.type">Nil</span>
            val <a title="scala.collection.immutable.Vector[java.lang.reflect.Type]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.genParams">genParams</a> = <span title="(elems: java.lang.reflect.Type*)scala.collection.immutable.Vector[java.lang.reflect.Type]">Vector</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctor" title="java.lang.reflect.Constructor[_]">ctor</a>.<span title="()Array[java.lang.reflect.Type]">getGenericParameterTypes</span>: _*<span class="delimiter">)</span>
            val ctorParams = <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParameterNames" title="Seq[String]">ctorParameterNames</a>.<span title="(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],(String, Int),Seq[(String, Int)]])Seq[(String, Int)]">zipWithIndex</span> <a title="Seq[org.scalatra.swagger.reflect.ConstructorParamDescriptor]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams">map</a> <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.x0$3" title="org.scalatra.swagger.reflect.ConstructorParamDescriptor" class="delimiter">{</a>
              case <span class="delimiter">(</span><a title="String" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.paramName">paramName</a>, <a title="Int" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.index">index</a><span class="delimiter">)</span> =&gt;
                val <a title="String" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.decoded">decoded</a> = <a href="#org.scalatra.swagger.reflect.Reflector.unmangleName" title="(name: String)String">unmangleName</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.paramName" title="String">paramName</a><span class="delimiter">)</span>
                val default = <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.companion" title="Option[org.scalatra.swagger.reflect.SingletonDescriptor]">companion</a> <a title="Option[() =&gt; Object]" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.default">flatMap</a> <span class="delimiter">{</span>
                  <a title="org.scalatra.swagger.reflect.SingletonDescriptor" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.default.$anonfun.comp">comp</a> =&gt;
                    <a href="#org.scalatra.swagger.reflect.Reflector.defaultValue" title="(compClass: Class[_], compObj: AnyRef, argIndex: Int)Option[() =&gt; Object]">defaultValue</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.default.$anonfun.comp" title="org.scalatra.swagger.reflect.SingletonDescriptor">comp</a>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;SingletonDescriptor.erasure" title="=&gt; org.scalatra.swagger.reflect.ScalaType">erasure</a>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType.erasure" title="=&gt; Class[_]">erasure</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.default.$anonfun.comp" title="org.scalatra.swagger.reflect.SingletonDescriptor">comp</a>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;SingletonDescriptor.instance" title="=&gt; AnyRef">instance</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.index" title="Int">index</a><span class="delimiter">)</span>
                <span class="delimiter">}</span>
                val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.theType">theType</a> = <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.ctorParamType" title="(name: String, index: Int, owner: org.scalatra.swagger.reflect.ScalaType, ctorParameterNames: List[String], t: java.lang.reflect.Type, container: Option[(org.scalatra.swagger.reflect.ScalaType, List[Int])])org.scalatra.swagger.reflect.ScalaType">ctorParamType</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.paramName" title="String">paramName</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.index" title="Int">index</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.tpe" title="org.scalatra.swagger.reflect.ScalaType">tpe</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParameterNames" title="Seq[String]">ctorParameterNames</a>.<span title="=&gt; List[String]">toList</span>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.genParams" title="(index: Int)java.lang.reflect.Type">genParams</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.index" title="Int">index</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="descriptors.scala.html#org.scalatra.swagger.reflect;ConstructorParamDescriptor" title="(name: String, mangledName: String, argIndex: Int, argType: org.scalatra.swagger.reflect.ScalaType, defaultValue: Option[() =&gt; Any])org.scalatra.swagger.reflect.ConstructorParamDescriptor">ConstructorParamDescriptor</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.decoded" title="String">decoded</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.paramName" title="String">paramName</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.index" title="Int">index</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.theType" title="org.scalatra.swagger.reflect.ScalaType">theType</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams.$anonfun.default" title="Option[() =&gt; Object]">default</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <a href="descriptors.scala.html#org.scalatra.swagger.reflect;ConstructorDescriptor" title="(params: Seq[org.scalatra.swagger.reflect.ConstructorParamDescriptor], constructor: java.lang.reflect.Constructor[_], isPrimary: Boolean)org.scalatra.swagger.reflect.ConstructorDescriptor">ConstructorDescriptor</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctorParams" title="Seq[org.scalatra.swagger.reflect.ConstructorParamDescriptor]">ctorParams</a>.<span title="=&gt; Seq[org.scalatra.swagger.reflect.ConstructorParamDescriptor]">toSeq</span>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors.$anonfun.ctor" title="java.lang.reflect.Constructor[_]">ctor</a>, isPrimary = false<span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="descriptors.scala.html#org.scalatra.swagger.reflect;ClassDescriptor" title="(simpleName: String, fullName: String, erasure: org.scalatra.swagger.reflect.ScalaType, companion: Option[org.scalatra.swagger.reflect.SingletonDescriptor], constructors: Seq[org.scalatra.swagger.reflect.ConstructorDescriptor], properties: Seq[org.scalatra.swagger.reflect.PropertyDescriptor])org.scalatra.swagger.reflect.ClassDescriptor">ClassDescriptor</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.tpe" title="org.scalatra.swagger.reflect.ScalaType">tpe</a>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType.simpleName" title="=&gt; String">simpleName</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.tpe" title="org.scalatra.swagger.reflect.ScalaType">tpe</a>.<a href="descriptors.scala.html#org.scalatra.swagger.reflect;ScalaType.fullName" title="=&gt; String">fullName</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.tpe" title="org.scalatra.swagger.reflect.ScalaType">tpe</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.companion" title="Option[org.scalatra.swagger.reflect.SingletonDescriptor]">companion</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.constructors" title="=&gt; Seq[org.scalatra.swagger.reflect.ConstructorDescriptor]">constructors</a>, <a href="#org.scalatra.swagger.reflect.Reflector.createDescriptor.properties" title="=&gt; Seq[org.scalatra.swagger.reflect.PropertyDescriptor]">properties</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(compClass: Class[_], compObj: AnyRef, argIndex: Int)Option[() =&gt; Object]" id="org.scalatra.swagger.reflect.Reflector.defaultValue">defaultValue</a><span class="delimiter">(</span><a title="Class[_]" id="org.scalatra.swagger.reflect.Reflector.defaultValue.compClass">compClass</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="AnyRef" id="org.scalatra.swagger.reflect.Reflector.defaultValue.compObj">compObj</a>: <span title="AnyRef">AnyRef</span>, <a title="Int" id="org.scalatra.swagger.reflect.Reflector.defaultValue.argIndex">argIndex</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span title="util.control.Exception.Catch[Nothing]">allCatch</span>.<span title="(f: Throwable =&gt; None.type)util.control.Exception.Catch[None.type]">withApply</span><span title="(body: =&gt; Option[() =&gt; Object])Option[() =&gt; Object]" class="delimiter">(</span><a title="Throwable" id="org.scalatra.swagger.reflect.Reflector.defaultValue.$anonfun.x$7">_</a> =&gt; <span title="None.type">None</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(x: java.lang.reflect.Method)Option[java.lang.reflect.Method]">Option</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.defaultValue.compClass" title="Class[_]">compClass</a>.<span title="(x$1: String, x$2: Class[_]*)java.lang.reflect.Method">getMethod</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%s$%d&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="package.scala.html#org.scalatra.swagger.reflect.package.ConstructorDefault" title="=&gt; String">ConstructorDefault</a>, <a href="#org.scalatra.swagger.reflect.Reflector.defaultValue.argIndex" title="Int">argIndex</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(f: java.lang.reflect.Method =&gt; (() =&gt; Object))Option[() =&gt; Object]">map</span> <span class="delimiter">{</span>
        <a title="java.lang.reflect.Method" id="org.scalatra.swagger.reflect.Reflector.defaultValue.$anonfun.meth">meth</a> =&gt; <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#org.scalatra.swagger.reflect.Reflector.defaultValue.$anonfun.meth" title="java.lang.reflect.Method">meth</a>.<span title="(x$1: Any, x$2: Object*)Object">invoke</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.defaultValue.compObj" title="AnyRef">compObj</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(t: java.lang.reflect.Type)Class[_]" id="org.scalatra.swagger.reflect.Reflector.rawClassOf">rawClassOf</a><span class="delimiter">(</span><a title="java.lang.reflect.Type" id="org.scalatra.swagger.reflect.Reflector.rawClassOf.t">t</a>: <span title="java.lang.reflect.Type">Type</span><span class="delimiter">)</span>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span> = <a href="package.scala.html#org.scalatra.swagger.reflect.package;Memo.apply" title="(x: java.lang.reflect.Type, f: java.lang.reflect.Type =&gt; Class[_])Class[_]">rawClasses</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.rawClassOf.t" title="java.lang.reflect.Type">t</a>, <a href="#org.scalatra.swagger.reflect.Reflector.rawClassOf.$anonfun.x$8" title="java.lang.reflect.Type">_</a> match <span class="delimiter">{</span>
    case <a title="Class[_]" id="org.scalatra.swagger.reflect.Reflector.rawClassOf.$anonfun.c">c</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="#org.scalatra.swagger.reflect.Reflector.rawClassOf.$anonfun.c" title="Class[_]">c</a>
    case <a title="java.lang.reflect.ParameterizedType" id="org.scalatra.swagger.reflect.Reflector.rawClassOf.$anonfun.p">p</a>: <span title="java.lang.reflect.ParameterizedType">ParameterizedType</span> =&gt; <a href="#org.scalatra.swagger.reflect.Reflector.rawClassOf" title="(t: java.lang.reflect.Type)Class[_]">rawClassOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.rawClassOf.$anonfun.p" title="java.lang.reflect.ParameterizedType">p</a>.<span title="()java.lang.reflect.Type">getRawType</span><span class="delimiter">)</span>
    case <a title="java.lang.reflect.Type" id="org.scalatra.swagger.reflect.Reflector.rawClassOf.$anonfun.x">x</a> =&gt; sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;Raw type of &quot;)" class="string">&quot;Raw type of &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#org.scalatra.swagger.reflect.Reflector.rawClassOf.$anonfun.x" title="java.lang.reflect.Type">x</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; not known&quot;)" class="string">&quot; not known&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span><span class="delimiter">)</span>

  def <a title="(name: String)String" id="org.scalatra.swagger.reflect.Reflector.unmangleName">unmangleName</a><span class="delimiter">(</span><a title="String" id="org.scalatra.swagger.reflect.Reflector.unmangleName.name">name</a>: <span title="String">String</span><span class="delimiter">)</span> =
    <a href="package.scala.html#org.scalatra.swagger.reflect.package;Memo.apply" title="(x: String, f: String =&gt; String)String">unmangledNames</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.Reflector.unmangleName.name" title="String">name</a>, scala.reflect.<span title="scala.reflect.NameTransformer.type">NameTransformer</span>.<a href="#org.scalatra.swagger.reflect.Reflector.unmangleName.$anonfun.name0" title="(name0: String)String">decode</a><span class="delimiter">)</span>


<span class="delimiter">}</span>
        </pre>
    </body>
</html>
