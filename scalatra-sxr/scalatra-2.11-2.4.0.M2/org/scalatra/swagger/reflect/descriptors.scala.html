<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>org/scalatra/swagger/reflect/descriptors.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package org.scalatra.swagger.reflect

import java.lang.reflect.<span class="delimiter">{</span>Field, TypeVariable<span class="delimiter">}</span>

sealed trait <a title="trait Descriptor extends AnyRef" id="org.scalatra.swagger.reflect;Descriptor">Descriptor</a>
object <a title="org.scalatra.swagger.reflect.ManifestScalaType.type" id="org.scalatra.swagger.reflect.ManifestScalaType">ManifestScalaType</a> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type" class="delimiter">{</a>
  private val <a title="org.scalatra.swagger.reflect.Memo[scala.reflect.Manifest[_],org.scalatra.swagger.reflect.ScalaType]" id="org.scalatra.swagger.reflect.ManifestScalaType.types">types</a> = new <a href="package.scala.html#org.scalatra.swagger.reflect.package;Memo" title="org.scalatra.swagger.reflect.Memo[Manifest[_],org.scalatra.swagger.reflect.ScalaType]">Memo</a><span class="delimiter">[</span>Manifest<span class="delimiter">[</span>_<span class="delimiter">]</span>, ScalaType<span class="delimiter">]</span>

  def <a title="[T](mf: Manifest[T])org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c)">apply</a><span class="delimiter">[</span><a title="" id="org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Manifest[T]" id="org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf">mf</a>: <span title="Manifest[T]">Manifest</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = <span class="delimiter">{</span>
    <span class="comment">/* optimization */</span>
    if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Int](classOf[scala.Int])" class="delimiter">[</span>Int<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Integer](classOf[java.lang.Integer])" class="delimiter">[</span>java.lang.Integer<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.IntType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">IntType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Long](classOf[scala.Long])" class="delimiter">[</span>Long<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Long](classOf[java.lang.Long])" class="delimiter">[</span>java.lang.Long<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.LongType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">LongType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Byte](classOf[scala.Byte])" class="delimiter">[</span>Byte<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Byte](classOf[java.lang.Byte])" class="delimiter">[</span>java.lang.Byte<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.ByteType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">ByteType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Short](classOf[scala.Short])" class="delimiter">[</span>Short<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Short](classOf[java.lang.Short])" class="delimiter">[</span>java.lang.Short<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.ShortType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">ShortType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Float](classOf[scala.Float])" class="delimiter">[</span>Float<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Float](classOf[java.lang.Float])" class="delimiter">[</span>java.lang.Float<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.FloatType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">FloatType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Double](classOf[scala.Double])" class="delimiter">[</span>Double<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Double](classOf[java.lang.Double])" class="delimiter">[</span>java.lang.Double<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.DoubleType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">DoubleType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[BigInt](classOf[scala.math.BigInt])" class="delimiter">[</span>BigInt<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[java.math.BigInteger](classOf[java.math.BigInteger])" class="delimiter">[</span>java.math.BigInteger<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.BigIntType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">BigIntType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[BigDecimal](classOf[scala.math.BigDecimal])" class="delimiter">[</span>BigDecimal<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[java.math.BigDecimal](classOf[java.math.BigDecimal])" class="delimiter">[</span>java.math.BigDecimal<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.BigDecimalType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">BigDecimalType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Boolean](classOf[scala.Boolean])" class="delimiter">[</span>Boolean<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Boolean](classOf[java.lang.Boolean])" class="delimiter">[</span>java.lang.Boolean<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.BooleanType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">BooleanType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>String<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>java.lang.String<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.StringType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">StringType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[java.util.Date](classOf[java.util.Date])" class="delimiter">[</span>java.util.Date<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.DateType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">DateType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[java.sql.Timestamp](classOf[java.sql.Timestamp])" class="delimiter">[</span>java.sql.Timestamp<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.TimestampType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">TimestampType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Symbol](classOf[scala.Symbol])" class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.SymbolType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">SymbolType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Number](classOf[java.lang.Number])" class="delimiter">[</span>Number<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.NumberType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">NumberType</a>
    <span class="comment">/* end optimization */</span>
    else <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>.<span title="=&gt; List[scala.reflect.Manifest[_]]">typeArguments</span>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="package.scala.html#org.scalatra.swagger.reflect.package;Memo.apply" title="(x: scala.reflect.Manifest[_], f: scala.reflect.Manifest[_] =&gt; org.scalatra.swagger.reflect.ScalaType)org.scalatra.swagger.reflect.ScalaType">types</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a>, new <a href="#org.scalatra.swagger.reflect;ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType">ManifestScalaType</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).$anonfun.x$1" title="scala.reflect.Manifest[_]">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
      else new <a href="#org.scalatra.swagger.reflect;ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType">ManifestScalaType</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c).mf" title="Manifest[T]">mf</a><span class="delimiter">)</span>
<span class="comment">//      if (!mf.runtimeClass.isArray) types(mf, new ScalaType(_))</span>
<span class="comment">//      else {</span>
<span class="comment">//        val nmf = ManifestFactory.manifestOf(mf.runtimeClass, List(ManifestFactory.manifestOf(mf.runtimeClass.getComponentType)))</span>
<span class="comment">//        types(nmf, new ScalaType(_))</span>
<span class="comment">//      }</span>
<span class="comment">//      new ScalaType(mf)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(erasure: Class[_], typeArgs: Seq[org.scalatra.swagger.reflect.ScalaType])org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.apply(8ae5cd933c)">apply</a><span class="delimiter">(</span><a title="Class[_]" id="org.scalatra.swagger.reflect.ManifestScalaType.apply(8ae5cd933c).erasure">erasure</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Seq[org.scalatra.swagger.reflect.ScalaType]" id="org.scalatra.swagger.reflect.ManifestScalaType.apply$default$2">typeArgs</a>: <span title="Seq[org.scalatra.swagger.reflect.ScalaType]">Seq</span><span class="delimiter">[</span>ScalaType<span class="delimiter">]</span> = <span title="scala.collection.Seq.type">Seq</span>.<span title="Seq[Nothing]">empty</span><span class="delimiter">)</span>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = <span class="delimiter">{</span>
    val <a title="scala.reflect.Manifest[_]" id="org.scalatra.swagger.reflect.ManifestScalaType.apply(8ae5cd933c).mf">mf</a> = <a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory" title="org.scalatra.swagger.reflect.ManifestFactory.type">ManifestFactory</a>.<a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory.manifestOf(c8ffe084e8)" title="(erasure: Class[_], typeArgs: Seq[scala.reflect.Manifest[_]])scala.reflect.Manifest[_]">manifestOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(8ae5cd933c).erasure" title="Class[_]">erasure</a>, <a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply$default$2" title="Seq[org.scalatra.swagger.reflect.ScalaType]">typeArgs</a>.<span title="(f: org.scalatra.swagger.reflect.ScalaType =&gt; scala.reflect.Manifest[_])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[org.scalatra.swagger.reflect.ScalaType],scala.reflect.Manifest[_],Seq[scala.reflect.Manifest[_]]])Seq[scala.reflect.Manifest[_]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scala.reflect.Manifest[_],Seq[scala.reflect.Manifest[_]]]" class="delimiter">(</span><a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory" title="org.scalatra.swagger.reflect.ManifestFactory.type">ManifestFactory</a>.<a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory.manifestOf(5757560000)" title="(st: org.scalatra.swagger.reflect.ScalaType)scala.reflect.Manifest[_]">manifestOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(8ae5cd933c).mf.$anonfun.x$2" title="org.scalatra.swagger.reflect.ScalaType">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c)" title="(mf: Manifest[_$4])org.scalatra.swagger.reflect.ScalaType">ManifestScalaType</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(8ae5cd933c).mf" title="scala.reflect.Manifest[_]">mf</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.IntType">IntType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = new <a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.PrimitiveManifestScalaType">PrimitiveManifestScalaType</a><span class="delimiter">(</span><span title="=&gt; scala.reflect.ManifestFactory.type">Manifest</span>.<span title="=&gt; scala.reflect.AnyValManifest[Int]">Int</span><span class="delimiter">)</span>
  private val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.NumberType">NumberType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = new <a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.PrimitiveManifestScalaType">PrimitiveManifestScalaType</a><span class="delimiter">(</span><span title="[T](implicit m: Manifest[T])Manifest[T]">manifest</span><span title="(implicit m: Manifest[Number])Manifest[Number]" class="delimiter">[</span><span title="Number">Number</span><span class="delimiter">]</span><span class="delimiter">)</span>
  private val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.LongType">LongType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = new <a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.PrimitiveManifestScalaType">PrimitiveManifestScalaType</a><span class="delimiter">(</span><span title="=&gt; scala.reflect.ManifestFactory.type">Manifest</span>.<span title="=&gt; scala.reflect.AnyValManifest[Long]">Long</span><span class="delimiter">)</span>
  private val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.ByteType">ByteType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = new <a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.PrimitiveManifestScalaType">PrimitiveManifestScalaType</a><span class="delimiter">(</span><span title="=&gt; scala.reflect.ManifestFactory.type">Manifest</span>.<span title="=&gt; scala.reflect.AnyValManifest[Byte]">Byte</span><span class="delimiter">)</span>
  private val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.ShortType">ShortType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = new <a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.PrimitiveManifestScalaType">PrimitiveManifestScalaType</a><span class="delimiter">(</span><span title="=&gt; scala.reflect.ManifestFactory.type">Manifest</span>.<span title="=&gt; scala.reflect.AnyValManifest[Short]">Short</span><span class="delimiter">)</span>
  private val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.BooleanType">BooleanType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = new <a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.PrimitiveManifestScalaType">PrimitiveManifestScalaType</a><span class="delimiter">(</span><span title="=&gt; scala.reflect.ManifestFactory.type">Manifest</span>.<span title="=&gt; scala.reflect.AnyValManifest[Boolean]">Boolean</span><span class="delimiter">)</span>
  private val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.FloatType">FloatType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = new <a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.PrimitiveManifestScalaType">PrimitiveManifestScalaType</a><span class="delimiter">(</span><span title="=&gt; scala.reflect.ManifestFactory.type">Manifest</span>.<span title="=&gt; scala.reflect.AnyValManifest[Float]">Float</span><span class="delimiter">)</span>
  private val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.DoubleType">DoubleType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = new <a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.PrimitiveManifestScalaType">PrimitiveManifestScalaType</a><span class="delimiter">(</span><span title="=&gt; scala.reflect.ManifestFactory.type">Manifest</span>.<span title="=&gt; scala.reflect.AnyValManifest[Double]">Double</span><span class="delimiter">)</span>
  private val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.StringType">StringType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = new <a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.PrimitiveManifestScalaType">PrimitiveManifestScalaType</a><span class="delimiter">(</span><span title="[T](implicit m: Manifest[T])Manifest[T]">manifest</span><span title="(implicit m: Manifest[String])Manifest[String]" class="delimiter">[</span>java.lang.<span title="String">String</span><span class="delimiter">]</span><span class="delimiter">)</span>
  private val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.SymbolType">SymbolType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = new <a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.PrimitiveManifestScalaType">PrimitiveManifestScalaType</a><span class="delimiter">(</span><span title="[T](implicit m: Manifest[T])Manifest[T]">manifest</span><span title="(implicit m: Manifest[Symbol])Manifest[Symbol]" class="delimiter">[</span><span title="Symbol">Symbol</span><span class="delimiter">]</span><span class="delimiter">)</span>
  private val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.BigDecimalType">BigDecimalType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = new <a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.PrimitiveManifestScalaType">PrimitiveManifestScalaType</a><span class="delimiter">(</span><span title="[T](implicit m: Manifest[T])Manifest[T]">manifest</span><span title="(implicit m: Manifest[BigDecimal])Manifest[BigDecimal]" class="delimiter">[</span><span title="BigDecimal">BigDecimal</span><span class="delimiter">]</span><span class="delimiter">)</span>
  private val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.BigIntType">BigIntType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = new <a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.PrimitiveManifestScalaType">PrimitiveManifestScalaType</a><span class="delimiter">(</span><span title="[T](implicit m: Manifest[T])Manifest[T]">manifest</span><span title="(implicit m: Manifest[BigInt])Manifest[BigInt]" class="delimiter">[</span><span title="BigInt">BigInt</span><span class="delimiter">]</span><span class="delimiter">)</span>
  private val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.DateType">DateType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = new <a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.PrimitiveManifestScalaType">PrimitiveManifestScalaType</a><span class="delimiter">(</span><span title="[T](implicit m: Manifest[T])Manifest[T]">manifest</span><span title="(implicit m: Manifest[java.util.Date])Manifest[java.util.Date]" class="delimiter">[</span>java.util.<span title="java.util.Date">Date</span><span class="delimiter">]</span><span class="delimiter">)</span>
  private val <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType.TimestampType">TimestampType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = new <a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.PrimitiveManifestScalaType">PrimitiveManifestScalaType</a><span class="delimiter">(</span><span title="[T](implicit m: Manifest[T])Manifest[T]">manifest</span><span title="(implicit m: Manifest[java.sql.Timestamp])Manifest[java.sql.Timestamp]" class="delimiter">[</span>java.sql.<span title="java.sql.Timestamp">Timestamp</span><span class="delimiter">]</span><span class="delimiter">)</span>

  private class <a title="class PrimitiveManifestScalaType extends org.scalatra.swagger.reflect.ManifestScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType">PrimitiveManifestScalaType</a><a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.PrimitiveManifestScalaType" class="delimiter">(</a><a title="Manifest[_]" id="org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType.mf">mf</a>: <span title="Manifest[_]">Manifest</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#org.scalatra.swagger.reflect;ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType">ManifestScalaType</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType.mf" title="Manifest[_]">mf</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    override val <a title="Boolean" id="org.scalatra.swagger.reflect.ManifestScalaType;PrimitiveManifestScalaType.isPrimitive">isPrimitive</a> = true
  <span class="delimiter">}</span>
  private class <a title="class CopiedManifestScalaType extends org.scalatra.swagger.reflect.ManifestScalaType" id="org.scalatra.swagger.reflect.ManifestScalaType;CopiedManifestScalaType">CopiedManifestScalaType</a><a href="#org.scalatra.swagger.reflect.ManifestScalaType;CopiedManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.CopiedManifestScalaType" class="delimiter">(</a>
                    <a title="Manifest[_]" id="org.scalatra.swagger.reflect.ManifestScalaType;CopiedManifestScalaType.mf">mf</a>: <span title="Manifest[_]">Manifest</span><span class="delimiter">[</span>_<span class="delimiter">]</span>,
                    private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]" id="org.scalatra.swagger.reflect.ManifestScalaType;CopiedManifestScalaType._typeVars">_typeVars</a>: <span title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">Map</span><span class="delimiter">[</span>TypeVariable<span class="delimiter">[</span>_<span class="delimiter">]</span>, ScalaType<span class="delimiter">]</span>,
                    override val <a title="Boolean" id="org.scalatra.swagger.reflect.ManifestScalaType;CopiedManifestScalaType.isPrimitive">isPrimitive</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> extends <a href="#org.scalatra.swagger.reflect;ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType">ManifestScalaType</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType;CopiedManifestScalaType.mf" title="Manifest[_]">mf</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    override def <a title="=&gt; Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]" id="org.scalatra.swagger.reflect.ManifestScalaType;CopiedManifestScalaType.typeVars">typeVars</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType;CopiedManifestScalaType._typeVars" title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">_typeVars</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span>
        <a href="#org.scalatra.swagger.reflect.ManifestScalaType;CopiedManifestScalaType._typeVars" title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">_typeVars</a> = <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]" class="delimiter">[</span><span title="java.lang.reflect.TypeVariable[_]">TypeVariable</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a><span class="delimiter">]</span> <span title="(xs: scala.collection.GenTraversableOnce[(java.lang.reflect.TypeVariable[_], org.scalatra.swagger.reflect.ScalaType)])scala.collection.immutable.Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">++</span>
          <a href="#org.scalatra.swagger.reflect;ManifestScalaType.erasure" title="=&gt; Class[_]">erasure</a>.<span title="(xs: Array[java.lang.reflect.TypeVariable[Class[_$13]]])scala.collection.mutable.ArrayOps[java.lang.reflect.TypeVariable[Class[_$13]]]">getTypeParameters</span>.<span title="(f: java.lang.reflect.TypeVariable[Class[_$13]] =&gt; java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration])(implicit bf: scala.collection.generic.CanBuildFrom[Array[java.lang.reflect.TypeVariable[Class[_$13]]],java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration],Array[java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration]]])Array[java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration]]">map</span><span title="(xs: Array[java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration]])scala.collection.mutable.ArrayOps[java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration]]" class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType;CopiedManifestScalaType.typeVars.$anonfun.x$3" title="java.lang.reflect.TypeVariable[Class[_$13]]">_</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="java.lang.reflect.TypeVariable[_$7]" class="delimiter">[</span><span title="java.lang.reflect.TypeVariable[_]">TypeVariable</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>.<span title="=&gt; List[java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration]]">toList</span>.<span title="(that: scala.collection.GenIterable[org.scalatra.swagger.reflect.ScalaType])(implicit bf: scala.collection.generic.CanBuildFrom[List[java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration]],(java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration], org.scalatra.swagger.reflect.ScalaType),List[(java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration], org.scalatra.swagger.reflect.ScalaType)]])List[(java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration], org.scalatra.swagger.reflect.ScalaType)]">zip</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,(java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration], org.scalatra.swagger.reflect.ScalaType),List[(java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration], org.scalatra.swagger.reflect.ScalaType)]]" class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.manifest" title="=&gt; Manifest[_]">manifest</a>.<span title="=&gt; List[scala.reflect.Manifest[_]]">typeArguments</span> <span title="(f: scala.reflect.Manifest[_] =&gt; org.scalatra.swagger.reflect.ScalaType)(implicit bf: scala.collection.generic.CanBuildFrom[List[scala.reflect.Manifest[_]],org.scalatra.swagger.reflect.ScalaType,List[org.scalatra.swagger.reflect.ScalaType]])List[org.scalatra.swagger.reflect.ScalaType]">map</span> <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c)" title="(mf: Manifest[_$1])org.scalatra.swagger.reflect.ScalaType">ManifestScalaType</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType;CopiedManifestScalaType.typeVars.$anonfun.x$4" title="scala.reflect.Manifest[_]">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#org.scalatra.swagger.reflect.ManifestScalaType;CopiedManifestScalaType._typeVars" title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">_typeVars</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

trait <a title="trait ScalaType extends AnyRef with Equals" id="org.scalatra.swagger.reflect;ScalaType">ScalaType</a> extends <span title="Equals">Equals</span> <span class="delimiter">{</span>
  def <a title="=&gt; Class[_]" id="org.scalatra.swagger.reflect;ScalaType.erasure">erasure</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span>
  def <a title="=&gt; Seq[org.scalatra.swagger.reflect.ScalaType]" id="org.scalatra.swagger.reflect;ScalaType.typeArgs">typeArgs</a>: <span title="Seq[org.scalatra.swagger.reflect.ScalaType]">Seq</span><span class="delimiter">[</span>ScalaType<span class="delimiter">]</span>
  def <a title="=&gt; Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]" id="org.scalatra.swagger.reflect;ScalaType.typeVars">typeVars</a>: <span title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">Map</span><span class="delimiter">[</span>TypeVariable<span class="delimiter">[</span>_<span class="delimiter">]</span>, ScalaType<span class="delimiter">]</span>
  def <a title="=&gt; Boolean" id="org.scalatra.swagger.reflect;ScalaType.isArray">isArray</a>: <span title="Boolean">Boolean</span>
  def <a title="=&gt; String" id="org.scalatra.swagger.reflect;ScalaType.rawFullName">rawFullName</a>: <span title="String">String</span>
  def <a title="=&gt; String" id="org.scalatra.swagger.reflect;ScalaType.rawSimpleName">rawSimpleName</a>: <span title="String">String</span>
  def <a title="=&gt; String" id="org.scalatra.swagger.reflect;ScalaType.simpleName">simpleName</a>: <span title="String">String</span>
  def <a title="=&gt; String" id="org.scalatra.swagger.reflect;ScalaType.fullName">fullName</a>: <span title="String">String</span>
  def <a title="=&gt; Boolean" id="org.scalatra.swagger.reflect;ScalaType.isPrimitive">isPrimitive</a>: <span title="Boolean">Boolean</span>
  def <a title="=&gt; Boolean" id="org.scalatra.swagger.reflect;ScalaType.isMap">isMap</a>: <span title="Boolean">Boolean</span>
  def <a title="=&gt; Boolean" id="org.scalatra.swagger.reflect;ScalaType.isCollection">isCollection</a>: <span title="Boolean">Boolean</span>
  def <a title="=&gt; Boolean" id="org.scalatra.swagger.reflect;ScalaType.isOption">isOption</a>: <span title="Boolean">Boolean</span>
  def <a title="(that: org.scalatra.swagger.reflect.ScalaType)Boolean" id="org.scalatra.swagger.reflect;ScalaType.<:<">&lt;:&lt;</a><span class="delimiter">(</span><a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect;ScalaType.<:<.that">that</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span>
  def <a title="(that: org.scalatra.swagger.reflect.ScalaType)Boolean" id="org.scalatra.swagger.reflect;ScalaType.>:>">&gt;:&gt;</a><span class="delimiter">(</span><a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect;ScalaType.>:>.that">that</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span>
  def <a title="(erasure: Class[_], typeArgs: Seq[org.scalatra.swagger.reflect.ScalaType], typeVars: Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType])org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect;ScalaType.copy">copy</a><span class="delimiter">(</span><a title="Class[_]" id="org.scalatra.swagger.reflect;ScalaType.copy$default$1">erasure</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span> = <a href="#org.scalatra.swagger.reflect;ScalaType.copy$default$1" title="Class[_]">erasure</a>, <a title="Seq[org.scalatra.swagger.reflect.ScalaType]" id="org.scalatra.swagger.reflect;ScalaType.copy$default$2">typeArgs</a>: <span title="Seq[org.scalatra.swagger.reflect.ScalaType]">Seq</span><span class="delimiter">[</span>ScalaType<span class="delimiter">]</span> = <a href="#org.scalatra.swagger.reflect;ScalaType.copy$default$2" title="Seq[org.scalatra.swagger.reflect.ScalaType]">typeArgs</a>, <a title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]" id="org.scalatra.swagger.reflect;ScalaType.copy$default$3">typeVars</a>: <span title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">Map</span><span class="delimiter">[</span>TypeVariable<span class="delimiter">[</span>_<span class="delimiter">]</span>, ScalaType<span class="delimiter">]</span> = <a href="#org.scalatra.swagger.reflect;ScalaType.copy$default$3" title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">typeVars</a><span class="delimiter">)</span>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a>
<span class="delimiter">}</span>

class <a title="class ManifestScalaType extends AnyRef with org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect;ManifestScalaType">ManifestScalaType</a><a href="#org.scalatra.swagger.reflect;ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType" class="delimiter">(</a>val <a title="Manifest[_]" id="org.scalatra.swagger.reflect;ManifestScalaType.manifest">manifest</a>: <span title="Manifest[_]">Manifest</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> <span class="delimiter">{</span>

  import <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<span class="delimiter">{</span> types, CopiedManifestScalaType <span class="delimiter">}</span>
  private<span class="delimiter">[</span>this<span class="delimiter">]</span> val <a title="org.scalatra.swagger.reflect.ManifestScalaType" id="org.scalatra.swagger.reflect;ManifestScalaType.self">self</a> = this
  val <a title="Class[_]" id="org.scalatra.swagger.reflect;ManifestScalaType.erasure">erasure</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span> = <a href="#org.scalatra.swagger.reflect;ManifestScalaType.manifest" title="=&gt; Manifest[_]">manifest</a>.<span title="=&gt; Class[_]">runtimeClass</span>

<span class="comment">//  private[this] var _typeArgs: Seq[ScalaType] = null</span>
<span class="comment">//  def typeArgs: Seq[ScalaType] = {</span>
<span class="comment">//    if (_typeArgs == null)</span>
<span class="comment">//      _typeArgs = manifest.typeArguments.map(ta =&gt; Reflector.scalaTypeOf(ta)) ++ (</span>
<span class="comment">//        if (erasure.isArray) List(Reflector.scalaTypeOf(erasure.getComponentType)) else Nil</span>
<span class="comment">//      )</span>
<span class="comment">//    _typeArgs</span>
<span class="comment">//  }</span>

  val typeArgs = <a href="#org.scalatra.swagger.reflect;ManifestScalaType.manifest" title="=&gt; Manifest[_]">manifest</a>.<span title="=&gt; List[scala.reflect.Manifest[_]]">typeArguments</span>.<span title="(f: scala.reflect.Manifest[_] =&gt; org.scalatra.swagger.reflect.ScalaType)(implicit bf: scala.collection.generic.CanBuildFrom[List[scala.reflect.Manifest[_]],org.scalatra.swagger.reflect.ScalaType,List[org.scalatra.swagger.reflect.ScalaType]])List[org.scalatra.swagger.reflect.ScalaType]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,org.scalatra.swagger.reflect.ScalaType,List[org.scalatra.swagger.reflect.ScalaType]]" class="delimiter">(</span><a title="scala.reflect.Manifest[_]" id="org.scalatra.swagger.reflect;ManifestScalaType.typeArgs.$anonfun.ta">ta</a> =&gt; <a href="Reflector.scala.html#org.scalatra.swagger.reflect.Reflector" title="org.scalatra.swagger.reflect.Reflector.type">Reflector</a>.<a href="Reflector.scala.html#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(dc1d6d5194)" title="(implicit mf: Manifest[_$1])org.scalatra.swagger.reflect.ScalaType">scalaTypeOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.typeArgs.$anonfun.ta" title="scala.reflect.Manifest[_]">ta</a><span class="delimiter">)</span><span class="delimiter">)</span> <a title="List[org.scalatra.swagger.reflect.ScalaType]" id="org.scalatra.swagger.reflect;ManifestScalaType.typeArgs">++</a> <span class="delimiter">(</span>
    if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.erasure" title="=&gt; Class[_]">erasure</a>.<span title="()Boolean">isArray</span><span class="delimiter">)</span> <span title="(xs: org.scalatra.swagger.reflect.ScalaType*)List[org.scalatra.swagger.reflect.ScalaType]">List</span><span class="delimiter">(</span><a href="Reflector.scala.html#org.scalatra.swagger.reflect.Reflector" title="org.scalatra.swagger.reflect.Reflector.type">Reflector</a>.<a href="Reflector.scala.html#org.scalatra.swagger.reflect.Reflector.scalaTypeOf(2a95cce7f8)" title="(clazz: Class[_])org.scalatra.swagger.reflect.ScalaType">scalaTypeOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.erasure" title="=&gt; Class[_]">erasure</a>.<span title="()Class[_]">getComponentType</span><span class="delimiter">)</span><span class="delimiter">)</span> else <span title="scala.collection.immutable.Nil.type">Nil</span>
  <span class="delimiter">)</span>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]" id="org.scalatra.swagger.reflect;ManifestScalaType._typeVars">_typeVars</a>: <span title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">Map</span><span class="delimiter">[</span>TypeVariable<span class="delimiter">[</span>_<span class="delimiter">]</span>, ScalaType<span class="delimiter">]</span> = null
  def <a title="=&gt; Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]" id="org.scalatra.swagger.reflect;ManifestScalaType.typeVars">typeVars</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType._typeVars" title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">_typeVars</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span>
      <a href="#org.scalatra.swagger.reflect;ManifestScalaType._typeVars" title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">_typeVars</a> = <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="scala.collection.immutable.Map[java.lang.reflect.TypeVariable[_],Nothing]">empty</span> <span title="(xs: scala.collection.GenTraversableOnce[(java.lang.reflect.TypeVariable[_], org.scalatra.swagger.reflect.ScalaType)])scala.collection.immutable.Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">++</span>
        <a href="#org.scalatra.swagger.reflect;ManifestScalaType.erasure" title="=&gt; Class[_]">erasure</a>.<span title="(xs: Array[java.lang.reflect.TypeVariable[Class[_$13]]])scala.collection.mutable.ArrayOps[java.lang.reflect.TypeVariable[Class[_$13]]]">getTypeParameters</span>.<span title="(f: java.lang.reflect.TypeVariable[Class[_$13]] =&gt; java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration])(implicit bf: scala.collection.generic.CanBuildFrom[Array[java.lang.reflect.TypeVariable[Class[_$13]]],java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration],Array[java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration]]])Array[java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration]]">map</span><span title="(xs: Array[java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration]])scala.collection.mutable.ArrayOps[java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration]]" class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.typeVars.$anonfun.x$5" title="java.lang.reflect.TypeVariable[Class[_$13]]">_</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="java.lang.reflect.TypeVariable[_$15]" class="delimiter">[</span><span title="java.lang.reflect.TypeVariable[_]">TypeVariable</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>.<span title="=&gt; List[java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration]]">toList</span>.<span title="(that: scala.collection.GenIterable[org.scalatra.swagger.reflect.ScalaType])(implicit bf: scala.collection.generic.CanBuildFrom[List[java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration]],(java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration], org.scalatra.swagger.reflect.ScalaType),scala.collection.GenTraversableOnce[(java.lang.reflect.TypeVariable[_], org.scalatra.swagger.reflect.ScalaType)]])scala.collection.GenTraversableOnce[(java.lang.reflect.TypeVariable[_], org.scalatra.swagger.reflect.ScalaType)]">zip</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,(java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration], org.scalatra.swagger.reflect.ScalaType),List[(java.lang.reflect.TypeVariable[_ &lt;: java.lang.reflect.GenericDeclaration], org.scalatra.swagger.reflect.ScalaType)]]" class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.manifest" title="=&gt; Manifest[_]">manifest</a>.<span title="=&gt; List[scala.reflect.Manifest[_]]">typeArguments</span> <span title="(f: scala.reflect.Manifest[_] =&gt; org.scalatra.swagger.reflect.ScalaType)(implicit bf: scala.collection.generic.CanBuildFrom[List[scala.reflect.Manifest[_]],org.scalatra.swagger.reflect.ScalaType,List[org.scalatra.swagger.reflect.ScalaType]])List[org.scalatra.swagger.reflect.ScalaType]">map</span> <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect.ManifestScalaType.apply(c15be6163c)" title="(mf: Manifest[_$1])org.scalatra.swagger.reflect.ScalaType">ManifestScalaType</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.typeVars.$anonfun.x$6" title="scala.reflect.Manifest[_]">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#org.scalatra.swagger.reflect;ManifestScalaType._typeVars" title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">_typeVars</a>
  <span class="delimiter">}</span>


  val <a title="Boolean" id="org.scalatra.swagger.reflect;ManifestScalaType.isArray">isArray</a>: <span title="Boolean">Boolean</span> = <a href="#org.scalatra.swagger.reflect;ManifestScalaType.erasure" title="=&gt; Class[_]">erasure</a>.<span title="()Boolean">isArray</span>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="String" id="org.scalatra.swagger.reflect;ManifestScalaType._rawFullName">_rawFullName</a>: <span title="String">String</span> = null
  def <a title="=&gt; String" id="org.scalatra.swagger.reflect;ManifestScalaType.rawFullName">rawFullName</a>: <span title="String">String</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType._rawFullName" title="String">_rawFullName</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span>
      <a href="#org.scalatra.swagger.reflect;ManifestScalaType._rawFullName" title="String">_rawFullName</a> = <a href="#org.scalatra.swagger.reflect;ManifestScalaType.erasure" title="=&gt; Class[_]">erasure</a>.<span title="()String">getName</span>
    <a href="#org.scalatra.swagger.reflect;ManifestScalaType._rawFullName" title="String">_rawFullName</a>
  <span class="delimiter">}</span>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="String" id="org.scalatra.swagger.reflect;ManifestScalaType._rawSimpleName">_rawSimpleName</a>: <span title="String">String</span> = null
  def <a title="=&gt; String" id="org.scalatra.swagger.reflect;ManifestScalaType.rawSimpleName">rawSimpleName</a>: <span title="String">String</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType._rawSimpleName" title="String">_rawSimpleName</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span>
      <a href="#org.scalatra.swagger.reflect;ManifestScalaType._rawSimpleName" title="String">_rawSimpleName</a> = <a href="#org.scalatra.swagger.reflect;ManifestScalaType.erasure" title="=&gt; Class[_]">erasure</a>.<span title="()String">getSimpleName</span>
    <a href="#org.scalatra.swagger.reflect;ManifestScalaType._rawSimpleName" title="String">_rawSimpleName</a>
  <span class="delimiter">}</span>

  lazy val simpleName: <span title="String">String</span> =
    <a href="#org.scalatra.swagger.reflect;ManifestScalaType.rawSimpleName" title="=&gt; String">rawSimpleName</a> <a title="String" id="org.scalatra.swagger.reflect;ManifestScalaType.simpleName">+</a> <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.typeArgs" title="=&gt; List[org.scalatra.swagger.reflect.ScalaType]">typeArgs</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.typeArgs" title="=&gt; List[org.scalatra.swagger.reflect.ScalaType]">typeArgs</a>.<span title="(f: org.scalatra.swagger.reflect.ScalaType =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[org.scalatra.swagger.reflect.ScalaType],String,List[String]])List[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,String,List[String]]" class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.simpleName.$anonfun.x$7" title="org.scalatra.swagger.reflect.ScalaType">_</a>.<a href="#org.scalatra.swagger.reflect;ScalaType.simpleName" title="=&gt; String">simpleName</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span> else <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.typeVars" title="=&gt; Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">typeVars</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.typeVars" title="=&gt; Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">typeVars</a>.<span title="(f: ((java.lang.reflect.TypeVariable[_], org.scalatra.swagger.reflect.ScalaType)) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType],String,scala.collection.immutable.Iterable[String]])scala.collection.immutable.Iterable[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Iterable.Coll,String,scala.collection.immutable.Iterable[String]]" class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.simpleName.$anonfun.x$8" title="(java.lang.reflect.TypeVariable[_], org.scalatra.swagger.reflect.ScalaType)">_</a>.<span title="=&gt; org.scalatra.swagger.reflect.ScalaType">_2</span>.<a href="#org.scalatra.swagger.reflect;ScalaType.simpleName" title="=&gt; String">simpleName</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span> else <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

  lazy val fullName: <span title="String">String</span> =
    <a href="#org.scalatra.swagger.reflect;ManifestScalaType.rawFullName" title="=&gt; String">rawFullName</a> <a title="String" id="org.scalatra.swagger.reflect;ManifestScalaType.fullName">+</a> <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.typeArgs" title="=&gt; List[org.scalatra.swagger.reflect.ScalaType]">typeArgs</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.typeArgs" title="=&gt; List[org.scalatra.swagger.reflect.ScalaType]">typeArgs</a>.<span title="(f: org.scalatra.swagger.reflect.ScalaType =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[org.scalatra.swagger.reflect.ScalaType],String,List[String]])List[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,String,List[String]]" class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.fullName.$anonfun.x$9" title="org.scalatra.swagger.reflect.ScalaType">_</a>.<a href="#org.scalatra.swagger.reflect;ScalaType.fullName" title="=&gt; String">fullName</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span> else <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>

  val <a title="Boolean" id="org.scalatra.swagger.reflect;ManifestScalaType.isPrimitive">isPrimitive</a> = false

  def <a title="=&gt; Boolean" id="org.scalatra.swagger.reflect;ManifestScalaType.isMap">isMap</a> = classOf<span title="Class[Map[_, _]](classOf[scala.collection.immutable.Map])" class="delimiter">[</span>Map<span class="delimiter">[</span>_, _<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="(x$1: Class[_])Boolean">isAssignableFrom</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.erasure" title="=&gt; Class[_]">erasure</a><span class="delimiter">)</span>
  def <a title="=&gt; Boolean" id="org.scalatra.swagger.reflect;ManifestScalaType.isCollection">isCollection</a> = <a href="#org.scalatra.swagger.reflect;ManifestScalaType.erasure" title="=&gt; Class[_]">erasure</a>.<span title="()Boolean">isArray</span> <span title="(x: Boolean)Boolean">||</span> classOf<span title="Class[Iterable[_]](classOf[scala.collection.Iterable])" class="delimiter">[</span>Iterable<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="(x$1: Class[_])Boolean">isAssignableFrom</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.erasure" title="=&gt; Class[_]">erasure</a><span class="delimiter">)</span>
  def <a title="=&gt; Boolean" id="org.scalatra.swagger.reflect;ManifestScalaType.isOption">isOption</a> = classOf<span title="Class[Option[_]](classOf[scala.Option])" class="delimiter">[</span>Option<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="(x$1: Class[_])Boolean">isAssignableFrom</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.erasure" title="=&gt; Class[_]">erasure</a><span class="delimiter">)</span>
  def <a title="(that: org.scalatra.swagger.reflect.ScalaType)Boolean" id="org.scalatra.swagger.reflect;ManifestScalaType.<:<">&lt;:&lt;</a><span class="delimiter">(</span><a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect;ManifestScalaType.<:<.that">that</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#org.scalatra.swagger.reflect;ManifestScalaType.<:<.that" title="org.scalatra.swagger.reflect.ScalaType">that</a> match <span class="delimiter">{</span>
    case <a title="org.scalatra.swagger.reflect.ManifestScalaType" id="org.scalatra.swagger.reflect;ManifestScalaType.<:<.t">t</a>: <a href="#org.scalatra.swagger.reflect;ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType">ManifestScalaType</a> =&gt; <a href="#org.scalatra.swagger.reflect;ManifestScalaType.manifest" title="=&gt; Manifest[_]">manifest</a> <span title="(that: scala.reflect.ClassManifest[_])Boolean">&lt;:&lt;</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.<:<.t" title="org.scalatra.swagger.reflect.ManifestScalaType">t</a>.<a href="#org.scalatra.swagger.reflect;ManifestScalaType.manifest" title="=&gt; Manifest[_]">manifest</a>
    case _ =&gt; <a href="#org.scalatra.swagger.reflect;ManifestScalaType.manifest" title="=&gt; Manifest[_]">manifest</a> <span title="(that: scala.reflect.ClassManifest[_])Boolean">&lt;:&lt;</span> <a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory" title="org.scalatra.swagger.reflect.ManifestFactory.type">ManifestFactory</a>.<a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory.manifestOf(5757560000)" title="(st: org.scalatra.swagger.reflect.ScalaType)scala.reflect.Manifest[_]">manifestOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.<:<.that" title="org.scalatra.swagger.reflect.ScalaType">that</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  def <a title="(that: org.scalatra.swagger.reflect.ScalaType)Boolean" id="org.scalatra.swagger.reflect;ManifestScalaType.>:>">&gt;:&gt;</a><span class="delimiter">(</span><a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect;ManifestScalaType.>:>.that">that</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#org.scalatra.swagger.reflect;ManifestScalaType.>:>.that" title="org.scalatra.swagger.reflect.ScalaType">that</a> match <span class="delimiter">{</span>
    case <a title="org.scalatra.swagger.reflect.ManifestScalaType" id="org.scalatra.swagger.reflect;ManifestScalaType.>:>.t">t</a>: <a href="#org.scalatra.swagger.reflect;ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType">ManifestScalaType</a> =&gt; <a href="#org.scalatra.swagger.reflect;ManifestScalaType.manifest" title="=&gt; Manifest[_]">manifest</a> <span title="(that: scala.reflect.ClassManifest[_])Boolean">&gt;:&gt;</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.>:>.t" title="org.scalatra.swagger.reflect.ManifestScalaType">t</a>.<a href="#org.scalatra.swagger.reflect;ManifestScalaType.manifest" title="=&gt; Manifest[_]">manifest</a>
    case _ =&gt; <a href="#org.scalatra.swagger.reflect;ManifestScalaType.manifest" title="=&gt; Manifest[_]">manifest</a> <span title="(that: scala.reflect.ClassManifest[_])Boolean">&gt;:&gt;</span> <a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory" title="org.scalatra.swagger.reflect.ManifestFactory.type">ManifestFactory</a>.<a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory.manifestOf(5757560000)" title="(st: org.scalatra.swagger.reflect.ScalaType)scala.reflect.Manifest[_]">manifestOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.>:>.that" title="org.scalatra.swagger.reflect.ScalaType">that</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  override def <a title="()Int" id="org.scalatra.swagger.reflect;ManifestScalaType.hashCode">hashCode</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#org.scalatra.swagger.reflect;ManifestScalaType.manifest" title="=&gt; Manifest[_]">manifest</a>.<span title="()Int">##</span>

  override def <a title="(obj: Any)Boolean" id="org.scalatra.swagger.reflect;ManifestScalaType.equals">equals</a><span class="delimiter">(</span><a title="Any" id="org.scalatra.swagger.reflect;ManifestScalaType.equals.obj">obj</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#org.scalatra.swagger.reflect;ManifestScalaType.equals.obj" title="Any">obj</a> match <span class="delimiter">{</span>
    case <a title="org.scalatra.swagger.reflect.ManifestScalaType" id="org.scalatra.swagger.reflect;ManifestScalaType.equals.a">a</a>: <a href="#org.scalatra.swagger.reflect;ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType">ManifestScalaType</a> =&gt; <a href="#org.scalatra.swagger.reflect;ManifestScalaType.manifest" title="=&gt; Manifest[_]">manifest</a> <span title="(x$1: Any)Boolean">==</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.equals.a" title="org.scalatra.swagger.reflect.ManifestScalaType">a</a>.<a href="#org.scalatra.swagger.reflect;ManifestScalaType.manifest" title="=&gt; Manifest[_]">manifest</a>
    case _ =&gt; false
  <span class="delimiter">}</span>

  def <a title="(that: Any)Boolean" id="org.scalatra.swagger.reflect;ManifestScalaType.canEqual">canEqual</a><span class="delimiter">(</span><a title="Any" id="org.scalatra.swagger.reflect;ManifestScalaType.canEqual.that">that</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#org.scalatra.swagger.reflect;ManifestScalaType.canEqual.that" title="Any">that</a> match <span class="delimiter">{</span>
    case <a title="org.scalatra.swagger.reflect.ManifestScalaType" id="org.scalatra.swagger.reflect;ManifestScalaType.canEqual.s">s</a>: <a href="#org.scalatra.swagger.reflect;ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType">ManifestScalaType</a> =&gt; <a href="#org.scalatra.swagger.reflect;ManifestScalaType.manifest" title="=&gt; Manifest[_]">manifest</a>.<span title="(that: Any)Boolean">canEqual</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.canEqual.s" title="org.scalatra.swagger.reflect.ManifestScalaType">s</a>.<a href="#org.scalatra.swagger.reflect;ManifestScalaType.manifest" title="=&gt; Manifest[_]">manifest</a><span class="delimiter">)</span>
    case _ =&gt; false
  <span class="delimiter">}</span>

  def <a title="(erasure: Class[_], typeArgs: Seq[org.scalatra.swagger.reflect.ScalaType], typeVars: Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType])org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect;ManifestScalaType.copy">copy</a><span class="delimiter">(</span><a title="Class[_]" id="org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1">erasure</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span> = <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a>, <a title="Seq[org.scalatra.swagger.reflect.ScalaType]" id="org.scalatra.swagger.reflect;ManifestScalaType.copy$default$2">typeArgs</a>: <span title="Seq[org.scalatra.swagger.reflect.ScalaType]">Seq</span><span class="delimiter">[</span>ScalaType<span class="delimiter">]</span> = <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$2" title="Seq[org.scalatra.swagger.reflect.ScalaType]">typeArgs</a>, <a title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]" id="org.scalatra.swagger.reflect;ManifestScalaType.copy$default$3">typeVars</a>: <span title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">Map</span><span class="delimiter">[</span>TypeVariable<span class="delimiter">[</span>_<span class="delimiter">]</span>, ScalaType<span class="delimiter">]</span> = <a href="#org.scalatra.swagger.reflect;ManifestScalaType._typeVars" title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">_typeVars</a><span class="delimiter">)</span>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a> = <span class="delimiter">{</span>
    <span class="comment">/* optimization */</span>
    if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Int](classOf[scala.Int])" class="delimiter">[</span>Int<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Integer](classOf[java.lang.Integer])" class="delimiter">[</span>java.lang.Integer<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.IntType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">IntType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Long](classOf[scala.Long])" class="delimiter">[</span>Long<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Long](classOf[java.lang.Long])" class="delimiter">[</span>java.lang.Long<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.LongType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">LongType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Byte](classOf[scala.Byte])" class="delimiter">[</span>Byte<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Byte](classOf[java.lang.Byte])" class="delimiter">[</span>java.lang.Byte<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.ByteType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">ByteType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Short](classOf[scala.Short])" class="delimiter">[</span>Short<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Short](classOf[java.lang.Short])" class="delimiter">[</span>java.lang.Short<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.ShortType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">ShortType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Float](classOf[scala.Float])" class="delimiter">[</span>Float<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Float](classOf[java.lang.Float])" class="delimiter">[</span>java.lang.Float<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.FloatType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">FloatType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Double](classOf[scala.Double])" class="delimiter">[</span>Double<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Double](classOf[java.lang.Double])" class="delimiter">[</span>java.lang.Double<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.DoubleType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">DoubleType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[BigInt](classOf[scala.math.BigInt])" class="delimiter">[</span>BigInt<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[java.math.BigInteger](classOf[java.math.BigInteger])" class="delimiter">[</span>java.math.BigInteger<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.BigIntType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">BigIntType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[BigDecimal](classOf[scala.math.BigDecimal])" class="delimiter">[</span>BigDecimal<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[java.math.BigDecimal](classOf[java.math.BigDecimal])" class="delimiter">[</span>java.math.BigDecimal<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.BigDecimalType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">BigDecimalType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Boolean](classOf[scala.Boolean])" class="delimiter">[</span>Boolean<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Boolean](classOf[java.lang.Boolean])" class="delimiter">[</span>java.lang.Boolean<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.BooleanType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">BooleanType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>String<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>java.lang.String<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.StringType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">StringType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[java.util.Date](classOf[java.util.Date])" class="delimiter">[</span>java.util.Date<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.DateType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">DateType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[java.sql.Timestamp](classOf[java.sql.Timestamp])" class="delimiter">[</span>java.sql.Timestamp<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.TimestampType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">TimestampType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Symbol](classOf[scala.Symbol])" class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.SymbolType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">SymbolType</a>
    else if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[Number](classOf[java.lang.Number])" class="delimiter">[</span>Number<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.type">ManifestScalaType</a>.<a href="#org.scalatra.swagger.reflect.ManifestScalaType.NumberType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">NumberType</a>
    <span class="comment">/* end optimization */</span>
    else <span class="delimiter">{</span>
      val <a title="scala.reflect.Manifest[_]" id="org.scalatra.swagger.reflect;ManifestScalaType.copy.mf">mf</a> = <a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory" title="org.scalatra.swagger.reflect.ManifestFactory.type">ManifestFactory</a>.<a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory.manifestOf(c8ffe084e8)" title="(erasure: Class[_], typeArgs: Seq[scala.reflect.Manifest[_]])scala.reflect.Manifest[_]">manifestOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$1" title="Class[_]">erasure</a>, <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$2" title="Seq[org.scalatra.swagger.reflect.ScalaType]">typeArgs</a>.<span title="(f: org.scalatra.swagger.reflect.ScalaType =&gt; scala.reflect.Manifest[_])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[org.scalatra.swagger.reflect.ScalaType],scala.reflect.Manifest[_],Seq[scala.reflect.Manifest[_]]])Seq[scala.reflect.Manifest[_]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scala.reflect.Manifest[_],Seq[scala.reflect.Manifest[_]]]" class="delimiter">(</span><a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory" title="org.scalatra.swagger.reflect.ManifestFactory.type">ManifestFactory</a>.<a href="ManifestFactory.scala.html#org.scalatra.swagger.reflect.ManifestFactory.manifestOf(5757560000)" title="(st: org.scalatra.swagger.reflect.ScalaType)scala.reflect.Manifest[_]">manifestOf</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy.mf.$anonfun.x$10" title="org.scalatra.swagger.reflect.ScalaType">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      val <a title="org.scalatra.swagger.reflect.ManifestScalaType.CopiedManifestScalaType" id="org.scalatra.swagger.reflect;ManifestScalaType.copy.st">st</a> = new <a href="#org.scalatra.swagger.reflect.ManifestScalaType;CopiedManifestScalaType" title="org.scalatra.swagger.reflect.ManifestScalaType.CopiedManifestScalaType">CopiedManifestScalaType</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy.mf" title="scala.reflect.Manifest[_]">mf</a>, <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$3" title="Map[java.lang.reflect.TypeVariable[_],org.scalatra.swagger.reflect.ScalaType]">typeVars</a>, <a href="#org.scalatra.swagger.reflect;ManifestScalaType.isPrimitive" title="=&gt; Boolean">isPrimitive</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy$default$2" title="Seq[org.scalatra.swagger.reflect.ScalaType]">typeArgs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#org.scalatra.swagger.reflect.ManifestScalaType.types" title="=&gt; org.scalatra.swagger.reflect.Memo[scala.reflect.Manifest[_],org.scalatra.swagger.reflect.ScalaType]">types</a>.<a href="package.scala.html#org.scalatra.swagger.reflect.package;Memo.replace" title="(x: scala.reflect.Manifest[_], v: org.scalatra.swagger.reflect.ScalaType)org.scalatra.swagger.reflect.ScalaType">replace</a><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy.mf" title="scala.reflect.Manifest[_]">mf</a>, <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy.st" title="org.scalatra.swagger.reflect.ManifestScalaType.CopiedManifestScalaType">st</a><span class="delimiter">)</span>
      else <a href="#org.scalatra.swagger.reflect;ManifestScalaType.copy.st" title="org.scalatra.swagger.reflect.ManifestScalaType.CopiedManifestScalaType">st</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  override def <a title="()String" id="org.scalatra.swagger.reflect;ManifestScalaType.toString">toString</a>: <span title="String">String</span> = <a href="#org.scalatra.swagger.reflect;ManifestScalaType.simpleName" title="=&gt; String">simpleName</a>
<span class="delimiter">}</span>
case class <a title="class PropertyDescriptor extends AnyRef with org.scalatra.swagger.reflect.Descriptor with Product with Serializable" id="org.scalatra.swagger.reflect.PropertyDescriptor.readResolve">PropertyDescriptor</a><span title="Product" class="delimiter">(</span><a title="String" id="org.scalatra.swagger.reflect;PropertyDescriptor.name">name</a>: <span title="String">String</span>, <a title="String" id="org.scalatra.swagger.reflect;PropertyDescriptor.mangledName">mangledName</a>: <span title="String">String</span>, <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect;PropertyDescriptor.returnType">returnType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a>, <a title="java.lang.reflect.Field" id="org.scalatra.swagger.reflect;PropertyDescriptor.field">field</a>: <span title="java.lang.reflect.Field">Field</span><span class="delimiter">)</span> extends <a href="#org.scalatra.swagger.reflect;Descriptor" title="org.scalatra.swagger.reflect.Descriptor">Descriptor</a> <span class="delimiter">{</span>
  def <a title="(receiver: Any, value: Any)Unit" id="org.scalatra.swagger.reflect;PropertyDescriptor.set">set</a><span class="delimiter">(</span><a title="Any" id="org.scalatra.swagger.reflect;PropertyDescriptor.set.receiver">receiver</a>: <span title="Any">Any</span>, <a title="Any" id="org.scalatra.swagger.reflect;PropertyDescriptor.set.value">value</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <a href="#org.scalatra.swagger.reflect;PropertyDescriptor.field" title="=&gt; java.lang.reflect.Field">field</a>.<span title="(x$1: Any, x$2: Any)Unit">set</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;PropertyDescriptor.set.receiver" title="Any">receiver</a>, <a href="#org.scalatra.swagger.reflect;PropertyDescriptor.set.value" title="Any">value</a><span class="delimiter">)</span>
  def <a title="(receiver: AnyRef)Object" id="org.scalatra.swagger.reflect;PropertyDescriptor.get">get</a><span class="delimiter">(</span><a title="AnyRef" id="org.scalatra.swagger.reflect;PropertyDescriptor.get.receiver">receiver</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span> = <a href="#org.scalatra.swagger.reflect;PropertyDescriptor.field" title="=&gt; java.lang.reflect.Field">field</a>.<span title="(x$1: Any)Object">get</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;PropertyDescriptor.get.receiver" title="AnyRef">receiver</a><span class="delimiter">)</span>

  def <a title="=&gt; Boolean" id="org.scalatra.swagger.reflect;PropertyDescriptor.isPrimitive">isPrimitive</a> = <a href="#org.scalatra.swagger.reflect;PropertyDescriptor.returnType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">returnType</a>.<a href="#org.scalatra.swagger.reflect;ScalaType.isPrimitive" title="=&gt; Boolean">isPrimitive</a>
<span class="delimiter">}</span>
case class <a title="class ConstructorParamDescriptor extends AnyRef with org.scalatra.swagger.reflect.Descriptor with Product with Serializable" id="org.scalatra.swagger.reflect.ConstructorParamDescriptor.readResolve">ConstructorParamDescriptor</a><span title="Product" class="delimiter">(</span><a title="String" id="org.scalatra.swagger.reflect;ConstructorParamDescriptor.name">name</a>: <span title="String">String</span>, <a title="String" id="org.scalatra.swagger.reflect;ConstructorParamDescriptor.mangledName">mangledName</a>: <span title="String">String</span>, <a title="Int" id="org.scalatra.swagger.reflect;ConstructorParamDescriptor.argIndex">argIndex</a>: <span title="Int">Int</span>, <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect;ConstructorParamDescriptor.argType">argType</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a>, <a title="Option[() =&gt; Any]" id="org.scalatra.swagger.reflect;ConstructorParamDescriptor.defaultValue">defaultValue</a>: <span title="Option[() =&gt; Any]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Any<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#org.scalatra.swagger.reflect;Descriptor" title="org.scalatra.swagger.reflect.Descriptor">Descriptor</a> <span class="delimiter">{</span>
  lazy val isOptional = <a href="#org.scalatra.swagger.reflect;ConstructorParamDescriptor.defaultValue" title="=&gt; Option[() =&gt; Any]">defaultValue</a>.<span title="=&gt; Boolean">isDefined</span> <a title="Boolean" id="org.scalatra.swagger.reflect;ConstructorParamDescriptor.isOptional">||</a> <a href="#org.scalatra.swagger.reflect;ConstructorParamDescriptor.isOption" title="=&gt; Boolean">isOption</a>
  def <a title="=&gt; Boolean" id="org.scalatra.swagger.reflect;ConstructorParamDescriptor.isPrimitive">isPrimitive</a> = <a href="#org.scalatra.swagger.reflect;ConstructorParamDescriptor.argType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">argType</a>.<a href="#org.scalatra.swagger.reflect;ScalaType.isPrimitive" title="=&gt; Boolean">isPrimitive</a>
  def <a title="=&gt; Boolean" id="org.scalatra.swagger.reflect;ConstructorParamDescriptor.isMap">isMap</a> = <a href="#org.scalatra.swagger.reflect;ConstructorParamDescriptor.argType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">argType</a>.<a href="#org.scalatra.swagger.reflect;ScalaType.isMap" title="=&gt; Boolean">isMap</a>
  def <a title="=&gt; Boolean" id="org.scalatra.swagger.reflect;ConstructorParamDescriptor.isCollection">isCollection</a> = <a href="#org.scalatra.swagger.reflect;ConstructorParamDescriptor.argType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">argType</a>.<a href="#org.scalatra.swagger.reflect;ScalaType.isCollection" title="=&gt; Boolean">isCollection</a>
  def <a title="=&gt; Boolean" id="org.scalatra.swagger.reflect;ConstructorParamDescriptor.isOption">isOption</a> = <a href="#org.scalatra.swagger.reflect;ConstructorParamDescriptor.argType" title="=&gt; org.scalatra.swagger.reflect.ScalaType">argType</a>.<a href="#org.scalatra.swagger.reflect;ScalaType.isOption" title="=&gt; Boolean">isOption</a>
  def <a title="=&gt; Boolean" id="org.scalatra.swagger.reflect;ConstructorParamDescriptor.isCustom">isCustom</a> = <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ConstructorParamDescriptor.isPrimitive" title="=&gt; Boolean">isPrimitive</a> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect;ConstructorParamDescriptor.isMap" title="=&gt; Boolean">isMap</a> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect;ConstructorParamDescriptor.isCollection" title="=&gt; Boolean">isCollection</a> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra.swagger.reflect;ConstructorParamDescriptor.isOption" title="=&gt; Boolean">isOption</a><span class="delimiter">)</span>
<span class="delimiter">}</span>
case class <a title="class ConstructorDescriptor extends AnyRef with org.scalatra.swagger.reflect.Descriptor with Product with Serializable" id="org.scalatra.swagger.reflect.ConstructorDescriptor.readResolve">ConstructorDescriptor</a><span title="Product" class="delimiter">(</span><a title="Seq[org.scalatra.swagger.reflect.ConstructorParamDescriptor]" id="org.scalatra.swagger.reflect;ConstructorDescriptor.params">params</a>: <span title="Seq[org.scalatra.swagger.reflect.ConstructorParamDescriptor]">Seq</span><span class="delimiter">[</span>ConstructorParamDescriptor<span class="delimiter">]</span>, <a title="java.lang.reflect.Constructor[_]" id="org.scalatra.swagger.reflect;ConstructorDescriptor.constructor">constructor</a>: java.lang.reflect.<span title="java.lang.reflect.Constructor[_]">Constructor</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Boolean" id="org.scalatra.swagger.reflect;ConstructorDescriptor.isPrimary">isPrimary</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> extends <a href="#org.scalatra.swagger.reflect;Descriptor" title="org.scalatra.swagger.reflect.Descriptor">Descriptor</a>
case class <a title="class SingletonDescriptor extends AnyRef with org.scalatra.swagger.reflect.Descriptor with Product with Serializable" id="org.scalatra.swagger.reflect.SingletonDescriptor.readResolve">SingletonDescriptor</a><span title="Product" class="delimiter">(</span><a title="String" id="org.scalatra.swagger.reflect;SingletonDescriptor.simpleName">simpleName</a>: <span title="String">String</span>, <a title="String" id="org.scalatra.swagger.reflect;SingletonDescriptor.fullName">fullName</a>: <span title="String">String</span>, <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect;SingletonDescriptor.erasure">erasure</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a>, <a title="AnyRef" id="org.scalatra.swagger.reflect;SingletonDescriptor.instance">instance</a>: <span title="AnyRef">AnyRef</span>, <a title="Seq[org.scalatra.swagger.reflect.PropertyDescriptor]" id="org.scalatra.swagger.reflect;SingletonDescriptor.properties">properties</a>: <span title="Seq[org.scalatra.swagger.reflect.PropertyDescriptor]">Seq</span><span class="delimiter">[</span>PropertyDescriptor<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#org.scalatra.swagger.reflect;Descriptor" title="org.scalatra.swagger.reflect.Descriptor">Descriptor</a>

trait <a title="trait ObjectDescriptor extends AnyRef with org.scalatra.swagger.reflect.Descriptor" id="org.scalatra.swagger.reflect;ObjectDescriptor">ObjectDescriptor</a> extends <a href="#org.scalatra.swagger.reflect;Descriptor" title="org.scalatra.swagger.reflect.Descriptor">Descriptor</a>
case class <a title="class ClassDescriptor extends AnyRef with org.scalatra.swagger.reflect.ObjectDescriptor with Product with Serializable" id="org.scalatra.swagger.reflect.ClassDescriptor.readResolve">ClassDescriptor</a><span title="Product" class="delimiter">(</span><a title="String" id="org.scalatra.swagger.reflect;ClassDescriptor.simpleName">simpleName</a>: <span title="String">String</span>, <a title="String" id="org.scalatra.swagger.reflect;ClassDescriptor.fullName">fullName</a>: <span title="String">String</span>, <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect;ClassDescriptor.erasure">erasure</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a>, <a title="Option[org.scalatra.swagger.reflect.SingletonDescriptor]" id="org.scalatra.swagger.reflect;ClassDescriptor.companion">companion</a>: <span title="Option[org.scalatra.swagger.reflect.SingletonDescriptor]">Option</span><span class="delimiter">[</span>SingletonDescriptor<span class="delimiter">]</span>, <a title="Seq[org.scalatra.swagger.reflect.ConstructorDescriptor]" id="org.scalatra.swagger.reflect;ClassDescriptor.constructors">constructors</a>: <span title="Seq[org.scalatra.swagger.reflect.ConstructorDescriptor]">Seq</span><span class="delimiter">[</span>ConstructorDescriptor<span class="delimiter">]</span>, <a title="Seq[org.scalatra.swagger.reflect.PropertyDescriptor]" id="org.scalatra.swagger.reflect;ClassDescriptor.properties">properties</a>: <span title="Seq[org.scalatra.swagger.reflect.PropertyDescriptor]">Seq</span><span class="delimiter">[</span>PropertyDescriptor<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#org.scalatra.swagger.reflect;ObjectDescriptor" title="org.scalatra.swagger.reflect.ObjectDescriptor">ObjectDescriptor</a> <span class="delimiter">{</span>
<span class="comment">//    def bestConstructor(argNames: Seq[String]): Option[ConstructorDescriptor] = {</span>
<span class="comment">//      constructors.sortBy(-_.params.size)</span>
<span class="comment">//    }</span>
  lazy val <a title="Seq[org.scalatra.swagger.reflect.ConstructorParamDescriptor]" id="org.scalatra.swagger.reflect;ClassDescriptor.mostComprehensive">mostComprehensive</a>: <span title="Seq[org.scalatra.swagger.reflect.ConstructorParamDescriptor]">Seq</span><span class="delimiter">[</span>ConstructorParamDescriptor<span class="delimiter">]</span> = if <span class="delimiter">(</span><a href="#org.scalatra.swagger.reflect;ClassDescriptor.constructors" title="=&gt; Seq[org.scalatra.swagger.reflect.ConstructorDescriptor]">constructors</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="scala.collection.Seq.type">Seq</span>.<span title="Seq[Nothing]">empty</span> else <a href="#org.scalatra.swagger.reflect;ClassDescriptor.constructors" title="=&gt; Seq[org.scalatra.swagger.reflect.ConstructorDescriptor]">constructors</a>.<span title="(f: org.scalatra.swagger.reflect.ConstructorDescriptor =&gt; Int)(implicit ord: scala.math.Ordering[Int])Seq[org.scalatra.swagger.reflect.ConstructorDescriptor]">sortBy</span><span title="scala.math.Ordering.Int.type" class="delimiter">(</span><span title="=&gt; Int">-</span><a href="#org.scalatra.swagger.reflect;ClassDescriptor.mostComprehensive.$anonfun.x$11" title="org.scalatra.swagger.reflect.ConstructorDescriptor">_</a>.<a href="#org.scalatra.swagger.reflect;ConstructorDescriptor.params" title="=&gt; Seq[org.scalatra.swagger.reflect.ConstructorParamDescriptor]">params</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>.<span title="=&gt; org.scalatra.swagger.reflect.ConstructorDescriptor">head</span>.<a href="#org.scalatra.swagger.reflect;ConstructorDescriptor.params" title="=&gt; Seq[org.scalatra.swagger.reflect.ConstructorParamDescriptor]">params</a>
<span class="delimiter">}</span>
case class <a title="class PrimitiveDescriptor extends AnyRef with org.scalatra.swagger.reflect.ObjectDescriptor with Product with Serializable" id="org.scalatra.swagger.reflect.PrimitiveDescriptor.readResolve">PrimitiveDescriptor</a><span title="Product" class="delimiter">(</span><a title="String" id="org.scalatra.swagger.reflect;PrimitiveDescriptor.simpleName">simpleName</a>: <span title="String">String</span>, <a title="String" id="org.scalatra.swagger.reflect;PrimitiveDescriptor.fullName">fullName</a>: <span title="String">String</span>, <a title="org.scalatra.swagger.reflect.ScalaType" id="org.scalatra.swagger.reflect;PrimitiveDescriptor.erasure">erasure</a>: <a href="#org.scalatra.swagger.reflect;ScalaType" title="org.scalatra.swagger.reflect.ScalaType">ScalaType</a><span class="delimiter">)</span> extends <a href="#org.scalatra.swagger.reflect;ObjectDescriptor" title="org.scalatra.swagger.reflect.ObjectDescriptor">ObjectDescriptor</a> <span class="delimiter">{</span>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>
