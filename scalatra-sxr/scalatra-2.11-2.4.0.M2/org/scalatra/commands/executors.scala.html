<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>org/scalatra/commands/executors.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package org.scalatra.commands

import scalaz._
import syntax.<span title="scalaz.syntax.validation.type">validation</span>._
import org.scalatra.validation._
import grizzled.slf4j.Logger
import mojolly.inflector.<span title="mojolly.inflector.InflectorImports.type">InflectorImports</span>._
import annotation.implicitNotFound
import scala.util.<span class="delimiter">{</span>Failure =&gt; Fail, Success =&gt; Succ, Try<span class="delimiter">}</span>
import scalaz.Failure
import scala.concurrent.<span class="delimiter">{</span>ExecutionContext, Future<span class="delimiter">}</span>

trait <a title="trait CommandExecutors extends AnyRef" id="org.scalatra.commands;CommandExecutors">CommandExecutors</a> <span title="Unit" class="delimiter">{</span>

  implicit def <a title="[T &lt;: org.scalatra.commands.Command, S](handler: T =&gt; org.scalatra.commands.ModelValidation[S])org.scalatra.commands.CommandExecutor[T,org.scalatra.commands.ModelValidation[S]]" id="org.scalatra.commands;CommandExecutors.syncExecutor">syncExecutor</a><span class="delimiter">[</span><a title=" &lt;: org.scalatra.commands.Command" id="org.scalatra.commands;CommandExecutors.syncExecutor;T">T</a> &lt;: Command, <a title="" id="org.scalatra.commands;CommandExecutors.syncExecutor;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; org.scalatra.commands.ModelValidation[S]" id="org.scalatra.commands;CommandExecutors.syncExecutor.handler">handler</a>: T =&gt; ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.scalatra.commands;CommandExecutor" title="org.scalatra.commands.CommandExecutor[T,org.scalatra.commands.ModelValidation[S]]">CommandExecutor</a><span class="delimiter">[</span>T, ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span> =
    new <a href="#org.scalatra.commands;BlockingCommandExecutor" title="org.scalatra.commands.BlockingCommandExecutor[T,S]">BlockingCommandExecutor</a><span class="delimiter">(</span><a href="#org.scalatra.commands;CommandExecutors.syncExecutor.handler" title="T =&gt; org.scalatra.commands.ModelValidation[S]">handler</a><span class="delimiter">)</span>

  implicit def <a title="[T &lt;: org.scalatra.commands.Command, S](handler: S =&gt; org.scalatra.commands.ModelValidation[S])(implicit evidence$1: T =&gt; S)org.scalatra.commands.CommandExecutor[T,org.scalatra.commands.ModelValidation[S]]" id="org.scalatra.commands;CommandExecutors.syncModelExecutor">syncModelExecutor</a><span class="delimiter">[</span><a title=" &lt;: org.scalatra.commands.Command" id="org.scalatra.commands;CommandExecutors.syncModelExecutor;T">T</a> &lt;: Command &lt;% S, <a title="" id="org.scalatra.commands;CommandExecutors.syncModelExecutor;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S =&gt; org.scalatra.commands.ModelValidation[S]" id="org.scalatra.commands;CommandExecutors.syncModelExecutor.handler">handler</a>: S =&gt; ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.scalatra.commands;CommandExecutor" title="org.scalatra.commands.CommandExecutor[T,org.scalatra.commands.ModelValidation[S]]">CommandExecutor</a><span class="delimiter">[</span>T, ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span> =
    new <a href="#org.scalatra.commands;BlockingModelExecutor" title="org.scalatra.commands.BlockingModelExecutor[T,S]">BlockingModelExecutor</a><span class="delimiter">[</span>T, S<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.scalatra.commands;CommandExecutors.syncModelExecutor.handler" title="S =&gt; org.scalatra.commands.ModelValidation[S]">handler</a><span class="delimiter">)</span>

  implicit def <a title="[T &lt;: org.scalatra.commands.Command, S](handler: T =&gt; scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]])(implicit executionContext: scala.concurrent.ExecutionContext)org.scalatra.commands.CommandExecutor[T,scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]]" id="org.scalatra.commands;CommandExecutors.asyncExecutor">asyncExecutor</a><span class="delimiter">[</span><a title=" &lt;: org.scalatra.commands.Command" id="org.scalatra.commands;CommandExecutors.asyncExecutor;T">T</a> &lt;: Command, <a title="" id="org.scalatra.commands;CommandExecutors.asyncExecutor;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]" id="org.scalatra.commands;CommandExecutors.asyncExecutor.handler">handler</a>: T =&gt; Future<span class="delimiter">[</span>ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="org.scalatra.commands;CommandExecutors.asyncExecutor.executionContext">executionContext</a>: <span title="scala.concurrent.ExecutionContext">ExecutionContext</span><span class="delimiter">)</span>: <a href="#org.scalatra.commands;CommandExecutor" title="org.scalatra.commands.CommandExecutor[T,scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]]">CommandExecutor</a><span class="delimiter">[</span>T, Future<span class="delimiter">[</span>ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
    new <a href="#org.scalatra.commands;AsyncCommandExecutor" title="org.scalatra.commands.AsyncCommandExecutor[T,S]">AsyncCommandExecutor</a><span class="delimiter">(</span><a href="#org.scalatra.commands;CommandExecutors.asyncExecutor.handler" title="T =&gt; scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]">handler</a><span class="delimiter">)</span>

  implicit def <a title="[T &lt;: org.scalatra.commands.Command, S](handler: S =&gt; scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]])(implicit executionContext: scala.concurrent.ExecutionContext, implicit vw: T =&gt; S)org.scalatra.commands.CommandExecutor[T,scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]]" id="org.scalatra.commands;CommandExecutors.asyncModelExecutor">asyncModelExecutor</a><span class="delimiter">[</span><a title=" &lt;: org.scalatra.commands.Command" id="org.scalatra.commands;CommandExecutors.asyncModelExecutor;T">T</a> &lt;: Command, <a title="" id="org.scalatra.commands;CommandExecutors.asyncModelExecutor;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S =&gt; scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]" id="org.scalatra.commands;CommandExecutors.asyncModelExecutor.handler">handler</a>: S =&gt; Future<span class="delimiter">[</span>ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="org.scalatra.commands;CommandExecutors.asyncModelExecutor.executionContext">executionContext</a>: <span title="scala.concurrent.ExecutionContext">ExecutionContext</span>, <a title="T =&gt; S" id="org.scalatra.commands;CommandExecutors.asyncModelExecutor.vw">vw</a>: T =&gt; S<span class="delimiter">)</span>: <a href="#org.scalatra.commands;CommandExecutor" title="org.scalatra.commands.CommandExecutor[T,scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]]">CommandExecutor</a><span class="delimiter">[</span>T, Future<span class="delimiter">[</span>ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
    new <a href="#org.scalatra.commands;AsyncModelExecutor" title="org.scalatra.commands.AsyncModelExecutor[T,S]">AsyncModelExecutor</a><span class="delimiter">[</span>T, S<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.scalatra.commands;CommandExecutors.asyncModelExecutor.handler" title="S =&gt; scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]">handler</a><span class="delimiter">)</span>

<span class="delimiter">}</span>

object <a title="org.scalatra.commands.CommandExecutors.type" id="org.scalatra.commands.CommandExecutors">CommandExecutors</a> extends <a href="#org.scalatra.commands;CommandExecutors" title="org.scalatra.commands.CommandExecutors">CommandExecutors</a>



<span class="comment">/**
 * A typeclass for executing commands. This allows for picking an executor based on the return type of the
 * method that is used to handle the command.
 *
 * @param handler The function to handle the command
 * @tparam T The command type
 * @tparam S The result type of executing the command
 */</span>
@implicitNotFound<span class="delimiter">(</span>
  <span class="string">&quot;Couldn't find an executor for command of type ${T} and result of type ${S}. Did you import org.scalatra.commands.CommandExecutors._ ? You can also implement your own org.scalatra.CommandExecutor.&quot;</span>
<span class="delimiter">)</span>
abstract class <a title="class CommandExecutor[T &lt;: org.scalatra.commands.Command, S] extends AnyRef" id="org.scalatra.commands;CommandExecutor">CommandExecutor</a><span class="delimiter">[</span><a title=" &lt;: org.scalatra.commands.Command" id="org.scalatra.commands;CommandExecutor;T">T</a> &lt;: Command, <a title="" id="org.scalatra.commands;CommandExecutor;S">S</a><span class="delimiter">]</span><a href="#org.scalatra.commands;CommandExecutor" title="org.scalatra.commands.CommandExecutor[T,S]" class="delimiter">(</a><a title="T =&gt; S" id="org.scalatra.commands;CommandExecutor.handler">handler</a>: T =&gt; S<span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(command: T)S" id="org.scalatra.commands;CommandExecutor.execute">execute</a><span class="delimiter">(</span><a title="T" id="org.scalatra.commands;CommandExecutor.execute.command">command</a>: <a href="#org.scalatra.commands;CommandExecutor;T" title="T">T</a><span class="delimiter">)</span>: <a href="#org.scalatra.commands;CommandExecutor;S" title="S">S</a>
<span class="delimiter">}</span>

abstract class <a title="class BlockingExecutor[T &lt;: org.scalatra.commands.Command, S] extends org.scalatra.commands.CommandExecutor[T,org.scalatra.commands.ModelValidation[S]]" id="org.scalatra.commands;BlockingExecutor">BlockingExecutor</a><span class="delimiter">[</span><a title=" &lt;: org.scalatra.commands.Command" id="org.scalatra.commands;BlockingExecutor;T">T</a> &lt;: Command, <a title="" id="org.scalatra.commands;BlockingExecutor;S">S</a><span class="delimiter">]</span><a href="#org.scalatra.commands;BlockingExecutor" title="org.scalatra.commands.BlockingExecutor[T,S]" class="delimiter">(</a><a title="T =&gt; org.scalatra.commands.ModelValidation[S]" id="org.scalatra.commands;BlockingExecutor.handle">handle</a>: T =&gt; ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#org.scalatra.commands;CommandExecutor" title="org.scalatra.commands.CommandExecutor[T,org.scalatra.commands.ModelValidation[S]]">CommandExecutor</a><span class="delimiter">[</span>T, ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.scalatra.commands;BlockingExecutor.handle" title="T =&gt; org.scalatra.commands.ModelValidation[S]">handle</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  @transient private<span class="delimiter">[</span>this<span class="delimiter">]</span> val <a title="grizzled.slf4j.Logger" id="org.scalatra.commands;BlockingExecutor.logger">logger</a> = <span title="(cls: Class[_])grizzled.slf4j.Logger">Logger</span><span class="delimiter">(</span><a href="#org.scalatra.commands;BlockingExecutor" title="()Class[_]">getClass</a><span class="delimiter">)</span>

  def <a title="(cmd: T)org.scalatra.commands.ModelValidation[S]" id="org.scalatra.commands;BlockingExecutor.execute">execute</a><span class="delimiter">(</span><a title="T" id="org.scalatra.commands;BlockingExecutor.execute.cmd">cmd</a>: <a href="#org.scalatra.commands;BlockingExecutor;T" title="T">T</a><span class="delimiter">)</span>: <span title="org.scalatra.commands.ModelValidation[S]">ModelValidation</span><span class="delimiter">[</span>S<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#org.scalatra.commands;BlockingExecutor.logger" title="grizzled.slf4j.Logger">logger</a>.<span title="(msg: =&gt; Any)Unit">debug</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Executing [&quot;)">Executing [$</span><span class="delimiter">{</span><a href="#org.scalatra.commands;BlockingExecutor.execute.cmd" title="T">cmd</a>.<span title="()Class[_]">getClass</span>.<span title="()String">getName</span><span class="delimiter">}</span><span title="String(&quot;].\\n&quot;)">].\n$</span><a href="#org.scalatra.commands;BlockingExecutor.execute.cmd" title="T">cmd</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#org.scalatra.commands;BlockingExecutor.execute.cmd" title="T">cmd</a>.<a href="Command.scala.html#org.scalatra.commands;Command.isValid" title="=&gt; Boolean">isValid</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="scala.util.Try[org.scalatra.commands.ModelValidation[S]]" id="org.scalatra.commands;BlockingExecutor.execute.res">res</a> = <span title="(r: =&gt; org.scalatra.commands.ModelValidation[S])scala.util.Try[org.scalatra.commands.ModelValidation[S]]">Try</span><span class="delimiter">(</span><a href="#org.scalatra.commands;BlockingExecutor.handle" title="(v1: T)org.scalatra.commands.ModelValidation[S]">handle</a><span class="delimiter">(</span><a href="#org.scalatra.commands;BlockingExecutor.execute.cmd" title="T">cmd</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="#org.scalatra.commands;BlockingExecutor.execute.res" title="scala.util.Try[org.scalatra.commands.ModelValidation[S]]">res</a> match <span class="delimiter">{</span>
        case Succ<span class="delimiter">(</span><a title="org.scalatra.commands.ModelValidation[S]" id="org.scalatra.commands;BlockingExecutor.execute.r">r</a><span class="delimiter">)</span> ⇒
          def <a title="(count: Int)String" id="org.scalatra.commands;BlockingExecutor.execute.plur">plur</a><span class="delimiter">(</span><a title="Int" id="org.scalatra.commands;BlockingExecutor.execute.plur.count">count</a>: <span title="Int">Int</span><span class="delimiter">)</span> = if <span class="delimiter">(</span><a href="#org.scalatra.commands;BlockingExecutor.execute.plur.count" title="Int">count</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="String(&quot;failure&quot;)" class="string">&quot;failure&quot;</span> else <span title="String(&quot;failures&quot;)" class="string">&quot;failures&quot;</span>
          val <a title="String" id="org.scalatra.commands;BlockingExecutor.execute.resultLog">resultLog</a> = <a href="#org.scalatra.commands;BlockingExecutor.execute.r" title="org.scalatra.commands.ModelValidation[S]">r</a>.<span title="(fail: scalaz.NonEmptyList[org.scalatra.validation.ValidationError] =&gt; String, succ: S =&gt; String)String">fold</span><span class="delimiter">(</span>
            <span class="delimiter">{</span> <a title="scalaz.NonEmptyList[org.scalatra.validation.ValidationError]" id="org.scalatra.commands;BlockingExecutor.execute.resultLog.$anonfun.failures">failures</a> ⇒ <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;with &quot;)">with $</span><span class="delimiter">{</span><a href="#org.scalatra.commands;BlockingExecutor.execute.resultLog.$anonfun.failures" title="scalaz.NonEmptyList[org.scalatra.validation.ValidationError]">failures</a>.<span title="=&gt; List[org.scalatra.validation.ValidationError]">tail</span>.<span title="=&gt; Int">size</span> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">}</span><span title="String(&quot; &quot;)"> $</span><span class="delimiter">{</span><a href="#org.scalatra.commands;BlockingExecutor.execute.resultLog.$anonfun.failures" title="scalaz.NonEmptyList[org.scalatra.validation.ValidationError]">failures</a>.<span title="=&gt; List[org.scalatra.validation.ValidationError]">list</span>.<span title="=&gt; Int">size</span><span class="delimiter">}</span><span title="String(&quot;\\n&quot;)">\n$</span><span class="delimiter">{</span><a href="#org.scalatra.commands;BlockingExecutor.execute.resultLog.$anonfun.failures" title="scalaz.NonEmptyList[org.scalatra.validation.ValidationError]">failures</a>.<span title="=&gt; List[org.scalatra.validation.ValidationError]">list</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span> <span class="delimiter">}</span>,
            <span class="delimiter">{</span> <a title="S" id="org.scalatra.commands;BlockingExecutor.execute.resultLog.$anonfun.x$1">_</a> ⇒ <span title="String(&quot;successfully&quot;)" class="string">&quot;successfully&quot;</span> <span class="delimiter">}</span><span class="delimiter">)</span>
          <a href="#org.scalatra.commands;BlockingExecutor.logger" title="grizzled.slf4j.Logger">logger</a>.<span title="(msg: =&gt; Any)Unit">debug</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Command [&quot;)">Command [$</span><span class="delimiter">{</span><a href="#org.scalatra.commands;BlockingExecutor.execute.cmd" title="T">cmd</a>.<span title="()Class[_]">getClass</span>.<span title="()String">getName</span><span class="delimiter">}</span><span title="String(&quot;] executed &quot;)">] executed $</span><a href="#org.scalatra.commands;BlockingExecutor.execute.resultLog" title="String">resultLog</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
          <a href="#org.scalatra.commands;BlockingExecutor.execute.r" title="org.scalatra.commands.ModelValidation[S]">r</a>
        case Fail<span class="delimiter">(</span><a title="Throwable" id="org.scalatra.commands;BlockingExecutor.execute.t">t</a><span class="delimiter">)</span> ⇒
          <a href="#org.scalatra.commands;BlockingExecutor.logger" title="grizzled.slf4j.Logger">logger</a>.<span title="(msg: =&gt; Any, t: =&gt; Throwable)Unit">error</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Command [&quot;)">Command [$</span><span class="delimiter">{</span><a href="#org.scalatra.commands;BlockingExecutor.execute.cmd" title="T">cmd</a>.<span title="()Class[_]">getClass</span>.<span title="()String">getName</span><span class="delimiter">}</span><span title="String(&quot;] failed.&quot;)" class="string">] failed.&quot;</span>, <a href="#org.scalatra.commands;BlockingExecutor.execute.t" title="Throwable">t</a><span class="delimiter">)</span>
          <a href="../validation/ValidationError.scala.html#org.scalatra.validation.ValidationError.apply(a5c7fc7b86)" title="(msg: String, arguments: Any*)org.scalatra.validation.ValidationError">ValidationError</a><span title="(a: org.scalatra.validation.ValidationError)scalaz.syntax.ValidationOps[org.scalatra.validation.ValidationError]" class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Failed to execute &quot;)">Failed to execute $</span><span class="delimiter">{</span><a href="#org.scalatra.commands;BlockingExecutor.execute.cmd" title="T">cmd</a>.<span title="()Class[_]">getClass</span>.<span title="implicit mojolly.inflector.InflectorImports.string2InflectorString : (word: String)mojolly.inflector.Inflector.InflectorString">getSimpleName</span>.<span title="implicit mojolly.inflector.InflectorImports.string2InflectorString : (word: String)mojolly.inflector.Inflector.InflectorString">underscore</span>.<span title="=&gt; String">humanize</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span>, <a href="../validation/ValidationError.scala.html#org.scalatra.validation.UnknownError" title="org.scalatra.validation.UnknownError.type">UnknownError</a><span class="delimiter">)</span>.<span title="[X]=&gt; scalaz.ValidationNel[org.scalatra.validation.ValidationError,X]">failNel</span><span title="scalaz.ValidationNel[org.scalatra.validation.ValidationError,S]" class="delimiter">[</span><a href="#org.scalatra.commands;BlockingExecutor;S" title="S">S</a><span class="delimiter">]</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      val f = <a href="#org.scalatra.commands;BlockingExecutor.execute.cmd" title="T">cmd</a>.<a href="Command.scala.html#org.scalatra.commands;Command.errors" title="=&gt; Seq[org.scalatra.commands.Binding]">errors</a>.<span title="(f: org.scalatra.commands.Binding =&gt; scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[org.scalatra.commands.Binding],scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T],Seq[scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T]]])Seq[scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T],Seq[scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T]]]" class="delimiter">(</span><a href="#org.scalatra.commands;BlockingExecutor.execute.f.$anonfun.x$2" title="org.scalatra.commands.Binding">_</a>.<a href="binding.scala.html#org.scalatra.commands;Binding.validation" title="=&gt; org.scalatra.commands.FieldValidation[x$2.T]">validation</a><span class="delimiter">)</span> <a title="Seq[org.scalatra.validation.ValidationError]" id="org.scalatra.commands;BlockingExecutor.execute.f">collect</a> <a title="&lt;$anon: scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T] =&gt; org.scalatra.validation.ValidationError&gt; extends scala.runtime.AbstractPartialFunction[scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T],org.scalatra.validation.ValidationError] with Serializable" id="org.scalatra.commands;BlockingExecutor.execute.f;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
        case Failure<span class="delimiter">(</span><a title="org.scalatra.validation.ValidationError" id="org.scalatra.commands;BlockingExecutor.execute.f;$anonfun.isDefinedAt.e">e</a><span class="delimiter">)</span> ⇒ <a href="#org.scalatra.commands;BlockingExecutor.execute.f;$anonfun.isDefinedAt.e" title="org.scalatra.validation.ValidationError">e</a>
      <span class="delimiter">}</span>
      def <a title="=&gt; String" id="org.scalatra.commands;BlockingExecutor.execute.failures">failures</a> = if <span class="delimiter">(</span><a href="#org.scalatra.commands;BlockingExecutor.execute.f" title="Seq[org.scalatra.validation.ValidationError]">f</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="String(&quot;failure&quot;)" class="string">&quot;failure&quot;</span> else <span title="String(&quot;failures&quot;)" class="string">&quot;failures&quot;</span>
      <a href="#org.scalatra.commands;BlockingExecutor.logger" title="grizzled.slf4j.Logger">logger</a>.<span title="(msg: =&gt; Any)Unit">debug</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Command [&quot;)">Command [$</span><span class="delimiter">{</span><a href="#org.scalatra.commands;BlockingExecutor.execute.cmd" title="T">cmd</a>.<span title="()Class[_]">getClass</span>.<span title="()String">getName</span><span class="delimiter">}</span><span title="String(&quot;}] executed with &quot;)">}] executed with $</span><span class="delimiter">{</span><a href="#org.scalatra.commands;BlockingExecutor.execute.f" title="Seq[org.scalatra.validation.ValidationError]">f</a>.<span title="=&gt; Int">size</span><span class="delimiter">}</span><span title="String(&quot; &quot;)"> $</span><a href="#org.scalatra.commands;BlockingExecutor.execute.failures" title="=&gt; String">failures</a><span title="String(&quot;.\\n&quot;)">.\n$</span><span class="delimiter">{</span><a href="#org.scalatra.commands;BlockingExecutor.execute.f" title="Seq[org.scalatra.validation.ValidationError]">f</a>.<span title="=&gt; List[org.scalatra.validation.ValidationError]">toList</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
      <span title="(h: org.scalatra.validation.ValidationError, t: org.scalatra.validation.ValidationError*)scalaz.NonEmptyList[org.scalatra.validation.ValidationError]">NonEmptyList</span><span title="(a: scalaz.NonEmptyList[org.scalatra.validation.ValidationError])scalaz.syntax.ValidationOps[scalaz.NonEmptyList[org.scalatra.validation.ValidationError]]" class="delimiter">(</span><a href="#org.scalatra.commands;BlockingExecutor.execute.f" title="Seq[org.scalatra.validation.ValidationError]">f</a>.<span title="=&gt; org.scalatra.validation.ValidationError">head</span>, <a href="#org.scalatra.commands;BlockingExecutor.execute.f" title="Seq[org.scalatra.validation.ValidationError]">f</a>.<span title="=&gt; Seq[org.scalatra.validation.ValidationError]">tail</span>: _*<span class="delimiter">)</span>.<span title="scalaz.Validation[scalaz.NonEmptyList[org.scalatra.validation.ValidationError],Nothing]">fail</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * A command executor that can potentially block while executing the command
 *
 * @see [[org.scalatra.commands.CommandExecutor]]
 *
 * @param handle The function that takes a command and returns a [[org.scalatra.commands.ModelValidation]]
 * @tparam T The type of command to handle
 * @tparam S The success result type
 */</span>
class <a title="class BlockingCommandExecutor[T &lt;: org.scalatra.commands.Command, S] extends org.scalatra.commands.BlockingExecutor[T,S]" id="org.scalatra.commands;BlockingCommandExecutor">BlockingCommandExecutor</a><span class="delimiter">[</span><a title=" &lt;: org.scalatra.commands.Command" id="org.scalatra.commands;BlockingCommandExecutor;T">T</a> &lt;: Command, <a title="" id="org.scalatra.commands;BlockingCommandExecutor;S">S</a><span class="delimiter">]</span><a href="#org.scalatra.commands;BlockingCommandExecutor" title="org.scalatra.commands.BlockingCommandExecutor[T,S]" class="delimiter">(</a><a title="T =&gt; org.scalatra.commands.ModelValidation[S]" id="org.scalatra.commands;BlockingCommandExecutor.handle">handle</a>: T =&gt; ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#org.scalatra.commands;BlockingExecutor" title="org.scalatra.commands.BlockingExecutor[T,S]">BlockingExecutor</a><span class="delimiter">(</span><a href="#org.scalatra.commands;BlockingCommandExecutor.handle" title="T =&gt; org.scalatra.commands.ModelValidation[S]">handle</a><span class="delimiter">)</span>

<span class="comment">/**
 * A command executor that can potentially block while executing the command, uses a model as input value for the handler function.
 * This command requires an implicit conversion from command to model to be in scope ie.: by defining it in the companion
 * object of the command.
 *
 * @see [[org.scalatra.commands.CommandExecutor]]
 *
 * @param handle The function that takes a model and returns a [[org.scalatra.commands.ModelValidation]],
 *               requires an implicit conversion from command to model to be in scope
 * @tparam T The type of model
 * @tparam S The success result type
 */</span>
class <a title="class BlockingModelExecutor[T &lt;: org.scalatra.commands.Command, S] extends org.scalatra.commands.BlockingExecutor[T,S]" id="org.scalatra.commands;BlockingModelExecutor">BlockingModelExecutor</a><span class="delimiter">[</span><a title=" &lt;: org.scalatra.commands.Command" id="org.scalatra.commands;BlockingModelExecutor;T">T</a> &lt;: Command &lt;% S, <a title="" id="org.scalatra.commands;BlockingModelExecutor;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S =&gt; org.scalatra.commands.ModelValidation[S]" id="org.scalatra.commands;BlockingModelExecutor.handle">handle</a>: S =&gt; ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#org.scalatra.commands;BlockingExecutor" title="org.scalatra.commands.BlockingExecutor[T,S]">BlockingExecutor</a><span class="delimiter">[</span>T, S<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.scalatra.commands;BlockingModelExecutor.handle" title="(v1: S)org.scalatra.commands.ModelValidation[S]">handle</a><span class="delimiter">(</span><a href="#org.scalatra.commands;BlockingModelExecutor.evidence$2" title="(v1: T)S">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

abstract class <a title="class AsyncExecutor[T &lt;: org.scalatra.commands.Command, S] extends org.scalatra.commands.CommandExecutor[T,scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]]" id="org.scalatra.commands;AsyncExecutor">AsyncExecutor</a><span class="delimiter">[</span><a title=" &lt;: org.scalatra.commands.Command" id="org.scalatra.commands;AsyncExecutor;T">T</a> &lt;: Command, <a title="" id="org.scalatra.commands;AsyncExecutor;S">S</a><span class="delimiter">]</span><a href="#org.scalatra.commands;AsyncExecutor" title="org.scalatra.commands.AsyncExecutor[T,S]" class="delimiter">(</a><a title="T =&gt; scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]" id="org.scalatra.commands;AsyncExecutor.handle">handle</a>: T =&gt; Future<span class="delimiter">[</span>ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="org.scalatra.commands;AsyncExecutor.executionContext">executionContext</a>: <span title="scala.concurrent.ExecutionContext">ExecutionContext</span><span class="delimiter">)</span> extends <a href="#org.scalatra.commands;CommandExecutor" title="org.scalatra.commands.CommandExecutor[T,scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]]">CommandExecutor</a><span class="delimiter">[</span>T, Future<span class="delimiter">[</span>ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.scalatra.commands;AsyncExecutor.handle" title="T =&gt; scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]">handle</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  @transient private<span class="delimiter">[</span>this<span class="delimiter">]</span> val <a title="grizzled.slf4j.Logger" id="org.scalatra.commands;AsyncExecutor.logger">logger</a> = <span title="(cls: Class[_])grizzled.slf4j.Logger">Logger</span><span class="delimiter">(</span><a href="#org.scalatra.commands;AsyncExecutor" title="()Class[_]">getClass</a><span class="delimiter">)</span>
  def <a title="(cmd: T)scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]" id="org.scalatra.commands;AsyncExecutor.execute">execute</a><span class="delimiter">(</span><a title="T" id="org.scalatra.commands;AsyncExecutor.execute.cmd">cmd</a>: <a href="#org.scalatra.commands;AsyncExecutor;T" title="T">T</a><span class="delimiter">)</span>: <span title="scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]">Future</span><span class="delimiter">[</span>ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#org.scalatra.commands;AsyncExecutor.logger" title="grizzled.slf4j.Logger">logger</a>.<span title="(msg: =&gt; Any)Unit">debug</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Executing [&quot;)">Executing [$</span><span class="delimiter">{</span><a href="#org.scalatra.commands;AsyncExecutor.execute.cmd" title="T">cmd</a>.<span title="()Class[_]">getClass</span>.<span title="()String">getName</span><span class="delimiter">}</span><span title="String(&quot;].\\n&quot;)">].\n$</span><a href="#org.scalatra.commands;AsyncExecutor.execute.cmd" title="T">cmd</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#org.scalatra.commands;AsyncExecutor.execute.cmd" title="T">cmd</a>.<a href="Command.scala.html#org.scalatra.commands;Command.isValid" title="=&gt; Boolean">isValid</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]" id="org.scalatra.commands;AsyncExecutor.execute.res">res</a> = <a href="#org.scalatra.commands;AsyncExecutor.handle" title="(v1: T)scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]">handle</a><span class="delimiter">(</span><a href="#org.scalatra.commands;AsyncExecutor.execute.cmd" title="T">cmd</a><span class="delimiter">)</span>

      <a href="#org.scalatra.commands;AsyncExecutor.execute.res" title="scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]">res</a> <a href="#org.scalatra.commands;AsyncExecutor.executionContext" title="(pf: PartialFunction[org.scalatra.commands.ModelValidation[S],Unit])(implicit executor: scala.concurrent.ExecutionContext)Unit">onSuccess</a> <span title="&lt;$anon: org.scalatra.commands.ModelValidation[S] =&gt; Unit&gt; extends scala.runtime.AbstractPartialFunction[org.scalatra.commands.ModelValidation[S],Unit] with Serializable" class="delimiter">{</span>
        case <a title="org.scalatra.commands.ModelValidation[S]" id="org.scalatra.commands;AsyncExecutor.execute;$anonfun.isDefinedAt.r">r</a> ⇒
          def <a title="(count: Int)String" id="org.scalatra.commands;AsyncExecutor.execute;$anonfun.applyOrElse.plur">plur</a><span class="delimiter">(</span><a title="Int" id="org.scalatra.commands;AsyncExecutor.execute;$anonfun.applyOrElse.plur.count">count</a>: <span title="Int">Int</span><span class="delimiter">)</span> = if <span class="delimiter">(</span><a href="#org.scalatra.commands;AsyncExecutor.execute;$anonfun.applyOrElse.plur.count" title="Int">count</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="String(&quot;failure&quot;)" class="string">&quot;failure&quot;</span> else <span title="String(&quot;failures&quot;)" class="string">&quot;failures&quot;</span>
          val <a title="String" id="org.scalatra.commands;AsyncExecutor.execute;$anonfun.applyOrElse.resultLog">resultLog</a> = <a href="#org.scalatra.commands;AsyncExecutor.execute;$anonfun.isDefinedAt.r" title="org.scalatra.commands.ModelValidation[S]">r</a>.<span title="(fail: scalaz.NonEmptyList[org.scalatra.validation.ValidationError] =&gt; String, succ: S =&gt; String)String">fold</span><span class="delimiter">(</span>
            <span class="delimiter">{</span> <a title="scalaz.NonEmptyList[org.scalatra.validation.ValidationError]" id="org.scalatra.commands;AsyncExecutor.execute;$anonfun.applyOrElse.resultLog.$anonfun.failures">failures</a> ⇒ <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;with &quot;)">with $</span><span class="delimiter">{</span><a href="#org.scalatra.commands;AsyncExecutor.execute;$anonfun.applyOrElse.resultLog.$anonfun.failures" title="scalaz.NonEmptyList[org.scalatra.validation.ValidationError]">failures</a>.<span title="=&gt; List[org.scalatra.validation.ValidationError]">list</span>.<span title="=&gt; Int">size</span><span class="delimiter">}</span><span title="String(&quot; &quot;)"> $</span><span class="delimiter">{</span><a href="#org.scalatra.commands;AsyncExecutor.execute;$anonfun.applyOrElse.plur" title="(count: Int)String">plur</a><span class="delimiter">(</span><a href="#org.scalatra.commands;AsyncExecutor.execute;$anonfun.applyOrElse.resultLog.$anonfun.failures" title="scalaz.NonEmptyList[org.scalatra.validation.ValidationError]">failures</a>.<span title="=&gt; List[org.scalatra.validation.ValidationError]">list</span>.<span title="=&gt; Int">size</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;.\\n&quot;)">.\n$</span><span class="delimiter">{</span><a href="#org.scalatra.commands;AsyncExecutor.execute;$anonfun.applyOrElse.resultLog.$anonfun.failures" title="scalaz.NonEmptyList[org.scalatra.validation.ValidationError]">failures</a>.<span title="=&gt; List[org.scalatra.validation.ValidationError]">list</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span> <span class="delimiter">}</span>,
            <span class="delimiter">{</span> <a title="S" id="org.scalatra.commands;AsyncExecutor.execute;$anonfun.applyOrElse.resultLog.$anonfun.x$4">_</a> ⇒ <span title="String(&quot;successfully&quot;)" class="string">&quot;successfully&quot;</span> <span class="delimiter">}</span><span class="delimiter">)</span>
          <a href="#org.scalatra.commands;AsyncExecutor.logger" title="grizzled.slf4j.Logger">logger</a>.<span title="(msg: =&gt; Any)Unit">debug</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Command [&quot;)">Command [$</span><span class="delimiter">{</span><a href="#org.scalatra.commands;AsyncExecutor.execute.cmd" title="T">cmd</a>.<span title="()Class[_]">getClass</span>.<span title="()String">getName</span><span class="delimiter">}</span><span title="String(&quot;] executed &quot;)">] executed $</span><a href="#org.scalatra.commands;AsyncExecutor.execute;$anonfun.applyOrElse.resultLog" title="String">resultLog</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <a href="#org.scalatra.commands;AsyncExecutor.execute.res" title="scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]">res</a> <a href="#org.scalatra.commands;AsyncExecutor.executionContext" title="(pf: PartialFunction[Throwable,org.scalatra.commands.ModelValidation[S]])(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]">recover</a> <span title="&lt;$anon: Throwable =&gt; org.scalatra.commands.ModelValidation[S]&gt; extends scala.runtime.AbstractPartialFunction[Throwable,org.scalatra.commands.ModelValidation[S]] with Serializable" class="delimiter">{</span>
        case <a title="Throwable" id="org.scalatra.commands;AsyncExecutor.execute;$anonfun.isDefinedAt.t">t</a>: <span title="Throwable">Throwable</span> =&gt;
          <a href="#org.scalatra.commands;AsyncExecutor.logger" title="grizzled.slf4j.Logger">logger</a>.<span title="(msg: =&gt; Any, t: =&gt; Throwable)Unit">error</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Command [&quot;)">Command [$</span><span class="delimiter">{</span><a href="#org.scalatra.commands;AsyncExecutor.execute.cmd" title="T">cmd</a>.<span title="()Class[_]">getClass</span>.<span title="()String">getName</span><span class="delimiter">}</span><span title="String(&quot;] failed.&quot;)" class="string">] failed.&quot;</span>, <a href="#org.scalatra.commands;AsyncExecutor.execute;$anonfun.isDefinedAt.t" title="Throwable">t</a><span class="delimiter">)</span>
          <a href="../validation/ValidationError.scala.html#org.scalatra.validation.ValidationError.apply(a5c7fc7b86)" title="(msg: String, arguments: Any*)org.scalatra.validation.ValidationError">ValidationError</a><span title="(a: org.scalatra.validation.ValidationError)scalaz.syntax.ValidationOps[org.scalatra.validation.ValidationError]" class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Failed to execute &quot;)">Failed to execute $</span><span class="delimiter">{</span><a href="#org.scalatra.commands;AsyncExecutor.execute.cmd" title="T">cmd</a>.<span title="()Class[_]">getClass</span>.<span title="implicit mojolly.inflector.InflectorImports.string2InflectorString : (word: String)mojolly.inflector.Inflector.InflectorString">getSimpleName</span>.<span title="implicit mojolly.inflector.InflectorImports.string2InflectorString : (word: String)mojolly.inflector.Inflector.InflectorString">underscore</span>.<span title="=&gt; String">humanize</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span>, <a href="../validation/ValidationError.scala.html#org.scalatra.validation.UnknownError" title="org.scalatra.validation.UnknownError.type">UnknownError</a><span class="delimiter">)</span>.<span title="[X]=&gt; scalaz.ValidationNel[org.scalatra.validation.ValidationError,X]">failNel</span><span title="scalaz.ValidationNel[org.scalatra.validation.ValidationError,S]" class="delimiter">[</span><a href="#org.scalatra.commands;AsyncExecutor;S" title="S">S</a><span class="delimiter">]</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      val f = <a href="#org.scalatra.commands;AsyncExecutor.execute.cmd" title="T">cmd</a>.<a href="Command.scala.html#org.scalatra.commands;Command.errors" title="=&gt; Seq[org.scalatra.commands.Binding]">errors</a>.<span title="(f: org.scalatra.commands.Binding =&gt; scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[org.scalatra.commands.Binding],scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T],Seq[scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T]]])Seq[scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T],Seq[scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T]]]" class="delimiter">(</span><a href="#org.scalatra.commands;AsyncExecutor.execute.f.$anonfun.x$5" title="org.scalatra.commands.Binding">_</a>.<a href="binding.scala.html#org.scalatra.commands;Binding.validation" title="=&gt; org.scalatra.commands.FieldValidation[x$5.T]">validation</a><span class="delimiter">)</span> <a title="Seq[org.scalatra.validation.ValidationError]" id="org.scalatra.commands;AsyncExecutor.execute.f">collect</a> <a title="&lt;$anon: scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T] =&gt; org.scalatra.validation.ValidationError&gt; extends scala.runtime.AbstractPartialFunction[scalaz.Validation[org.scalatra.validation.ValidationError,org.scalatra.commands.Binding#T],org.scalatra.validation.ValidationError] with Serializable" id="org.scalatra.commands;AsyncExecutor.execute.f;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
        case Failure<span class="delimiter">(</span><a title="org.scalatra.validation.ValidationError" id="org.scalatra.commands;AsyncExecutor.execute.f;$anonfun.isDefinedAt.e">e</a><span class="delimiter">)</span> ⇒ <a href="#org.scalatra.commands;AsyncExecutor.execute.f;$anonfun.isDefinedAt.e" title="org.scalatra.validation.ValidationError">e</a>
      <span class="delimiter">}</span>
      def <a title="=&gt; String" id="org.scalatra.commands;AsyncExecutor.execute.failures">failures</a> = if <span class="delimiter">(</span><a href="#org.scalatra.commands;AsyncExecutor.execute.f" title="Seq[org.scalatra.validation.ValidationError]">f</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="String(&quot;failure&quot;)" class="string">&quot;failure&quot;</span> else <span title="String(&quot;failures&quot;)" class="string">&quot;failures&quot;</span>
      <a href="#org.scalatra.commands;AsyncExecutor.logger" title="grizzled.slf4j.Logger">logger</a>.<span title="(msg: =&gt; Any)Unit">debug</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Command [&quot;)">Command [$</span><span class="delimiter">{</span><a href="#org.scalatra.commands;AsyncExecutor.execute.cmd" title="T">cmd</a>.<span title="()Class[_]">getClass</span>.<span title="()String">getName</span><span class="delimiter">}</span><span title="String(&quot;] executed with &quot;)">] executed with $</span><span class="delimiter">{</span><a href="#org.scalatra.commands;AsyncExecutor.execute.f" title="Seq[org.scalatra.validation.ValidationError]">f</a>.<span title="=&gt; Int">size</span><span class="delimiter">}</span><span title="String(&quot; &quot;)"> $</span><a href="#org.scalatra.commands;AsyncExecutor.execute.failures" title="=&gt; String">failures</a><span title="String(&quot;.\\n&quot;)">.\n$</span><span class="delimiter">{</span><a href="#org.scalatra.commands;AsyncExecutor.execute.f" title="Seq[org.scalatra.validation.ValidationError]">f</a>.<span title="=&gt; List[org.scalatra.validation.ValidationError]">toList</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
      <span title="scala.concurrent.Future.type">Future</span>.<span title="(result: scalaz.Validation[scalaz.NonEmptyList[org.scalatra.validation.ValidationError],Nothing])scala.concurrent.Future[scalaz.Validation[scalaz.NonEmptyList[org.scalatra.validation.ValidationError],Nothing]]">successful</span><span class="delimiter">(</span><span title="(h: org.scalatra.validation.ValidationError, t: org.scalatra.validation.ValidationError*)scalaz.NonEmptyList[org.scalatra.validation.ValidationError]">NonEmptyList</span><span title="(a: scalaz.NonEmptyList[org.scalatra.validation.ValidationError])scalaz.syntax.ValidationOps[scalaz.NonEmptyList[org.scalatra.validation.ValidationError]]" class="delimiter">(</span><a href="#org.scalatra.commands;AsyncExecutor.execute.f" title="Seq[org.scalatra.validation.ValidationError]">f</a>.<span title="=&gt; org.scalatra.validation.ValidationError">head</span>, <a href="#org.scalatra.commands;AsyncExecutor.execute.f" title="Seq[org.scalatra.validation.ValidationError]">f</a>.<span title="=&gt; Seq[org.scalatra.validation.ValidationError]">tail</span>: _*<span class="delimiter">)</span>.<span title="scalaz.Validation[scalaz.NonEmptyList[org.scalatra.validation.ValidationError],Nothing]">fail</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>
<span class="comment">/**
 * A command executor that doesn't block while executing the command
 *
 * @see [[org.scalatra.commands.CommandExecutor]]
 *
 * @param handle The function that takes a command and returns a Future.
 * @tparam T The type of command to handle
 * @tparam S The success result type
 */</span>
class <a title="class AsyncCommandExecutor[T &lt;: org.scalatra.commands.Command, S] extends org.scalatra.commands.AsyncExecutor[T,S]" id="org.scalatra.commands;AsyncCommandExecutor">AsyncCommandExecutor</a><span class="delimiter">[</span><a title=" &lt;: org.scalatra.commands.Command" id="org.scalatra.commands;AsyncCommandExecutor;T">T</a> &lt;: Command, <a title="" id="org.scalatra.commands;AsyncCommandExecutor;S">S</a><span class="delimiter">]</span><a href="#org.scalatra.commands;AsyncCommandExecutor" title="org.scalatra.commands.AsyncCommandExecutor[T,S]" class="delimiter">(</a><a title="T =&gt; scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]" id="org.scalatra.commands;AsyncCommandExecutor.handle">handle</a>: T =&gt; Future<span class="delimiter">[</span>ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="org.scalatra.commands;AsyncCommandExecutor.executionContext">executionContext</a>: <span title="scala.concurrent.ExecutionContext">ExecutionContext</span><span class="delimiter">)</span> extends <a href="#org.scalatra.commands;AsyncExecutor" title="org.scalatra.commands.AsyncExecutor[T,S]">AsyncExecutor</a><span class="delimiter">[</span>T, S<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.scalatra.commands;AsyncCommandExecutor.handle" title="T =&gt; scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]">handle</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#org.scalatra.commands;AsyncCommandExecutor.executionContext" title="scala.concurrent.ExecutionContext">executionContext</a><span class="delimiter">)</span>
<span class="comment">/**
 * A command executor that can potentially block while executing the command, uses a model as input value for the handler function.
 * This command requires an implicit conversion from command to model to be in scope ie.: by defining it in the companion
 * object of the command.
 *
 * @see [[org.scalatra.commands.CommandExecutor]]
 *
 * @param handle The function that takes a model and returns a Future,
 *               requires an implicit conversion from command to model to be in scope
 * @tparam T The type of model
 * @tparam S The success result type
 */</span>
class <a title="class AsyncModelExecutor[T &lt;: org.scalatra.commands.Command, S] extends org.scalatra.commands.AsyncExecutor[T,S]" id="org.scalatra.commands;AsyncModelExecutor">AsyncModelExecutor</a><span class="delimiter">[</span><a title=" &lt;: org.scalatra.commands.Command" id="org.scalatra.commands;AsyncModelExecutor;T">T</a> &lt;: Command, <a title="" id="org.scalatra.commands;AsyncModelExecutor;S">S</a><span class="delimiter">]</span><a href="#org.scalatra.commands;AsyncModelExecutor" title="org.scalatra.commands.AsyncModelExecutor[T,S]" class="delimiter">(</a><a title="S =&gt; scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]" id="org.scalatra.commands;AsyncModelExecutor.handle">handle</a>: S =&gt; Future<span class="delimiter">[</span>ModelValidation<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="org.scalatra.commands;AsyncModelExecutor.executionContext">executionContext</a>: <span title="scala.concurrent.ExecutionContext">ExecutionContext</span>, <a title="T =&gt; S" id="org.scalatra.commands;AsyncModelExecutor.vw">vw</a>: T =&gt; S<span class="delimiter">)</span> extends <a href="#org.scalatra.commands;AsyncExecutor" title="org.scalatra.commands.AsyncExecutor[T,S]">AsyncExecutor</a><span class="delimiter">[</span>T, S<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.scalatra.commands;AsyncModelExecutor.handle" title="(v1: S)scala.concurrent.Future[org.scalatra.commands.ModelValidation[S]]">handle</a><span class="delimiter">(</span><a href="#org.scalatra.commands;AsyncModelExecutor.vw" title="(v1: T)S">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#org.scalatra.commands;AsyncModelExecutor.executionContext" title="scala.concurrent.ExecutionContext">executionContext</a><span class="delimiter">)</span>

        </pre>
    </body>
</html>
