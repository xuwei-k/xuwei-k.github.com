<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>org/scalatra/commands/Command.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package org.scalatra
package commands

import org.scalatra.util._
import org.scalatra.util.conversion._

<span class="comment">/**
* Trait that identifies a ''Command object'', i.e. a Scala class instance which fields are bound to external parameters
* taken from Scalatra' __params__ object.
*
* An usage example can be seen below:
* {{{
* class PersonForm extends Command {
*
*  import Command._
*
*  val name = bind[String](&quot;f_name&quot;)
*  val surname = bind[String](&quot;f_surname&quot;)
*  val age = bind[Int](&quot;f_age&quot;)
*  val registeredOn = bind[Date](&quot;f_reg_date&quot; -&gt; &quot;yyyyMMdd&quot;)
* }
* }}}
*
* In the example above, class field ''name'' will be bound, at runtime, with a parameter named ''f_name'' and so on.
* The binding is typed and for every registered type `T` (see [[org.scalatra.util.conversion.DefaultImplicitConversions]] for
* a list of all availables) an automatic conversion `(String) =&gt; T` will take place during binding phase.
*
* After that binding has been performed (i.e. after that [[org.scalatra.commands.Command#bindTo()]] has been called)
* on a specific instance, it is possible retrieve field values as [[scalaz.Validation]], i.e.:
*
* {{{
* val form = new PersonForm
* form.doBinding(params)
* val registrationDate = form.registeredOn.value.getOrElse(new Date())
* }}}
*
*
* @author mmazzarolo
* @version 0.1
*
*/</span>

trait <a title="trait Command extends AnyRef with org.scalatra.commands.BindingSyntax with org.scalatra.util.ParamsValueReaderProperties" id="org.scalatra.commands;Command">Command</a> extends <a href="binding.scala.html#org.scalatra.commands;BindingSyntax" title="org.scalatra.commands.BindingSyntax">BindingSyntax</a> with <a href="../util/valueReader.scala.html#org.scalatra.util;ParamsValueReaderProperties" title="org.scalatra.util.ParamsValueReaderProperties">ParamsValueReaderProperties</a> <span class="delimiter">{</span>

  type <a title="[T] &lt;: org.scalatra.commands.TypeConverterFactory[T]" id="org.scalatra.commands;Command;CommandTypeConverterFactory">CommandTypeConverterFactory</a><span class="delimiter">[</span><a title="" id="org.scalatra.commands;Command;CommandTypeConverterFactory;T">T</a><span class="delimiter">]</span> &lt;: TypeConverterFactory<span class="delimiter">[</span>T<span class="delimiter">]</span>
  private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="Seq[org.scalatra.commands.BindingAction]" id="org.scalatra.commands;Command.preBindingActions">preBindingActions</a>: <span title="Seq[org.scalatra.commands.BindingAction]">Seq</span><span class="delimiter">[</span>BindingAction<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="Seq[org.scalatra.commands.BindingAction]" id="org.scalatra.commands;Command.postBindingActions">postBindingActions</a>: <span title="Seq[org.scalatra.commands.BindingAction]">Seq</span><span class="delimiter">[</span>BindingAction<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>

  private<span class="delimiter">[</span>commands<span class="delimiter">]</span> var <a title="Map[String,org.scalatra.commands.Binding]" id="org.scalatra.commands;Command.bindings_=">bindings</a>: <span title="Map[String,org.scalatra.commands.Binding]">Map</span><span class="delimiter">[</span>String, Binding<span class="delimiter">]</span> = <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="scala.collection.immutable.Map[String,Nothing]">empty</span>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="Seq[org.scalatra.commands.Binding]" id="org.scalatra.commands;Command._errors">_errors</a>: <span title="Seq[org.scalatra.commands.Binding]">Seq</span><span class="delimiter">[</span>Binding<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>

  var <a title="String" id="org.scalatra.commands;Command.commandName_=">commandName</a> = <a href="#org.scalatra.commands;Command" title="()Class[_]">getClass</a>.<span title="()String">getSimpleName</span>

  var <a title="String" id="org.scalatra.commands;Command.commandDescription_=">commandDescription</a> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>

  <span class="comment">/**
   * Check whether this command is valid.
   */</span>
  def <a title="=&gt; Boolean" id="org.scalatra.commands;Command.isValid">isValid</a> = <a href="#org.scalatra.commands;Command.errors" title="=&gt; Seq[org.scalatra.commands.Binding]">errors</a>.<span title="=&gt; Boolean">isEmpty</span>
  def <a title="=&gt; Boolean" id="org.scalatra.commands;Command.isInvalid">isInvalid</a> = <a href="#org.scalatra.commands;Command.errors" title="=&gt; Seq[org.scalatra.commands.Binding]">errors</a>.<span title="=&gt; Boolean">nonEmpty</span>

  <span class="comment">/**
   * Return a Map of all field command error keyed by field binding name (NOT the name of the variable in command
   * object).
   */</span>
  def <a title="=&gt; Seq[org.scalatra.commands.Binding]" id="org.scalatra.commands;Command.errors">errors</a>: <span title="Seq[org.scalatra.commands.Binding]">Seq</span><span class="delimiter">[</span>Binding<span class="delimiter">]</span> = <a href="#org.scalatra.commands;Command._errors" title="Seq[org.scalatra.commands.Binding]">_errors</a>

  <span class="comment">/**
   * Perform command as afterBinding task.
   */</span>
  <a href="#org.scalatra.commands;Command.afterBinding" title="(action: =&gt; Any)Unit">afterBinding</a> <span class="delimiter">{</span>
    <a href="#org.scalatra.commands;Command._errors" title="Seq[org.scalatra.commands.Binding]">_errors</a> = <a href="#org.scalatra.commands;Command.bindings_=" title="=&gt; Map[String,org.scalatra.commands.Binding]">bindings</a>.<span title="=&gt; Iterable[org.scalatra.commands.Binding]">values</span>.<span title="(p: org.scalatra.commands.Binding =&gt; Boolean)Iterable[org.scalatra.commands.Binding]">filter</span><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.<local Command>.$anonfun.x$1" title="org.scalatra.commands.Binding">_</a>.<a href="binding.scala.html#org.scalatra.commands;Binding.isInvalid" title="=&gt; Boolean">isInvalid</a><span class="delimiter">)</span>.<span title="=&gt; Seq[org.scalatra.commands.Binding]">toSeq</span>
  <span class="delimiter">}</span>


  implicit def <a title="[T](field: org.scalatra.commands.FieldDescriptor[T])(implicit evidence$1: Manifest[T], implicit evidence$2: org.scalatra.commands.TypeConverterFactory[T])org.scalatra.commands.Field[T]" id="org.scalatra.commands;Command.binding2field">binding2field</a><span class="delimiter">[</span><a title="" id="org.scalatra.commands;Command.binding2field;T">T</a>:Manifest:TypeConverterFactory<span class="delimiter">]</span><span class="delimiter">(</span><a title="org.scalatra.commands.FieldDescriptor[T]" id="org.scalatra.commands;Command.binding2field.field">field</a>: <a href="field.scala.html#org.scalatra.commands;FieldDescriptor" title="org.scalatra.commands.FieldDescriptor[T]">FieldDescriptor</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="field.scala.html#org.scalatra.commands;Field" title="org.scalatra.commands.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="field.scala.html#org.scalatra.commands;Field" title="org.scalatra.commands.Field[T]">Field</a><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bind" title="(field: org.scalatra.commands.FieldDescriptor[T])(implicit mf: Manifest[T], implicit conv: org.scalatra.commands.TypeConverterFactory[T])org.scalatra.commands.FieldDescriptor[T]">bind</a><a href="#org.scalatra.commands;Command.binding2field.evidence$1" title="Manifest[T]" class="delimiter">(</a><a href="#org.scalatra.commands;Command.binding2field.field" title="org.scalatra.commands.FieldDescriptor[T]">field</a><span class="delimiter">)</span>, this<span class="delimiter">)</span>
  <span class="delimiter">}</span>

  implicit def <a title="[T](fieldName: String)(implicit evidence$3: Manifest[T], implicit evidence$4: org.scalatra.commands.TypeConverterFactory[T])org.scalatra.commands.Field[T]" id="org.scalatra.commands;Command.autoBind">autoBind</a><span class="delimiter">[</span><a title="" id="org.scalatra.commands;Command.autoBind;T">T</a>:Manifest:TypeConverterFactory<span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="org.scalatra.commands;Command.autoBind.fieldName">fieldName</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="field.scala.html#org.scalatra.commands;Field" title="org.scalatra.commands.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="#org.scalatra.commands;Command.bind" title="[T](field: org.scalatra.commands.FieldDescriptor[T])(implicit mf: Manifest[T], implicit conv: org.scalatra.commands.TypeConverterFactory[T])org.scalatra.commands.FieldDescriptor[T]">bind</a><span title="(field: org.scalatra.commands.FieldDescriptor[T])(implicit mf: Manifest[T], implicit conv: org.scalatra.commands.TypeConverterFactory[T])org.scalatra.commands.FieldDescriptor[T]" class="delimiter">[</span><a href="#org.scalatra.commands;Command.autoBind;T" title="T">T</a><span class="delimiter">]</span><a href="#org.scalatra.commands;Command.binding2field" title="(field: org.scalatra.commands.FieldDescriptor[T])(implicit evidence$1: Manifest[T], implicit evidence$2: org.scalatra.commands.TypeConverterFactory[T])org.scalatra.commands.Field[T]" class="delimiter">(</a><a href="field.scala.html#org.scalatra.commands.FieldDescriptor.apply" title="[T](name: String)(implicit mf: Manifest[T])org.scalatra.commands.FieldDescriptor[T]">FieldDescriptor</a><span title="(name: String)(implicit mf: Manifest[T])org.scalatra.commands.FieldDescriptor[T]" class="delimiter">[</span><a href="#org.scalatra.commands;Command.autoBind;T" title="T">T</a><span class="delimiter">]</span><a href="#org.scalatra.commands;Command.autoBind.evidence$3" title="Manifest[T]" class="delimiter">(</a><a href="#org.scalatra.commands;Command.autoBind.fieldName" title="String">fieldName</a><span class="delimiter">)</span><span class="delimiter">)</span>

  implicit def <a title="[T](field: org.scalatra.commands.FieldDescriptor[T])(implicit mf: Manifest[T], implicit conv: org.scalatra.commands.TypeConverterFactory[T])org.scalatra.commands.FieldDescriptor[T]" id="org.scalatra.commands;Command.bind">bind</a><span class="delimiter">[</span><a title="" id="org.scalatra.commands;Command.bind;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="org.scalatra.commands.FieldDescriptor[T]" id="org.scalatra.commands;Command.bind.field">field</a>: <a href="field.scala.html#org.scalatra.commands;FieldDescriptor" title="org.scalatra.commands.FieldDescriptor[T]">FieldDescriptor</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Manifest[T]" id="org.scalatra.commands;Command.bind.mf">mf</a>:<span title="Manifest[T]">Manifest</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="org.scalatra.commands.TypeConverterFactory[T]" id="org.scalatra.commands;Command.bind.conv">conv</a>:<a href="TypeConverterFactory.scala.html#org.scalatra.commands;TypeConverterFactory" title="org.scalatra.commands.TypeConverterFactory[T]">TypeConverterFactory</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="field.scala.html#org.scalatra.commands;FieldDescriptor" title="org.scalatra.commands.FieldDescriptor[T]">FieldDescriptor</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="org.scalatra.commands.FieldDescriptor[T]" id="org.scalatra.commands;Command.bind.f">f</a>: <a href="field.scala.html#org.scalatra.commands;FieldDescriptor" title="org.scalatra.commands.FieldDescriptor[T]">FieldDescriptor</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bind.mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span>.<span title="(x$1: Class[_])Boolean">isAssignableFrom</span><span class="delimiter">(</span>classOf<span title="Class[Option[_]](classOf[scala.Option])" class="delimiter">[</span>Option<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// Yay! not one but 2 casts in the same line</span>
        <a href="#org.scalatra.commands;Command.bind.field" title="org.scalatra.commands.FieldDescriptor[T]">field</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="org.scalatra.commands.FieldDescriptor[Option[_]]" class="delimiter">[</span><a href="field.scala.html#org.scalatra.commands;FieldDescriptor" title="org.scalatra.commands.FieldDescriptor[Option[_]]">FieldDescriptor</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>.<a href="field.scala.html#org.scalatra.commands;FieldDescriptor.withDefaultValue" title="(default: =&gt; Option[_])org.scalatra.commands.FieldDescriptor[Option[_]]">withDefaultValue</a><span class="delimiter">(</span><span title="None.type">None</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="org.scalatra.commands.FieldDescriptor[T]" class="delimiter">[</span><a href="field.scala.html#org.scalatra.commands;FieldDescriptor" title="org.scalatra.commands.FieldDescriptor[T]">FieldDescriptor</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
      <span class="delimiter">}</span> else <a href="#org.scalatra.commands;Command.bind.field" title="org.scalatra.commands.FieldDescriptor[T]">field</a>
    val <a title="org.scalatra.commands.Binding" id="org.scalatra.commands;Command.bind.b">b</a> = <a href="binding.scala.html#org.scalatra.commands.Binding.apply(01ffabe066)" title="(initial: org.scalatra.commands.FieldDescriptor[T])(implicit ma: Manifest[T], implicit tcFactory: org.scalatra.commands.TypeConverterFactory[T])org.scalatra.commands.Binding">Binding</a><a href="#org.scalatra.commands;Command.bind.mf" title="Manifest[T]" class="delimiter">(</a><a href="#org.scalatra.commands;Command.bind.f" title="org.scalatra.commands.FieldDescriptor[T]">f</a><span class="delimiter">)</span>
    <a href="#org.scalatra.commands;Command.bindings_=" title="(x$1: Map[String,org.scalatra.commands.Binding])Unit">bindings</a> <span title="(kv: (String, org.scalatra.commands.Binding))scala.collection.immutable.Map[String,org.scalatra.commands.Binding]">+=</span> <a href="#org.scalatra.commands;Command.bind.b" title="org.scalatra.commands.Binding">b</a>.<a href="binding.scala.html#org.scalatra.commands;Binding.name" title="(self: String)ArrowAssoc[String]">name</a> <span title="(y: org.scalatra.commands.Binding)(String, org.scalatra.commands.Binding)">-&gt;</span> <a href="#org.scalatra.commands;Command.bind.b" title="org.scalatra.commands.Binding">b</a>
    <a href="#org.scalatra.commands;Command.bind.f" title="org.scalatra.commands.FieldDescriptor[T]">f</a>
  <span class="delimiter">}</span>

  def <a title="[I](tc: Command.this.CommandTypeConverterFactory[_])PartialFunction[org.scalatra.util.ValueReader[_, _],org.scalatra.util.conversion.TypeConverter[I, _]]" id="org.scalatra.commands;Command.typeConverterBuilder">typeConverterBuilder</a><span class="delimiter">[</span><a title="" id="org.scalatra.commands;Command.typeConverterBuilder;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Command.this.CommandTypeConverterFactory[_]" id="org.scalatra.commands;Command.typeConverterBuilder.tc">tc</a>: <a href="#org.scalatra.commands;Command;CommandTypeConverterFactory" title="Command.this.CommandTypeConverterFactory[_]">CommandTypeConverterFactory</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="PartialFunction[org.scalatra.util.ValueReader[_, _],org.scalatra.util.conversion.TypeConverter[I, _]]">PartialFunction</span><span class="delimiter">[</span>ValueReader<span class="delimiter">[</span>_, _<span class="delimiter">]</span>, TypeConverter<span class="delimiter">[</span>I, _<span class="delimiter">]</span><span class="delimiter">]</span> = <a title="&lt;$anon: org.scalatra.util.ValueReader[_, _] =&gt; org.scalatra.util.conversion.TypeConverter[I, _]&gt; extends scala.runtime.AbstractPartialFunction[org.scalatra.util.ValueReader[_, _],org.scalatra.util.conversion.TypeConverter[I, _]] with Serializable" id="org.scalatra.commands;Command.typeConverterBuilder;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
    case <span title="org.scalatra.util.MultiParamsValueReader">r</span>: <a href="../util/valueReader.scala.html#org.scalatra.util;MultiParamsValueReader" title="org.scalatra.util.MultiParamsValueReader">MultiParamsValueReader</a> =&gt; <a href="#org.scalatra.commands;Command.typeConverterBuilder.tc" title="Command.this.CommandTypeConverterFactory[_]">tc</a>.<a href="TypeConverterFactory.scala.html#org.scalatra.commands;TypeConverterFactory.resolveMultiParams" title="=&gt; org.scalatra.util.conversion.TypeConverter[Seq[String],_$3]">resolveMultiParams</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="org.scalatra.util.conversion.TypeConverter[I,_$7]" class="delimiter">[</span><a href="../util/conversion/package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[I, _]">TypeConverter</a><span class="delimiter">[</span>I, _<span class="delimiter">]</span><span class="delimiter">]</span>
    case <span title="&lt;refinement of org.scalatra.util.ValueReader[_$4,_$5] with org.scalatra.util.MultiMapHeadViewValueReader[_]&gt; extends org.scalatra.util.ValueReader[_$4,_$5] with org.scalatra.util.MultiMapHeadViewValueReader[_]">r</span>: <a href="../util/valueReader.scala.html#org.scalatra.util;MultiMapHeadViewValueReader" title="org.scalatra.util.MultiMapHeadViewValueReader[_]">MultiMapHeadViewValueReader</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="#org.scalatra.commands;Command.typeConverterBuilder.tc" title="Command.this.CommandTypeConverterFactory[_]">tc</a>.<a href="TypeConverterFactory.scala.html#org.scalatra.commands;TypeConverterFactory.resolveStringParams" title="=&gt; org.scalatra.util.conversion.TypeConverter[String,_$3]">resolveStringParams</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="org.scalatra.util.conversion.TypeConverter[I,_$8]" class="delimiter">[</span><a href="../util/conversion/package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[I, _]">TypeConverter</a><span class="delimiter">[</span>I, _<span class="delimiter">]</span><span class="delimiter">]</span>
    case <span title="org.scalatra.util.StringMapValueReader">r</span>: <a href="../util/valueReader.scala.html#org.scalatra.util;StringMapValueReader" title="org.scalatra.util.StringMapValueReader">StringMapValueReader</a> =&gt; <a href="#org.scalatra.commands;Command.typeConverterBuilder.tc" title="Command.this.CommandTypeConverterFactory[_]">tc</a>.<a href="TypeConverterFactory.scala.html#org.scalatra.commands;TypeConverterFactory.resolveStringParams" title="=&gt; org.scalatra.util.conversion.TypeConverter[String,_$3]">resolveStringParams</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="org.scalatra.util.conversion.TypeConverter[I,_$9]" class="delimiter">[</span><a href="../util/conversion/package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[I, _]">TypeConverter</a><span class="delimiter">[</span>I, _<span class="delimiter">]</span><span class="delimiter">]</span>
    case <span title="org.scalatra.util.ValueReader[_$4,_$5]">r</span> =&gt; throw new <a href="binding.scala.html#org.scalatra.commands;BindingException" title="org.scalatra.commands.BindingException">BindingException</a><span class="delimiter">(</span><span title="String(&quot;No converter found for value reader: &quot;)" class="string">&quot;No converter found for value reader: &quot;</span> <span title="(x$1: Any)String">+</span> <span title="org.scalatra.util.ValueReader[_$4,_$5]">r</span>.<span title="()Class[_]">getClass</span>.<span title="()String">getSimpleName</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Add an action that will be evaluated before field binding occurs.
   */</span>
  protected def <a title="(action: =&gt; Any)Unit" id="org.scalatra.commands;Command.beforeBinding">beforeBinding</a><span class="delimiter">(</span><a title="=&gt; Any" id="org.scalatra.commands;Command.beforeBinding.action">action</a>: =&gt; Any<span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#org.scalatra.commands;Command.preBindingActions" title="Seq[org.scalatra.commands.BindingAction]">preBindingActions</a> = <a href="#org.scalatra.commands;Command.preBindingActions" title="Seq[org.scalatra.commands.BindingAction]">preBindingActions</a> <span title="(elem: org.scalatra.commands.BindingAction)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[org.scalatra.commands.BindingAction],org.scalatra.commands.BindingAction,Seq[org.scalatra.commands.BindingAction]])Seq[org.scalatra.commands.BindingAction]">:+</span> <span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#org.scalatra.commands;Command.beforeBinding.action" title="=&gt; Any">action</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Add an action that will be evaluated after field binding has been done.
   */</span>
  protected def <a title="(action: =&gt; Any)Unit" id="org.scalatra.commands;Command.afterBinding">afterBinding</a><span class="delimiter">(</span><a title="=&gt; Any" id="org.scalatra.commands;Command.afterBinding.action">action</a>: =&gt; Any<span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#org.scalatra.commands;Command.postBindingActions" title="Seq[org.scalatra.commands.BindingAction]">postBindingActions</a> = <a href="#org.scalatra.commands;Command.postBindingActions" title="Seq[org.scalatra.commands.BindingAction]">postBindingActions</a> <span title="(elem: org.scalatra.commands.BindingAction)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[org.scalatra.commands.BindingAction],org.scalatra.commands.BindingAction,Seq[org.scalatra.commands.BindingAction]])Seq[org.scalatra.commands.BindingAction]">:+</span> <span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#org.scalatra.commands;Command.afterBinding.action" title="=&gt; Any">action</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="[S, I](data: S, params: org.scalatra.MultiParams, headers: Map[String,String])(implicit r: S =&gt; org.scalatra.util.ValueReader[S,I], implicit mi: Manifest[I], implicit multiParams: org.scalatra.MultiParams =&gt; org.scalatra.util.ValueReader[org.scalatra.MultiParams,Seq[String]])Command.this.type" id="org.scalatra.commands;Command.bindTo">bindTo</a><span class="delimiter">[</span><a title="" id="org.scalatra.commands;Command.bindTo$default$3;S">S</a>, <a title="" id="org.scalatra.commands;Command.bindTo$default$3;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span>
            <a title="S" id="org.scalatra.commands;Command.bindTo.data">data</a>: <a href="#org.scalatra.commands;Command.bindTo$default$3;S" title="S">S</a>,
            <a title="org.scalatra.MultiParams" id="org.scalatra.commands;Command.bindTo$default$2">params</a>: <a href="../util/MultiMap.scala.html#org.scalatra.util;MultiMap" title="org.scalatra.MultiParams">MultiParams</a> = <a href="../util/MultiMap.scala.html#org.scalatra.util.MultiMap" title="org.scalatra.util.MultiMap.type">MultiMap</a>.<a href="../util/MultiMap.scala.html#org.scalatra.util.MultiMap.empty" title="=&gt; org.scalatra.util.MultiMap">empty</a>,
            <a title="Map[String,String]" id="org.scalatra.commands;Command.bindTo$default$3">headers</a>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span> = <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="scala.collection.immutable.Map[String,Nothing]">empty</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="S =&gt; org.scalatra.util.ValueReader[S,I]" id="org.scalatra.commands;Command.bindTo.r">r</a>: S =&gt; ValueReader<span class="delimiter">[</span>S, I<span class="delimiter">]</span>, <a title="Manifest[I]" id="org.scalatra.commands;Command.bindTo.mi">mi</a>: <span title="Manifest[I]">Manifest</span><span class="delimiter">[</span>I<span class="delimiter">]</span>, <a title="org.scalatra.MultiParams =&gt; org.scalatra.util.ValueReader[org.scalatra.MultiParams,Seq[String]]" id="org.scalatra.commands;Command.bindTo.multiParams">multiParams</a>: MultiParams =&gt; ValueReader<span class="delimiter">[</span>MultiParams, Seq<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: this.type = <span class="delimiter">{</span>
    <a href="#org.scalatra.commands;Command.doBeforeBindingActions" title="()Unit">doBeforeBindingActions</a><span class="delimiter">(</span><span class="delimiter">)</span>

    <a href="#org.scalatra.commands;Command.bindings_=" title="(x$1: Map[String,org.scalatra.commands.Binding])Unit">bindings</a> = <a href="#org.scalatra.commands;Command.bindings_=" title="=&gt; Map[String,org.scalatra.commands.Binding]">bindings</a> <span title="(f: ((String, org.scalatra.commands.Binding)) =&gt; (String, org.scalatra.commands.Binding))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[String,org.scalatra.commands.Binding],(String, org.scalatra.commands.Binding),Map[String,org.scalatra.commands.Binding]])Map[String,org.scalatra.commands.Binding]">map</span> <a href="#org.scalatra.commands;Command.bindTo.$anonfun.x0$1" title="(String, org.scalatra.commands.Binding)" class="delimiter">{</a> case <span class="delimiter">(</span><a title="String" id="org.scalatra.commands;Command.bindTo.$anonfun.name">name</a>, <a title="org.scalatra.commands.Binding" id="org.scalatra.commands;Command.bindTo.$anonfun.b">b</a><span class="delimiter">)</span> =&gt;
      val <a title="org.scalatra.commands.TypeConverterFactory[_]" id="org.scalatra.commands;Command.bindTo.$anonfun.tcf">tcf</a> = <a href="#org.scalatra.commands;Command.bindTo.$anonfun.b" title="org.scalatra.commands.Binding">b</a>.<a href="binding.scala.html#org.scalatra.commands;Binding.typeConverterFactory" title="=&gt; org.scalatra.commands.TypeConverterFactory[_]">typeConverterFactory</a>
      val <a title="org.scalatra.util.conversion.TypeConverter[I,b.T]" id="org.scalatra.commands;Command.bindTo.$anonfun.cv">cv</a> = <a href="#org.scalatra.commands;Command.typeConverterBuilder" title="(tc: Command.this.CommandTypeConverterFactory[_])PartialFunction[org.scalatra.util.ValueReader[_, _],org.scalatra.util.conversion.TypeConverter[Nothing, _]]">typeConverterBuilder</a><span title="(v1: org.scalatra.util.ValueReader[_, _])org.scalatra.util.conversion.TypeConverter[Nothing, _]" class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.$anonfun.tcf" title="org.scalatra.commands.TypeConverterFactory[_]">tcf</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Command.this.CommandTypeConverterFactory[_$10]" class="delimiter">[</span><a href="#org.scalatra.commands;Command;CommandTypeConverterFactory" title="Command.this.CommandTypeConverterFactory[_]">CommandTypeConverterFactory</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.r" title="(v1: S)org.scalatra.util.ValueReader[S,I]">data</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="org.scalatra.util.conversion.TypeConverter[I,b.T]" class="delimiter">[</span><a href="../util/conversion/package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[I,b.T]">TypeConverter</a><span class="delimiter">[</span>I, b.T<span class="delimiter">]</span><span class="delimiter">]</span>
      val <a title="org.scalatra.commands.Binding" id="org.scalatra.commands;Command.bindTo.$anonfun.fieldBinding">fieldBinding</a> = <a href="binding.scala.html#org.scalatra.commands.Binding.apply(586e5eb11a)" title="(prev: org.scalatra.commands.FieldDescriptor[b.T], cv: org.scalatra.util.conversion.TypeConverter[I,b.T], tcf: org.scalatra.commands.TypeConverterFactory[_])(implicit mf: Manifest[I], implicit mt: Manifest[b.T])org.scalatra.commands.Binding">Binding</a><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.$anonfun.b" title="org.scalatra.commands.Binding">b</a>.<a href="binding.scala.html#org.scalatra.commands;Binding.field" title="=&gt; org.scalatra.commands.FieldDescriptor[b.T]">field</a>, <a href="#org.scalatra.commands;Command.bindTo.$anonfun.cv" title="org.scalatra.util.conversion.TypeConverter[I,b.T]">cv</a>, <a href="#org.scalatra.commands;Command.bindTo.$anonfun.b" title="org.scalatra.commands.Binding">b</a>.<a href="binding.scala.html#org.scalatra.commands;Binding.typeConverterFactory" title="=&gt; org.scalatra.commands.TypeConverterFactory[_]">typeConverterFactory</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.mi" title="Manifest[I]">mi</a>, <a href="#org.scalatra.commands;Command.bindTo.$anonfun.b" title="org.scalatra.commands.Binding">b</a>.<a href="binding.scala.html#org.scalatra.commands;Binding.valueManifest" title="=&gt; Manifest[b.T]">valueManifest</a><span class="delimiter">)</span>
      
      val <a title="org.scalatra.commands.Binding" id="org.scalatra.commands;Command.bindTo.$anonfun.result">result</a> = <a href="#org.scalatra.commands;Command.bindTo.$anonfun.b" title="org.scalatra.commands.Binding">b</a>.<a href="binding.scala.html#org.scalatra.commands;Binding.field" title="=&gt; org.scalatra.commands.FieldDescriptor[b.T]">field</a>.<a href="field.scala.html#org.scalatra.commands;FieldDescriptor.valueSource" title="=&gt; org.scalatra.commands.ValueSource.Value">valueSource</a> match <span class="delimiter">{</span>
        case <a href="field.scala.html#org.scalatra.commands.ValueSource" title="org.scalatra.commands.ValueSource.type">ValueSource</a>.<a href="field.scala.html#org.scalatra.commands.ValueSource.Body" title="=&gt; org.scalatra.commands.ValueSource.Value">Body</a> =&gt; <a href="binding.scala.html#org.scalatra.commands;Binding.apply" title="(toBind: Either[String,Option[fieldBinding.S]])org.scalatra.commands.Binding">fieldBinding</a><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.r" title="(v1: S)org.scalatra.util.ValueReader[S,I]">data</a>.<a href="../util/valueReader.scala.html#org.scalatra.util;ValueReader.read" title="(key: String)Either[String,Option[I]]">read</a><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.$anonfun.name" title="String">name</a><span class="delimiter">)</span>.<span title="=&gt; scala.util.Either.RightProjection[String,Option[I]]">right</span>.<span title="(f: Option[I] =&gt; Option[fieldBinding.S])Serializable with Product with scala.util.Either[String,Option[fieldBinding.S]]">map</span><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.$anonfun.result.$anonfun.x$2" title="Option[I]">_</a> <span title="(f: I =&gt; fieldBinding.S)Option[fieldBinding.S]">map</span> <span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.$anonfun.result.$anonfun.$anonfun.x$3" title="I">_</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="fieldBinding.S" class="delimiter">[</span>fieldBinding.<a href="binding.scala.html#org.scalatra.commands;Binding;S" title="fieldBinding.S">S</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case <a href="field.scala.html#org.scalatra.commands.ValueSource" title="org.scalatra.commands.ValueSource.type">ValueSource</a>.<a href="field.scala.html#org.scalatra.commands.ValueSource.Header" title="=&gt; org.scalatra.commands.ValueSource.Value">Header</a> =&gt; 
          val <a title="org.scalatra.util.conversion.TypeConverter[String, _]" id="org.scalatra.commands;Command.bindTo.$anonfun.result.tc">tc</a>: <a href="../util/conversion/package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String, _]">TypeConverter</a><span class="delimiter">[</span>String, _<span class="delimiter">]</span> = <a href="#org.scalatra.commands;Command.bindTo.$anonfun.tcf" title="org.scalatra.commands.TypeConverterFactory[_]">tcf</a>.<a href="TypeConverterFactory.scala.html#org.scalatra.commands;TypeConverterFactory.resolveStringParams" title="=&gt; org.scalatra.util.conversion.TypeConverter[String,_$4]">resolveStringParams</a>
          val <a title="org.scalatra.commands.Binding" id="org.scalatra.commands;Command.bindTo.$anonfun.result.headersBinding">headersBinding</a> = <a href="binding.scala.html#org.scalatra.commands.Binding.apply(586e5eb11a)" title="(prev: org.scalatra.commands.FieldDescriptor[b.T], cv: org.scalatra.util.conversion.TypeConverter[String,b.T], tcf: org.scalatra.commands.TypeConverterFactory[_])(implicit mf: Manifest[String], implicit mt: Manifest[b.T])org.scalatra.commands.Binding">Binding</a><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.$anonfun.b" title="org.scalatra.commands.Binding">b</a>.<a href="binding.scala.html#org.scalatra.commands;Binding.field" title="=&gt; org.scalatra.commands.FieldDescriptor[b.T]">field</a>, <a href="#org.scalatra.commands;Command.bindTo.$anonfun.result.tc" title="org.scalatra.util.conversion.TypeConverter[String, _]">tc</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="org.scalatra.util.conversion.TypeConverter[String,b.T]" class="delimiter">[</span><a href="../util/conversion/package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,b.T]">TypeConverter</a><span class="delimiter">[</span>String, b.T<span class="delimiter">]</span><span class="delimiter">]</span>, <a href="#org.scalatra.commands;Command.bindTo.$anonfun.tcf" title="org.scalatra.commands.TypeConverterFactory[_]">tcf</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="[T](implicit m: Manifest[T])Manifest[T]">manifest</span><span title="(implicit m: Manifest[String])Manifest[String]" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span>, <a href="#org.scalatra.commands;Command.bindTo.$anonfun.b" title="org.scalatra.commands.Binding">b</a>.<a href="binding.scala.html#org.scalatra.commands;Binding.valueManifest" title="=&gt; Manifest[b.T]">valueManifest</a><span class="delimiter">)</span>
          <a href="binding.scala.html#org.scalatra.commands;Binding.apply" title="(toBind: Either[String,Option[headersBinding.S]])org.scalatra.commands.Binding">headersBinding</a><span class="delimiter">(</span><span title="(b: Option[headersBinding.S])scala.util.Right[Nothing,Option[headersBinding.S]]">Right</span><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo$default$3" title="Map[String,String]">headers</a>.<span title="(key: String)Option[String]">get</span><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.$anonfun.name" title="String">name</a><span class="delimiter">)</span>.<span title="(f: String =&gt; headersBinding.S)Option[headersBinding.S]">map</span><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.$anonfun.result.$anonfun.x$4" title="String">_</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="headersBinding.S" class="delimiter">[</span>headersBinding.<a href="binding.scala.html#org.scalatra.commands;Binding;S" title="headersBinding.S">S</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case <a href="field.scala.html#org.scalatra.commands.ValueSource" title="org.scalatra.commands.ValueSource.type">ValueSource</a>.<a href="field.scala.html#org.scalatra.commands.ValueSource.Path" title="=&gt; org.scalatra.commands.ValueSource.Value">Path</a> | <a href="field.scala.html#org.scalatra.commands.ValueSource" title="org.scalatra.commands.ValueSource.type">ValueSource</a>.<a href="field.scala.html#org.scalatra.commands.ValueSource.Query" title="=&gt; org.scalatra.commands.ValueSource.Value">Query</a> =&gt;
          val <a title="org.scalatra.util.conversion.TypeConverter[Seq[String],b.T]" id="org.scalatra.commands;Command.bindTo.$anonfun.result.pv">pv</a> = <a href="#org.scalatra.commands;Command.typeConverterBuilder" title="(tc: Command.this.CommandTypeConverterFactory[_])PartialFunction[org.scalatra.util.ValueReader[_, _],org.scalatra.util.conversion.TypeConverter[Nothing, _]]">typeConverterBuilder</a><span title="(v1: org.scalatra.util.ValueReader[_, _])org.scalatra.util.conversion.TypeConverter[Nothing, _]" class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.$anonfun.tcf" title="org.scalatra.commands.TypeConverterFactory[_]">tcf</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Command.this.CommandTypeConverterFactory[_$12]" class="delimiter">[</span><a href="#org.scalatra.commands;Command;CommandTypeConverterFactory" title="Command.this.CommandTypeConverterFactory[_]">CommandTypeConverterFactory</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.multiParams" title="(v1: org.scalatra.MultiParams)org.scalatra.util.ValueReader[org.scalatra.MultiParams,Seq[String]]">params</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="org.scalatra.util.conversion.TypeConverter[Seq[String],b.T]" class="delimiter">[</span><a href="../util/conversion/package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[Seq[String],b.T]">TypeConverter</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>String<span class="delimiter">]</span>, b.T<span class="delimiter">]</span><span class="delimiter">]</span>
          val <a title="org.scalatra.commands.Binding" id="org.scalatra.commands;Command.bindTo.$anonfun.result.paramsBinding">paramsBinding</a> = <a href="binding.scala.html#org.scalatra.commands.Binding.apply(586e5eb11a)" title="(prev: org.scalatra.commands.FieldDescriptor[b.T], cv: org.scalatra.util.conversion.TypeConverter[Seq[String],b.T], tcf: org.scalatra.commands.TypeConverterFactory[_])(implicit mf: Manifest[Seq[String]], implicit mt: Manifest[b.T])org.scalatra.commands.Binding">Binding</a><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.$anonfun.b" title="org.scalatra.commands.Binding">b</a>.<a href="binding.scala.html#org.scalatra.commands;Binding.field" title="=&gt; org.scalatra.commands.FieldDescriptor[b.T]">field</a>, <a href="#org.scalatra.commands;Command.bindTo.$anonfun.result.pv" title="org.scalatra.util.conversion.TypeConverter[Seq[String],b.T]">pv</a>, <a href="#org.scalatra.commands;Command.bindTo.$anonfun.b" title="org.scalatra.commands.Binding">b</a>.<a href="binding.scala.html#org.scalatra.commands;Binding.typeConverterFactory" title="=&gt; org.scalatra.commands.TypeConverterFactory[_]">typeConverterFactory</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="[T](implicit m: Manifest[T])Manifest[T]">manifest</span><span title="(implicit m: Manifest[Seq[String]])Manifest[Seq[String]]" class="delimiter">[</span><span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span>, <a href="#org.scalatra.commands;Command.bindTo.$anonfun.b" title="org.scalatra.commands.Binding">b</a>.<a href="binding.scala.html#org.scalatra.commands;Binding.valueManifest" title="=&gt; Manifest[b.T]">valueManifest</a><span class="delimiter">)</span>
          <a href="binding.scala.html#org.scalatra.commands;Binding.apply" title="(toBind: Either[String,Option[paramsBinding.S]])org.scalatra.commands.Binding">paramsBinding</a><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.multiParams" title="(v1: org.scalatra.MultiParams)org.scalatra.util.ValueReader[org.scalatra.MultiParams,Seq[String]]">params</a>.<a href="../util/valueReader.scala.html#org.scalatra.util;ValueReader.read" title="(key: String)Either[String,Option[Seq[String]]]">read</a><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.$anonfun.name" title="String">name</a><span class="delimiter">)</span>.<span title="=&gt; scala.util.Either.RightProjection[String,Option[Seq[String]]]">right</span>.<span title="(f: Option[Seq[String]] =&gt; Option[paramsBinding.S])Serializable with Product with scala.util.Either[String,Option[paramsBinding.S]]">map</span><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.$anonfun.result.$anonfun.x$5" title="Option[Seq[String]]">_</a> <span title="(f: Seq[String] =&gt; paramsBinding.S)Option[paramsBinding.S]">map</span> <span class="delimiter">(</span><a href="#org.scalatra.commands;Command.bindTo.$anonfun.result.$anonfun.$anonfun.x$6" title="Seq[String]">_</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="paramsBinding.S" class="delimiter">[</span>paramsBinding.<a href="binding.scala.html#org.scalatra.commands;Binding;S" title="paramsBinding.S">S</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      
      <a href="#org.scalatra.commands;Command.bindTo.$anonfun.name" title="(self: String)ArrowAssoc[String]">name</a> <span title="(y: org.scalatra.commands.Binding)(String, org.scalatra.commands.Binding)">-&gt;</span> <a href="#org.scalatra.commands;Command.bindTo.$anonfun.result" title="org.scalatra.commands.Binding">result</a>
    <span class="delimiter">}</span>

    <span class="comment">// Defer validation until after all the fields have been bound.</span>
    <a href="#org.scalatra.commands;Command.bindings_=" title="(x$1: Map[String,org.scalatra.commands.Binding])Unit">bindings</a> = <a href="#org.scalatra.commands;Command.bindings_=" title="=&gt; Map[String,org.scalatra.commands.Binding]">bindings</a> <span title="(f: ((String, org.scalatra.commands.Binding)) =&gt; (String, org.scalatra.commands.Binding))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[String,org.scalatra.commands.Binding],(String, org.scalatra.commands.Binding),Map[String,org.scalatra.commands.Binding]])Map[String,org.scalatra.commands.Binding]">map</span> <a href="#org.scalatra.commands;Command.bindTo.$anonfun.x0$2" title="(String, org.scalatra.commands.Binding)" class="delimiter">{</a> case <span class="delimiter">(</span><a title="String" id="org.scalatra.commands;Command.bindTo.$anonfun.k">k</a>,<a title="org.scalatra.commands.Binding" id="org.scalatra.commands;Command.bindTo.$anonfun.v">v</a><span class="delimiter">)</span> =&gt; <a href="#org.scalatra.commands;Command.bindTo.$anonfun.k" title="(self: String)ArrowAssoc[String]">k</a> <span title="(y: org.scalatra.commands.Binding)(String, org.scalatra.commands.Binding)">-&gt;</span> <a href="#org.scalatra.commands;Command.bindTo.$anonfun.v" title="org.scalatra.commands.Binding">v</a>.<a href="binding.scala.html#org.scalatra.commands;Binding.validate" title="=&gt; org.scalatra.commands.Binding">validate</a> <span class="delimiter">}</span>

    <a href="#org.scalatra.commands;Command.doAfterBindingActions" title="()Unit">doAfterBindingActions</a><span class="delimiter">(</span><span class="delimiter">)</span>
    this
  <span class="delimiter">}</span>

  private def <a title="()Unit" id="org.scalatra.commands;Command.doBeforeBindingActions">doBeforeBindingActions</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="#org.scalatra.commands;Command.preBindingActions" title="Seq[org.scalatra.commands.BindingAction]">preBindingActions</a>.<span title="(f: org.scalatra.commands.BindingAction =&gt; Any)Unit">foreach</span><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.doBeforeBindingActions.$anonfun.x$7" title="org.scalatra.commands.BindingAction">_</a>.<span title="()Any">apply</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  private def <a title="()Unit" id="org.scalatra.commands;Command.doAfterBindingActions">doAfterBindingActions</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="#org.scalatra.commands;Command.postBindingActions" title="Seq[org.scalatra.commands.BindingAction]">postBindingActions</a>.<span title="(f: org.scalatra.commands.BindingAction =&gt; Any)Unit">foreach</span><span class="delimiter">(</span><a href="#org.scalatra.commands;Command.doAfterBindingActions.$anonfun.x$8" title="org.scalatra.commands.BindingAction">_</a>.<span title="()Any">apply</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  override def <a title="()String" id="org.scalatra.commands;Command.toString">toString</a>: <span title="String">String</span> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%s(bindings: [%s])&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#org.scalatra.commands;Command" title="()Class[_]">getClass</a>.<span title="()String">getName</span>, <a href="#org.scalatra.commands;Command.bindings_=" title="=&gt; Map[String,org.scalatra.commands.Binding]">bindings</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

  private type <a title="[S](Command.this.type =&gt; S) =&gt; org.scalatra.commands.CommandExecutor[Command.this.type,S]" id="org.scalatra.commands;Command;ExecutorView">ExecutorView</a><span class="delimiter">[</span><a title="" id="org.scalatra.commands;Command;ExecutorView;S">S</a><span class="delimiter">]</span> = <span class="delimiter">(</span>this.type =&gt; S<span class="delimiter">)</span> =&gt; CommandExecutor<span class="delimiter">[</span>this.type, S<span class="delimiter">]</span>
  def <a title="[S](handler: Command.this.type =&gt; S)(implicit executor: Command.this.ExecutorView[S])S" id="org.scalatra.commands;Command.apply">apply</a><span class="delimiter">[</span><a title="" id="org.scalatra.commands;Command.apply;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Command.this.type =&gt; S" id="org.scalatra.commands;Command.apply.handler">handler</a>: this.type =&gt; S<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Command.this.ExecutorView[S]" id="org.scalatra.commands;Command.apply.executor">executor</a>: <span title="Command.this.ExecutorView[S]">ExecutorView</span><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#org.scalatra.commands;Command.apply.executor" title="(v1: Command.this.type =&gt; S)org.scalatra.commands.CommandExecutor[Command.this.type,S]">handler</a>.<a href="executors.scala.html#org.scalatra.commands;CommandExecutor.execute" title="(command: Command.this.type)S">execute</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
  def <a title="[S](handler: Command.this.type =&gt; S)(implicit executor: Command.this.ExecutorView[S])S" id="org.scalatra.commands;Command.execute">execute</a><span class="delimiter">[</span><a title="" id="org.scalatra.commands;Command.execute;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Command.this.type =&gt; S" id="org.scalatra.commands;Command.execute.handler">handler</a>: this.type =&gt; S<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Command.this.ExecutorView[S]" id="org.scalatra.commands;Command.execute.executor">executor</a>: <span title="Command.this.ExecutorView[S]">ExecutorView</span><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#org.scalatra.commands;Command.apply" title="(handler: Command.this.type =&gt; S)(implicit executor: Command.this.ExecutorView[S])S">apply</a><a href="#org.scalatra.commands;Command.execute.executor" title="Command.this.ExecutorView[S]" class="delimiter">(</a><a href="#org.scalatra.commands;Command.execute.handler" title="Command.this.type =&gt; S">handler</a><span class="delimiter">)</span>
  def <a title="[S](handler: Command.this.type =&gt; S)(implicit executor: Command.this.ExecutorView[S])S" id="org.scalatra.commands;Command.>>">&gt;&gt;</a><span class="delimiter">[</span><a title="" id="org.scalatra.commands;Command.>>;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Command.this.type =&gt; S" id="org.scalatra.commands;Command.>>.handler">handler</a>: this.type =&gt; S<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Command.this.ExecutorView[S]" id="org.scalatra.commands;Command.>>.executor">executor</a>: <span title="Command.this.ExecutorView[S]">ExecutorView</span><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.scalatra.commands;Command.>>;S" title="S">S</a> = <a href="#org.scalatra.commands;Command.apply" title="(handler: Command.this.type =&gt; S)(implicit executor: Command.this.ExecutorView[S])S">apply</a><a href="#org.scalatra.commands;Command.>>.executor" title="Command.this.ExecutorView[S]" class="delimiter">(</a><a href="#org.scalatra.commands;Command.>>.handler" title="Command.this.type =&gt; S">handler</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

trait <a title="trait ParamsOnlyCommand extends AnyRef with org.scalatra.commands.TypeConverterFactories with org.scalatra.commands.Command" id="org.scalatra.commands;ParamsOnlyCommand">ParamsOnlyCommand</a> extends <a href="TypeConverterFactory.scala.html#org.scalatra.commands;TypeConverterFactories" title="org.scalatra.commands.TypeConverterFactories">TypeConverterFactories</a> with <a href="#org.scalatra.commands;Command" title="org.scalatra.commands.Command">Command</a> <span class="delimiter">{</span>
  type <a title="[T]org.scalatra.commands.TypeConverterFactory[T]" id="org.scalatra.commands;ParamsOnlyCommand;CommandTypeConverterFactory">CommandTypeConverterFactory</a><span class="delimiter">[</span><a title="" id="org.scalatra.commands;ParamsOnlyCommand;CommandTypeConverterFactory;T">T</a><span class="delimiter">]</span> = <a href="TypeConverterFactory.scala.html#org.scalatra.commands;TypeConverterFactory" title="org.scalatra.commands.TypeConverterFactory[T]">TypeConverterFactory</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
<span class="delimiter">}</span>

<span class="comment">//trait ForceFromParams { self: Command =&gt;</span>
<span class="comment">//</span>
<span class="comment">//  def forceFromParams: Set[String]</span>
<span class="comment">//}</span>
<span class="comment">//</span>
<span class="comment">//trait ForceFromHeaders { self: Command =&gt;</span>
<span class="comment">//</span>
<span class="comment">//  def forceFromHeaders: Set[String]</span>
<span class="comment">//}</span>


        </pre>
    </body>
</html>
