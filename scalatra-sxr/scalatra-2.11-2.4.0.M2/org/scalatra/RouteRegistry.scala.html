<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>org/scalatra/RouteRegistry.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package org.scalatra

import scala.annotation.tailrec
import scala.collection.<span title="scala.collection.JavaConverters.type">JavaConverters</span>._
import scala.collection.concurrent.<span class="delimiter">{</span>Map =&gt; ConcurrentMap<span class="delimiter">}</span>
import java.util.concurrent.ConcurrentHashMap

class <a title="class RouteRegistry extends AnyRef" id="org.scalatra;RouteRegistry">RouteRegistry</a> <a href="#org.scalatra;RouteRegistry" title="org.scalatra.RouteRegistry" class="delimiter">{</a>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> val <a title="scala.collection.concurrent.Map[org.scalatra.HttpMethod,Seq[org.scalatra.Route]]" id="org.scalatra;RouteRegistry._methodRoutes">_methodRoutes</a>: <span title="scala.collection.concurrent.Map[org.scalatra.HttpMethod,Seq[org.scalatra.Route]]">ConcurrentMap</span><span class="delimiter">[</span>HttpMethod, Seq<span class="delimiter">[</span>Route<span class="delimiter">]</span><span class="delimiter">]</span> =
    new <span title="java.util.concurrent.ConcurrentHashMap[org.scalatra.HttpMethod,Seq[org.scalatra.Route]]">ConcurrentHashMap</span><span class="delimiter">[</span>HttpMethod, Seq<span class="delimiter">[</span>Route<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; scala.collection.concurrent.Map[org.scalatra.HttpMethod,Seq[org.scalatra.Route]]">asScala</span>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> val <a title="scala.collection.concurrent.Map[Int,org.scalatra.Route]" id="org.scalatra;RouteRegistry._statusRoutes">_statusRoutes</a>: <span title="scala.collection.concurrent.Map[Int,org.scalatra.Route]">ConcurrentMap</span><span class="delimiter">[</span>Int, Route<span class="delimiter">]</span> =
    new <span title="java.util.concurrent.ConcurrentHashMap[Int,org.scalatra.Route]">ConcurrentHashMap</span><span class="delimiter">[</span>Int, Route<span class="delimiter">]</span>.<span title="=&gt; scala.collection.concurrent.Map[Int,org.scalatra.Route]">asScala</span>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="Seq[org.scalatra.Route]" id="org.scalatra;RouteRegistry._beforeFilters">_beforeFilters</a>: <span title="Seq[org.scalatra.Route]">Seq</span><span class="delimiter">[</span>Route<span class="delimiter">]</span> = <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span>
  private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="Seq[org.scalatra.Route]" id="org.scalatra;RouteRegistry._afterFilters">_afterFilters</a>: <span title="Seq[org.scalatra.Route]">Seq</span><span class="delimiter">[</span>Route<span class="delimiter">]</span> = <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span>

  <span class="comment">/**
   * Returns the sequence of routes registered for the specified method.
   *
   * HEAD must be identical to GET without a body, so HEAD returns GET's
   * routes.
   */</span>
  def <a title="(method: org.scalatra.HttpMethod)Seq[org.scalatra.Route]" id="org.scalatra;RouteRegistry.apply(7a78a51ab2)">apply</a><span class="delimiter">(</span><a title="org.scalatra.HttpMethod" id="org.scalatra;RouteRegistry.apply(7a78a51ab2).method">method</a>: <a href="HttpMethod.scala.html#org.scalatra;HttpMethod" title="org.scalatra.HttpMethod">HttpMethod</a><span class="delimiter">)</span>: <span title="Seq[org.scalatra.Route]">Seq</span><span class="delimiter">[</span>Route<span class="delimiter">]</span> =
    <a href="#org.scalatra;RouteRegistry.apply(7a78a51ab2).method" title="org.scalatra.HttpMethod">method</a> match <span class="delimiter">{</span>
      case <a href="HttpMethod.scala.html#org.scalatra.Head" title="org.scalatra.Head.type">Head</a> =&gt; <a href="#org.scalatra;RouteRegistry._methodRoutes" title="scala.collection.concurrent.Map[org.scalatra.HttpMethod,Seq[org.scalatra.Route]]">_methodRoutes</a>.<span title="(key: org.scalatra.HttpMethod, default: =&gt; Seq[org.scalatra.Route])Seq[org.scalatra.Route]">getOrElse</span><span class="delimiter">(</span><a href="HttpMethod.scala.html#org.scalatra.Head" title="org.scalatra.Head.type">Head</a>, <a href="#org.scalatra;RouteRegistry._methodRoutes" title="scala.collection.concurrent.Map[org.scalatra.HttpMethod,Seq[org.scalatra.Route]]">_methodRoutes</a>.<span title="(key: org.scalatra.HttpMethod, default: =&gt; Seq[org.scalatra.Route])Seq[org.scalatra.Route]">getOrElse</span><span class="delimiter">(</span><a href="HttpMethod.scala.html#org.scalatra.Get" title="org.scalatra.Get.type">Get</a>, <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case <a title="org.scalatra.HttpMethod" id="org.scalatra;RouteRegistry.apply(7a78a51ab2).m">m</a> =&gt; <a href="#org.scalatra;RouteRegistry._methodRoutes" title="scala.collection.concurrent.Map[org.scalatra.HttpMethod,Seq[org.scalatra.Route]]">_methodRoutes</a>.<span title="(key: org.scalatra.HttpMethod, default: =&gt; Seq[org.scalatra.Route])Seq[org.scalatra.Route]">getOrElse</span><span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.apply(7a78a51ab2).m" title="org.scalatra.HttpMethod">m</a>, <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Return a route for a specific HTTP response status code.
   * @param statusCode the status code.
   *
   */</span>
  def <a title="(statusCode: Int)Option[org.scalatra.Route]" id="org.scalatra;RouteRegistry.apply(617297f2cf)">apply</a><span class="delimiter">(</span><a title="Int" id="org.scalatra;RouteRegistry.apply(617297f2cf).statusCode">statusCode</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Option[org.scalatra.Route]">Option</span><span class="delimiter">[</span>Route<span class="delimiter">]</span> = <a href="#org.scalatra;RouteRegistry._statusRoutes" title="scala.collection.concurrent.Map[Int,org.scalatra.Route]">_statusRoutes</a>.<span title="(key: Int)Option[org.scalatra.Route]">get</span><span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.apply(617297f2cf).statusCode" title="Int">statusCode</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns a set of methods with a matching route.
   *
   * HEAD must be identical to GET without a body, so GET implies HEAD.
   */</span>
  def <a title="(requestPath: String)Set[org.scalatra.HttpMethod]" id="org.scalatra;RouteRegistry.matchingMethods">matchingMethods</a><span class="delimiter">(</span><a title="String" id="org.scalatra;RouteRegistry.matchingMethods.requestPath">requestPath</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Set[org.scalatra.HttpMethod]">Set</span><span class="delimiter">[</span>HttpMethod<span class="delimiter">]</span> = <a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150)" title="(requestPath: String)(p: org.scalatra.HttpMethod =&gt; Boolean)scala.collection.immutable.Set[org.scalatra.HttpMethod]">matchingMethodsExcept</a><span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.matchingMethods.requestPath" title="String">requestPath</a><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="org.scalatra.HttpMethod" id="org.scalatra;RouteRegistry.matchingMethods.$anonfun.x$1">_</a> =&gt; false <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a set of methods with a matching route minus a specified
   * method.
   *
   * HEAD must be identical to GET without a body, so:
   * - GET implies HEAD
   * - filtering one filters the other
   */</span>
  def <a title="(method: org.scalatra.HttpMethod, requestPath: String)Set[org.scalatra.HttpMethod]" id="org.scalatra;RouteRegistry.matchingMethodsExcept(1136c98797)">matchingMethodsExcept</a><span class="delimiter">(</span><a title="org.scalatra.HttpMethod" id="org.scalatra;RouteRegistry.matchingMethodsExcept(1136c98797).method">method</a>: <a href="HttpMethod.scala.html#org.scalatra;HttpMethod" title="org.scalatra.HttpMethod">HttpMethod</a>, <a title="String" id="org.scalatra;RouteRegistry.matchingMethodsExcept(1136c98797).requestPath">requestPath</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Set[org.scalatra.HttpMethod]">Set</span><span class="delimiter">[</span>HttpMethod<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="org.scalatra.HttpMethod =&gt; Boolean" id="org.scalatra;RouteRegistry.matchingMethodsExcept(1136c98797).p">p</a>: HttpMethod =&gt; Boolean = <a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(1136c98797).method" title="org.scalatra.HttpMethod">method</a> match <span class="delimiter">{</span>
      case <a href="HttpMethod.scala.html#org.scalatra.Get" title="org.scalatra.Get.type">Get</a> | <a href="HttpMethod.scala.html#org.scalatra.Head" title="org.scalatra.Head.type">Head</a> =&gt; <span class="delimiter">{</span> <a title="org.scalatra.HttpMethod" id="org.scalatra;RouteRegistry.matchingMethodsExcept(1136c98797).p.$anonfun.m">m</a> =&gt; <a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(1136c98797).p.$anonfun.m" title="org.scalatra.HttpMethod">m</a> <span title="(x$1: Any)Boolean">==</span> <a href="HttpMethod.scala.html#org.scalatra.Get" title="org.scalatra.Get.type">Get</a> <span title="(x: Boolean)Boolean">||</span> <a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(1136c98797).p.$anonfun.m" title="org.scalatra.HttpMethod">m</a> <span title="(x$1: Any)Boolean">==</span> <a href="HttpMethod.scala.html#org.scalatra.Head" title="org.scalatra.Head.type">Head</a> <span class="delimiter">}</span>
      case _ =&gt; <span class="delimiter">{</span> <a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(1136c98797).p.$anonfun.x$2" title="org.scalatra.HttpMethod">_</a> <span title="(x$1: Any)Boolean">==</span> <a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(1136c98797).method" title="org.scalatra.HttpMethod">method</a> <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150)" title="(requestPath: String)(p: org.scalatra.HttpMethod =&gt; Boolean)scala.collection.immutable.Set[org.scalatra.HttpMethod]">matchingMethodsExcept</a><span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(1136c98797).requestPath" title="String">requestPath</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(1136c98797).p" title="org.scalatra.HttpMethod =&gt; Boolean">p</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private def <a title="(requestPath: String)(p: org.scalatra.HttpMethod =&gt; Boolean)scala.collection.immutable.Set[org.scalatra.HttpMethod]" id="org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150)">matchingMethodsExcept</a><span class="delimiter">(</span><a title="String" id="org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).requestPath">requestPath</a>: <span title="String">String</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="org.scalatra.HttpMethod =&gt; Boolean" id="org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).p">p</a>: HttpMethod =&gt; Boolean<span class="delimiter">)</span> = <span class="delimiter">{</span>
    var <a title="scala.collection.immutable.Set[org.scalatra.HttpMethod]" id="org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).methods">methods</a> = <span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry._methodRoutes" title="scala.collection.concurrent.Map[org.scalatra.HttpMethod,Seq[org.scalatra.Route]]">_methodRoutes</a> <span title="(p: ((org.scalatra.HttpMethod, Seq[org.scalatra.Route])) =&gt; Boolean)scala.collection.mutable.Map[org.scalatra.HttpMethod,Seq[org.scalatra.Route]]">filter</span> <span class="delimiter">{</span> <a title="(org.scalatra.HttpMethod, Seq[org.scalatra.Route])" id="org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).methods.$anonfun.kv">kv</a> =&gt;
      val <a title="org.scalatra.HttpMethod" id="org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).methods.$anonfun.method">method</a> = <a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).methods.$anonfun.kv" title="(org.scalatra.HttpMethod, Seq[org.scalatra.Route])">kv</a>.<span title="=&gt; org.scalatra.HttpMethod">_1</span>
      val <a title="Seq[org.scalatra.Route]" id="org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).methods.$anonfun.routes">routes</a> = <a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).methods.$anonfun.kv" title="(org.scalatra.HttpMethod, Seq[org.scalatra.Route])">kv</a>.<span title="=&gt; Seq[org.scalatra.Route]">_2</span>
      <span title="=&gt; Boolean">!</span><a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).p" title="(v1: org.scalatra.HttpMethod)Boolean">p</a><span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).methods.$anonfun.method" title="org.scalatra.HttpMethod">method</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).methods.$anonfun.routes" title="Seq[org.scalatra.Route]">routes</a> <span title="(p: org.scalatra.Route =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).methods.$anonfun.$anonfun.x$3" title="org.scalatra.Route">_</a>.<a href="route.scala.html#org.scalatra;Route.apply" title="(requestPath: String)Option[org.scalatra.MatchedRoute]">apply</a><span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).requestPath" title="String">requestPath</a><span class="delimiter">)</span>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>.<span title="=&gt; Iterable[org.scalatra.HttpMethod]">keys</span>.<span title="scala.collection.immutable.Set[org.scalatra.HttpMethod]">toSet</span>
    if <span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).methods" title="scala.collection.immutable.Set[org.scalatra.HttpMethod]">methods</a>.<span title="(elem: org.scalatra.HttpMethod)Boolean">contains</span><span class="delimiter">(</span><a href="HttpMethod.scala.html#org.scalatra.Get" title="org.scalatra.Get.type">Get</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).methods" title="scala.collection.immutable.Set[org.scalatra.HttpMethod]">methods</a> <span title="(elem: org.scalatra.HttpMethod)scala.collection.immutable.Set[org.scalatra.HttpMethod]">+=</span> <a href="HttpMethod.scala.html#org.scalatra.Head" title="org.scalatra.Head.type">Head</a>
    <a href="#org.scalatra;RouteRegistry.matchingMethodsExcept(a0b6236150).methods" title="scala.collection.immutable.Set[org.scalatra.HttpMethod]">methods</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Add a route that explicitly matches one or more response codes.
   */</span>
  def <a title="(codes: Range, route: org.scalatra.Route)Unit" id="org.scalatra;RouteRegistry.addStatusRoute">addStatusRoute</a><span class="delimiter">(</span><a title="Range" id="org.scalatra;RouteRegistry.addStatusRoute.codes">codes</a>: <span title="Range">Range</span>, <a title="org.scalatra.Route" id="org.scalatra;RouteRegistry.addStatusRoute.route">route</a>: <a href="route.scala.html#org.scalatra;Route" title="org.scalatra.Route">Route</a><span class="delimiter">)</span> = <a href="#org.scalatra;RouteRegistry.addStatusRoute.codes" title="Range">codes</a>.<span title="(f: Int =&gt; Option[org.scalatra.Route])Unit">foreach</span> <span class="delimiter">{</span> <a title="Int" id="org.scalatra;RouteRegistry.addStatusRoute.$anonfun.code">code</a> =&gt; <a href="#org.scalatra;RouteRegistry._statusRoutes" title="scala.collection.concurrent.Map[Int,org.scalatra.Route]">_statusRoutes</a>.<span title="(key: Int, value: org.scalatra.Route)Option[org.scalatra.Route]">put</span><span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.addStatusRoute.$anonfun.code" title="Int">code</a>, <a href="#org.scalatra;RouteRegistry.addStatusRoute.route" title="org.scalatra.Route">route</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">/**
   * Prepends a route to the method's route sequence.
   */</span>
  def <a title="(method: org.scalatra.HttpMethod, route: org.scalatra.Route)Unit" id="org.scalatra;RouteRegistry.prependRoute">prependRoute</a><span class="delimiter">(</span><a title="org.scalatra.HttpMethod" id="org.scalatra;RouteRegistry.prependRoute.method">method</a>: <a href="HttpMethod.scala.html#org.scalatra;HttpMethod" title="org.scalatra.HttpMethod">HttpMethod</a>, <a title="org.scalatra.Route" id="org.scalatra;RouteRegistry.prependRoute.route">route</a>: <a href="route.scala.html#org.scalatra;Route" title="org.scalatra.Route">Route</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#org.scalatra;RouteRegistry.modifyRoutes" title="(method: org.scalatra.HttpMethod, f: Seq[org.scalatra.Route] =&gt; Seq[org.scalatra.Route])Unit">modifyRoutes</a><span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.prependRoute.method" title="org.scalatra.HttpMethod">method</a>, <a href="#org.scalatra;RouteRegistry.prependRoute.route" title="org.scalatra.Route">route</a> <a href="#org.scalatra;RouteRegistry.prependRoute.$anonfun.x$5" title="(elem: org.scalatra.Route)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[org.scalatra.Route],org.scalatra.Route,Seq[org.scalatra.Route]])Seq[org.scalatra.Route]">+:</a> <a href="#org.scalatra;RouteRegistry.prependRoute.$anonfun.x$4" title="Seq[org.scalatra.Route]">_</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Removes a route from the method's route seqeuence.
   */</span>
  def <a title="(method: org.scalatra.HttpMethod, route: org.scalatra.Route)Unit" id="org.scalatra;RouteRegistry.removeRoute">removeRoute</a><span class="delimiter">(</span><a title="org.scalatra.HttpMethod" id="org.scalatra;RouteRegistry.removeRoute.method">method</a>: <a href="HttpMethod.scala.html#org.scalatra;HttpMethod" title="org.scalatra.HttpMethod">HttpMethod</a>, <a title="org.scalatra.Route" id="org.scalatra;RouteRegistry.removeRoute.route">route</a>: <a href="route.scala.html#org.scalatra;Route" title="org.scalatra.Route">Route</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#org.scalatra;RouteRegistry.modifyRoutes" title="(method: org.scalatra.HttpMethod, f: Seq[org.scalatra.Route] =&gt; Seq[org.scalatra.Route])Unit">modifyRoutes</a><span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.removeRoute.method" title="org.scalatra.HttpMethod">method</a>, <a href="#org.scalatra;RouteRegistry.removeRoute.$anonfun.x$6" title="Seq[org.scalatra.Route]">_</a> <span title="(p: org.scalatra.Route =&gt; Boolean)Seq[org.scalatra.Route]">filterNot</span> <span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.removeRoute.$anonfun.$anonfun.x$7" title="org.scalatra.Route">_</a> <span title="(x$1: Any)Boolean">==</span> <a href="#org.scalatra;RouteRegistry.removeRoute.route" title="org.scalatra.Route">route</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the sequence of filters to run before the route.
   */</span>
  def <a title="=&gt; Seq[org.scalatra.Route]" id="org.scalatra;RouteRegistry.beforeFilters">beforeFilters</a>: <span title="Seq[org.scalatra.Route]">Seq</span><span class="delimiter">[</span>Route<span class="delimiter">]</span> = <a href="#org.scalatra;RouteRegistry._beforeFilters" title="Seq[org.scalatra.Route]">_beforeFilters</a>

  <span class="comment">/**
   * Appends a filter to the sequence of before filters.
   */</span>
  def <a title="(route: org.scalatra.Route)Unit" id="org.scalatra;RouteRegistry.appendBeforeFilter">appendBeforeFilter</a><span class="delimiter">(</span><a title="org.scalatra.Route" id="org.scalatra;RouteRegistry.appendBeforeFilter.route">route</a>: <a href="route.scala.html#org.scalatra;Route" title="org.scalatra.Route">Route</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#org.scalatra;RouteRegistry._beforeFilters" title="Seq[org.scalatra.Route]">_beforeFilters</a> <span title="(elem: org.scalatra.Route)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[org.scalatra.Route],org.scalatra.Route,Seq[org.scalatra.Route]])Seq[org.scalatra.Route]">:+=</span> <a href="#org.scalatra;RouteRegistry.appendBeforeFilter.route" title="org.scalatra.Route">route</a>

  <span class="comment">/**
   * Returns the sequence of filters to run after the route.
   */</span>
  def <a title="=&gt; Seq[org.scalatra.Route]" id="org.scalatra;RouteRegistry.afterFilters">afterFilters</a>: <span title="Seq[org.scalatra.Route]">Seq</span><span class="delimiter">[</span>Route<span class="delimiter">]</span> = <a href="#org.scalatra;RouteRegistry._afterFilters" title="Seq[org.scalatra.Route]">_afterFilters</a>

  <span class="comment">/**
   * Appends a filter to the sequence of before filters.
   */</span>
  def <a title="(route: org.scalatra.Route)Unit" id="org.scalatra;RouteRegistry.appendAfterFilter">appendAfterFilter</a><span class="delimiter">(</span><a title="org.scalatra.Route" id="org.scalatra;RouteRegistry.appendAfterFilter.route">route</a>: <a href="route.scala.html#org.scalatra;Route" title="org.scalatra.Route">Route</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#org.scalatra;RouteRegistry._afterFilters" title="Seq[org.scalatra.Route]">_afterFilters</a> <span title="(elem: org.scalatra.Route)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[org.scalatra.Route],org.scalatra.Route,Seq[org.scalatra.Route]])Seq[org.scalatra.Route]">:+=</span> <a href="#org.scalatra;RouteRegistry.appendAfterFilter.route" title="org.scalatra.Route">route</a>

  @tailrec private def <a title="(method: org.scalatra.HttpMethod, f: Seq[org.scalatra.Route] =&gt; Seq[org.scalatra.Route])Unit" id="org.scalatra;RouteRegistry.modifyRoutes">modifyRoutes</a><span class="delimiter">(</span><a title="org.scalatra.HttpMethod" id="org.scalatra;RouteRegistry.modifyRoutes.method">method</a>: <a href="HttpMethod.scala.html#org.scalatra;HttpMethod" title="org.scalatra.HttpMethod">HttpMethod</a>, <a title="Seq[org.scalatra.Route] =&gt; Seq[org.scalatra.Route]" id="org.scalatra;RouteRegistry.modifyRoutes.f">f</a>: <span class="delimiter">(</span>Seq<span class="delimiter">[</span>Route<span class="delimiter">]</span> =&gt; Seq<span class="delimiter">[</span>Route<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry._methodRoutes" title="scala.collection.concurrent.Map[org.scalatra.HttpMethod,Seq[org.scalatra.Route]]">_methodRoutes</a>.<span title="(k: org.scalatra.HttpMethod, v: Seq[org.scalatra.Route])Option[Seq[org.scalatra.Route]]">putIfAbsent</span><span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.modifyRoutes.method" title="org.scalatra.HttpMethod">method</a>, <a href="#org.scalatra;RouteRegistry.modifyRoutes.f" title="(v1: Seq[org.scalatra.Route])Seq[org.scalatra.Route]">f</a><span class="delimiter">(</span><span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="Seq[org.scalatra.Route]" id="org.scalatra;RouteRegistry.modifyRoutes.oldRoutes">oldRoutes</a> = <a href="#org.scalatra;RouteRegistry._methodRoutes" title="(key: org.scalatra.HttpMethod)Seq[org.scalatra.Route]">_methodRoutes</a><span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.modifyRoutes.method" title="org.scalatra.HttpMethod">method</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#org.scalatra;RouteRegistry._methodRoutes" title="scala.collection.concurrent.Map[org.scalatra.HttpMethod,Seq[org.scalatra.Route]]">_methodRoutes</a>.<span title="(k: org.scalatra.HttpMethod, oldvalue: Seq[org.scalatra.Route], newvalue: Seq[org.scalatra.Route])Boolean">replace</span><span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.modifyRoutes.method" title="org.scalatra.HttpMethod">method</a>, <a href="#org.scalatra;RouteRegistry.modifyRoutes.oldRoutes" title="Seq[org.scalatra.Route]">oldRoutes</a>, <a href="#org.scalatra;RouteRegistry.modifyRoutes.f" title="(v1: Seq[org.scalatra.Route])Seq[org.scalatra.Route]">f</a><span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.modifyRoutes.oldRoutes" title="Seq[org.scalatra.Route]">oldRoutes</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#org.scalatra;RouteRegistry.modifyRoutes" title="(method: org.scalatra.HttpMethod, f: Seq[org.scalatra.Route] =&gt; Seq[org.scalatra.Route])Unit">modifyRoutes</a><span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.modifyRoutes.method" title="org.scalatra.HttpMethod">method</a>, <a href="#org.scalatra;RouteRegistry.modifyRoutes.f" title="Seq[org.scalatra.Route] =&gt; Seq[org.scalatra.Route]">f</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * List of entry points, made of all route matchers
   */</span>
  def <a title="=&gt; Seq[String]" id="org.scalatra;RouteRegistry.entryPoints">entryPoints</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span> =
    <span class="delimiter">(</span>for <span class="delimiter">{</span>
      <span class="delimiter">(</span><a title="org.scalatra.HttpMethod" id="org.scalatra;RouteRegistry.entryPoints.$anonfun.method">method</a>, <a title="Seq[org.scalatra.Route]" id="org.scalatra;RouteRegistry.entryPoints.$anonfun.routes">routes</a><span class="delimiter">)</span> &lt;- <a href="#org.scalatra;RouteRegistry._methodRoutes" title="(f: ((org.scalatra.HttpMethod, Seq[org.scalatra.Route])) =&gt; scala.collection.GenTraversableOnce[String])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.Map[org.scalatra.HttpMethod,Seq[org.scalatra.Route]],String,scala.collection.mutable.Iterable[String]])scala.collection.mutable.Iterable[String]">_methodRoutes</a>
      <a title="org.scalatra.Route" id="org.scalatra;RouteRegistry.entryPoints.$anonfun.$anonfun.route">route</a> &lt;- <a href="#org.scalatra;RouteRegistry.entryPoints.$anonfun.routes" title="(f: org.scalatra.Route =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[org.scalatra.Route],String,Seq[String]])Seq[String]">routes</a>
    <span class="delimiter">}</span> yield <a href="#org.scalatra;RouteRegistry.entryPoints.$anonfun.method" title="(self: org.scalatra.HttpMethod)any2stringadd[org.scalatra.HttpMethod]">method</a> <span title="(other: String)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#org.scalatra;RouteRegistry.entryPoints.$anonfun.$anonfun.route" title="org.scalatra.Route">route</a><span class="delimiter">)</span>.<span title="=&gt; Seq[String]">toSeq</span> <span title="(lt: (String, String) =&gt; Boolean)Seq[String]">sortWith</span> <span class="delimiter">(</span><a href="#org.scalatra;RouteRegistry.entryPoints.$anonfun.x$9" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">_</a> <span title="(that: String)Boolean">&lt;</span> <a href="#org.scalatra;RouteRegistry.entryPoints.$anonfun.x$10" title="String">_</a><span class="delimiter">)</span>

  def <a title="=&gt; scala.collection.mutable.Map[org.scalatra.HttpMethod,Seq[org.scalatra.Route]]" id="org.scalatra;RouteRegistry.methodRoutes">methodRoutes</a> = <a href="#org.scalatra;RouteRegistry._methodRoutes" title="scala.collection.concurrent.Map[org.scalatra.HttpMethod,Seq[org.scalatra.Route]]">_methodRoutes</a>.<span title="()scala.collection.mutable.Map[org.scalatra.HttpMethod,Seq[org.scalatra.Route]]">clone</span><span class="delimiter">(</span><span class="delimiter">)</span>

  override def <a title="()String" id="org.scalatra;RouteRegistry.toString">toString</a>: <span title="String">String</span> = <a href="#org.scalatra;RouteRegistry.entryPoints" title="=&gt; Seq[String]">entryPoints</a> <span title="(sep: String)String">mkString</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
