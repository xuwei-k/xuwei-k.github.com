<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>org/scalatra/util/conversion/conversions.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package org.scalatra
package util
package conversion

import java.util.Date
import java.text.<span class="delimiter">{</span>DateFormat, SimpleDateFormat<span class="delimiter">}</span>
import scala.util.control.<span title="scala.util.control.Exception.type">Exception</span>.allCatch
import scala._

<span class="comment">/**
 * Support types and implicits for [[org.scalatra.util.conversion.TypeConverter]].
 */</span>
trait <a title="trait TypeConverterSupport extends AnyRef" id="org.scalatra.util.conversion;TypeConverterSupport">TypeConverterSupport</a> <span title="Unit" class="delimiter">{</span>

  implicit def <a title="[S, T](f: S =&gt; T)org.scalatra.util.conversion.TypeConverter[S,T]" id="org.scalatra.util.conversion;TypeConverterSupport.safe">safe</a><span class="delimiter">[</span><a title="" id="org.scalatra.util.conversion;TypeConverterSupport.safe;S">S</a>, <a title="" id="org.scalatra.util.conversion;TypeConverterSupport.safe;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S =&gt; T" id="org.scalatra.util.conversion;TypeConverterSupport.safe.f">f</a>: S =&gt; T<span class="delimiter">)</span>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[S,T]">TypeConverter</a><span class="delimiter">[</span>S, T<span class="delimiter">]</span> = new <a title="&lt;$anon: org.scalatra.util.conversion.TypeConverter[S,T]&gt; extends AnyRef with org.scalatra.util.conversion.TypeConverter[S,T]" id="org.scalatra.util.conversion;TypeConverterSupport.safe;$anon">TypeConverter</a><span class="delimiter">[</span>S, T<span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="(s: S)Option[T]" id="org.scalatra.util.conversion;TypeConverterSupport.safe;$anon.apply">apply</a><span class="delimiter">(</span><a title="S" id="org.scalatra.util.conversion;TypeConverterSupport.safe;$anon.apply.s">s</a>: <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe;S" title="S">S</a><span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="util.control.Exception.Catch[Nothing]">allCatch</span> <span title="(body: =&gt; T)Option[T]">opt</span> <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe.f" title="(v1: S)T">f</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;TypeConverterSupport.safe;$anon.apply.s" title="S">s</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * Implicit convert a `(String) =&gt; Option[T]` function into a `TypeConverter[T]`
   */</span>
  implicit def <a title="[S, T](f: S =&gt; Option[T])org.scalatra.util.conversion.TypeConverter[S,T]" id="org.scalatra.util.conversion;TypeConverterSupport.safeOption">safeOption</a><span class="delimiter">[</span><a title="" id="org.scalatra.util.conversion;TypeConverterSupport.safeOption;S">S</a>, <a title="" id="org.scalatra.util.conversion;TypeConverterSupport.safeOption;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S =&gt; Option[T]" id="org.scalatra.util.conversion;TypeConverterSupport.safeOption.f">f</a>: S =&gt; Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[S,T]">TypeConverter</a><span class="delimiter">[</span>S, T<span class="delimiter">]</span> = new <a title="&lt;$anon: org.scalatra.util.conversion.TypeConverter[S,T]&gt; extends AnyRef with org.scalatra.util.conversion.TypeConverter[S,T]" id="org.scalatra.util.conversion;TypeConverterSupport.safeOption;$anon">TypeConverter</a><span class="delimiter">[</span>S, T<span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="(v1: S)Option[T]" id="org.scalatra.util.conversion;TypeConverterSupport.safeOption;$anon.apply">apply</a><span class="delimiter">(</span><a title="S" id="org.scalatra.util.conversion;TypeConverterSupport.safeOption;$anon.apply.v1">v1</a>: <a href="#org.scalatra.util.conversion;TypeConverterSupport.safeOption;S" title="S">S</a><span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="util.control.Exception.Catch[Nothing]">allCatch</span>.<span title="(f: Throwable =&gt; None.type)util.control.Exception.Catch[None.type]">withApply</span><span title="(body: =&gt; Option[T])Option[T]" class="delimiter">(</span><a title="Throwable" id="org.scalatra.util.conversion;TypeConverterSupport.safeOption;$anon.apply.$anonfun.x$1">_</a> =&gt; <span title="None.type">None</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;TypeConverterSupport.safeOption.f" title="(v1: S)Option[T]">f</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;TypeConverterSupport.safeOption;$anon.apply.v1" title="S">v1</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

object <a title="org.scalatra.util.conversion.TypeConverterSupport.type" id="org.scalatra.util.conversion.TypeConverterSupport">TypeConverterSupport</a> extends <a href="#org.scalatra.util.conversion;TypeConverterSupport" title="org.scalatra.util.conversion.TypeConverterSupport">TypeConverterSupport</a>

trait <a title="trait LowestPriorityImplicitConversions extends AnyRef with org.scalatra.util.conversion.TypeConverterSupport" id="org.scalatra.util.conversion;LowestPriorityImplicitConversions">LowestPriorityImplicitConversions</a> extends <a href="#org.scalatra.util.conversion;TypeConverterSupport" title="org.scalatra.util.conversion.TypeConverterSupport">TypeConverterSupport</a> <span class="delimiter">{</span>
  implicit def <a title="[T](implicit evidence$1: Manifest[T])org.scalatra.util.conversion.TypeConverter[Any,T]" id="org.scalatra.util.conversion;LowestPriorityImplicitConversions.lowestPriorityAny2T">lowestPriorityAny2T</a><span class="delimiter">[</span><a title="" id="org.scalatra.util.conversion;LowestPriorityImplicitConversions.lowestPriorityAny2T;T">T</a>:Manifest<span class="delimiter">]</span>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[Any,T]">TypeConverter</a><span class="delimiter">[</span>Any, T<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: Any =&gt; T)org.scalatra.util.conversion.TypeConverter[Any,T]">safe</a> <a href="#org.scalatra.util.conversion;LowestPriorityImplicitConversions.lowestPriorityAny2T.$anonfun.x0$1" title="T" class="delimiter">{</a>
    case <a title="Any" id="org.scalatra.util.conversion;LowestPriorityImplicitConversions.lowestPriorityAny2T.$anonfun.a">a</a> if <span title="[T](implicit m: Manifest[T])Manifest[T]">manifest</span><a href="#org.scalatra.util.conversion;LowestPriorityImplicitConversions.lowestPriorityAny2T.evidence$1" title="(implicit m: Manifest[T])Manifest[T]" class="delimiter">[</a><a href="#org.scalatra.util.conversion;LowestPriorityImplicitConversions.lowestPriorityAny2T;T" title="T">T</a><span class="delimiter">]</span>.<span title="=&gt; Class[_]">erasure</span>.<span title="(x$1: Class[_])Boolean">isAssignableFrom</span><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;LowestPriorityImplicitConversions.lowestPriorityAny2T.$anonfun.a" title="Any">a</a>.<span title="()Class[_]">getClass</span><span class="delimiter">)</span> =&gt; <a href="#org.scalatra.util.conversion;LowestPriorityImplicitConversions.lowestPriorityAny2T.$anonfun.a" title="Any">a</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#org.scalatra.util.conversion;LowestPriorityImplicitConversions.lowestPriorityAny2T;T" title="T">T</a><span class="delimiter">]</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

trait <a title="trait LowPriorityImplicitConversions extends AnyRef with org.scalatra.util.conversion.LowestPriorityImplicitConversions" id="org.scalatra.util.conversion;LowPriorityImplicitConversions">LowPriorityImplicitConversions</a> extends <a href="#org.scalatra.util.conversion;LowestPriorityImplicitConversions" title="org.scalatra.util.conversion.LowestPriorityImplicitConversions">LowestPriorityImplicitConversions</a> <span class="delimiter">{</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[Any,Boolean]" id="org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToBoolean">anyToBoolean</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[Any,Boolean]">TypeConverter</a><span class="delimiter">[</span>Any, Boolean<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: Any =&gt; Boolean)org.scalatra.util.conversion.TypeConverter[Any,Boolean]">safe</a> <a href="#org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToBoolean.$anonfun.x0$2" title="Boolean" class="delimiter">{</a>
    case <a title="Boolean" id="org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToBoolean.$anonfun.b">b</a>: <span title="Boolean">Boolean</span> =&gt; <a href="#org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToBoolean.$anonfun.b" title="Boolean">b</a>
    case <span title="String(&quot;ON&quot;)" class="string">&quot;ON&quot;</span> | <span title="String(&quot;TRUE&quot;)" class="string">&quot;TRUE&quot;</span> | <span title="String(&quot;OK&quot;)" class="string">&quot;OK&quot;</span> | <span title="String(&quot;1&quot;)" class="string">&quot;1&quot;</span> | <span title="String(&quot;CHECKED&quot;)" class="string">&quot;CHECKED&quot;</span> | <span title="String(&quot;YES&quot;)" class="string">&quot;YES&quot;</span> | <span title="String(&quot;ENABLE&quot;)" class="string">&quot;ENABLE&quot;</span> | <span title="String(&quot;ENABLED&quot;)" class="string">&quot;ENABLED&quot;</span> =&gt; true
    case <a title="Number" id="org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToBoolean.$anonfun.n">n</a>: <span title="Number">Number</span> =&gt; <a href="#org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToBoolean.$anonfun.n" title="Number">n</a> <span title="(x$1: Any)Boolean">!=</span> <span title="Int(0)" class="int">0</span>
    case _ =&gt; false
  <span class="delimiter">}</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[Any,Float]" id="org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToFloat">anyToFloat</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[Any,Float]">TypeConverter</a><span class="delimiter">[</span>Any, Float<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: Any =&gt; Float)org.scalatra.util.conversion.TypeConverter[Any,Float]">safe</a> <a href="#org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToFloat.$anonfun.x0$3" title="Float" class="delimiter">{</a>
    case <span title="Byte">i</span>: <span title="Byte">Byte</span> =&gt; <span title="Byte">i</span>.<span title="=&gt; Float">toFloat</span>
    case <span title="Short">i</span>: <span title="Short">Short</span> =&gt; <span title="Short">i</span>.<span title="=&gt; Float">toFloat</span>
    case <span title="Int">i</span>: <span title="Int">Int</span> =&gt; <span title="Int">i</span>.<span title="=&gt; Float">toFloat</span>
    case <span title="Long">i</span>: <span title="Long">Long</span> =&gt; <span title="Long">i</span>.<span title="=&gt; Float">toFloat</span>
    case <span title="Double">i</span>: <span title="Double">Double</span> =&gt; <span title="Double">i</span>.<span title="=&gt; Float">toFloat</span>
    case <span title="Float">i</span>: <span title="Float">Float</span> =&gt; <span title="Float">i</span>
    case <span title="String">i</span>: <span title="String">String</span> =&gt; <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">i</span>.<span title="=&gt; Float">toFloat</span>
  <span class="delimiter">}</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[Any,Double]" id="org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToDouble">anyToDouble</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[Any,Double]">TypeConverter</a><span class="delimiter">[</span>Any, Double<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: Any =&gt; Double)org.scalatra.util.conversion.TypeConverter[Any,Double]">safe</a> <a href="#org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToDouble.$anonfun.x0$4" title="Double" class="delimiter">{</a>
    case <span title="Byte">i</span>: <span title="Byte">Byte</span> =&gt; <span title="Byte">i</span>.<span title="=&gt; Double">toDouble</span>
    case <span title="Short">i</span>: <span title="Short">Short</span> =&gt; <span title="Short">i</span>.<span title="=&gt; Double">toDouble</span>
    case <span title="Int">i</span>: <span title="Int">Int</span> =&gt; <span title="Int">i</span>.<span title="=&gt; Double">toDouble</span>
    case <span title="Long">i</span>: <span title="Long">Long</span> =&gt; <span title="Long">i</span>.<span title="=&gt; Double">toDouble</span>
    case <span title="Double">i</span>: <span title="Double">Double</span> =&gt; <span title="Double">i</span>
    case <span title="Float">i</span>: <span title="Float">Float</span> =&gt; <span title="Float">i</span>.<span title="=&gt; Double">toDouble</span>
    case <span title="String">i</span>: <span title="String">String</span> =&gt; <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">i</span>.<span title="=&gt; Double">toDouble</span>
  <span class="delimiter">}</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[Any,Byte]" id="org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToByte">anyToByte</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[Any,Byte]">TypeConverter</a><span class="delimiter">[</span>Any, Byte<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: Any =&gt; Byte)org.scalatra.util.conversion.TypeConverter[Any,Byte]">safe</a> <a href="#org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToByte.$anonfun.x0$5" title="Byte" class="delimiter">{</a>
    case <span title="Byte">i</span>: <span title="Byte">Byte</span> =&gt; <span title="Byte">i</span>
    case <span title="Short">i</span>: <span title="Short">Short</span> =&gt; <span title="Short">i</span>.<span title="=&gt; Byte">toByte</span>
    case <span title="Int">i</span>: <span title="Int">Int</span> =&gt; <span title="Int">i</span>.<span title="=&gt; Byte">toByte</span>
    case <span title="Long">i</span>: <span title="Long">Long</span> =&gt; <span title="Long">i</span>.<span title="=&gt; Byte">toByte</span>
    case <span title="Double">i</span>: <span title="Double">Double</span> =&gt; <span title="Double">i</span>.<span title="=&gt; Byte">toByte</span>
    case <span title="Float">i</span>: <span title="Float">Float</span> =&gt; <span title="Float">i</span>.<span title="=&gt; Byte">toByte</span>
    case <span title="String">i</span>: <span title="String">String</span> =&gt; <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">i</span>.<span title="=&gt; Byte">toByte</span>
  <span class="delimiter">}</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[Any,Short]" id="org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToShort">anyToShort</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[Any,Short]">TypeConverter</a><span class="delimiter">[</span>Any, Short<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: Any =&gt; Short)org.scalatra.util.conversion.TypeConverter[Any,Short]">safe</a> <a href="#org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToShort.$anonfun.x0$6" title="Short" class="delimiter">{</a>
    case <span title="Byte">i</span>: <span title="Byte">Byte</span> =&gt; <span title="Byte">i</span>.<span title="=&gt; Short">toShort</span>
    case <span title="Short">i</span>: <span title="Short">Short</span> =&gt; <span title="Short">i</span>
    case <span title="Int">i</span>: <span title="Int">Int</span> =&gt; <span title="Int">i</span>.<span title="=&gt; Short">toShort</span>
    case <span title="Long">i</span>: <span title="Long">Long</span> =&gt; <span title="Long">i</span>.<span title="=&gt; Short">toShort</span>
    case <span title="Double">i</span>: <span title="Double">Double</span> =&gt; <span title="Double">i</span>.<span title="=&gt; Short">toShort</span>
    case <span title="Float">i</span>: <span title="Float">Float</span> =&gt; <span title="Float">i</span>.<span title="=&gt; Short">toShort</span>
    case <span title="String">i</span>: <span title="String">String</span> =&gt; <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">i</span>.<span title="=&gt; Short">toShort</span>
  <span class="delimiter">}</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[Any,Int]" id="org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToInt">anyToInt</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[Any,Int]">TypeConverter</a><span class="delimiter">[</span>Any, Int<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: Any =&gt; Int)org.scalatra.util.conversion.TypeConverter[Any,Int]">safe</a> <a href="#org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToInt.$anonfun.x0$7" title="Int" class="delimiter">{</a>
    case <span title="Byte">i</span>: <span title="Byte">Byte</span> =&gt; <span title="Byte">i</span>.<span title="=&gt; Int">toInt</span>
    case <span title="Short">i</span>: <span title="Short">Short</span> =&gt; <span title="Short">i</span>.<span title="=&gt; Int">toInt</span>
    case <span title="Int">i</span>: <span title="Int">Int</span> =&gt; <span title="Int">i</span>
    case <span title="Long">i</span>: <span title="Long">Long</span> =&gt; <span title="Long">i</span>.<span title="=&gt; Int">toInt</span>
    case <span title="Double">i</span>: <span title="Double">Double</span> =&gt; <span title="Double">i</span>.<span title="=&gt; Int">toInt</span>
    case <span title="Float">i</span>: <span title="Float">Float</span> =&gt; <span title="Float">i</span>.<span title="=&gt; Int">toInt</span>
    case <span title="String">i</span>: <span title="String">String</span> =&gt; <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">i</span>.<span title="=&gt; Int">toInt</span>
  <span class="delimiter">}</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[Any,Long]" id="org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToLong">anyToLong</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[Any,Long]">TypeConverter</a><span class="delimiter">[</span>Any, Long<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: Any =&gt; Long)org.scalatra.util.conversion.TypeConverter[Any,Long]">safe</a> <a href="#org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToLong.$anonfun.x0$8" title="Long" class="delimiter">{</a>
    case <span title="Byte">i</span>: <span title="Byte">Byte</span> =&gt; <span title="Byte">i</span>.<span title="=&gt; Long">toLong</span>
    case <span title="Short">i</span>: <span title="Short">Short</span> =&gt; <span title="Short">i</span>.<span title="=&gt; Long">toLong</span>
    case <span title="Int">i</span>: <span title="Int">Int</span> =&gt; <span title="Int">i</span>.<span title="=&gt; Long">toLong</span>
    case <span title="Long">i</span>: <span title="Long">Long</span> =&gt; <span title="Long">i</span>
    case <span title="Double">i</span>: <span title="Double">Double</span> =&gt; <span title="Double">i</span>.<span title="=&gt; Long">toLong</span>
    case <span title="Float">i</span>: <span title="Float">Float</span> =&gt; <span title="Float">i</span>.<span title="=&gt; Long">toLong</span>
    case <span title="String">i</span>: <span title="String">String</span> =&gt; <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">i</span>.<span title="=&gt; Long">toLong</span>
  <span class="delimiter">}</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[Any,String]" id="org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToString">anyToString</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[Any,String]">TypeConverter</a><span class="delimiter">[</span>Any, String<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: Any =&gt; String)org.scalatra.util.conversion.TypeConverter[Any,String]">safe</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;LowPriorityImplicitConversions.anyToString.$anonfun.x$2" title="Any">_</a>.<span title="()String">toString</span><span class="delimiter">)</span>

<span class="delimiter">}</span>

trait <a title="trait BigDecimalImplicitConversions extends AnyRef" id="org.scalatra.util.conversion;BigDecimalImplicitConversions">BigDecimalImplicitConversions</a> <span title="Unit" class="delimiter">{</span> self: DefaultImplicitConversions =&gt;
  implicit val <a title="org.scalatra.util.conversion.TypeConverter[String,BigDecimal]" id="org.scalatra.util.conversion;BigDecimalImplicitConversions.stringToBigDecimal">stringToBigDecimal</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,BigDecimal]">TypeConverter</a><span class="delimiter">[</span>String, BigDecimal<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: String =&gt; scala.math.BigDecimal)org.scalatra.util.conversion.TypeConverter[String,scala.math.BigDecimal]">safe</a><span class="delimiter">(</span><span title="(x: String)scala.math.BigDecimal">BigDecimal</span><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;BigDecimalImplicitConversions.stringToBigDecimal.$anonfun.x$3" title="String">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
  implicit val <a title="org.scalatra.util.conversion.TypeConverter[String,Seq[BigDecimal]]" id="org.scalatra.util.conversion;BigDecimalImplicitConversions.stringToSeqBigDecimal">stringToSeqBigDecimal</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,Seq[BigDecimal]]">TypeConverter</a><span class="delimiter">[</span>String, Seq<span class="delimiter">[</span>BigDecimal<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToSeq" title="(elementConverter: org.scalatra.util.conversion.TypeConverter[String,BigDecimal], separator: String)(implicit evidence$2: Manifest[BigDecimal])org.scalatra.util.conversion.TypeConverter[String,Seq[BigDecimal]]">stringToSeq</a><span title="(clazz: Class[_])scala.reflect.Manifest[BigDecimal]" class="delimiter">(</span><a href="#org.scalatra.util.conversion;BigDecimalImplicitConversions.stringToBigDecimal" title="=&gt; org.scalatra.util.conversion.TypeConverter[String,BigDecimal]">stringToBigDecimal</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Implicit TypeConverter values for value types and some factory method for
 * dates and seqs.
 */</span>
trait <a title="trait DefaultImplicitConversions extends AnyRef with org.scalatra.util.conversion.LowPriorityImplicitConversions" id="org.scalatra.util.conversion;DefaultImplicitConversions">DefaultImplicitConversions</a> extends <a href="#org.scalatra.util.conversion;LowPriorityImplicitConversions" title="org.scalatra.util.conversion.LowPriorityImplicitConversions">LowPriorityImplicitConversions</a> <span class="delimiter">{</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[String,Boolean]" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToBoolean">stringToBoolean</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,Boolean]">TypeConverter</a><span class="delimiter">[</span>String, Boolean<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: String =&gt; Boolean)org.scalatra.util.conversion.TypeConverter[String,Boolean]">safe</a> <span class="delimiter">{</span> <a title="String" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToBoolean.$anonfun.s">s</a> =&gt; <a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToBoolean.$anonfun.s" title="String">s</a>.<span title="()String">toUpperCase</span> match <span class="delimiter">{</span>
    case <span title="String(&quot;ON&quot;)" class="string">&quot;ON&quot;</span> | <span title="String(&quot;TRUE&quot;)" class="string">&quot;TRUE&quot;</span> | <span title="String(&quot;OK&quot;)" class="string">&quot;OK&quot;</span> | <span title="String(&quot;1&quot;)" class="string">&quot;1&quot;</span> | <span title="String(&quot;CHECKED&quot;)" class="string">&quot;CHECKED&quot;</span> | <span title="String(&quot;YES&quot;)" class="string">&quot;YES&quot;</span> | <span title="String(&quot;ENABLE&quot;)" class="string">&quot;ENABLE&quot;</span> | <span title="String(&quot;ENABLED&quot;)" class="string">&quot;ENABLED&quot;</span> =&gt; true
    case _ =&gt; false
  <span class="delimiter">}</span> <span class="delimiter">}</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[String,Float]" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToFloat">stringToFloat</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,Float]">TypeConverter</a><span class="delimiter">[</span>String, Float<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: String =&gt; Float)org.scalatra.util.conversion.TypeConverter[String,Float]">safe</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToFloat.$anonfun.x$4" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">_</a>.<span title="=&gt; Float">toFloat</span><span class="delimiter">)</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[String,Double]" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToDouble">stringToDouble</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,Double]">TypeConverter</a><span class="delimiter">[</span>String, Double<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: String =&gt; Double)org.scalatra.util.conversion.TypeConverter[String,Double]">safe</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToDouble.$anonfun.x$5" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">_</a>.<span title="=&gt; Double">toDouble</span><span class="delimiter">)</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[String,Byte]" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToByte">stringToByte</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,Byte]">TypeConverter</a><span class="delimiter">[</span>String, Byte<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: String =&gt; Byte)org.scalatra.util.conversion.TypeConverter[String,Byte]">safe</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToByte.$anonfun.x$6" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">_</a>.<span title="=&gt; Byte">toByte</span><span class="delimiter">)</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[String,Short]" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToShort">stringToShort</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,Short]">TypeConverter</a><span class="delimiter">[</span>String, Short<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: String =&gt; Short)org.scalatra.util.conversion.TypeConverter[String,Short]">safe</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToShort.$anonfun.x$7" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">_</a>.<span title="=&gt; Short">toShort</span><span class="delimiter">)</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[String,Int]" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToInt">stringToInt</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,Int]">TypeConverter</a><span class="delimiter">[</span>String, Int<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: String =&gt; Int)org.scalatra.util.conversion.TypeConverter[String,Int]">safe</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToInt.$anonfun.x$8" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">_</a>.<span title="=&gt; Int">toInt</span><span class="delimiter">)</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[String,Long]" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToLong">stringToLong</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,Long]">TypeConverter</a><span class="delimiter">[</span>String, Long<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: String =&gt; Long)org.scalatra.util.conversion.TypeConverter[String,Long]">safe</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToLong.$anonfun.x$9" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">_</a>.<span title="=&gt; Long">toLong</span><span class="delimiter">)</span>

  implicit val <a title="org.scalatra.util.conversion.TypeConverter[String,String]" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToSelf">stringToSelf</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,String]">TypeConverter</a><span class="delimiter">[</span>String, String<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: String =&gt; String)org.scalatra.util.conversion.TypeConverter[String,String]">safe</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToSelf.$anonfun.x" title="(x: String)String">identity</a><span class="delimiter">)</span>


  def <a title="(format: =&gt; String)org.scalatra.util.conversion.TypeConverter[String,java.util.Date]" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToDate">stringToDate</a><span class="delimiter">(</span><a title="=&gt; String" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToDate.format">format</a>: =&gt; String<span class="delimiter">)</span>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,java.util.Date]">TypeConverter</a><span class="delimiter">[</span>String, Date<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToDateFormat" title="(format: =&gt; java.text.DateFormat)org.scalatra.util.conversion.TypeConverter[String,java.util.Date]">stringToDateFormat</a><span class="delimiter">(</span>new <span title="java.text.SimpleDateFormat">SimpleDateFormat</span><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToDate.format" title="=&gt; String">format</a><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="(format: =&gt; java.text.DateFormat)org.scalatra.util.conversion.TypeConverter[String,java.util.Date]" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToDateFormat">stringToDateFormat</a><span class="delimiter">(</span><a title="=&gt; java.text.DateFormat" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToDateFormat.format">format</a>: =&gt; DateFormat<span class="delimiter">)</span>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,java.util.Date]">TypeConverter</a><span class="delimiter">[</span>String, Date<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: String =&gt; java.util.Date)org.scalatra.util.conversion.TypeConverter[String,java.util.Date]">safe</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToDateFormat.format" title="=&gt; java.text.DateFormat">format</a>.<span title="(x$1: String)java.util.Date">parse</span><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToDateFormat.$anonfun.x$10" title="String">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  implicit def <a title="[T](implicit elementConverter: org.scalatra.util.conversion.TypeConverter[String,T], implicit mf: Manifest[T])org.scalatra.util.conversion.TypeConverter[String,Seq[T]]" id="org.scalatra.util.conversion;DefaultImplicitConversions.defaultStringToSeq">defaultStringToSeq</a><span class="delimiter">[</span><a title="" id="org.scalatra.util.conversion;DefaultImplicitConversions.defaultStringToSeq;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="org.scalatra.util.conversion.TypeConverter[String,T]" id="org.scalatra.util.conversion;DefaultImplicitConversions.defaultStringToSeq.elementConverter">elementConverter</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,T]">TypeConverter</a><span class="delimiter">[</span>String, T<span class="delimiter">]</span>, <a title="Manifest[T]" id="org.scalatra.util.conversion;DefaultImplicitConversions.defaultStringToSeq.mf">mf</a>: <span title="Manifest[T]">Manifest</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,Seq[T]]">TypeConverter</a><span class="delimiter">[</span>String, Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToSeq" title="[T](elementConverter: org.scalatra.util.conversion.TypeConverter[String,T], separator: String)(implicit evidence$2: Manifest[T])org.scalatra.util.conversion.TypeConverter[String,Seq[T]]">stringToSeq</a><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToSeq$default$2" title="(elementConverter: org.scalatra.util.conversion.TypeConverter[String,T], separator: String)(implicit evidence$2: Manifest[T])org.scalatra.util.conversion.TypeConverter[String,Seq[T]]" class="delimiter">[</a><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.defaultStringToSeq;T" title="T">T</a><span class="delimiter">]</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.defaultStringToSeq.mf" title="Manifest[T]" class="delimiter">(</a><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.defaultStringToSeq.elementConverter" title="org.scalatra.util.conversion.TypeConverter[String,T]">elementConverter</a><span class="delimiter">)</span>

  def <a title="[T](elementConverter: org.scalatra.util.conversion.TypeConverter[String,T], separator: String)(implicit evidence$2: Manifest[T])org.scalatra.util.conversion.TypeConverter[String,Seq[T]]" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToSeq">stringToSeq</a><span class="delimiter">[</span><a title="" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToSeq$default$2;T">T</a>:Manifest<span class="delimiter">]</span><span class="delimiter">(</span><a title="org.scalatra.util.conversion.TypeConverter[String,T]" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToSeq.elementConverter">elementConverter</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,T]">TypeConverter</a><span class="delimiter">[</span>String, T<span class="delimiter">]</span>, <a title="String" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToSeq$default$2">separator</a>: <span title="String">String</span> = <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,Seq[T]]">TypeConverter</a><span class="delimiter">[</span>String, Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: String =&gt; Seq[T])org.scalatra.util.conversion.TypeConverter[String,Seq[T]]">safe</a><span class="delimiter">(</span><a title="String" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToSeq.$anonfun.s">s</a> =&gt; <a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToSeq.$anonfun.s" title="String">s</a>.<span title="(x$1: String)Array[String]">split</span><span title="(xs: Array[String])scala.collection.mutable.ArrayOps[String]" class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToSeq$default$2" title="String">separator</a><span class="delimiter">)</span>.<span title="=&gt; Seq[String]">toSeq</span>.<span title="(f: String =&gt; scala.collection.GenTraversableOnce[T])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],T,Seq[T]])Seq[T]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,T,Seq[T]]" class="delimiter">(</span><a title="String" id="org.scalatra.util.conversion;DefaultImplicitConversions.stringToSeq.$anonfun.$anonfun.e">e</a> =&gt; <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter.apply" title="(s: String)Option[T]">elementConverter</a><span title="(xo: Option[T])Iterable[T]" class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToSeq.$anonfun.$anonfun.e" title="String">e</a>.<span title="()String">trim</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  implicit def <a title="[T](implicit elementConverter: org.scalatra.util.conversion.TypeConverter[String,T], implicit mf: Manifest[T])org.scalatra.util.conversion.TypeConverter[Seq[String],T]" id="org.scalatra.util.conversion;DefaultImplicitConversions.seqHead">seqHead</a><span class="delimiter">[</span><a title="" id="org.scalatra.util.conversion;DefaultImplicitConversions.seqHead;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="org.scalatra.util.conversion.TypeConverter[String,T]" id="org.scalatra.util.conversion;DefaultImplicitConversions.seqHead.elementConverter">elementConverter</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,T]">TypeConverter</a><span class="delimiter">[</span>String, T<span class="delimiter">]</span>, <a title="Manifest[T]" id="org.scalatra.util.conversion;DefaultImplicitConversions.seqHead.mf">mf</a>: <span title="Manifest[T]">Manifest</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[Seq[String],T]">TypeConverter</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>String<span class="delimiter">]</span>, T<span class="delimiter">]</span> =
    <a href="#org.scalatra.util.conversion;TypeConverterSupport.safeOption" title="(f: Seq[String] =&gt; Option[T])org.scalatra.util.conversion.TypeConverter[Seq[String],T]">safeOption</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.seqHead.$anonfun.x$11" title="Seq[String]">_</a>.<span title="=&gt; Option[String]">headOption</span>.<span title="(f: String =&gt; Option[T])Option[T]">flatMap</span><span class="delimiter">(</span><a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter.apply" title="(s: String)Option[T]">elementConverter</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.seqHead.$anonfun.$anonfun.x$12" title="String">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  implicit def <a title="[T](implicit elementConverter: org.scalatra.util.conversion.TypeConverter[String,T], implicit mf: Manifest[T])org.scalatra.util.conversion.TypeConverter[Seq[String],Seq[T]]" id="org.scalatra.util.conversion;DefaultImplicitConversions.seqToSeq">seqToSeq</a><span class="delimiter">[</span><a title="" id="org.scalatra.util.conversion;DefaultImplicitConversions.seqToSeq;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="org.scalatra.util.conversion.TypeConverter[String,T]" id="org.scalatra.util.conversion;DefaultImplicitConversions.seqToSeq.elementConverter">elementConverter</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,T]">TypeConverter</a><span class="delimiter">[</span>String, T<span class="delimiter">]</span>, <a title="Manifest[T]" id="org.scalatra.util.conversion;DefaultImplicitConversions.seqToSeq.mf">mf</a>: <span title="Manifest[T]">Manifest</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[Seq[String],Seq[T]]">TypeConverter</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>String<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#org.scalatra.util.conversion;TypeConverterSupport.safe" title="(f: Seq[String] =&gt; Seq[T])org.scalatra.util.conversion.TypeConverter[Seq[String],Seq[T]]">safe</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.seqToSeq.$anonfun.x$13" title="Seq[String]">_</a>.<span title="(f: String =&gt; scala.collection.GenTraversableOnce[T])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],T,Seq[T]])Seq[T]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,T,Seq[T]]" class="delimiter">(</span><a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter.apply" title="(s: String)Option[T]">elementConverter</a><span title="(xo: Option[T])Iterable[T]" class="delimiter">(</span><a href="#org.scalatra.util.conversion;DefaultImplicitConversions.seqToSeq.$anonfun.$anonfun.x$14" title="String">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

<span class="delimiter">}</span>

object <a title="org.scalatra.util.conversion.Conversions.type" id="org.scalatra.util.conversion.Conversions">Conversions</a> extends <a href="#org.scalatra.util.conversion;DefaultImplicitConversions" title="org.scalatra.util.conversion.DefaultImplicitConversions">DefaultImplicitConversions</a> <span class="delimiter">{</span>


  private type <a title="[T]org.scalatra.util.conversion.TypeConverter[String,T]" id="org.scalatra.util.conversion.Conversions;StringTypeConverter">StringTypeConverter</a><span class="delimiter">[</span><a title="" id="org.scalatra.util.conversion.Conversions;StringTypeConverter;T">T</a><span class="delimiter">]</span> = <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,T]">TypeConverter</a><span class="delimiter">[</span>String, T<span class="delimiter">]</span>
  class <a title="class ValConversion extends AnyRef" id="org.scalatra.util.conversion.Conversions;ValConversion">ValConversion</a><a href="#org.scalatra.util.conversion.Conversions;ValConversion" title="org.scalatra.util.conversion.Conversions.ValConversion" class="delimiter">(</a><a title="String" id="org.scalatra.util.conversion.Conversions;ValConversion.source">source</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="[T](implicit evidence$3: org.scalatra.util.conversion.Conversions.StringTypeConverter[T])Option[T]" id="org.scalatra.util.conversion.Conversions;ValConversion.as">as</a><span class="delimiter">[</span><a title="" id="org.scalatra.util.conversion.Conversions;ValConversion.as;T">T</a>: StringTypeConverter<span class="delimiter">]</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="[T](implicit e: T)T">implicitly</span><a href="#org.scalatra.util.conversion.Conversions;ValConversion.as.evidence$3" title="(implicit e: org.scalatra.util.conversion.TypeConverter[String,T])org.scalatra.util.conversion.TypeConverter[String,T]" class="delimiter">[</a><a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,T]">TypeConverter</a><span class="delimiter">[</span>String, T<span class="delimiter">]</span><span class="delimiter">]</span>.<a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter.apply" title="(s: String)Option[T]">apply</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion.Conversions;ValConversion.source" title="String">source</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  class <a title="class DateConversion extends AnyRef" id="org.scalatra.util.conversion.Conversions;DateConversion">DateConversion</a><a href="#org.scalatra.util.conversion.Conversions;DateConversion" title="org.scalatra.util.conversion.Conversions.DateConversion" class="delimiter">(</a><a title="String" id="org.scalatra.util.conversion.Conversions;DateConversion.source">source</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="(format: String)Option[java.util.Date]" id="org.scalatra.util.conversion.Conversions;DateConversion.asDate">asDate</a><span class="delimiter">(</span><a title="String" id="org.scalatra.util.conversion.Conversions;DateConversion.asDate.format">format</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Option[java.util.Date]">Option</span><span class="delimiter">[</span>Date<span class="delimiter">]</span> = <a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToDate" title="(format: =&gt; String)org.scalatra.util.conversion.TypeConverter[String,java.util.Date]">stringToDate</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion.Conversions;DateConversion.asDate.format" title="String">format</a><span class="delimiter">)</span>.<a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter.apply" title="(s: String)Option[java.util.Date]">apply</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion.Conversions;DateConversion.source" title="String">source</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  class <a title="class SeqConversion extends AnyRef" id="org.scalatra.util.conversion.Conversions;SeqConversion">SeqConversion</a><a href="#org.scalatra.util.conversion.Conversions;SeqConversion" title="org.scalatra.util.conversion.Conversions.SeqConversion" class="delimiter">(</a><a title="String" id="org.scalatra.util.conversion.Conversions;SeqConversion.source">source</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    def <a title="[T](separator: String)(implicit mf: Manifest[T], implicit tc: org.scalatra.util.conversion.TypeConverter[String,T])Option[Seq[T]]" id="org.scalatra.util.conversion.Conversions;SeqConversion.asSeq">asSeq</a><span class="delimiter">[</span><a title="" id="org.scalatra.util.conversion.Conversions;SeqConversion.asSeq;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="org.scalatra.util.conversion.Conversions;SeqConversion.asSeq.separator">separator</a>: <span title="String">String</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Manifest[T]" id="org.scalatra.util.conversion.Conversions;SeqConversion.asSeq.mf">mf</a>: <span title="Manifest[T]">Manifest</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="org.scalatra.util.conversion.TypeConverter[String,T]" id="org.scalatra.util.conversion.Conversions;SeqConversion.asSeq.tc">tc</a>: <a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter" title="org.scalatra.util.conversion.TypeConverter[String,T]">TypeConverter</a><span class="delimiter">[</span>String, T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[Seq[T]]">Option</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#org.scalatra.util.conversion;DefaultImplicitConversions.stringToSeq" title="[T](elementConverter: org.scalatra.util.conversion.TypeConverter[String,T], separator: String)(implicit evidence$2: Manifest[T])org.scalatra.util.conversion.TypeConverter[String,Seq[T]]">stringToSeq</a><span title="(elementConverter: org.scalatra.util.conversion.TypeConverter[String,T], separator: String)(implicit evidence$2: Manifest[T])org.scalatra.util.conversion.TypeConverter[String,Seq[T]]" class="delimiter">[</span><a href="#org.scalatra.util.conversion.Conversions;SeqConversion.asSeq;T" title="T">T</a><span class="delimiter">]</span><a href="#org.scalatra.util.conversion.Conversions;SeqConversion.asSeq.mf" title="Manifest[T]" class="delimiter">(</a><a href="#org.scalatra.util.conversion.Conversions;SeqConversion.asSeq.tc" title="org.scalatra.util.conversion.TypeConverter[String,T]">tc</a>, <a href="#org.scalatra.util.conversion.Conversions;SeqConversion.asSeq.separator" title="String">separator</a><span class="delimiter">)</span>.<a href="package.scala.html#org.scalatra.util.conversion.package;TypeConverter.apply" title="(s: String)Option[Seq[T]]">apply</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion.Conversions;SeqConversion.source" title="String">source</a><span class="delimiter">)</span>

  <span class="delimiter">}</span>

  implicit def <a title="implicit org.scalatra.util.conversion.Conversions.stringToValTypeConversion : (source: String)org.scalatra.util.conversion.Conversions.ValConversion" id="org.scalatra.util.conversion.Conversions.stringToValTypeConversion">stringToValTypeConversion</a><span class="delimiter">(</span><a title="String" id="org.scalatra.util.conversion.Conversions.stringToValTypeConversion.source">source</a>: <span title="String">String</span><span class="delimiter">)</span> = new <a href="#org.scalatra.util.conversion.Conversions;ValConversion" title="org.scalatra.util.conversion.Conversions.ValConversion">ValConversion</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion.Conversions.stringToValTypeConversion.source" title="String">source</a><span class="delimiter">)</span>

  implicit def <a title="implicit org.scalatra.util.conversion.Conversions.stringToDateConversion : (source: String)org.scalatra.util.conversion.Conversions.DateConversion" id="org.scalatra.util.conversion.Conversions.stringToDateConversion">stringToDateConversion</a><span class="delimiter">(</span><a title="String" id="org.scalatra.util.conversion.Conversions.stringToDateConversion.source">source</a>: <span title="String">String</span><span class="delimiter">)</span> = new <a href="#org.scalatra.util.conversion.Conversions;DateConversion" title="org.scalatra.util.conversion.Conversions.DateConversion">DateConversion</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion.Conversions.stringToDateConversion.source" title="String">source</a><span class="delimiter">)</span>

  implicit def <a title="implicit org.scalatra.util.conversion.Conversions.stringToSeqConversion : (source: String)org.scalatra.util.conversion.Conversions.SeqConversion" id="org.scalatra.util.conversion.Conversions.stringToSeqConversion">stringToSeqConversion</a><span class="delimiter">(</span><a title="String" id="org.scalatra.util.conversion.Conversions.stringToSeqConversion.source">source</a>: <span title="String">String</span><span class="delimiter">)</span> = new <a href="#org.scalatra.util.conversion.Conversions;SeqConversion" title="org.scalatra.util.conversion.Conversions.SeqConversion">SeqConversion</a><span class="delimiter">(</span><a href="#org.scalatra.util.conversion.Conversions.stringToSeqConversion.source" title="String">source</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
