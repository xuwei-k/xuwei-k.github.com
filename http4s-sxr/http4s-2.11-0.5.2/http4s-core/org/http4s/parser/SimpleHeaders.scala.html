<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>http4s-core/org/http4s/parser/SimpleHeaders.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Derived from https://github.com/spray/spray/blob/v1.1-M7/spray-http/src/main/scala/spray/http/parser/SimpleHeaders.scala
 *
 * Copyright (C) 2011-2012 spray.io
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>
package org.http4s
package parser


import <a href="../Header.scala.html#org.http4s.Header" title="org.http4s.Header.type">Header</a>._
import java.net.InetAddress
import org.http4s.util.<a href="../util/CaseInsensitiveString.scala.html#org.http4s.util.CaseInsensitiveString" title="org.http4s.util.CaseInsensitiveString.type">CaseInsensitiveString</a>._

<span class="comment">/**
 * parser rules for all headers that can be parsed with one simple rule
 */</span>
private<span class="delimiter">[</span>parser<span class="delimiter">]</span> trait <a title="trait SimpleHeaders extends AnyRef" id="org.http4s.parser;SimpleHeaders">SimpleHeaders</a> <span title="Unit" class="delimiter">{</span> self: HttpParser =&gt;

  def <a title="(value: String)org.http4s.ParseResult[org.http4s.Header.Connection]" id="org.http4s.parser;SimpleHeaders.CONNECTION">CONNECTION</a><span class="delimiter">(</span><a title="String" id="org.http4s.parser;SimpleHeaders.CONNECTION.value">value</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="org.http4s.ParseResult[org.http4s.Header.Connection]">ParseResult</span><span class="delimiter">[</span>Connection<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a title="&lt;$anon: org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Connection]&gt; extends org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Connection]" id="org.http4s.parser;SimpleHeaders.CONNECTION;$anon">Http4sHeaderParser</a><span class="delimiter">[</span>Connection<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.CONNECTION.value" title="implicit org.parboiled2.ParserInput.apply : (string: String)org.parboiled2.ParserInput.StringBasedParserInput">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      def <a title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Connection,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.CONNECTION;$anon.entry">entry</a> = rule <a href="#org.http4s.parser;SimpleHeaders.CONNECTION;$anon" title="org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Connection,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.CONNECTION;$anon.entry.matched.xs" class="delimiter">(</a>
            oneOrMore<span class="delimiter">(</span><a href="Rfc2616BasicRules.scala.html#org.http4s.parser;Rfc2616BasicRules.Token" title="=&gt; org.parboiled2.Rule1[String]">Token</a><span class="delimiter">)</span>.separatedBy<span class="delimiter">(</span><a href="Rfc2616BasicRules.scala.html#org.http4s.parser;Rfc2616BasicRules.ListSep" title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.HNil]">ListSep</a><span class="delimiter">)</span> ~ <a href="AdditionalRules.scala.html#org.http4s.parser;AdditionalRules.EOL" title="=&gt; org.parboiled2.Rule0">EOL</a> ~&gt;
              <span class="delimiter">{</span>xs: Seq<span class="delimiter">[</span>String<span class="delimiter">]</span> =&gt; <a href="../Header.scala.html#org.http4s.Header" title="org.http4s.Header.type">Header</a>.<a href="../HeaderKey.scala.html#org.http4s.HeaderKey;Recurring.apply(ca1e975507)" title="(first: org.http4s.Header.Connection.HeaderT#Value, more: org.http4s.Header.Connection.HeaderT#Value*)org.http4s.Header.Connection.HeaderT">Connection</a><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.CONNECTION;$anon.entry.matched.xs" title="scala.collection.immutable.Seq[String]">xs</a>.<a href="../util/CaseInsensitiveString.scala.html#org.http4s.util;CaseInsensitiveStringSyntax.ToCaseInsensitiveStringSyntax" title="implicit org.http4s.util.CaseInsensitiveStringSyntax.ToCaseInsensitiveStringSyntax : (cs: CharSequence)org.http4s.util.CaseInsensitiveStringOps">head</a>.<a href="../util/CaseInsensitiveString.scala.html#org.http4s.util;CaseInsensitiveStringOps.ci" title="=&gt; org.http4s.util.CaseInsensitiveString">ci</a>, <a href="#org.http4s.parser;SimpleHeaders.CONNECTION;$anon.entry.matched.xs" title="scala.collection.immutable.Seq[String]">xs</a>.<span title="=&gt; scala.collection.immutable.Seq[String]">tail</span>.<span title="(f: String =&gt; org.http4s.util.CaseInsensitiveString)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Seq[String],org.http4s.util.CaseInsensitiveString,Seq[org.http4s.util.CaseInsensitiveString]])Seq[org.http4s.util.CaseInsensitiveString]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,org.http4s.util.CaseInsensitiveString,Seq[org.http4s.util.CaseInsensitiveString]]" class="delimiter">(</span><a href="../util/CaseInsensitiveString.scala.html#org.http4s.util;CaseInsensitiveStringSyntax.ToCaseInsensitiveStringSyntax" title="implicit org.http4s.util.CaseInsensitiveStringSyntax.ToCaseInsensitiveStringSyntax : (cs: CharSequence)org.http4s.util.CaseInsensitiveStringOps">_</a>.<a href="../util/CaseInsensitiveString.scala.html#org.http4s.util;CaseInsensitiveStringOps.ci" title="=&gt; org.http4s.util.CaseInsensitiveString">ci</a><span class="delimiter">)</span>: _*<span class="delimiter">)</span><span class="delimiter">}</span>
        <span class="delimiter">)</span>
    <span class="delimiter">}</span>.<a href="Http4sHeaderParser.scala.html#org.http4s.parser;Http4sHeaderParser.parse" title="=&gt; org.http4s.ParseResult[org.http4s.Header.Connection]">parse</a>
  <span class="delimiter">}</span>

  def <a title="(value: String)org.http4s.ParseResult[org.http4s.Header.Content-Length]" id="org.http4s.parser;SimpleHeaders.CONTENT_LENGTH">CONTENT_LENGTH</a><span class="delimiter">(</span><a title="String" id="org.http4s.parser;SimpleHeaders.CONTENT_LENGTH.value">value</a>: <span title="String">String</span><span class="delimiter">)</span> = new <a title="&lt;$anon: org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Content-Length]&gt; extends org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Content-Length]" id="org.http4s.parser;SimpleHeaders.CONTENT_LENGTH;$anon">Http4sHeaderParser</a><span class="delimiter">[</span>`Content-Length`<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.CONTENT_LENGTH.value" title="implicit org.parboiled2.ParserInput.apply : (string: String)org.parboiled2.ParserInput.StringBasedParserInput">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Content-Length,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.CONTENT_LENGTH;$anon.entry">entry</a> = rule <a title="org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Content-Length,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.CONTENT_LENGTH;$anon.entry.matched.s" class="delimiter">{</a> <a href="AdditionalRules.scala.html#org.http4s.parser;AdditionalRules.Digits" title="=&gt; org.parboiled2.Rule1[String]">Digits</a> ~ <a href="AdditionalRules.scala.html#org.http4s.parser;AdditionalRules.EOL" title="=&gt; org.parboiled2.Rule0">EOL</a> ~&gt; <span class="delimiter">{</span>s: String =&gt; <a href="../Header.scala.html#org.http4s.Header;Content-Length" title="(length: Int)org.http4s.Header.Content-Length">`Content-Length`</a><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.CONTENT_LENGTH;$anon.entry.matched.s" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">s</a>.<span title="=&gt; Int">toInt</span><span class="delimiter">)</span><span class="delimiter">}</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>.<a href="Http4sHeaderParser.scala.html#org.http4s.parser;Http4sHeaderParser.parse" title="=&gt; org.http4s.ParseResult[org.http4s.Header.Content-Length]">parse</a>

  def <a title="(value: String)org.http4s.ParseResult[org.http4s.Header.Content-Encoding]" id="org.http4s.parser;SimpleHeaders.CONTENT_ENCODING">CONTENT_ENCODING</a><span class="delimiter">(</span><a title="String" id="org.http4s.parser;SimpleHeaders.CONTENT_ENCODING.value">value</a>: <span title="String">String</span><span class="delimiter">)</span> = new <a title="&lt;$anon: org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Content-Encoding]&gt; extends org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Content-Encoding]" id="org.http4s.parser;SimpleHeaders.CONTENT_ENCODING;$anon">Http4sHeaderParser</a><span class="delimiter">[</span>`Content-Encoding`<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.CONTENT_ENCODING.value" title="implicit org.parboiled2.ParserInput.apply : (string: String)org.parboiled2.ParserInput.StringBasedParserInput">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Content-Encoding,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.CONTENT_ENCODING;$anon.entry">entry</a> = rule <a title="org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Content-Encoding,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.CONTENT_ENCODING;$anon.entry.matched.s" class="delimiter">{</a> <a href="Rfc2616BasicRules.scala.html#org.http4s.parser;Rfc2616BasicRules.Token" title="=&gt; org.parboiled2.Rule1[String]">Token</a> ~ <a href="AdditionalRules.scala.html#org.http4s.parser;AdditionalRules.EOL" title="=&gt; org.parboiled2.Rule0">EOL</a> ~&gt; <span class="delimiter">{</span>s: String =&gt;
      <a href="../Header.scala.html#org.http4s.Header" title="org.http4s.Header.type">Header</a>.<a href="../Header.scala.html#org.http4s.Header;Content-Encoding" title="(contentCoding: org.http4s.ContentCoding)org.http4s.Header.Content-Encoding">`Content-Encoding`</a><span class="delimiter">(</span><a href="../ContentCoding.scala.html#org.http4s.ContentCoding" title="org.http4s.ContentCoding.type">ContentCoding</a>.<a href="../util/Registry.scala.html#org.http4s.util;Registry.getOrElseCreate" title="(key: org.http4s.ContentCoding.Key)(implicit ev: org.http4s.ContentCoding.Key =&gt; org.http4s.ContentCoding.Value)org.http4s.ContentCoding.Value">getOrElseCreate</a><a href="../ContentCoding.scala.html#org.http4s.ContentCoding.fromKey" title="implicit org.http4s.ContentCoding.fromKey : (k: org.http4s.util.CaseInsensitiveString)org.http4s.ContentCoding" class="delimiter">(</a><a href="../util/CaseInsensitiveString.scala.html#org.http4s.util;CaseInsensitiveStringSyntax.ToCaseInsensitiveStringSyntax" title="implicit org.http4s.util.CaseInsensitiveStringSyntax.ToCaseInsensitiveStringSyntax : (cs: CharSequence)org.http4s.util.CaseInsensitiveStringOps">s</a>.<a href="../util/CaseInsensitiveString.scala.html#org.http4s.util;CaseInsensitiveStringOps.ci" title="=&gt; org.http4s.util.CaseInsensitiveString">ci</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>.<a href="Http4sHeaderParser.scala.html#org.http4s.parser;Http4sHeaderParser.parse" title="=&gt; org.http4s.ParseResult[org.http4s.Header.Content-Encoding]">parse</a>

  def <a title="(value: String)org.http4s.ParseResult[org.http4s.Header.Content-Disposition]" id="org.http4s.parser;SimpleHeaders.CONTENT_DISPOSITION">CONTENT_DISPOSITION</a><span class="delimiter">(</span><a title="String" id="org.http4s.parser;SimpleHeaders.CONTENT_DISPOSITION.value">value</a>: <span title="String">String</span><span class="delimiter">)</span> = new <a title="&lt;$anon: org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Content-Disposition]&gt; extends org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Content-Disposition]" id="org.http4s.parser;SimpleHeaders.CONTENT_DISPOSITION;$anon">Http4sHeaderParser</a><span class="delimiter">[</span>`Content-Disposition`<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.CONTENT_DISPOSITION.value" title="implicit org.parboiled2.ParserInput.apply : (string: String)org.parboiled2.ParserInput.StringBasedParserInput">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Content-Disposition,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.CONTENT_DISPOSITION;$anon.entry">entry</a> = rule <a title="org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Content-Disposition,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.CONTENT_DISPOSITION;$anon.entry.matched.token" class="delimiter">{</a>
     <a href="Rfc2616BasicRules.scala.html#org.http4s.parser;Rfc2616BasicRules.Token" title="=&gt; org.parboiled2.Rule1[String]">Token</a> ~ zeroOrMore<span class="delimiter">(</span><span class="string">&quot;;&quot;</span> ~ <a href="Rfc2616BasicRules.scala.html#org.http4s.parser;Rfc2616BasicRules.OptWS" title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.HNil]">OptWS</a> ~ <a href="AdditionalRules.scala.html#org.http4s.parser;AdditionalRules.Parameter" title="=&gt; org.parboiled2.Rule1[(String, String)]">Parameter</a><span class="delimiter">)</span> ~ <a href="AdditionalRules.scala.html#org.http4s.parser;AdditionalRules.EOL" title="=&gt; org.parboiled2.Rule0">EOL</a> ~&gt; <span class="delimiter">{</span> <span class="delimiter">(</span>token:String, params: Seq<span class="delimiter">[</span><span class="delimiter">(</span>String, String<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> =&gt;
      <a href="../Header.scala.html#org.http4s.Header;Content-Disposition" title="(dispositionType: String, parameters: Map[String,String])org.http4s.Header.Content-Disposition">`Content-Disposition`</a><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.CONTENT_DISPOSITION;$anon.entry.matched.token" title="String">token</a>, <a href="#org.http4s.parser;SimpleHeaders.CONTENT_DISPOSITION;$anon.entry.matched.token" title="scala.collection.immutable.Seq[(String, String)]">params</a>.<span title="(implicit ev: &lt;:&lt;[(String, String),(String, String)])scala.collection.immutable.Map[String,String]">toMap</span><span class="delimiter">)</span><span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>.<a href="Http4sHeaderParser.scala.html#org.http4s.parser;Http4sHeaderParser.parse" title="=&gt; org.http4s.ParseResult[org.http4s.Header.Content-Disposition]">parse</a>

  def <a title="(value: String)org.http4s.ParseResult[org.http4s.Header.Date]" id="org.http4s.parser;SimpleHeaders.DATE">DATE</a><span class="delimiter">(</span><a title="String" id="org.http4s.parser;SimpleHeaders.DATE.value">value</a>: <span title="String">String</span><span class="delimiter">)</span> = new <a title="&lt;$anon: org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Date]&gt; extends org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Date]" id="org.http4s.parser;SimpleHeaders.DATE;$anon">Http4sHeaderParser</a><span class="delimiter">[</span>Date<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.DATE.value" title="implicit org.parboiled2.ParserInput.apply : (string: String)org.parboiled2.ParserInput.StringBasedParserInput">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Date,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.DATE;$anon.entry">entry</a> = rule <a title="org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Date,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.DATE;$anon.entry.matched.x$2" class="delimiter">{</a>
      <a href="AdditionalRules.scala.html#org.http4s.parser;AdditionalRules.HttpDate" title="=&gt; org.parboiled2.Rule1[org.http4s.DateTime]">HttpDate</a> ~ <a href="AdditionalRules.scala.html#org.http4s.parser;AdditionalRules.EOL" title="=&gt; org.parboiled2.Rule0">EOL</a> ~&gt; <span class="delimiter">(</span><a href="../Header.scala.html#org.http4s.Header;Date" title="(date: org.http4s.DateTime)org.http4s.Header.Date">Date</a><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.DATE;$anon.entry.matched.x$2" title="org.http4s.DateTime">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>.<a href="Http4sHeaderParser.scala.html#org.http4s.parser;Http4sHeaderParser.parse" title="=&gt; org.http4s.ParseResult[org.http4s.Header.Date]">parse</a>

<span class="comment">//  // Do not accept scoped IPv6 addresses as they should not appear in the Host header,</span>
<span class="comment">//  // see also https://issues.apache.org/bugzilla/show_bug.cgi?id=35122 (WONTFIX in Apache 2 issue) and</span>
<span class="comment">//  // https://bugzilla.mozilla.org/show_bug.cgi?id=464162 (FIXED in mozilla)</span>
  def <a title="(value: String)org.http4s.ParseResult[org.http4s.Header.Host]" id="org.http4s.parser;SimpleHeaders.HOST">HOST</a><span class="delimiter">(</span><a title="String" id="org.http4s.parser;SimpleHeaders.HOST.value">value</a>: <span title="String">String</span><span class="delimiter">)</span> = new <a title="&lt;$anon: org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Host]&gt; extends org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Host]" id="org.http4s.parser;SimpleHeaders.HOST;$anon">Http4sHeaderParser</a><span class="delimiter">[</span>Host<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.HOST.value" title="implicit org.parboiled2.ParserInput.apply : (string: String)org.parboiled2.ParserInput.StringBasedParserInput">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Host,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.HOST;$anon.entry">entry</a> = rule <a href="#org.http4s.parser;SimpleHeaders.HOST;$anon" title="org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Host,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.HOST;$anon.entry.matched.x$4" class="delimiter">{</a>
      <span class="delimiter">(</span><a href="Rfc2616BasicRules.scala.html#org.http4s.parser;Rfc2616BasicRules.Token" title="=&gt; org.parboiled2.Rule1[String]">Token</a> | <a href="Rfc2616BasicRules.scala.html#org.http4s.parser;Rfc2616BasicRules.IPv6Reference" title="=&gt; org.parboiled2.Rule1[String]">IPv6Reference</a><span class="delimiter">)</span> ~ <a href="Rfc2616BasicRules.scala.html#org.http4s.parser;Rfc2616BasicRules.OptWS" title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.HNil]">OptWS</a> ~
        optional<span class="delimiter">(</span><span class="string">&quot;:&quot;</span> ~ capture<span class="delimiter">(</span>oneOrMore<span class="delimiter">(</span><a href="Rfc2616BasicRules.scala.html#org.http4s.parser;Rfc2616BasicRules.Digit" title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.HNil]">Digit</a><span class="delimiter">)</span><span class="delimiter">)</span> ~&gt; <span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.HOST;$anon.entry.matched.x$4" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">_</a>.<span title="=&gt; Int">toInt</span><span class="delimiter">)</span><span class="delimiter">)</span> ~ <a href="AdditionalRules.scala.html#org.http4s.parser;AdditionalRules.EOL" title="=&gt; org.parboiled2.Rule0">EOL</a> ~&gt; <span class="delimiter">(</span><a href="../Header.scala.html#org.http4s.Header;Host" title="(host: String, port: Option[Int])org.http4s.Header.Host">Host</a><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.HOST;$anon.entry.matched.x$4" title="String">_</a>:<span title="String">String</span>, <a href="#org.http4s.parser;SimpleHeaders.HOST;$anon.entry.matched.x$4" title="Option[Int]">_</a>:<span title="Option[Int]">Option</span><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>.<a href="Http4sHeaderParser.scala.html#org.http4s.parser;Http4sHeaderParser.parse" title="=&gt; org.http4s.ParseResult[org.http4s.Header.Host]">parse</a>

  def <a title="(value: String)org.http4s.ParseResult[org.http4s.Header.Last-Modified]" id="org.http4s.parser;SimpleHeaders.LAST_MODIFIED">LAST_MODIFIED</a><span class="delimiter">(</span><a title="String" id="org.http4s.parser;SimpleHeaders.LAST_MODIFIED.value">value</a>: <span title="String">String</span><span class="delimiter">)</span> = new <a title="&lt;$anon: org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Last-Modified]&gt; extends org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Last-Modified]" id="org.http4s.parser;SimpleHeaders.LAST_MODIFIED;$anon">Http4sHeaderParser</a><span class="delimiter">[</span>`Last-Modified`<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.LAST_MODIFIED.value" title="implicit org.parboiled2.ParserInput.apply : (string: String)org.parboiled2.ParserInput.StringBasedParserInput">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Last-Modified,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.LAST_MODIFIED;$anon.entry">entry</a> = rule <a title="org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Last-Modified,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.LAST_MODIFIED;$anon.entry.matched.x$6" class="delimiter">{</a>
      <a href="AdditionalRules.scala.html#org.http4s.parser;AdditionalRules.HttpDate" title="=&gt; org.parboiled2.Rule1[org.http4s.DateTime]">HttpDate</a> ~ <a href="AdditionalRules.scala.html#org.http4s.parser;AdditionalRules.EOL" title="=&gt; org.parboiled2.Rule0">EOL</a> ~&gt; <span class="delimiter">(</span><a href="../Header.scala.html#org.http4s.Header;Last-Modified" title="(date: org.http4s.DateTime)org.http4s.Header.Last-Modified">`Last-Modified`</a><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.LAST_MODIFIED;$anon.entry.matched.x$6" title="org.http4s.DateTime">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>.<a href="Http4sHeaderParser.scala.html#org.http4s.parser;Http4sHeaderParser.parse" title="=&gt; org.http4s.ParseResult[org.http4s.Header.Last-Modified]">parse</a>

  def <a title="(value: String)org.http4s.ParseResult[org.http4s.Header.If-Modified-Since]" id="org.http4s.parser;SimpleHeaders.IF_MODIFIED_SINCE">IF_MODIFIED_SINCE</a><span class="delimiter">(</span><a title="String" id="org.http4s.parser;SimpleHeaders.IF_MODIFIED_SINCE.value">value</a>: <span title="String">String</span><span class="delimiter">)</span> = new <a title="&lt;$anon: org.http4s.parser.Http4sHeaderParser[org.http4s.Header.If-Modified-Since]&gt; extends org.http4s.parser.Http4sHeaderParser[org.http4s.Header.If-Modified-Since]" id="org.http4s.parser;SimpleHeaders.IF_MODIFIED_SINCE;$anon">Http4sHeaderParser</a><span class="delimiter">[</span>`If-Modified-Since`<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.IF_MODIFIED_SINCE.value" title="implicit org.parboiled2.ParserInput.apply : (string: String)org.parboiled2.ParserInput.StringBasedParserInput">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.If-Modified-Since,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.IF_MODIFIED_SINCE;$anon.entry">entry</a> = rule <a title="org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.If-Modified-Since,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.IF_MODIFIED_SINCE;$anon.entry.matched.x$7" class="delimiter">{</a>
      <a href="AdditionalRules.scala.html#org.http4s.parser;AdditionalRules.HttpDate" title="=&gt; org.parboiled2.Rule1[org.http4s.DateTime]">HttpDate</a> ~ <a href="AdditionalRules.scala.html#org.http4s.parser;AdditionalRules.EOL" title="=&gt; org.parboiled2.Rule0">EOL</a> ~&gt; <span class="delimiter">(</span><a href="../Header.scala.html#org.http4s.Header;If-Modified-Since" title="(date: org.http4s.DateTime)org.http4s.Header.If-Modified-Since">`If-Modified-Since`</a><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.IF_MODIFIED_SINCE;$anon.entry.matched.x$7" title="org.http4s.DateTime">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>.<a href="Http4sHeaderParser.scala.html#org.http4s.parser;Http4sHeaderParser.parse" title="=&gt; org.http4s.ParseResult[org.http4s.Header.If-Modified-Since]">parse</a>

  def <a title="(value: String)org.http4s.ParseResult[org.http4s.Header.ETag]" id="org.http4s.parser;SimpleHeaders.ETAG">ETAG</a><span class="delimiter">(</span><a title="String" id="org.http4s.parser;SimpleHeaders.ETAG.value">value</a>: <span title="String">String</span><span class="delimiter">)</span> = new <a title="&lt;$anon: org.http4s.parser.Http4sHeaderParser[org.http4s.Header.ETag]&gt; extends org.http4s.parser.Http4sHeaderParser[org.http4s.Header.ETag]" id="org.http4s.parser;SimpleHeaders.ETAG;$anon">Http4sHeaderParser</a><span class="delimiter">[</span>ETag<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.ETAG.value" title="implicit org.parboiled2.ParserInput.apply : (string: String)org.parboiled2.ParserInput.StringBasedParserInput">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.ETag,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.ETAG;$anon.entry">entry</a> = rule <a href="#org.http4s.parser;SimpleHeaders.ETAG;$anon" title="org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.ETag,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.ETAG;$anon.entry.matched.x$8" class="delimiter">{</a>
      capture<span class="delimiter">(</span>zeroOrMore<span class="delimiter">(</span><a href="Rfc2616BasicRules.scala.html#org.http4s.parser;Rfc2616BasicRules.AlphaNum" title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.HNil]">AlphaNum</a><span class="delimiter">)</span><span class="delimiter">)</span> ~&gt; <span class="delimiter">(</span><a href="../Header.scala.html#org.http4s.Header;ETag" title="(tag: String)org.http4s.Header.ETag">ETag</a><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.ETAG;$anon.entry.matched.x$8" title="String">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>.<a href="Http4sHeaderParser.scala.html#org.http4s.parser;Http4sHeaderParser.parse" title="=&gt; org.http4s.ParseResult[org.http4s.Header.ETag]">parse</a>

  def <a title="(value: String)org.http4s.ParseResult[org.http4s.Header.If-None-Match]" id="org.http4s.parser;SimpleHeaders.IF_NONE_MATCH">IF_NONE_MATCH</a><span class="delimiter">(</span><a title="String" id="org.http4s.parser;SimpleHeaders.IF_NONE_MATCH.value">value</a>: <span title="String">String</span><span class="delimiter">)</span> = new <a title="&lt;$anon: org.http4s.parser.Http4sHeaderParser[org.http4s.Header.If-None-Match]&gt; extends org.http4s.parser.Http4sHeaderParser[org.http4s.Header.If-None-Match]" id="org.http4s.parser;SimpleHeaders.IF_NONE_MATCH;$anon">Http4sHeaderParser</a><span class="delimiter">[</span>`If-None-Match`<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.IF_NONE_MATCH.value" title="implicit org.parboiled2.ParserInput.apply : (string: String)org.parboiled2.ParserInput.StringBasedParserInput">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.If-None-Match,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.IF_NONE_MATCH;$anon.entry">entry</a> = rule <a href="#org.http4s.parser;SimpleHeaders.IF_NONE_MATCH;$anon" title="org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.If-None-Match,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.IF_NONE_MATCH;$anon.entry.matched.x$9" class="delimiter">{</a>
      capture<span class="delimiter">(</span>zeroOrMore<span class="delimiter">(</span><a href="Rfc2616BasicRules.scala.html#org.http4s.parser;Rfc2616BasicRules.AlphaNum" title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.HNil]">AlphaNum</a><span class="delimiter">)</span><span class="delimiter">)</span> ~&gt; <span class="delimiter">(</span><a href="../Header.scala.html#org.http4s.Header;If-None-Match" title="(tag: String)org.http4s.Header.If-None-Match">`If-None-Match`</a><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.IF_NONE_MATCH;$anon.entry.matched.x$9" title="String">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>.<a href="Http4sHeaderParser.scala.html#org.http4s.parser;Http4sHeaderParser.parse" title="=&gt; org.http4s.ParseResult[org.http4s.Header.If-None-Match]">parse</a>

  def <a title="(value: String)org.http4s.ParseResult[org.http4s.Header.Transfer-Encoding]" id="org.http4s.parser;SimpleHeaders.TRANSFER_ENCODING">TRANSFER_ENCODING</a><span class="delimiter">(</span><a title="String" id="org.http4s.parser;SimpleHeaders.TRANSFER_ENCODING.value">value</a>: <span title="String">String</span><span class="delimiter">)</span> = new <a title="&lt;$anon: org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Transfer-Encoding]&gt; extends org.http4s.parser.Http4sHeaderParser[org.http4s.Header.Transfer-Encoding]" id="org.http4s.parser;SimpleHeaders.TRANSFER_ENCODING;$anon">Http4sHeaderParser</a><span class="delimiter">[</span>`Transfer-Encoding`<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.TRANSFER_ENCODING.value" title="implicit org.parboiled2.ParserInput.apply : (string: String)org.parboiled2.ParserInput.StringBasedParserInput">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Transfer-Encoding,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.TRANSFER_ENCODING;$anon.entry">entry</a> = rule <a href="#org.http4s.parser;SimpleHeaders.TRANSFER_ENCODING;$anon" title="org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.Transfer-Encoding,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.TRANSFER_ENCODING;$anon.entry.matched.vals" class="delimiter">{</a>
      oneOrMore<span class="delimiter">(</span><a href="Rfc2616BasicRules.scala.html#org.http4s.parser;Rfc2616BasicRules.Token" title="=&gt; org.parboiled2.Rule1[String]">Token</a><span class="delimiter">)</span>.separatedBy<span class="delimiter">(</span><a href="Rfc2616BasicRules.scala.html#org.http4s.parser;Rfc2616BasicRules.ListSep" title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.HNil]">ListSep</a><span class="delimiter">)</span> ~&gt; <span class="delimiter">{</span> vals: Seq<span class="delimiter">[</span>String<span class="delimiter">]</span> =&gt;
        if <span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.TRANSFER_ENCODING;$anon.entry.matched.vals" title="scala.collection.immutable.Seq[String]">vals</a>.<span title="=&gt; scala.collection.immutable.Seq[String]">tail</span>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="../HeaderKey.scala.html#org.http4s.HeaderKey;Recurring.apply(ca1e975507)" title="(first: org.http4s.Header.Transfer-Encoding.HeaderT#Value, more: org.http4s.Header.Transfer-Encoding.HeaderT#Value*)org.http4s.Header.Transfer-Encoding.HeaderT">`Transfer-Encoding`</a><span class="delimiter">(</span><a href="../TransferCoding.scala.html#org.http4s.TransferCoding" title="org.http4s.TransferCoding.type">TransferCoding</a>.<a href="../TransferCoding.scala.html#org.http4s.TransferCoding.fromKey" title="implicit org.http4s.TransferCoding.fromKey : (k: org.http4s.util.CaseInsensitiveString)org.http4s.TransferCoding">fromKey</a><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.TRANSFER_ENCODING;$anon.entry.matched.vals" title="scala.collection.immutable.Seq[String]">vals</a>.<a href="../util/CaseInsensitiveString.scala.html#org.http4s.util;CaseInsensitiveStringSyntax.ToCaseInsensitiveStringSyntax" title="implicit org.http4s.util.CaseInsensitiveStringSyntax.ToCaseInsensitiveStringSyntax : (cs: CharSequence)org.http4s.util.CaseInsensitiveStringOps">head</a>.<a href="../util/CaseInsensitiveString.scala.html#org.http4s.util;CaseInsensitiveStringOps.ci" title="=&gt; org.http4s.util.CaseInsensitiveString">ci</a><span class="delimiter">)</span><span class="delimiter">)</span>
        else <a href="../HeaderKey.scala.html#org.http4s.HeaderKey;Recurring.apply(ca1e975507)" title="(first: org.http4s.Header.Transfer-Encoding.HeaderT#Value, more: org.http4s.Header.Transfer-Encoding.HeaderT#Value*)org.http4s.Header.Transfer-Encoding.HeaderT">`Transfer-Encoding`</a><span class="delimiter">(</span><a href="../TransferCoding.scala.html#org.http4s.TransferCoding" title="org.http4s.TransferCoding.type">TransferCoding</a>.<a href="../TransferCoding.scala.html#org.http4s.TransferCoding.fromKey" title="implicit org.http4s.TransferCoding.fromKey : (k: org.http4s.util.CaseInsensitiveString)org.http4s.TransferCoding">fromKey</a><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.TRANSFER_ENCODING;$anon.entry.matched.vals" title="scala.collection.immutable.Seq[String]">vals</a>.<a href="../util/CaseInsensitiveString.scala.html#org.http4s.util;CaseInsensitiveStringSyntax.ToCaseInsensitiveStringSyntax" title="implicit org.http4s.util.CaseInsensitiveStringSyntax.ToCaseInsensitiveStringSyntax : (cs: CharSequence)org.http4s.util.CaseInsensitiveStringOps">head</a>.<a href="../util/CaseInsensitiveString.scala.html#org.http4s.util;CaseInsensitiveStringOps.ci" title="=&gt; org.http4s.util.CaseInsensitiveString">ci</a><span class="delimiter">)</span>, <a href="#org.http4s.parser;SimpleHeaders.TRANSFER_ENCODING;$anon.entry.matched.vals" title="scala.collection.immutable.Seq[String]">vals</a>.<span title="=&gt; scala.collection.immutable.Seq[String]">tail</span>.<span title="(f: String =&gt; org.http4s.TransferCoding)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Seq[String],org.http4s.TransferCoding,Seq[org.http4s.TransferCoding]])Seq[org.http4s.TransferCoding]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,org.http4s.TransferCoding,Seq[org.http4s.TransferCoding]]" class="delimiter">(</span><a title="String" id="org.http4s.parser;SimpleHeaders.TRANSFER_ENCODING;$anon.entry.matched.$anonfun.s">s</a> =&gt; <a href="../TransferCoding.scala.html#org.http4s.TransferCoding" title="org.http4s.TransferCoding.type">TransferCoding</a>.<a href="../TransferCoding.scala.html#org.http4s.TransferCoding.fromKey" title="implicit org.http4s.TransferCoding.fromKey : (k: org.http4s.util.CaseInsensitiveString)org.http4s.TransferCoding">fromKey</a><span class="delimiter">(</span><a href="../util/CaseInsensitiveString.scala.html#org.http4s.util;CaseInsensitiveStringSyntax.ToCaseInsensitiveStringSyntax" title="implicit org.http4s.util.CaseInsensitiveStringSyntax.ToCaseInsensitiveStringSyntax : (cs: CharSequence)org.http4s.util.CaseInsensitiveStringOps">s</a>.<a href="../util/CaseInsensitiveString.scala.html#org.http4s.util;CaseInsensitiveStringOps.ci" title="=&gt; org.http4s.util.CaseInsensitiveString">ci</a><span class="delimiter">)</span><span class="delimiter">)</span>: _*<span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>.<a href="Http4sHeaderParser.scala.html#org.http4s.parser;Http4sHeaderParser.parse" title="=&gt; org.http4s.ParseResult[org.http4s.Header.Transfer-Encoding]">parse</a>

  def <a title="(value: String)org.http4s.ParseResult[org.http4s.Header.X-Forwarded-For]" id="org.http4s.parser;SimpleHeaders.X_FORWARDED_FOR">X_FORWARDED_FOR</a><span class="delimiter">(</span><a title="String" id="org.http4s.parser;SimpleHeaders.X_FORWARDED_FOR.value">value</a>: <span title="String">String</span><span class="delimiter">)</span> = new <a title="&lt;$anon: org.http4s.parser.Http4sHeaderParser[org.http4s.Header.X-Forwarded-For]&gt; extends org.http4s.parser.Http4sHeaderParser[org.http4s.Header.X-Forwarded-For]" id="org.http4s.parser;SimpleHeaders.X_FORWARDED_FOR;$anon">Http4sHeaderParser</a><span class="delimiter">[</span>`X-Forwarded-For`<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.X_FORWARDED_FOR.value" title="implicit org.parboiled2.ParserInput.apply : (string: String)org.parboiled2.ParserInput.StringBasedParserInput">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.X-Forwarded-For,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.X_FORWARDED_FOR;$anon.entry">entry</a> = rule <a href="#org.http4s.parser;SimpleHeaders.X_FORWARDED_FOR;$anon" title="org.parboiled2.Rule[shapeless.HNil,shapeless.::[org.http4s.Header.X-Forwarded-For,shapeless.HNil]]" id="org.http4s.parser;SimpleHeaders.X_FORWARDED_FOR;$anon.entry.matched.xs" class="delimiter">{</a>
      oneOrMore<span class="delimiter">(</span><span class="delimiter">(</span><a href="AdditionalRules.scala.html#org.http4s.parser;AdditionalRules.Ip" title="=&gt; org.parboiled2.Rule1[java.net.InetAddress]">Ip</a> ~&gt; <span class="delimiter">(</span><span title="(x: java.net.InetAddress)Some[java.net.InetAddress]">Some</span><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.X_FORWARDED_FOR;$anon.entry.matched.xs" title="java.net.InetAddress">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>  | <span class="delimiter">(</span><span class="string">&quot;unknown&quot;</span> ~ push<span class="delimiter">(</span><span title="None.type">None</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.separatedBy<span class="delimiter">(</span><a href="Rfc2616BasicRules.scala.html#org.http4s.parser;Rfc2616BasicRules.ListSep" title="=&gt; org.parboiled2.Rule[shapeless.HNil,shapeless.HNil]">ListSep</a><span class="delimiter">)</span> ~
        <a href="AdditionalRules.scala.html#org.http4s.parser;AdditionalRules.EOL" title="=&gt; org.parboiled2.Rule0">EOL</a> ~&gt; <span class="delimiter">{</span> xs: Seq<span class="delimiter">[</span>Option<span class="delimiter">[</span>InetAddress<span class="delimiter">]</span><span class="delimiter">]</span> =&gt;
        <a href="../HeaderKey.scala.html#org.http4s.HeaderKey;Recurring.apply(ca1e975507)" title="(first: org.http4s.Header.X-Forwarded-For.HeaderT#Value, more: org.http4s.Header.X-Forwarded-For.HeaderT#Value*)org.http4s.Header.X-Forwarded-For.HeaderT">`X-Forwarded-For`</a><span class="delimiter">(</span><a href="#org.http4s.parser;SimpleHeaders.X_FORWARDED_FOR;$anon.entry.matched.xs" title="scala.collection.immutable.Seq[Option[java.net.InetAddress]]">xs</a>.<span title="=&gt; Option[java.net.InetAddress]">head</span>, <a href="#org.http4s.parser;SimpleHeaders.X_FORWARDED_FOR;$anon.entry.matched.xs" title="scala.collection.immutable.Seq[Option[java.net.InetAddress]]">xs</a>.<span title="=&gt; scala.collection.immutable.Seq[Option[java.net.InetAddress]]">tail</span>: _*<span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>.<a href="Http4sHeaderParser.scala.html#org.http4s.parser;Http4sHeaderParser.parse" title="=&gt; org.http4s.ParseResult[org.http4s.Header.X-Forwarded-For]">parse</a>

<span class="delimiter">}</span>
        </pre>
    </body>
</html>
