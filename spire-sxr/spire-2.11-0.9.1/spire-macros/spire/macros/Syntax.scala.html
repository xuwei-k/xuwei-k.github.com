<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>spire-macros/spire/macros/Syntax.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package spire.macros

import spire.macros.<a href="compat.scala.html#spire.macros.compat" title="spire.macros.compat.type">compat</a>.<span class="delimiter">{</span>termName, freshTermName, resetLocalAttrs, Context<span class="delimiter">}</span>

import scala.<span title="language.type">language</span>.higherKinds

object <a title="spire.macros.Ops.type" id="spire.macros.Ops">Ops</a> extends machinist.<span title="machinist.Ops">Ops</span> <span class="delimiter">{</span>

  def <a title="(c: Char)String" id="spire.macros.Ops.uesc">uesc</a><span class="delimiter">(</span><a title="Char" id="spire.macros.Ops.uesc.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span>: <span title="String">String</span> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;$u%04X&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#spire.macros.Ops.uesc.c" title="Char">c</a>.<span title="=&gt; Int">toInt</span><span class="delimiter">)</span>

  val operatorNames: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span> =
    machinist.<span title="machinist.DefaultOps.type">DefaultOps</span>.<span title="=&gt; scala.collection.immutable.Map[String,String]">operatorNames</span> <a title="Map[String,String]" id="spire.macros.Ops.operatorNames">++</a> <span title="(elems: (String, String)*)scala.collection.immutable.Map[String,String]">Map</span><span class="delimiter">(</span>
      <span class="comment">// partial operations |+|? |+|?? |-|? |-|??</span>
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><span title="String(&quot;$bar$plus$bar$qmark$qmark&quot;)" class="string">&quot;$bar$plus$bar$qmark$qmark&quot;</span>, <span title="String(&quot;opIsDefined&quot;)" class="string">&quot;opIsDefined&quot;</span><span class="delimiter">)</span>,
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><span title="String(&quot;$bar$minus$bar$qmark$qmark&quot;)" class="string">&quot;$bar$minus$bar$qmark$qmark&quot;</span>, <span title="String(&quot;opInverseIsDefined&quot;)" class="string">&quot;opInverseIsDefined&quot;</span><span class="delimiter">)</span>,
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><span title="String(&quot;$bar$plus$bar$qmark&quot;)" class="string">&quot;$bar$plus$bar$qmark&quot;</span>, <span title="String(&quot;partialOp&quot;)" class="string">&quot;partialOp&quot;</span><span class="delimiter">)</span>,
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><span title="String(&quot;$bar$minus$bar$qmark&quot;)" class="string">&quot;$bar$minus$bar$qmark&quot;</span>, <span title="String(&quot;partialOpInverse&quot;)" class="string">&quot;partialOpInverse&quot;</span><span class="delimiter">)</span>,

      <span class="comment">// partial actions ?|+|&gt; ??|+|&gt; &lt;|+|? &lt;|+|??</span>
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><span title="String(&quot;$qmark$bar$plus$bar$greater&quot;)" class="string">&quot;$qmark$bar$plus$bar$greater&quot;</span>, <span title="String(&quot;partialActl&quot;)" class="string">&quot;partialActl&quot;</span><span class="delimiter">)</span>,
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><span title="String(&quot;$qmark$qmark$bar$plus$bar$greater&quot;)" class="string">&quot;$qmark$qmark$bar$plus$bar$greater&quot;</span>, <span title="String(&quot;actlIsDefined&quot;)" class="string">&quot;actlIsDefined&quot;</span><span class="delimiter">)</span>,
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><span title="String(&quot;$less$bar$plus$bar$qmark&quot;)" class="string">&quot;$less$bar$plus$bar$qmark&quot;</span>, <span title="String(&quot;partialActr&quot;)" class="string">&quot;partialActr&quot;</span><span class="delimiter">)</span>,
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><span title="String(&quot;$less$bar$plus$bar$qmark$qmark&quot;)" class="string">&quot;$less$bar$plus$bar$qmark$qmark&quot;</span>, <span title="String(&quot;actrIsDefined&quot;)" class="string">&quot;actrIsDefined&quot;</span><span class="delimiter">)</span>,
      
      <span class="comment">// square root</span>
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#spire.macros.Ops.uesc" title="(c: Char)String">uesc</a><span class="delimiter">(</span><span title="Char('√')" class="char">'√'</span><span class="delimiter">)</span>, <span title="String(&quot;sqrt&quot;)" class="string">&quot;sqrt&quot;</span><span class="delimiter">)</span>,

      <span class="comment">// equality, comparisons</span>
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#spire.macros.Ops.uesc" title="(c: Char)String">uesc</a><span class="delimiter">(</span><span title="Char('≡')" class="char">'≡'</span><span class="delimiter">)</span>, <span title="String(&quot;eqv&quot;)" class="string">&quot;eqv&quot;</span><span class="delimiter">)</span>,
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#spire.macros.Ops.uesc" title="(c: Char)String">uesc</a><span class="delimiter">(</span><span title="Char('≠')" class="char">'≠'</span><span class="delimiter">)</span>, <span title="String(&quot;neqv&quot;)" class="string">&quot;neqv&quot;</span><span class="delimiter">)</span>,
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#spire.macros.Ops.uesc" title="(c: Char)String">uesc</a><span class="delimiter">(</span><span title="Char('≤')" class="char">'≤'</span><span class="delimiter">)</span>, <span title="String(&quot;lteqv&quot;)" class="string">&quot;lteqv&quot;</span><span class="delimiter">)</span>,
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#spire.macros.Ops.uesc" title="(c: Char)String">uesc</a><span class="delimiter">(</span><span title="Char('≥')" class="char">'≥'</span><span class="delimiter">)</span>, <span title="String(&quot;gteqv&quot;)" class="string">&quot;gteqv&quot;</span><span class="delimiter">)</span>,

      <span class="comment">// lattices/heyting</span>
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#spire.macros.Ops.uesc" title="(c: Char)String">uesc</a><span class="delimiter">(</span><span title="Char('∧')" class="char">'∧'</span><span class="delimiter">)</span>, <span title="String(&quot;meet&quot;)" class="string">&quot;meet&quot;</span><span class="delimiter">)</span>,
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#spire.macros.Ops.uesc" title="(c: Char)String">uesc</a><span class="delimiter">(</span><span title="Char('∨')" class="char">'∨'</span><span class="delimiter">)</span>, <span title="String(&quot;join&quot;)" class="string">&quot;join&quot;</span><span class="delimiter">)</span>,
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#spire.macros.Ops.uesc" title="(c: Char)String">uesc</a><span class="delimiter">(</span><span title="Char('⊃')" class="char">'⊃'</span><span class="delimiter">)</span>, <span title="String(&quot;imp&quot;)" class="string">&quot;imp&quot;</span><span class="delimiter">)</span>,
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#spire.macros.Ops.uesc" title="(c: Char)String">uesc</a><span class="delimiter">(</span><span title="Char('¬')" class="char">'¬'</span><span class="delimiter">)</span>, <span title="String(&quot;complement&quot;)" class="string">&quot;complement&quot;</span><span class="delimiter">)</span>,

      <span class="comment">// bool</span>
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#spire.macros.Ops.uesc" title="(c: Char)String">uesc</a><span class="delimiter">(</span><span title="Char('⊻')" class="char">'⊻'</span><span class="delimiter">)</span>, <span title="String(&quot;xor&quot;)" class="string">&quot;xor&quot;</span><span class="delimiter">)</span>,
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#spire.macros.Ops.uesc" title="(c: Char)String">uesc</a><span class="delimiter">(</span><span title="Char('⊼')" class="char">'⊼'</span><span class="delimiter">)</span>, <span title="String(&quot;nand&quot;)" class="string">&quot;nand&quot;</span><span class="delimiter">)</span>,
      <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#spire.macros.Ops.uesc" title="(c: Char)String">uesc</a><span class="delimiter">(</span><span title="Char('⊽')" class="char">'⊽'</span><span class="delimiter">)</span>, <span title="String(&quot;nor&quot;)" class="string">&quot;nor&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="[Ev1, R](c: spire.macros.compat.Context)(ev1: c.Expr[Ev1])c.Expr[R]" id="spire.macros.Ops.unopWithEv2">unopWithEv2</a><span class="delimiter">[</span><a title="" id="spire.macros.Ops.unopWithEv2;Ev1">Ev1</a>, <a title="" id="spire.macros.Ops.unopWithEv2;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="spire.macros.compat.Context" id="spire.macros.Ops.unopWithEv2.c">c</a>: <span title="spire.macros.compat.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[Ev1]" id="spire.macros.Ops.unopWithEv2.ev1">ev1</a>: c.<span title="c.Expr[Ev1]">Expr</span><span class="delimiter">[</span>Ev1<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[R]">Expr</span><span class="delimiter">[</span>R<span class="delimiter">]</span> = <span class="delimiter">{</span>
    import <a href="#spire.macros.Ops.unopWithEv2.c" title="spire.macros.compat.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
    val <a href="#spire.macros.Ops.unopWithEv2.ev" title="(c.universe.Tree, c.universe.Tree)" class="delimiter">(</a><a href="#spire.macros.Ops.unopWithEv2.x$1" title="c.universe.Tree" id="spire.macros.Ops.unopWithEv2.ev">ev</a>, <a href="#spire.macros.Ops.unopWithEv2.x$1" title="c.universe.Tree" id="spire.macros.Ops.unopWithEv2.lhs">lhs</a><span class="delimiter">)</span> = <span title="(c: reflect.macros.Context)(c.universe.Tree, c.universe.Tree)">unpack</span><span title="(c.universe.Tree, c.universe.Tree) @unchecked" class="delimiter">(</span><a href="#spire.macros.Ops.unopWithEv2.c" title="spire.macros.compat.Context">c</a><span class="delimiter">)</span>
    <a href="#spire.macros.Ops.unopWithEv2.c" title="spire.macros.compat.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[R])c.Expr[R]" class="delimiter">[</span><a href="#spire.macros.Ops.unopWithEv2;R" title="R">R</a><span class="delimiter">]</span><a href="#spire.macros.Ops.unopWithEv2.c" title="c.universe.type" id="spire.macros.Ops.unopWithEv2;$typecreator1.apply.free$R1" class="delimiter">(</a><a href="#spire.macros.Ops.unopWithEv2.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#spire.macros.Ops.unopWithEv2.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#spire.macros.Ops.unopWithEv2.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#spire.macros.Ops.unopWithEv2.ev" title="c.universe.Tree">ev</a>, <span title="(c: reflect.macros.Context)c.universe.TermName">findMethodName</span><span class="delimiter">(</span><a href="#spire.macros.Ops.unopWithEv2.c" title="spire.macros.compat.Context">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="(xs: c.universe.Tree*)List[c.universe.Tree]">List</span><span class="delimiter">(</span><a href="#spire.macros.Ops.unopWithEv2.lhs" title="c.universe.Tree">lhs</a><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="(xs: c.universe.Tree*)List[c.universe.Tree]">List</span><span class="delimiter">(</span><a href="#spire.macros.Ops.unopWithEv2.ev1" title="c.Expr[Ev1]">ev1</a>.<span title="=&gt; c.universe.Tree">tree</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

case class <a href="#spire.macros;SyntaxUtil.productElement.x$1" title="class SyntaxUtil[C &lt;: spire.macros.compat.Context with Singleton] extends AnyRef with Product with Serializable" id="spire.macros.SyntaxUtil.readResolve">SyntaxUtil</a><span class="delimiter">[</span><a title=" &lt;: spire.macros.compat.Context with Singleton" id="spire.macros;SyntaxUtil;C">C</a> &lt;: Context with Singleton<span class="delimiter">]</span><a href="#spire.macros.SyntaxUtil.readResolve" title="Product" class="delimiter">(</a>val <a title="C" id="spire.macros;SyntaxUtil.c">c</a>: <a href="#spire.macros;SyntaxUtil;C" title="C">C</a><span class="delimiter">)</span> <span class="delimiter">{</span>

  import <a href="#spire.macros;SyntaxUtil.c" title="=&gt; C">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._

  def <a title="(s: String)SyntaxUtil.this.c.universe.TermName" id="spire.macros;SyntaxUtil.name">name</a><span class="delimiter">(</span><a title="String" id="spire.macros;SyntaxUtil.name.s">s</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="compat.scala.html#spire.macros.compat.freshTermName" title="(c: C)(s: String)c.universe.TermName">freshTermName</a><span class="delimiter">(</span><a href="#spire.macros;SyntaxUtil.c" title="=&gt; C">c</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.macros;SyntaxUtil.name.s" title="String">s</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;$&quot;)" class="string">&quot;$&quot;</span><span class="delimiter">)</span>

  def <a title="(bs: String*)List[SyntaxUtil.this.c.universe.TermName]" id="spire.macros;SyntaxUtil.names">names</a><span class="delimiter">(</span><a title="String*" id="spire.macros;SyntaxUtil.names.bs">bs</a>: <span title="String*">String</span>*<span class="delimiter">)</span> = <a href="#spire.macros;SyntaxUtil.names.bs" title="String*">bs</a>.<span title="=&gt; List[String]">toList</span>.<span title="(f: String =&gt; SyntaxUtil.this.c.universe.TermName)(implicit bf: scala.collection.generic.CanBuildFrom[List[String],SyntaxUtil.this.c.universe.TermName,List[SyntaxUtil.this.c.universe.TermName]])List[SyntaxUtil.this.c.universe.TermName]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,SyntaxUtil.this.c.universe.TermName,List[SyntaxUtil.this.c.universe.TermName]]" class="delimiter">(</span><a href="#spire.macros;SyntaxUtil.name" title="(s: String)SyntaxUtil.this.c.universe.TermName">name</a><span class="delimiter">)</span>

  def <a title="(es: SyntaxUtil.this.c.Expr[_]*)Boolean" id="spire.macros;SyntaxUtil.isClean">isClean</a><span class="delimiter">(</span><a title="SyntaxUtil.this.c.Expr[_]*" id="spire.macros;SyntaxUtil.isClean.es">es</a>: c.<span title="SyntaxUtil.this.c.Expr[_]*">Expr</span><span class="delimiter">[</span>_<span class="delimiter">]</span>*<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#spire.macros;SyntaxUtil.isClean.es" title="SyntaxUtil.this.c.Expr[_]*">es</a>.<span title="(p: SyntaxUtil.this.c.Expr[_] =&gt; Boolean)Boolean">forall</span> <span class="delimiter">{</span>
      <a href="#spire.macros;SyntaxUtil.isClean.$anonfun.x$2" title="SyntaxUtil.this.c.Expr[_]">_</a>.<span title="=&gt; SyntaxUtil.this.c.universe.Tree">tree</span> match <span class="delimiter">{</span>
        case <a title="SyntaxUtil.this.c.universe.Ident" id="spire.macros;SyntaxUtil.isClean.$anonfun.t">t</a> @ <a href="#spire.macros;SyntaxUtil.c" title="(x: Any)Option[SyntaxUtil.this.c.universe.Ident]">Ident</a><span class="delimiter">(</span>_: <a href="#spire.macros;SyntaxUtil.c" title="(x: Any)Option[SyntaxUtil.this.c.universe.TermName]">TermName</a><span class="delimiter">)</span> if <a href="#spire.macros;SyntaxUtil.isClean.$anonfun.t" title="SyntaxUtil.this.c.universe.Ident">t</a>.<span title="=&gt; SyntaxUtil.this.c.universe.Symbol">symbol</span>.<span title="=&gt; SyntaxUtil.this.c.universe.TermSymbol">asTerm</span>.<span title="=&gt; Boolean">isStable</span> =&gt; true
        case <a href="#spire.macros;SyntaxUtil.c" title="(x: Any)Option[SyntaxUtil.this.c.universe.Function]">Function</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; true
        case _ =&gt; false
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">// This is Scala reflection source compatibility hack between Scala 2.10 and 2.11</span>
private object <a title="spire.macros.HasCompat.type" id="spire.macros.HasCompat">HasCompat</a> <a href="#spire.macros.HasCompat" title="spire.macros.HasCompat.type" class="delimiter">{</a> val <a title="Nothing" id="spire.macros.HasCompat.compat">compat</a> = <span title="=&gt; Nothing">???</span> <span class="delimiter">}</span>; import <a href="#spire.macros.HasCompat" title="spire.macros.HasCompat.type">HasCompat</a>._

class <a title="class InlineUtil[C &lt;: spire.macros.compat.Context with Singleton] extends AnyRef" id="spire.macros;InlineUtil">InlineUtil</a><span class="delimiter">[</span><a title=" &lt;: spire.macros.compat.Context with Singleton" id="spire.macros;InlineUtil;C">C</a> &lt;: Context with Singleton<span class="delimiter">]</span><a href="#spire.macros;InlineUtil" title="spire.macros.InlineUtil[C]" class="delimiter">(</a>val <a title="C" id="spire.macros;InlineUtil.c">c</a>: <a href="#spire.macros;InlineUtil;C" title="C">C</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  import <a href="#spire.macros;InlineUtil.c" title="=&gt; C">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
  <span class="comment">// This is Scala reflection source compatibility hack between Scala 2.10 and 2.11</span>
  import <a href="#spire.macros;InlineUtil.c" title="=&gt; InlineUtil.this.c.universe.Compat">compat</a>._

  def <a title="[T](tree: InlineUtil.this.c.universe.Tree)InlineUtil.this.c.Expr[T]" id="spire.macros;InlineUtil.inlineAndReset">inlineAndReset</a><span class="delimiter">[</span><a title="" id="spire.macros;InlineUtil.inlineAndReset;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="InlineUtil.this.c.universe.Tree" id="spire.macros;InlineUtil.inlineAndReset.tree">tree</a>: <span title="InlineUtil.this.c.universe.Tree">Tree</span><span class="delimiter">)</span>: c.<span title="InlineUtil.this.c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="InlineUtil.this.c.universe.Tree" id="spire.macros;InlineUtil.inlineAndReset.inlined">inlined</a> = <a href="#spire.macros;InlineUtil.inlineApplyRecursive" title="(tree: InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.Tree">inlineApplyRecursive</a><span class="delimiter">(</span><a href="#spire.macros;InlineUtil.inlineAndReset.tree" title="InlineUtil.this.c.universe.Tree">tree</a><span class="delimiter">)</span>
    <a href="#spire.macros;InlineUtil.c" title="=&gt; C">c</a>.<span title="[T](tree: InlineUtil.this.c.Tree)(implicit evidence$1: InlineUtil.this.c.WeakTypeTag[T])InlineUtil.this.c.Expr[T]">Expr</span><span title="(tree: InlineUtil.this.c.Tree)(implicit evidence$1: InlineUtil.this.c.WeakTypeTag[T])InlineUtil.this.c.Expr[T]" class="delimiter">[</span><a href="#spire.macros;InlineUtil.inlineAndReset;T" title="T">T</a><span class="delimiter">]</span><a href="#spire.macros;InlineUtil.c" title="InlineUtil.this.c.universe.type" id="spire.macros;InlineUtil.inlineAndReset;$typecreator2.apply.free$T1" class="delimiter">(</a><a href="compat.scala.html#spire.macros.compat.resetLocalAttrs" title="(c: C)(t: c.Tree)c.Tree">resetLocalAttrs</a><span class="delimiter">(</span><a href="#spire.macros;InlineUtil.c" title="=&gt; C">c</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.macros;InlineUtil.inlineAndReset.inlined" title="InlineUtil.this.c.universe.Tree">inlined</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(tree: InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.Tree" id="spire.macros;InlineUtil.inlineApplyRecursive">inlineApplyRecursive</a><span class="delimiter">(</span><a title="InlineUtil.this.c.universe.Tree" id="spire.macros;InlineUtil.inlineApplyRecursive.tree">tree</a>: <span title="InlineUtil.this.c.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="InlineUtil.this.c.universe.Tree">Tree</span> = <span class="delimiter">{</span>
    val <a title="InlineUtil.this.c.universe.TermName" id="spire.macros;InlineUtil.inlineApplyRecursive.ApplyName">ApplyName</a> = <a href="compat.scala.html#spire.macros.compat.termName" title="(c: C)(s: String)c.universe.TermName">termName</a><span class="delimiter">(</span><a href="#spire.macros;InlineUtil.c" title="=&gt; C">c</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="String(&quot;apply&quot;)" class="string">&quot;apply&quot;</span><span class="delimiter">)</span>

    class <a title="class InlineSymbol extends InlineUtil.this.c.universe.Transformer" id="spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol">InlineSymbol</a><a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol" title="InlineSymbol" class="delimiter">(</a><a title="InlineUtil.this.c.universe.Symbol" id="spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol.symbol">symbol</a>: <span title="InlineUtil.this.c.universe.Symbol">Symbol</span>, <a title="InlineUtil.this.c.universe.Tree" id="spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol.value">value</a>: <span title="InlineUtil.this.c.universe.Tree">Tree</span><span class="delimiter">)</span> extends <a href="#spire.macros;InlineUtil.c" title="InlineUtil.this.c.universe.Transformer">Transformer</a> <span class="delimiter">{</span>
      override def <a title="(tree: InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.Tree" id="spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol.transform">transform</a><span class="delimiter">(</span><a title="InlineUtil.this.c.universe.Tree" id="spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol.transform.tree">tree</a>: <span title="InlineUtil.this.c.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="InlineUtil.this.c.universe.Tree">Tree</span> = <a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol.transform.tree" title="InlineUtil.this.c.universe.Tree">tree</a> match <span class="delimiter">{</span>
        case <a href="#spire.macros;InlineUtil.c" title="(x: Any)Option[InlineUtil.this.c.universe.Ident]">Ident</a><span class="delimiter">(</span>_<span class="delimiter">)</span> if <a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol.transform.tree" title="InlineUtil.this.c.universe.Tree">tree</a>.<span title="=&gt; InlineUtil.this.c.universe.Symbol">symbol</span> <span title="(x$1: Any)Boolean">==</span> <a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol.symbol" title="InlineUtil.this.c.universe.Symbol">symbol</a> =&gt;
          <a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol.value" title="InlineUtil.this.c.universe.Tree">value</a>
        case <a title="InlineUtil.this.c.universe.TypeTree" id="spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol.transform.tt">tt</a>: <a href="#spire.macros;InlineUtil.c" title="(x: Any)Option[InlineUtil.this.c.universe.TypeTree]">TypeTree</a> if <a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol.transform.tt" title="InlineUtil.this.c.universe.TypeTree">tt</a>.<span title="=&gt; InlineUtil.this.c.universe.Tree">original</span> <span title="(x$1: Any)Boolean">!=</span> null =&gt;
          super.<span title="(tree: InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.Tree">transform</span><span class="delimiter">(</span><a href="#spire.macros;InlineUtil.c" title="()InlineUtil.this.c.universe.TypeTree">TypeTree</a><a href="#spire.macros;InlineUtil.c" title="implicit scala.reflect.macros.Universe.MacroCompatApi.CompatibleTypeTree : (tt: InlineUtil.this.c.universe.TypeTree)InlineUtil.this.c.universe.compat.CompatibleTypeTree" class="delimiter">(</a><span class="delimiter">)</span>.<span title="(tree: InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.TypeTree">setOriginal</span><span class="delimiter">(</span><a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol.transform" title="(tree: InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.Tree">transform</a><span class="delimiter">(</span><a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol.transform.tt" title="InlineUtil.this.c.universe.TypeTree">tt</a>.<span title="=&gt; InlineUtil.this.c.universe.Tree">original</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case _ =&gt;
          super.<span title="(tree: InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.Tree">transform</span><span class="delimiter">(</span><a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol.transform.tree" title="InlineUtil.this.c.universe.Tree">tree</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    object <a title="InlineApply.type" id="spire.macros;InlineUtil.inlineApplyRecursive.InlineApply">InlineApply</a> extends <a href="#spire.macros;InlineUtil.c" title="InlineUtil.this.c.universe.Transformer">Transformer</a> <span class="delimiter">{</span>
      def <a title="(symbol: InlineUtil.this.c.universe.Symbol, body: InlineUtil.this.c.universe.Tree, arg: InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.Tree" id="spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.inlineSymbol">inlineSymbol</a><span class="delimiter">(</span><a title="InlineUtil.this.c.universe.Symbol" id="spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.inlineSymbol.symbol">symbol</a>: <span title="InlineUtil.this.c.universe.Symbol">Symbol</span>, <a title="InlineUtil.this.c.universe.Tree" id="spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.inlineSymbol.body">body</a>: <span title="InlineUtil.this.c.universe.Tree">Tree</span>, <a title="InlineUtil.this.c.universe.Tree" id="spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.inlineSymbol.arg">arg</a>: <span title="InlineUtil.this.c.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="InlineUtil.this.c.universe.Tree">Tree</span> =
        new <a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol" title="InlineSymbol">InlineSymbol</a><span class="delimiter">(</span><a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.inlineSymbol.symbol" title="InlineUtil.this.c.universe.Symbol">symbol</a>, <a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.inlineSymbol.arg" title="InlineUtil.this.c.universe.Tree">arg</a><span class="delimiter">)</span>.<a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineSymbol.transform" title="(tree: InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.Tree">transform</a><span class="delimiter">(</span><a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.inlineSymbol.body" title="InlineUtil.this.c.universe.Tree">body</a><span class="delimiter">)</span>

      override def <a title="(tree: InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.Tree" id="spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.transform">transform</a><span class="delimiter">(</span><a title="InlineUtil.this.c.universe.Tree" id="spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.transform.tree">tree</a>: <span title="InlineUtil.this.c.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="InlineUtil.this.c.universe.Tree">Tree</span> = <a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.transform.tree" title="InlineUtil.this.c.universe.Tree">tree</a> match <span class="delimiter">{</span>
        case <a href="#spire.macros;InlineUtil.c" title="(x: Any)Option[InlineUtil.this.c.universe.Apply]">Apply</a><span class="delimiter">(</span><a href="#spire.macros;InlineUtil.c" title="(x: Any)Option[InlineUtil.this.c.universe.Select]">Select</a><span class="delimiter">(</span><a href="#spire.macros;InlineUtil.c" title="(x: Any)Option[InlineUtil.this.c.universe.Function]">Function</a><span class="delimiter">(</span><span title="List[InlineUtil.this.c.universe.ValDef]">params</span>, <span title="InlineUtil.this.c.universe.Tree">body</span><span class="delimiter">)</span>, <a href="#spire.macros;InlineUtil.inlineApplyRecursive.ApplyName" title="InlineUtil.this.c.universe.TermName">ApplyName</a><span class="delimiter">)</span>, <span title="List[InlineUtil.this.c.universe.Tree]">args</span><span class="delimiter">)</span> =&gt;
          <span title="List[InlineUtil.this.c.universe.ValDef]">params</span>.<span title="(that: scala.collection.GenIterable[InlineUtil.this.c.universe.Tree])(implicit bf: scala.collection.generic.CanBuildFrom[List[InlineUtil.this.c.universe.ValDef],(InlineUtil.this.c.universe.ValDef, InlineUtil.this.c.universe.Tree),List[(InlineUtil.this.c.universe.ValDef, InlineUtil.this.c.universe.Tree)]])List[(InlineUtil.this.c.universe.ValDef, InlineUtil.this.c.universe.Tree)]">zip</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,(InlineUtil.this.c.universe.ValDef, InlineUtil.this.c.universe.Tree),List[(InlineUtil.this.c.universe.ValDef, InlineUtil.this.c.universe.Tree)]]" class="delimiter">(</span><span title="List[InlineUtil.this.c.universe.Tree]">args</span><span class="delimiter">)</span>.<span title="(z: InlineUtil.this.c.universe.Tree)(f: (InlineUtil.this.c.universe.Tree, (InlineUtil.this.c.universe.ValDef, InlineUtil.this.c.universe.Tree)) =&gt; InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.Tree">foldLeft</span><span class="delimiter">(</span><span title="InlineUtil.this.c.universe.Tree">body</span><span class="delimiter">)</span> <a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.transform.$anonfun.x0$1" title="InlineUtil.this.c.universe.Tree" class="delimiter">{</a> case <span class="delimiter">(</span><span title="InlineUtil.this.c.universe.Tree">b</span>, <span class="delimiter">(</span><span title="InlineUtil.this.c.universe.ValDef">param</span>, <span title="InlineUtil.this.c.universe.Tree">arg</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
            <a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.inlineSymbol" title="(symbol: InlineUtil.this.c.universe.Symbol, body: InlineUtil.this.c.universe.Tree, arg: InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.Tree">inlineSymbol</a><span class="delimiter">(</span><span title="InlineUtil.this.c.universe.ValDef">param</span>.<span title="=&gt; InlineUtil.this.c.universe.Symbol">symbol</span>, <span title="InlineUtil.this.c.universe.Tree">b</span>, <span title="InlineUtil.this.c.universe.Tree">arg</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          
        case <a href="#spire.macros;InlineUtil.c" title="(x: Any)Option[InlineUtil.this.c.universe.Apply]">Apply</a><span class="delimiter">(</span><a href="#spire.macros;InlineUtil.c" title="(x: Any)Option[InlineUtil.this.c.universe.Function]">Function</a><span class="delimiter">(</span><span title="List[InlineUtil.this.c.universe.ValDef]">params</span>, <span title="InlineUtil.this.c.universe.Tree">body</span><span class="delimiter">)</span>, <span title="List[InlineUtil.this.c.universe.Tree]">args</span><span class="delimiter">)</span> =&gt;
          <span title="List[InlineUtil.this.c.universe.ValDef]">params</span>.<span title="(that: scala.collection.GenIterable[InlineUtil.this.c.universe.Tree])(implicit bf: scala.collection.generic.CanBuildFrom[List[InlineUtil.this.c.universe.ValDef],(InlineUtil.this.c.universe.ValDef, InlineUtil.this.c.universe.Tree),List[(InlineUtil.this.c.universe.ValDef, InlineUtil.this.c.universe.Tree)]])List[(InlineUtil.this.c.universe.ValDef, InlineUtil.this.c.universe.Tree)]">zip</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,(InlineUtil.this.c.universe.ValDef, InlineUtil.this.c.universe.Tree),List[(InlineUtil.this.c.universe.ValDef, InlineUtil.this.c.universe.Tree)]]" class="delimiter">(</span><span title="List[InlineUtil.this.c.universe.Tree]">args</span><span class="delimiter">)</span>.<span title="(z: InlineUtil.this.c.universe.Tree)(f: (InlineUtil.this.c.universe.Tree, (InlineUtil.this.c.universe.ValDef, InlineUtil.this.c.universe.Tree)) =&gt; InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.Tree">foldLeft</span><span class="delimiter">(</span><span title="InlineUtil.this.c.universe.Tree">body</span><span class="delimiter">)</span> <a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.transform.$anonfun.x0$2" title="InlineUtil.this.c.universe.Tree" class="delimiter">{</a> case <span class="delimiter">(</span><span title="InlineUtil.this.c.universe.Tree">b</span>, <span class="delimiter">(</span><span title="InlineUtil.this.c.universe.ValDef">param</span>, <span title="InlineUtil.this.c.universe.Tree">arg</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
            <a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.inlineSymbol" title="(symbol: InlineUtil.this.c.universe.Symbol, body: InlineUtil.this.c.universe.Tree, arg: InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.Tree">inlineSymbol</a><span class="delimiter">(</span><span title="InlineUtil.this.c.universe.ValDef">param</span>.<span title="=&gt; InlineUtil.this.c.universe.Symbol">symbol</span>, <span title="InlineUtil.this.c.universe.Tree">b</span>, <span title="InlineUtil.this.c.universe.Tree">arg</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>

        case _ =&gt;
          super.<span title="(tree: InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.Tree">transform</span><span class="delimiter">(</span><a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.transform.tree" title="InlineUtil.this.c.universe.Tree">tree</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="#spire.macros;InlineUtil.inlineApplyRecursive.InlineApply" title="InlineApply.type">InlineApply</a>.<a href="#spire.macros;InlineUtil.inlineApplyRecursive;InlineApply.transform" title="(tree: InlineUtil.this.c.universe.Tree)InlineUtil.this.c.universe.Tree">transform</a><span class="delimiter">(</span><a href="#spire.macros;InlineUtil.inlineApplyRecursive.tree" title="InlineUtil.this.c.universe.Tree">tree</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

object <a title="spire.macros.Syntax.type" id="spire.macros.Syntax">Syntax</a> <a href="#spire.macros.Syntax" title="spire.macros.Syntax.type" class="delimiter">{</a>

  def <a title="[A](c: spire.macros.compat.Context)(init: c.Expr[A])(test: c.Expr[A =&gt; Boolean], next: c.Expr[A =&gt; A])(body: c.Expr[A =&gt; Unit])c.Expr[Unit]" id="spire.macros.Syntax.cforMacro">cforMacro</a><span class="delimiter">[</span><a title="" id="spire.macros.Syntax.cforMacro;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="spire.macros.compat.Context" id="spire.macros.Syntax.cforMacro.c">c</a>: <span title="spire.macros.compat.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[A]" id="spire.macros.Syntax.cforMacro.init">init</a>: c.<span title="c.Expr[A]">Expr</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>
     <span class="delimiter">(</span><a title="c.Expr[A =&gt; Boolean]" id="spire.macros.Syntax.cforMacro.test">test</a>: c.<span title="c.Expr[A =&gt; Boolean]">Expr</span><span class="delimiter">[</span>A =&gt; Boolean<span class="delimiter">]</span>, <a title="c.Expr[A =&gt; A]" id="spire.macros.Syntax.cforMacro.next">next</a>: c.<span title="c.Expr[A =&gt; A]">Expr</span><span class="delimiter">[</span>A =&gt; A<span class="delimiter">]</span><span class="delimiter">)</span>
     <span class="delimiter">(</span><a title="c.Expr[A =&gt; Unit]" id="spire.macros.Syntax.cforMacro.body">body</a>: c.<span title="c.Expr[A =&gt; Unit]">Expr</span><span class="delimiter">[</span>A =&gt; Unit<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[Unit]">Expr</span><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <span class="delimiter">{</span>


    import <a href="#spire.macros.Syntax.cforMacro.c" title="spire.macros.compat.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
    val <a title="spire.macros.SyntaxUtil[c.type]" id="spire.macros.Syntax.cforMacro.util">util</a> = <a href="#spire.macros.SyntaxUtil.readResolve" title="[C &lt;: spire.macros.compat.Context with Singleton](c: C)spire.macros.SyntaxUtil[C]">SyntaxUtil</a><span title="(c: c.type)spire.macros.SyntaxUtil[c.type]" class="delimiter">[</span>c.type<span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.macros.Syntax.cforMacro.c" title="spire.macros.compat.Context">c</a><span class="delimiter">)</span>
    val <a title="util.c.universe.TermName" id="spire.macros.Syntax.cforMacro.index">index</a> = <a href="#spire.macros.Syntax.cforMacro.util" title="spire.macros.SyntaxUtil[c.type]">util</a>.<a href="#spire.macros;SyntaxUtil.name" title="(s: String)util.c.universe.TermName">name</a><span class="delimiter">(</span><span title="String(&quot;index&quot;)" class="string">&quot;index&quot;</span><span class="delimiter">)</span>

    <span class="comment">/**
     * If our arguments are all &quot;clean&quot; (anonymous functions or simple
     * identifiers) then we can go ahead and just inline them directly
     * into a while loop.
     * 
     * If one or more of our arguments are &quot;dirty&quot; (something more
     * complex than an anonymous function or simple identifier) then
     * we will go ahead and bind each argument to a val just to be
     * safe.
     */</span>
    val <a title="c.universe.Tree" id="spire.macros.Syntax.cforMacro.tree">tree</a> = if <span class="delimiter">(</span><a href="#spire.macros.Syntax.cforMacro.util" title="spire.macros.SyntaxUtil[c.type]">util</a>.<a href="#spire.macros;SyntaxUtil.isClean" title="(es: util.c.Expr[_]*)Boolean">isClean</a><span class="delimiter">(</span><a href="#spire.macros.Syntax.cforMacro.test" title="c.Expr[A =&gt; Boolean]">test</a>, <a href="#spire.macros.Syntax.cforMacro.next" title="c.Expr[A =&gt; A]">next</a>, <a href="#spire.macros.Syntax.cforMacro.body" title="c.Expr[A =&gt; Unit]">body</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.macros.Syntax.cforMacro.c" title="c.universe.TermName" id="spire.macros.Syntax.cforMacro.tree.nn$macro$97">q</a>&quot;&quot;&quot;
      var $<a href="#spire.macros.Syntax.cforMacro.index" title="util.c.universe.TermName">index</a> = $<a href="#spire.macros.Syntax.cforMacro.init" title="c.Expr[A]">init</a>
      while ($<a href="#spire.macros.Syntax.cforMacro.test" title="c.Expr[A =&gt; Boolean]">test</a>($<a href="#spire.macros.Syntax.cforMacro.index" title="util.c.universe.TermName">index</a>)) {
        $<a href="#spire.macros.Syntax.cforMacro.body" title="c.Expr[A =&gt; Unit]">body</a>($<a href="#spire.macros.Syntax.cforMacro.index" title="util.c.universe.TermName">index</a>)
        $<a href="#spire.macros.Syntax.cforMacro.index" title="util.c.universe.TermName">index</a> = $<a href="#spire.macros.Syntax.cforMacro.next" title="c.Expr[A =&gt; A]">next</a>($<a href="#spire.macros.Syntax.cforMacro.index" title="util.c.universe.TermName">index</a><span class="string">)
      }
      &quot;&quot;&quot;</span>

    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      val <a title="util.c.universe.TermName" id="spire.macros.Syntax.cforMacro.tree.testName">testName</a> = <a href="#spire.macros.Syntax.cforMacro.util" title="spire.macros.SyntaxUtil[c.type]">util</a>.<a href="#spire.macros;SyntaxUtil.name" title="(s: String)util.c.universe.TermName">name</a><span class="delimiter">(</span><span title="String(&quot;test&quot;)" class="string">&quot;test&quot;</span><span class="delimiter">)</span>
      val <a title="util.c.universe.TermName" id="spire.macros.Syntax.cforMacro.tree.nextName">nextName</a> = <a href="#spire.macros.Syntax.cforMacro.util" title="spire.macros.SyntaxUtil[c.type]">util</a>.<a href="#spire.macros;SyntaxUtil.name" title="(s: String)util.c.universe.TermName">name</a><span class="delimiter">(</span><span title="String(&quot;next&quot;)" class="string">&quot;next&quot;</span><span class="delimiter">)</span>
      val <a title="util.c.universe.TermName" id="spire.macros.Syntax.cforMacro.tree.bodyName">bodyName</a> = <a href="#spire.macros.Syntax.cforMacro.util" title="spire.macros.SyntaxUtil[c.type]">util</a>.<a href="#spire.macros;SyntaxUtil.name" title="(s: String)util.c.universe.TermName">name</a><span class="delimiter">(</span><span title="String(&quot;body&quot;)" class="string">&quot;body&quot;</span><span class="delimiter">)</span>

      <a href="#spire.macros.Syntax.cforMacro.c" title="c.universe.TermName" id="spire.macros.Syntax.cforMacro.tree.nn$macro$113">q</a>&quot;&quot;&quot;
      val $<a href="#spire.macros.Syntax.cforMacro.tree.testName" title="util.c.universe.TermName">testName</a>: Int =&gt; Boolean = $<a href="#spire.macros.Syntax.cforMacro.test" title="c.Expr[A =&gt; Boolean]">test</a>
      val $<a href="#spire.macros.Syntax.cforMacro.tree.nextName" title="util.c.universe.TermName">nextName</a>: Int =&gt; Int = $<a href="#spire.macros.Syntax.cforMacro.next" title="c.Expr[A =&gt; A]">next</a>
      val $<a href="#spire.macros.Syntax.cforMacro.tree.bodyName" title="util.c.universe.TermName">bodyName</a>: Int =&gt; Unit = $<a href="#spire.macros.Syntax.cforMacro.body" title="c.Expr[A =&gt; Unit]">body</a>
      var $<a href="#spire.macros.Syntax.cforMacro.index" title="util.c.universe.TermName">index</a>: Int = $<a href="#spire.macros.Syntax.cforMacro.init" title="c.Expr[A]">init</a>
      while ($<a href="#spire.macros.Syntax.cforMacro.tree.testName" title="util.c.universe.TermName">testName</a>($<a href="#spire.macros.Syntax.cforMacro.index" title="util.c.universe.TermName">index</a>)) {
        $<a href="#spire.macros.Syntax.cforMacro.tree.bodyName" title="util.c.universe.TermName">bodyName</a>($<a href="#spire.macros.Syntax.cforMacro.index" title="util.c.universe.TermName">index</a>)
        $<a href="#spire.macros.Syntax.cforMacro.index" title="util.c.universe.TermName">index</a> = $<a href="#spire.macros.Syntax.cforMacro.tree.nextName" title="util.c.universe.TermName">nextName</a>($<a href="#spire.macros.Syntax.cforMacro.index" title="util.c.universe.TermName">index</a><span class="string">)
      }
      &quot;&quot;&quot;</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Instead of just returning 'tree', we will go ahead and inline
     * anonymous functions which are immediately applied.
v     */</span>
    new <a href="#spire.macros;InlineUtil" title="spire.macros.InlineUtil[c.type]">InlineUtil</a><span class="delimiter">[</span>c.type<span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.macros.Syntax.cforMacro.c" title="spire.macros.compat.Context">c</a><span class="delimiter">)</span>.<a href="#spire.macros;InlineUtil.inlineAndReset" title="([T](tree: _444.c.universe.Tree)_444.c.universe.Expr[T]) forSome { val _444: spire.macros.InlineUtil[c.type] }">inlineAndReset</a><span title="(tree: _58.c.universe.Tree)_58.c.universe.Expr[Unit]" class="delimiter">[</span><span title="Unit">Unit</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.macros.Syntax.cforMacro.tree" title="c.universe.Tree">tree</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(c: spire.macros.compat.Context)(r: c.Expr[Range])(body: c.Expr[Int =&gt; Unit])c.Expr[Unit]" id="spire.macros.Syntax.cforRangeMacro">cforRangeMacro</a><span class="delimiter">(</span><a title="spire.macros.compat.Context" id="spire.macros.Syntax.cforRangeMacro.c">c</a>: <span title="spire.macros.compat.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[Range]" id="spire.macros.Syntax.cforRangeMacro.r">r</a>: c.<span title="c.Expr[Range]">Expr</span><span class="delimiter">[</span>Range<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[Int =&gt; Unit]" id="spire.macros.Syntax.cforRangeMacro.body">body</a>: c.<span title="c.Expr[Int =&gt; Unit]">Expr</span><span class="delimiter">[</span>Int =&gt; Unit<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[Unit]">Expr</span><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <span class="delimiter">{</span>

    import <a href="#spire.macros.Syntax.cforRangeMacro.c" title="spire.macros.compat.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
    val <a title="spire.macros.SyntaxUtil[c.type]" id="spire.macros.Syntax.cforRangeMacro.util">util</a> = <a href="#spire.macros.SyntaxUtil.readResolve" title="[C &lt;: spire.macros.compat.Context with Singleton](c: C)spire.macros.SyntaxUtil[C]">SyntaxUtil</a><span title="(c: c.type)spire.macros.SyntaxUtil[c.type]" class="delimiter">[</span>c.type<span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.macros.Syntax.cforRangeMacro.c" title="spire.macros.compat.Context">c</a><span class="delimiter">)</span>

    val <a href="#spire.macros.Syntax.cforRangeMacro.x$3.<unapply-selector>" title="(x: List[util.c.universe.TermName])Some[List[util.c.universe.TermName]]">List</a><a href="#spire.macros.Syntax.cforRangeMacro.range" title="(util.c.universe.TermName, util.c.universe.TermName, util.c.universe.TermName, util.c.universe.TermName, util.c.universe.TermName)" class="delimiter">(</a><a href="#spire.macros.Syntax.cforRangeMacro.x$3" title="util.c.universe.TermName" id="spire.macros.Syntax.cforRangeMacro.range">range</a>, <a href="#spire.macros.Syntax.cforRangeMacro.x$3" title="util.c.universe.TermName" id="spire.macros.Syntax.cforRangeMacro.index">index</a>, <a href="#spire.macros.Syntax.cforRangeMacro.x$3" title="util.c.universe.TermName" id="spire.macros.Syntax.cforRangeMacro.end">end</a>, <a href="#spire.macros.Syntax.cforRangeMacro.x$3" title="util.c.universe.TermName" id="spire.macros.Syntax.cforRangeMacro.limit">limit</a>, <a href="#spire.macros.Syntax.cforRangeMacro.x$3" title="util.c.universe.TermName" id="spire.macros.Syntax.cforRangeMacro.step">step</a><span class="delimiter">)</span> =
      <a href="#spire.macros.Syntax.cforRangeMacro.util" title="spire.macros.SyntaxUtil[c.type]">util</a>.<a href="#spire.macros;SyntaxUtil.names" title="(bs: String*)List[util.c.universe.TermName]">names</a><span title="List[util.c.universe.TermName] @unchecked" class="delimiter">(</span><span title="String(&quot;range&quot;)" class="string">&quot;range&quot;</span>, <span title="String(&quot;index&quot;)" class="string">&quot;index&quot;</span>, <span title="String(&quot;end&quot;)" class="string">&quot;end&quot;</span>, <span title="String(&quot;limit&quot;)" class="string">&quot;limit&quot;</span>, <span title="String(&quot;step&quot;)" class="string">&quot;step&quot;</span><span class="delimiter">)</span>

    def <a title="(t: c.universe.Tree)Option[Int]" id="spire.macros.Syntax.cforRangeMacro.isLiteral">isLiteral</a><span class="delimiter">(</span><a title="c.universe.Tree" id="spire.macros.Syntax.cforRangeMacro.isLiteral.t">t</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="Option[Int]">Option</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> = <a href="#spire.macros.Syntax.cforRangeMacro.isLiteral.t" title="c.universe.Tree">t</a> match <span class="delimiter">{</span>
      case <a href="#spire.macros.Syntax.cforRangeMacro.c" title="(x: Any)Option[c.universe.Literal]">Literal</a><span class="delimiter">(</span><a href="#spire.macros.Syntax.cforRangeMacro.c" title="(x: Any)Option[c.universe.Constant]">Constant</a><span class="delimiter">(</span><a title="Any" id="spire.macros.Syntax.cforRangeMacro.isLiteral.a">a</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.macros.Syntax.cforRangeMacro.isLiteral.a" title="Any">a</a> match <span class="delimiter">{</span>
        case <a title="Int" id="spire.macros.Syntax.cforRangeMacro.isLiteral.n">n</a>: <span title="Int">Int</span> =&gt; <span title="(x: Int)Some[Int]">Some</span><span class="delimiter">(</span><a href="#spire.macros.Syntax.cforRangeMacro.isLiteral.n" title="Int">n</a><span class="delimiter">)</span>
        case _ =&gt; <span title="None.type">None</span>
      <span class="delimiter">}</span>
      case _ =&gt; <span title="None.type">None</span>
    <span class="delimiter">}</span>

    def <a title="(fromExpr: c.universe.Tree, toExpr: c.universe.Tree, stride: Int)c.universe.Tree" id="spire.macros.Syntax.cforRangeMacro.strideUpTo">strideUpTo</a><span class="delimiter">(</span><a title="c.universe.Tree" id="spire.macros.Syntax.cforRangeMacro.strideUpTo.fromExpr">fromExpr</a>: <span title="c.universe.Tree">Tree</span>, <a title="c.universe.Tree" id="spire.macros.Syntax.cforRangeMacro.strideUpTo.toExpr">toExpr</a>: <span title="c.universe.Tree">Tree</span>, <a title="Int" id="spire.macros.Syntax.cforRangeMacro.strideUpTo.stride">stride</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="c.universe.Tree">Tree</span> =
      <a href="#spire.macros.Syntax.cforRangeMacro.c" title="c.universe.TermName" id="spire.macros.Syntax.cforRangeMacro.strideUpTo.nn$macro$124">q</a>&quot;&quot;&quot;
      var $<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a>: Int = $<a href="#spire.macros.Syntax.cforRangeMacro.strideUpTo.fromExpr" title="c.universe.Tree">fromExpr</a>
      val $<a href="#spire.macros.Syntax.cforRangeMacro.end" title="util.c.universe.TermName">end</a>: Int = $<a href="#spire.macros.Syntax.cforRangeMacro.strideUpTo.toExpr" title="c.universe.Tree">toExpr</a>
      while ($<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a> &lt;= $<a href="#spire.macros.Syntax.cforRangeMacro.end" title="util.c.universe.TermName">end</a>) {
        $<a href="#spire.macros.Syntax.cforRangeMacro.body" title="c.Expr[Int =&gt; Unit]">body</a>($<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a>)
        $<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a> += $<a href="#spire.macros.Syntax.cforRangeMacro.strideUpTo.stride" title="Int">stride</a><span class="string">
      }&quot;&quot;&quot;</span>

    def <a title="(fromExpr: c.universe.Tree, untilExpr: c.universe.Tree, stride: Int)c.universe.Tree" id="spire.macros.Syntax.cforRangeMacro.strideUpUntil">strideUpUntil</a><span class="delimiter">(</span><a title="c.universe.Tree" id="spire.macros.Syntax.cforRangeMacro.strideUpUntil.fromExpr">fromExpr</a>: <span title="c.universe.Tree">Tree</span>, <a title="c.universe.Tree" id="spire.macros.Syntax.cforRangeMacro.strideUpUntil.untilExpr">untilExpr</a>: <span title="c.universe.Tree">Tree</span>, <a title="Int" id="spire.macros.Syntax.cforRangeMacro.strideUpUntil.stride">stride</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="c.universe.Tree">Tree</span> =
      <a href="#spire.macros.Syntax.cforRangeMacro.c" title="c.universe.TermName" id="spire.macros.Syntax.cforRangeMacro.strideUpUntil.nn$macro$135">q</a>&quot;&quot;&quot;
      var $<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a>: Int = $<a href="#spire.macros.Syntax.cforRangeMacro.strideUpUntil.fromExpr" title="c.universe.Tree">fromExpr</a>
      val $<a href="#spire.macros.Syntax.cforRangeMacro.limit" title="util.c.universe.TermName">limit</a>: Int = $<a href="#spire.macros.Syntax.cforRangeMacro.strideUpUntil.untilExpr" title="c.universe.Tree">untilExpr</a>
      while ($<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a> &lt; $<a href="#spire.macros.Syntax.cforRangeMacro.limit" title="util.c.universe.TermName">limit</a>) {
        $<a href="#spire.macros.Syntax.cforRangeMacro.body" title="c.Expr[Int =&gt; Unit]">body</a>($<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a>)
        $<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a> += $<a href="#spire.macros.Syntax.cforRangeMacro.strideUpUntil.stride" title="Int">stride</a><span class="string">
      }&quot;&quot;&quot;</span>

    def <a title="(fromExpr: c.universe.Tree, toExpr: c.universe.Tree, stride: Int)c.universe.Tree" id="spire.macros.Syntax.cforRangeMacro.strideDownTo">strideDownTo</a><span class="delimiter">(</span><a title="c.universe.Tree" id="spire.macros.Syntax.cforRangeMacro.strideDownTo.fromExpr">fromExpr</a>: <span title="c.universe.Tree">Tree</span>, <a title="c.universe.Tree" id="spire.macros.Syntax.cforRangeMacro.strideDownTo.toExpr">toExpr</a>: <span title="c.universe.Tree">Tree</span>, <a title="Int" id="spire.macros.Syntax.cforRangeMacro.strideDownTo.stride">stride</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="c.universe.Tree">Tree</span> =
      <a href="#spire.macros.Syntax.cforRangeMacro.c" title="c.universe.TermName" id="spire.macros.Syntax.cforRangeMacro.strideDownTo.nn$macro$146">q</a>&quot;&quot;&quot;
      var $<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a>: Int = $<a href="#spire.macros.Syntax.cforRangeMacro.strideDownTo.fromExpr" title="c.universe.Tree">fromExpr</a>
      val $<a href="#spire.macros.Syntax.cforRangeMacro.end" title="util.c.universe.TermName">end</a>: Int = $<a href="#spire.macros.Syntax.cforRangeMacro.strideDownTo.toExpr" title="c.universe.Tree">toExpr</a>
      while ($<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a> &gt;= $<a href="#spire.macros.Syntax.cforRangeMacro.end" title="util.c.universe.TermName">end</a>) {
        $<a href="#spire.macros.Syntax.cforRangeMacro.body" title="c.Expr[Int =&gt; Unit]">body</a>($<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a>)
        $<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a> -= $<a href="#spire.macros.Syntax.cforRangeMacro.strideDownTo.stride" title="Int">stride</a><span class="string">
      }&quot;&quot;&quot;</span>

    def <a title="(fromExpr: c.universe.Tree, untilExpr: c.universe.Tree, stride: Int)c.universe.Tree" id="spire.macros.Syntax.cforRangeMacro.strideDownUntil">strideDownUntil</a><span class="delimiter">(</span><a title="c.universe.Tree" id="spire.macros.Syntax.cforRangeMacro.strideDownUntil.fromExpr">fromExpr</a>: <span title="c.universe.Tree">Tree</span>, <a title="c.universe.Tree" id="spire.macros.Syntax.cforRangeMacro.strideDownUntil.untilExpr">untilExpr</a>: <span title="c.universe.Tree">Tree</span>, <a title="Int" id="spire.macros.Syntax.cforRangeMacro.strideDownUntil.stride">stride</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="c.universe.Tree">Tree</span> =
      <a href="#spire.macros.Syntax.cforRangeMacro.c" title="c.universe.TermName" id="spire.macros.Syntax.cforRangeMacro.strideDownUntil.nn$macro$157">q</a>&quot;&quot;&quot;
      var $<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a>: Int = $<a href="#spire.macros.Syntax.cforRangeMacro.strideDownUntil.fromExpr" title="c.universe.Tree">fromExpr</a>
      val $<a href="#spire.macros.Syntax.cforRangeMacro.limit" title="util.c.universe.TermName">limit</a>: Int = $<a href="#spire.macros.Syntax.cforRangeMacro.strideDownUntil.untilExpr" title="c.universe.Tree">untilExpr</a>
      while ($<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a> &gt; $<a href="#spire.macros.Syntax.cforRangeMacro.limit" title="util.c.universe.TermName">limit</a>) {
        $<a href="#spire.macros.Syntax.cforRangeMacro.body" title="c.Expr[Int =&gt; Unit]">body</a>($<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a>)
        $<a href="#spire.macros.Syntax.cforRangeMacro.index" title="util.c.universe.TermName">index</a> -= $<a href="#spire.macros.Syntax.cforRangeMacro.strideDownUntil.stride" title="Int">stride</a><span class="string">
      }&quot;&quot;&quot;</span>

    val <a title="c.universe.Tree" id="spire.macros.Syntax.cforRangeMacro.tree">tree</a>: <span title="c.universe.Tree">Tree</span> = <a href="#spire.macros.Syntax.cforRangeMacro.r" title="c.Expr[Range]">r</a>.<span title="=&gt; c.universe.Tree">tree</span> match <span class="delimiter">{</span>

      case <a title="(val tree: Any)Option[(c.universe.Tree, c.universe.Tree)]" id="spire.macros.Syntax.cforRangeMacro.tree;$anon.unapply.qq$e45ccc2f$macro$159">q</a>&quot;scala.this.Predef.intWrapper($<span title="c.universe.Tree">i</span>).until($<span title="c.universe.Tree">j</span><span class="string">)&quot;</span> =&gt;
        <a href="#spire.macros.Syntax.cforRangeMacro.strideUpUntil" title="(fromExpr: c.universe.Tree, untilExpr: c.universe.Tree, stride: Int)c.universe.Tree">strideUpUntil</a><span class="delimiter">(</span><span title="c.universe.Tree">i</span>, <span title="c.universe.Tree">j</span>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

      case <a title="(val tree: Any)Option[(c.universe.Tree, c.universe.Tree)]" id="spire.macros.Syntax.cforRangeMacro.tree;$anon.unapply.qq$43ad97e9$macro$161">q</a>&quot;scala.this.Predef.intWrapper($<span title="c.universe.Tree">i</span>).to($<span title="c.universe.Tree">j</span><span class="string">)&quot;</span> =&gt;
        <a href="#spire.macros.Syntax.cforRangeMacro.strideUpTo" title="(fromExpr: c.universe.Tree, toExpr: c.universe.Tree, stride: Int)c.universe.Tree">strideUpTo</a><span class="delimiter">(</span><span title="c.universe.Tree">i</span>, <span title="c.universe.Tree">j</span>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

      case <span title="c.universe.Tree">r</span> @ <a title="(val tree: Any)Option[(c.universe.Tree, c.universe.Tree, c.universe.Tree)]" id="spire.macros.Syntax.cforRangeMacro.tree;$anon.unapply.qq$4f96c43e$macro$164">q</a>&quot;scala.this.Predef.intWrapper($<span title="c.universe.Tree">i</span>).until($<span title="c.universe.Tree">j</span>).by($<span title="c.universe.Tree">step</span><span class="string">)&quot;</span> =&gt;
        <a href="#spire.macros.Syntax.cforRangeMacro.isLiteral" title="(t: c.universe.Tree)Option[Int]">isLiteral</a><span class="delimiter">(</span><span title="c.universe.Tree">step</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><span title="Int">k</span><span class="delimiter">)</span> if <span title="Int">k</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> =&gt; <a href="#spire.macros.Syntax.cforRangeMacro.strideUpUntil" title="(fromExpr: c.universe.Tree, untilExpr: c.universe.Tree, stride: Int)c.universe.Tree">strideUpUntil</a><span class="delimiter">(</span><span title="c.universe.Tree">i</span>, <span title="c.universe.Tree">j</span>, <span title="Int">k</span><span class="delimiter">)</span>
          case Some<span class="delimiter">(</span><span title="Int">k</span><span class="delimiter">)</span> if <span title="Int">k</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> =&gt; <a href="#spire.macros.Syntax.cforRangeMacro.strideDownUntil" title="(fromExpr: c.universe.Tree, untilExpr: c.universe.Tree, stride: Int)c.universe.Tree">strideDownUntil</a><span class="delimiter">(</span><span title="c.universe.Tree">i</span>, <span title="c.universe.Tree">j</span>, <span title="=&gt; Int">-</span><span title="Int">k</span><span class="delimiter">)</span>
          case Some<span class="delimiter">(</span><span title="Int">k</span><span class="delimiter">)</span> if <span title="Int">k</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span> =&gt;
            <a href="#spire.macros.Syntax.cforRangeMacro.c" title="spire.macros.compat.Context">c</a>.<span title="(pos: c.Position, msg: String)Unit">error</span><span class="delimiter">(</span><a href="#spire.macros.Syntax.cforRangeMacro.c" title="spire.macros.compat.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;zero stride&quot;)" class="string">&quot;zero stride&quot;</span><span class="delimiter">)</span>
            <a href="#spire.macros.Syntax.cforRangeMacro.c" title="(value: c.universe.Constant)c.universe.Literal">q</a>&quot;<span class="string">()&quot;</span>
          case <span title="None.type">None</span> =&gt;
            <a href="#spire.macros.Syntax.cforRangeMacro.c" title="spire.macros.compat.Context">c</a>.<span title="(pos: c.Position, msg: String, force: Boolean)Unit">info</span><span class="delimiter">(</span><a href="#spire.macros.Syntax.cforRangeMacro.c" title="spire.macros.compat.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;non-literal stride&quot;)" class="string">&quot;non-literal stride&quot;</span>, true<span class="delimiter">)</span>
            <a href="#spire.macros.Syntax.cforRangeMacro.c" title="(tree: c.universe.Tree, argss: List[List[c.universe.Tree]])c.universe.Tree">q</a>&quot;$<span title="c.universe.Tree">r</span>.foreach($<a href="#spire.macros.Syntax.cforRangeMacro.body" title="c.Expr[Int =&gt; Unit]">body</a><span class="string">)&quot;</span>
        <span class="delimiter">}</span>

      case <span title="c.universe.Tree">r</span> @ <a title="(val tree: Any)Option[(c.universe.Tree, c.universe.Tree, c.universe.Tree)]" id="spire.macros.Syntax.cforRangeMacro.tree;$anon.unapply.qq$41829486$macro$169">q</a>&quot;scala.this.Predef.intWrapper($<span title="c.universe.Tree">i</span>).to($<span title="c.universe.Tree">j</span>).by($<span title="c.universe.Tree">step</span><span class="string">)&quot;</span> =&gt;
        <a href="#spire.macros.Syntax.cforRangeMacro.isLiteral" title="(t: c.universe.Tree)Option[Int]">isLiteral</a><span class="delimiter">(</span><span title="c.universe.Tree">step</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><span title="Int">k</span><span class="delimiter">)</span> if <span title="Int">k</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> =&gt; <a href="#spire.macros.Syntax.cforRangeMacro.strideUpTo" title="(fromExpr: c.universe.Tree, toExpr: c.universe.Tree, stride: Int)c.universe.Tree">strideUpTo</a><span class="delimiter">(</span><span title="c.universe.Tree">i</span>, <span title="c.universe.Tree">j</span>, <span title="Int">k</span><span class="delimiter">)</span>
          case Some<span class="delimiter">(</span><span title="Int">k</span><span class="delimiter">)</span> if <span title="Int">k</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> =&gt; <a href="#spire.macros.Syntax.cforRangeMacro.strideDownTo" title="(fromExpr: c.universe.Tree, toExpr: c.universe.Tree, stride: Int)c.universe.Tree">strideDownTo</a><span class="delimiter">(</span><span title="c.universe.Tree">i</span>, <span title="c.universe.Tree">j</span>, <span title="=&gt; Int">-</span><span title="Int">k</span><span class="delimiter">)</span>
          case Some<span class="delimiter">(</span><span title="Int">k</span><span class="delimiter">)</span> if <span title="Int">k</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span> =&gt;
            <a href="#spire.macros.Syntax.cforRangeMacro.c" title="spire.macros.compat.Context">c</a>.<span title="(pos: c.Position, msg: String)Unit">error</span><span class="delimiter">(</span><a href="#spire.macros.Syntax.cforRangeMacro.c" title="spire.macros.compat.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;zero stride&quot;)" class="string">&quot;zero stride&quot;</span><span class="delimiter">)</span>
            <a href="#spire.macros.Syntax.cforRangeMacro.c" title="(value: c.universe.Constant)c.universe.Literal">q</a>&quot;<span class="string">()&quot;</span>
          case <span title="None.type">None</span> =&gt;
            <a href="#spire.macros.Syntax.cforRangeMacro.c" title="spire.macros.compat.Context">c</a>.<span title="(pos: c.Position, msg: String, force: Boolean)Unit">info</span><span class="delimiter">(</span><a href="#spire.macros.Syntax.cforRangeMacro.c" title="spire.macros.compat.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;non-literal stride&quot;)" class="string">&quot;non-literal stride&quot;</span>, true<span class="delimiter">)</span>
            <a href="#spire.macros.Syntax.cforRangeMacro.c" title="(tree: c.universe.Tree, argss: List[List[c.universe.Tree]])c.universe.Tree">q</a>&quot;$<span title="c.universe.Tree">r</span>.foreach($<a href="#spire.macros.Syntax.cforRangeMacro.body" title="c.Expr[Int =&gt; Unit]">body</a><span class="string">)&quot;</span>
        <span class="delimiter">}</span>

      case <span title="c.universe.Tree">r</span> =&gt;
        <a href="#spire.macros.Syntax.cforRangeMacro.c" title="spire.macros.compat.Context">c</a>.<span title="(pos: c.Position, msg: String, force: Boolean)Unit">info</span><span class="delimiter">(</span><a href="#spire.macros.Syntax.cforRangeMacro.c" title="spire.macros.compat.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;non-literal range&quot;)" class="string">&quot;non-literal range&quot;</span>, true<span class="delimiter">)</span>
        <a href="#spire.macros.Syntax.cforRangeMacro.c" title="(tree: c.universe.Tree, argss: List[List[c.universe.Tree]])c.universe.Tree">q</a>&quot;$<span title="c.universe.Tree">r</span>.foreach($<a href="#spire.macros.Syntax.cforRangeMacro.body" title="c.Expr[Int =&gt; Unit]">body</a><span class="string">)&quot;</span>
    <span class="delimiter">}</span>

    new <a href="#spire.macros;InlineUtil" title="spire.macros.InlineUtil[c.type]">InlineUtil</a><span class="delimiter">[</span>c.type<span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.macros.Syntax.cforRangeMacro.c" title="spire.macros.compat.Context">c</a><span class="delimiter">)</span>.<a href="#spire.macros;InlineUtil.inlineAndReset" title="([T](tree: _445.c.universe.Tree)_445.c.universe.Expr[T]) forSome { val _445: spire.macros.InlineUtil[c.type] }">inlineAndReset</a><span title="(tree: _80.c.universe.Tree)_80.c.universe.Expr[Unit]" class="delimiter">[</span><span title="Unit">Unit</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.macros.Syntax.cforRangeMacro.tree" title="c.universe.Tree">tree</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(c: spire.macros.compat.Context)(r1: c.Expr[Range], r2: c.Expr[Range])(body: c.Expr[(Int, Int) =&gt; Unit])c.Expr[Unit]" id="spire.macros.Syntax.cforRange2Macro">cforRange2Macro</a><span class="delimiter">(</span><a title="spire.macros.compat.Context" id="spire.macros.Syntax.cforRange2Macro.c">c</a>: <span title="spire.macros.compat.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[Range]" id="spire.macros.Syntax.cforRange2Macro.r1">r1</a>: c.<span title="c.Expr[Range]">Expr</span><span class="delimiter">[</span>Range<span class="delimiter">]</span>, <a title="c.Expr[Range]" id="spire.macros.Syntax.cforRange2Macro.r2">r2</a>: c.<span title="c.Expr[Range]">Expr</span><span class="delimiter">[</span>Range<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="delimiter">(</span><a title="c.Expr[(Int, Int) =&gt; Unit]" id="spire.macros.Syntax.cforRange2Macro.body">body</a>: c.<span title="c.Expr[(Int, Int) =&gt; Unit]">Expr</span><span class="delimiter">[</span><span class="delimiter">(</span>Int, Int<span class="delimiter">)</span> =&gt; Unit<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[Unit]">Expr</span><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <span class="delimiter">{</span>

    import <a href="#spire.macros.Syntax.cforRange2Macro.c" title="spire.macros.compat.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
    <a href="#spire.macros.Syntax.cforRange2Macro.c" title="spire.macros.compat.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[Unit])c.Expr[Unit]" class="delimiter">[</span><span title="Unit">Unit</span><span class="delimiter">]</span><a href="#spire.macros.Syntax.cforRange2Macro.c" title="=&gt; c.universe.WeakTypeTag[Unit]" class="delimiter">(</a><a href="#spire.macros.Syntax.cforRange2Macro.c" title="(tree: c.universe.Tree, argss: List[List[c.universe.Tree]])c.universe.Tree">q</a>&quot;cforRange($<a href="#spire.macros.Syntax.cforRange2Macro.r1" title="c.Expr[Range]">r1</a>)(i =&gt; cforRange($<a href="#spire.macros.Syntax.cforRange2Macro.r2" title="c.Expr[Range]">r2</a>)(j =&gt; $<a href="#spire.macros.Syntax.cforRange2Macro.body" title="c.Expr[(Int, Int) =&gt; Unit]">body</a><span class="string">(i, j)))&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
