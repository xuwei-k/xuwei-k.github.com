<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>spire/spire/math/Interval.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package spire.math

import <span title="type">Predef</span>.<span class="delimiter">{</span>any2stringadd =&gt; _, _<span class="delimiter">}</span>

import spire.algebra._
import spire.math.poly.Term
import spire.math.interval._
import spire.math.interval.<a href="interval/Bound.scala.html#spire.math.interval.Bound" title="spire.math.interval.Bound.type">Bound</a>._
import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.field" title="spire.syntax.field.type">field</a>._
import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.nroot" title="spire.syntax.nroot.type">nroot</a>._
import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.order" title="spire.syntax.order.type">order</a>._

import java.lang.<span title="Double.type">Double</span>.isNaN

<span class="comment">/**
 * Interval represents a set of values, usually numbers.
 * 
 * Intervals have upper and lower bounds. Each bound can be one of
 * four kinds:
 * 
 *  * Closed: The boundary value is included in the interval.
 *  * Open: The boundary value is excluded from the interval.
 *  * Unbound: There is no boundary value.
 *  * Empty: The interval itself is empty.
 *
 * When the underlying type of the interval supports it, intervals may
 * be used in arithmetic. There are several possible interpretations
 * of interval arithmetic: the interval can represent uncertainty
 * about a single value (for instance, a quantity +/- tolerance in
 * engineering) or it can represent all values in the interval
 * simultaneously. In this implementation we have chosen to use the
 * probabillistic interpretation.
 *
 * One common pitfall with interval arithmetic is that many familiar
 * algebraic relations do not hold. For instance, given two intervals
 * a and b:
 * 
 *   a == b does not imply a * a == a * b
 *
 * Consider a = b = [-1, 1]. Since any number times itself is
 * non-negative, a * a = [0, 1]. However, a * b = [-1, 1], since we
 * may actually have a=1 and b=-1.
 *
 * These situations will result in loss of precision (in the form of
 * wider intervals). The result is not wrong per se, but less
 * acccurate than it could be.
 */</span>
sealed abstract class <a title="class Interval[A] extends AnyRef" id="spire.math;Interval">Interval</a><span class="delimiter">[</span><a title="" id="spire.math;Interval;A">A</a><span class="delimiter">]</span><a href="#spire.math;Interval" title="spire.math.Interval[A]" class="delimiter">(</a>implicit <a title="spire.algebra.Order[A]" id="spire.math;Interval.order">order</a>: <a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span> lhs =&gt;

  @inline protected<span class="delimiter">[</span>this<span class="delimiter">]</span> final def <a title="(flags: Int)Boolean" id="spire.math;Interval.isClosed">isClosed</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.isClosed.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Interval.isClosed.flags" title="Int">flags</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span>
  @inline protected<span class="delimiter">[</span>this<span class="delimiter">]</span> final def <a title="(flags: Int)Boolean" id="spire.math;Interval.isClosedLower">isClosedLower</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.isClosedLower.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#spire.math;Interval.isClosedLower.flags" title="Int">flags</a> <span title="(x: Int)Int">&amp;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span>
  @inline protected<span class="delimiter">[</span>this<span class="delimiter">]</span> final def <a title="(flags: Int)Boolean" id="spire.math;Interval.isClosedUpper">isClosedUpper</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.isClosedUpper.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#spire.math;Interval.isClosedUpper.flags" title="Int">flags</a> <span title="(x: Int)Int">&amp;</span> <span title="Int(2)" class="int">2</span><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span>

  @inline protected<span class="delimiter">[</span>this<span class="delimiter">]</span> final def <a title="(flags: Int)Boolean" id="spire.math;Interval.isOpen">isOpen</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.isOpen.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Interval.isOpen.flags" title="Int">flags</a> <span title="(x: Int)Boolean">==</span> <span title="Int(3)" class="int">3</span>
  @inline protected<span class="delimiter">[</span>this<span class="delimiter">]</span> final def <a title="(flags: Int)Boolean" id="spire.math;Interval.isOpenLower">isOpenLower</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.isOpenLower.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#spire.math;Interval.isOpenLower.flags" title="Int">flags</a> <span title="(x: Int)Int">&amp;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span>
  @inline protected<span class="delimiter">[</span>this<span class="delimiter">]</span> final def <a title="(flags: Int)Boolean" id="spire.math;Interval.isOpenUpper">isOpenUpper</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.isOpenUpper.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#spire.math;Interval.isOpenUpper.flags" title="Int">flags</a> <span title="(x: Int)Int">&amp;</span> <span title="Int(2)" class="int">2</span><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(2)" class="int">2</span>

  @inline protected<span class="delimiter">[</span>this<span class="delimiter">]</span> final def <a title="(flags: Int)Int" id="spire.math;Interval.lowerFlag">lowerFlag</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.lowerFlag.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.math;Interval.lowerFlag.flags" title="Int">flags</a> <span title="(x: Int)Int">&amp;</span> <span title="Int(1)" class="int">1</span>
  @inline protected<span class="delimiter">[</span>this<span class="delimiter">]</span> final def <a title="(flags: Int)Int" id="spire.math;Interval.upperFlag">upperFlag</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.upperFlag.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.math;Interval.upperFlag.flags" title="Int">flags</a> <span title="(x: Int)Int">&amp;</span> <span title="Int(2)" class="int">2</span>

  @inline protected<span class="delimiter">[</span>this<span class="delimiter">]</span> final def <a title="(flags: Int)Int" id="spire.math;Interval.reverseLowerFlag">reverseLowerFlag</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.reverseLowerFlag.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.math;Interval.reverseLowerFlag.flags" title="Int">flags</a> <span title="(x: Int)Int">^</span> <span title="Int(1)" class="int">1</span>
  @inline protected<span class="delimiter">[</span>this<span class="delimiter">]</span> final def <a title="(flags: Int)Int" id="spire.math;Interval.reverseUpperFlag">reverseUpperFlag</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.reverseUpperFlag.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.math;Interval.reverseUpperFlag.flags" title="Int">flags</a> <span title="(x: Int)Int">^</span> <span title="Int(2)" class="int">2</span>
  @inline protected<span class="delimiter">[</span>this<span class="delimiter">]</span> final def <a title="(flags: Int)Int" id="spire.math;Interval.reverseFlags">reverseFlags</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.reverseFlags.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.math;Interval.reverseFlags.flags" title="Int">flags</a> <span title="(x: Int)Int">^</span> <span title="Int(3)" class="int">3</span>

  protected<span class="delimiter">[</span>this<span class="delimiter">]</span> final def <a title="(flags: Int)Int" id="spire.math;Interval.lowerFlagToUpper">lowerFlagToUpper</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.lowerFlagToUpper.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">(</span><a href="#spire.math;Interval.lowerFlagToUpper.flags" title="Int">flags</a> <span title="(x: Int)Int">&amp;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Int)Int">&lt;&lt;</span> <span title="Int(1)" class="int">1</span>
  protected<span class="delimiter">[</span>this<span class="delimiter">]</span> final def <a title="(flags: Int)Int" id="spire.math;Interval.upperFlagToLower">upperFlagToLower</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.upperFlagToLower.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">(</span><a href="#spire.math;Interval.upperFlagToLower.flags" title="Int">flags</a> <span title="(x: Int)Int">&amp;</span> <span title="Int(2)" class="int">2</span><span class="delimiter">)</span> <span title="(x: Int)Int">&gt;&gt;&gt;</span> <span title="Int(1)" class="int">1</span>

  @inline protected<span class="delimiter">[</span>this<span class="delimiter">]</span> final def <a title="(flags: Int)Int" id="spire.math;Interval.swapFlags">swapFlags</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.swapFlags.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> =
    <span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math;Interval.swapFlags.flags" title="Int">flags</a> <span title="(x: Int)Int">&amp;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Int)Int">&lt;&lt;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Int)Int">|</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math;Interval.swapFlags.flags" title="Int">flags</a> <span title="(x: Int)Int">&amp;</span> <span title="Int(2)" class="int">2</span><span class="delimiter">)</span> <span title="(x: Int)Int">&gt;&gt;&gt;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

  protected<span class="delimiter">[</span>this<span class="delimiter">]</span> def <a title="(lower1: A, flags1: Int, lower2: A, flags2: Int)Boolean" id="spire.math;Interval.lowerPairBelow">lowerPairBelow</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.lowerPairBelow.lower1">lower1</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="Int" id="spire.math;Interval.lowerPairBelow.flags1">flags1</a>: <span title="Int">Int</span>, <a title="A" id="spire.math;Interval.lowerPairBelow.lower2">lower2</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="Int" id="spire.math;Interval.lowerPairBelow.flags2">flags2</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower1</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math;Interval.lowerPairBelow.lower2" title="A">lower2</a> <span title="(x: Boolean)Boolean">||</span> <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower1</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: A, y: A)Boolean">===</a> <a href="#spire.math;Interval.lowerPairBelow.lower2" title="A">lower2</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#spire.math;Interval.isClosedLower" title="(flags: Int)Boolean">isClosedLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.lowerPairBelow.flags1" title="Int">flags1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#spire.math;Interval.isOpenLower" title="(flags: Int)Boolean">isOpenLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.lowerPairBelow.flags2" title="Int">flags2</a><span class="delimiter">)</span><span class="delimiter">)</span>

  protected<span class="delimiter">[</span>this<span class="delimiter">]</span> def <a title="(upper1: A, flags1: Int, upper2: A, flags2: Int)Boolean" id="spire.math;Interval.upperPairAbove">upperPairAbove</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.upperPairAbove.upper1">upper1</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="Int" id="spire.math;Interval.upperPairAbove.flags1">flags1</a>: <span title="Int">Int</span>, <a title="A" id="spire.math;Interval.upperPairAbove.upper2">upper2</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="Int" id="spire.math;Interval.upperPairAbove.flags2">flags2</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper1</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <a href="#spire.math;Interval.upperPairAbove.upper2" title="A">upper2</a> <span title="(x: Boolean)Boolean">||</span> <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper1</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: A, y: A)Boolean">===</a> <a href="#spire.math;Interval.upperPairAbove.upper2" title="A">upper2</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#spire.math;Interval.isClosedUpper" title="(flags: Int)Boolean">isClosedUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.upperPairAbove.flags1" title="Int">flags1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#spire.math;Interval.isOpenUpper" title="(flags: Int)Boolean">isOpenUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.upperPairAbove.flags2" title="Int">flags2</a><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="=&gt; Boolean" id="spire.math;Interval.isEmpty">isEmpty</a>: <span title="Boolean">Boolean</span> =
    this.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#spire.math.Empty.readResolve" title="spire.math.Empty[_]">Empty</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>

  def <a title="=&gt; Boolean" id="spire.math;Interval.nonEmpty">nonEmpty</a>: <span title="Boolean">Boolean</span> =
    <span title="=&gt; Boolean">!</span><a href="#spire.math;Interval.isEmpty" title="=&gt; Boolean">isEmpty</a>

  def <a title="=&gt; Boolean" id="spire.math;Interval.isPoint">isPoint</a>: <span title="Boolean">Boolean</span> =
    this.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#spire.math.Point.readResolve" title="spire.math.Point[_]">Point</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>

  def <a title="(t: A)Boolean" id="spire.math;Interval.contains">contains</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.contains.t">t</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#spire.math;Interval.hasAtOrBelow" title="(t: A)Boolean">hasAtOrBelow</a><span class="delimiter">(</span><a href="#spire.math;Interval.contains.t" title="A">t</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Interval.hasAtOrAbove" title="(t: A)Boolean">hasAtOrAbove</a><span class="delimiter">(</span><a href="#spire.math;Interval.contains.t" title="A">t</a><span class="delimiter">)</span>

  def <a title="(t: A)Boolean" id="spire.math;Interval.doesNotContain">doesNotContain</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.doesNotContain.t">t</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <span title="=&gt; Boolean">!</span><a href="#spire.math;Interval.hasAtOrBelow" title="(t: A)Boolean">hasAtOrBelow</a><span class="delimiter">(</span><a href="#spire.math;Interval.doesNotContain.t" title="A">t</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#spire.math;Interval.hasAtOrAbove" title="(t: A)Boolean">hasAtOrAbove</a><span class="delimiter">(</span><a href="#spire.math;Interval.doesNotContain.t" title="A">t</a><span class="delimiter">)</span>

  def <a title="(t: A)Boolean" id="spire.math;Interval.crosses">crosses</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.crosses.t">t</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#spire.math;Interval.hasBelow" title="(t: A)Boolean">hasBelow</a><span class="delimiter">(</span><a href="#spire.math;Interval.crosses.t" title="A">t</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Interval.hasAbove" title="(t: A)Boolean">hasAbove</a><span class="delimiter">(</span><a href="#spire.math;Interval.crosses.t" title="A">t</a><span class="delimiter">)</span>

  def <a title="(implicit ev: spire.algebra.AdditiveMonoid[A])Boolean" id="spire.math;Interval.crossesZero">crossesZero</a><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveMonoid[A]" id="spire.math;Interval.crossesZero.ev">ev</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#spire.math;Interval.hasBelow" title="(t: A)Boolean">hasBelow</a><span class="delimiter">(</span><a href="#spire.math;Interval.crossesZero.ev" title="spire.algebra.AdditiveMonoid[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Interval.hasAbove" title="(t: A)Boolean">hasAbove</a><span class="delimiter">(</span><a href="#spire.math;Interval.crossesZero.ev" title="spire.algebra.AdditiveMonoid[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span>

  def <a title="=&gt; Boolean" id="spire.math;Interval.isBounded">isBounded</a>: <span title="Boolean">Boolean</span> =
    this match <span class="delimiter">{</span>
      case Below<span class="delimiter">(</span>_, _<span class="delimiter">)</span> | Above<span class="delimiter">(</span>_, _<span class="delimiter">)</span> | All<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; true
      case _ =&gt; false
    <span class="delimiter">}</span>

  def <a title="=&gt; spire.math.interval.Bound[A]" id="spire.math;Interval.lowerBound">lowerBound</a>: <a href="interval/Bound.scala.html#spire.math.interval;Bound" title="spire.math.interval.Bound[A]">Bound</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  def <a title="=&gt; spire.math.interval.Bound[A]" id="spire.math;Interval.upperBound">upperBound</a>: <a href="interval/Bound.scala.html#spire.math.interval;Bound" title="spire.math.interval.Bound[A]">Bound</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  def <a title="[B](f: A =&gt; B)(implicit evidence$1: spire.algebra.Order[B])spire.math.Interval[B]" id="spire.math;Interval.mapBounds">mapBounds</a><span class="delimiter">[</span><a title="" id="spire.math;Interval.mapBounds;B">B</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="spire.math;Interval.mapBounds.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[B]">Interval</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =
    <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.fromBounds" title="(lower: spire.math.interval.Bound[B], upper: spire.math.interval.Bound[B])(implicit evidence$13: spire.algebra.Order[B])spire.math.Interval[B]">fromBounds</a><a href="#spire.math;Interval.mapBounds.evidence$1" title="spire.algebra.Order[B]" class="delimiter">(</a><a href="#spire.math;Interval.lowerBound" title="=&gt; spire.math.interval.Bound[A]">lowerBound</a>.<a href="interval/Bound.scala.html#spire.math.interval;Bound.map" title="(f: A =&gt; B)spire.math.interval.Bound[B]">map</a><span class="delimiter">(</span><a href="#spire.math;Interval.mapBounds.f" title="A =&gt; B">f</a><span class="delimiter">)</span>, <a href="#spire.math;Interval.upperBound" title="=&gt; spire.math.interval.Bound[A]">upperBound</a>.<a href="interval/Bound.scala.html#spire.math.interval;Bound.map" title="(f: A =&gt; B)spire.math.interval.Bound[B]">map</a><span class="delimiter">(</span><a href="#spire.math;Interval.mapBounds.f" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="[B](f: (spire.math.interval.Bound[A], spire.math.interval.Bound[A]) =&gt; B)B" id="spire.math;Interval.fold">fold</a><span class="delimiter">[</span><a title="" id="spire.math;Interval.fold;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(spire.math.interval.Bound[A], spire.math.interval.Bound[A]) =&gt; B" id="spire.math;Interval.fold.f">f</a>: <span class="delimiter">(</span>Bound<span class="delimiter">[</span>A<span class="delimiter">]</span>, Bound<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#spire.math;Interval.fold;B" title="B">B</a> =
    <a href="#spire.math;Interval.fold.f" title="(v1: spire.math.interval.Bound[A], v2: spire.math.interval.Bound[A])B">f</a><span class="delimiter">(</span><a href="#spire.math;Interval.lowerBound" title="=&gt; spire.math.interval.Bound[A]">lowerBound</a>, <a href="#spire.math;Interval.upperBound" title="=&gt; spire.math.interval.Bound[A]">upperBound</a><span class="delimiter">)</span>

  def <a title="(rhs: spire.math.Interval[A])Boolean" id="spire.math;Interval.isSupersetOf">isSupersetOf</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.isSupersetOf.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="(_1: spire.math.Interval[A], _2: spire.math.Interval[A])(spire.math.Interval[A], spire.math.Interval[A])" class="delimiter">(</span><a href="#spire.math;Interval" title="spire.math.Interval[A]">lhs</a>, <a href="#spire.math;Interval.isSupersetOf.rhs" title="spire.math.Interval[A]">rhs</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
    <span class="comment">// deal with All, Empty and Point on either left or right side</span>

    case <span class="delimiter">(</span>All<span class="delimiter">(</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; true
    case <span class="delimiter">(</span>_, All<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; false

    case <span class="delimiter">(</span>_, Empty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; true
    case <span class="delimiter">(</span>Empty<span class="delimiter">(</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; false

    case <span class="delimiter">(</span>Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.isSupersetOf.lhsval">lhsval</a><span class="delimiter">)</span>, Point<span class="delimiter">(</span><span title="A">rhsval</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lhsval</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: A, y: A)Boolean">===</a> <span title="A">rhsval</span>
    case <span class="delimiter">(</span>Point<span class="delimiter">(</span>_<span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; false <span class="comment">// rhs cannot be Empty or Point</span>
    case <span class="delimiter">(</span>_, Point<span class="delimiter">(</span><span title="A">rhsval</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval" title="Interval.this.type">lhs</a>.<a href="#spire.math;Interval.contains" title="(t: A)Boolean">contains</a><span class="delimiter">(</span><span title="A">rhsval</span><span class="delimiter">)</span>

    <span class="comment">// remaining cases are Above, Below and Bounded, we deal first with the obvious false</span>

    case <span class="delimiter">(</span>Above<span class="delimiter">(</span>_, _<span class="delimiter">)</span>, Below<span class="delimiter">(</span>_, _<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; false
    case <span class="delimiter">(</span>Below<span class="delimiter">(</span>_, _<span class="delimiter">)</span>, Above<span class="delimiter">(</span>_, _<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; false
    case <span class="delimiter">(</span>Bounded<span class="delimiter">(</span>_, _, _<span class="delimiter">)</span>, Below<span class="delimiter">(</span>_, _<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; false
    case <span class="delimiter">(</span>Bounded<span class="delimiter">(</span>_, _, _<span class="delimiter">)</span>, Above<span class="delimiter">(</span>_, _<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; false

    case <span class="delimiter">(</span>Above<span class="delimiter">(</span><span title="A">lower1</span>, <span title="Int">flags1</span><span class="delimiter">)</span>, Bounded<span class="delimiter">(</span><span title="A">lower2</span>, _, <span title="Int">flags2</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
      <a href="#spire.math;Interval.lowerPairBelow" title="(lower1: A, flags1: Int, lower2: A, flags2: Int)Boolean">lowerPairBelow</a><span class="delimiter">(</span><span title="A">lower1</span>, <span title="Int">flags1</span>, <span title="A">lower2</span>, <span title="Int">flags2</span><span class="delimiter">)</span>
    case <span class="delimiter">(</span>Above<span class="delimiter">(</span><span title="A">lower1</span>, <span title="Int">flags1</span><span class="delimiter">)</span>, Above<span class="delimiter">(</span><span title="A">lower2</span>, <span title="Int">flags2</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
      <a href="#spire.math;Interval.lowerPairBelow" title="(lower1: A, flags1: Int, lower2: A, flags2: Int)Boolean">lowerPairBelow</a><span class="delimiter">(</span><span title="A">lower1</span>, <span title="Int">flags1</span>, <span title="A">lower2</span>, <span title="Int">flags2</span><span class="delimiter">)</span>

    case <span class="delimiter">(</span>Below<span class="delimiter">(</span><span title="A">upper1</span>, <span title="Int">flags1</span><span class="delimiter">)</span>, Below<span class="delimiter">(</span><span title="A">upper2</span>, <span title="Int">flags2</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
      <a href="#spire.math;Interval.upperPairAbove" title="(upper1: A, flags1: Int, upper2: A, flags2: Int)Boolean">upperPairAbove</a><span class="delimiter">(</span><span title="A">upper1</span>, <span title="Int">flags1</span>, <span title="A">upper2</span>, <span title="Int">flags2</span><span class="delimiter">)</span>
    case <span class="delimiter">(</span>Below<span class="delimiter">(</span><span title="A">upper1</span>, <span title="Int">flags1</span><span class="delimiter">)</span>, Bounded<span class="delimiter">(</span>_, <span title="A">upper2</span>, <span title="Int">flags2</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
      <a href="#spire.math;Interval.upperPairAbove" title="(upper1: A, flags1: Int, upper2: A, flags2: Int)Boolean">upperPairAbove</a><span class="delimiter">(</span><span title="A">upper1</span>, <span title="Int">flags1</span>, <span title="A">upper2</span>, <span title="Int">flags2</span><span class="delimiter">)</span>

    case <span class="delimiter">(</span>Bounded<span class="delimiter">(</span><span title="A">lower1</span>, <span title="A">upper1</span>, <span title="Int">flags1</span><span class="delimiter">)</span>, Bounded<span class="delimiter">(</span><span title="A">lower2</span>, <span title="A">upper2</span>, <span title="Int">flags2</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
      <a href="#spire.math;Interval.lowerPairBelow" title="(lower1: A, flags1: Int, lower2: A, flags2: Int)Boolean">lowerPairBelow</a><span class="delimiter">(</span><span title="A">lower1</span>, <span title="Int">flags1</span>, <span title="A">lower2</span>, <span title="Int">flags2</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <a href="#spire.math;Interval.upperPairAbove" title="(upper1: A, flags1: Int, upper2: A, flags2: Int)Boolean">upperPairAbove</a><span class="delimiter">(</span><span title="A">upper1</span>, <span title="Int">flags1</span>, <span title="A">upper2</span>, <span title="Int">flags2</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(rhs: spire.math.Interval[A])Boolean" id="spire.math;Interval.isProperSupersetOf">isProperSupersetOf</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.isProperSupersetOf.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#spire.math;Interval.isProperSupersetOf.rhs" title="spire.math.Interval[A]">rhs</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.isSupersetOf" title="(rhs: spire.math.Interval[A])Boolean">isSupersetOf</a> <a href="#spire.math;Interval.isProperSupersetOf.rhs" title="spire.math.Interval[A]">rhs</a><span class="delimiter">)</span>

  def <a title="(rhs: spire.math.Interval[A])Boolean" id="spire.math;Interval.isSubsetOf">isSubsetOf</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.isSubsetOf.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#spire.math;Interval.isSubsetOf.rhs" title="spire.math.Interval[A]">rhs</a> <a href="#spire.math;Interval.isSupersetOf" title="(rhs: spire.math.Interval[A])Boolean">isSupersetOf</a> <a href="#spire.math;Interval" title="spire.math.Interval[A]">lhs</a>

  def <a title="(rhs: spire.math.Interval[A])Boolean" id="spire.math;Interval.isProperSubsetOf">isProperSubsetOf</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.isProperSubsetOf.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#spire.math;Interval.isProperSubsetOf.rhs" title="spire.math.Interval[A]">rhs</a> <a href="#spire.math;Interval.isProperSupersetOf" title="(rhs: spire.math.Interval[A])Boolean">isProperSupersetOf</a> <a href="#spire.math;Interval" title="spire.math.Interval[A]">lhs</a>

  <span class="comment">// Does this interval contain any points above t ?</span>
  def <a title="(t: A)Boolean" id="spire.math;Interval.hasAbove">hasAbove</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.hasAbove.t">t</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = this match <span class="delimiter">{</span>
    case Empty<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; false
    case Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.hasAbove.p">p</a><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">p</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <a href="#spire.math;Interval.hasAbove.t" title="A">t</a>
    case Below<span class="delimiter">(</span><span title="A">upper</span>, _<span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <a href="#spire.math;Interval.hasAbove.t" title="A">t</a>
    case Bounded<span class="delimiter">(</span>_, <span title="A">upper</span>, _<span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <a href="#spire.math;Interval.hasAbove.t" title="A">t</a>
    case All<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; true
    case Above<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; true
  <span class="delimiter">}</span>

  <span class="comment">// Does this interval contain any points below t ?</span>
  def <a title="(t: A)Boolean" id="spire.math;Interval.hasBelow">hasBelow</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.hasBelow.t">t</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = this match <span class="delimiter">{</span>
    case Empty<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; false
    case Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.hasBelow.p">p</a><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">p</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math;Interval.hasBelow.t" title="A">t</a>
    case Above<span class="delimiter">(</span><span title="A">lower</span>, _<span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math;Interval.hasBelow.t" title="A">t</a>
    case Bounded<span class="delimiter">(</span><span title="A">lower</span>, _, _<span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math;Interval.hasBelow.t" title="A">t</a>
    case Below<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; true
    case All<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; true
  <span class="delimiter">}</span>

  <span class="comment">// Does this interval contains any points at or above t ?</span>
  def <a title="(t: A)Boolean" id="spire.math;Interval.hasAtOrAbove">hasAtOrAbove</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.hasAtOrAbove.t">t</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span> = this match <span class="delimiter">{</span>
    case _: <a href="#spire.math.Empty.readResolve" title="spire.math.Empty[_]">Empty</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; false
    case Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.hasAtOrAbove.p">p</a><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">p</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gteqv" title="(x: A, y: A)Boolean">&gt;=</a> <a href="#spire.math;Interval.hasAtOrAbove.t" title="A">t</a>
    case Below<span class="delimiter">(</span><span title="A">upper</span>, <span title="Int">flags</span><span class="delimiter">)</span> =&gt;
      <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <a href="#spire.math;Interval.hasAtOrAbove.t" title="A">t</a> <span title="(x: Boolean)Boolean">||</span> <a href="#spire.math;Interval.isClosedUpper" title="(flags: Int)Boolean">isClosedUpper</a><span class="delimiter">(</span><span title="Int">flags</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: A, y: A)Boolean">===</a> <a href="#spire.math;Interval.hasAtOrAbove.t" title="A">t</a>
    case Bounded<span class="delimiter">(</span><a title="A" id="spire.math;Interval.hasAtOrAbove.lower">lower</a>, <span title="A">upper</span>, <span title="Int">flags</span><span class="delimiter">)</span> =&gt;
      <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <a href="#spire.math;Interval.hasAtOrAbove.t" title="A">t</a> <span title="(x: Boolean)Boolean">||</span> <a href="#spire.math;Interval.isClosedUpper" title="(flags: Int)Boolean">isClosedUpper</a><span class="delimiter">(</span><span title="Int">flags</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: A, y: A)Boolean">===</a> <a href="#spire.math;Interval.hasAtOrAbove.t" title="A">t</a>
    case _: <a href="#spire.math.Above.readResolve" title="spire.math.Above[_]">Above</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; true
    case _: <a href="#spire.math.All.readResolve" title="spire.math.All[_]">All</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; true
  <span class="delimiter">}</span>

  <span class="comment">// Does this interval contains any points at or below t ?</span>
  def <a title="(t: A)Boolean" id="spire.math;Interval.hasAtOrBelow">hasAtOrBelow</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.hasAtOrBelow.t">t</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span> = this match <span class="delimiter">{</span>
    case _: <a href="#spire.math.Empty.readResolve" title="spire.math.Empty[_]">Empty</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; false
    case Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.hasAtOrBelow.p">p</a><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">p</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lteqv" title="(x: A, y: A)Boolean">&lt;=</a> <a href="#spire.math;Interval.hasAtOrBelow.t" title="A">t</a>
    case Above<span class="delimiter">(</span><span title="A">lower</span>, <span title="Int">flags</span><span class="delimiter">)</span> =&gt;
      <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math;Interval.hasAtOrBelow.t" title="A">t</a> <span title="(x: Boolean)Boolean">||</span> <a href="#spire.math;Interval.isClosedLower" title="(flags: Int)Boolean">isClosedLower</a><span class="delimiter">(</span><span title="Int">flags</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: A, y: A)Boolean">===</a> <a href="#spire.math;Interval.hasAtOrBelow.t" title="A">t</a>
    case Bounded<span class="delimiter">(</span><span title="A">lower</span>, <a title="A" id="spire.math;Interval.hasAtOrBelow.upper">upper</a>, <span title="Int">flags</span><span class="delimiter">)</span> =&gt;
      <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math;Interval.hasAtOrBelow.t" title="A">t</a> <span title="(x: Boolean)Boolean">||</span> <a href="#spire.math;Interval.isClosedLower" title="(flags: Int)Boolean">isClosedLower</a><span class="delimiter">(</span><span title="Int">flags</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: A, y: A)Boolean">===</a> <a href="#spire.math;Interval.hasAtOrBelow.t" title="A">t</a>
    case _: <a href="#spire.math.Below.readResolve" title="spire.math.Below[_]">Below</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; true
    case _: <a href="#spire.math.All.readResolve" title="spire.math.All[_]">All</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; true
  <span class="delimiter">}</span>

  def <a title="(t: A)Boolean" id="spire.math;Interval.isAt">isAt</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.isAt.t">t</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span> = this match <span class="delimiter">{</span>
    case Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.isAt.p">p</a><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">t</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: A, y: A)Boolean">===</a> <a href="#spire.math;Interval.isAt.p" title="A">p</a>
    case _ =&gt; false
  <span class="delimiter">}</span>

  def <a title="(rhs: spire.math.Interval[A])Boolean" id="spire.math;Interval.intersects">intersects</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.intersects.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.intersect" title="(rhs: spire.math.Interval[A])spire.math.Interval[A]">intersect</a> <a href="#spire.math;Interval.intersects.rhs" title="spire.math.Interval[A]">rhs</a><span class="delimiter">)</span>.<a href="#spire.math;Interval.isEmpty" title="=&gt; Boolean">isEmpty</a>

  def <a title="(rhs: spire.math.Interval[A])spire.math.Interval[A]" id="spire.math;Interval.&">&amp;</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.&.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.intersect" title="(rhs: spire.math.Interval[A])spire.math.Interval[A]">intersect</a> <a href="#spire.math;Interval.&.rhs" title="spire.math.Interval[A]">rhs</a>

  def <a title="(rhs: spire.math.Interval[A])spire.math.Interval[A]" id="spire.math;Interval.intersect">intersect</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.intersect.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.fromBounds" title="(lower: spire.math.interval.Bound[A], upper: spire.math.interval.Bound[A])(implicit evidence$13: spire.algebra.Order[A])spire.math.Interval[A]">fromBounds</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="interval/Bound.scala.html#spire.math.interval.Bound.maxLower" title="(lhs: spire.math.interval.Bound[A], rhs: spire.math.interval.Bound[A], emptyIsMax: Boolean)(implicit evidence$2: spire.algebra.Order[A])spire.math.interval.Bound[A]">maxLower</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval" title="Interval.this.type">lhs</a>.<a href="#spire.math;Interval.lowerBound" title="=&gt; spire.math.interval.Bound[A]">lowerBound</a>, <a href="#spire.math;Interval.intersect.rhs" title="spire.math.Interval[A]">rhs</a>.<a href="#spire.math;Interval.lowerBound" title="=&gt; spire.math.interval.Bound[A]">lowerBound</a>, true<span class="delimiter">)</span>,
      <a href="interval/Bound.scala.html#spire.math.interval.Bound.minUpper" title="(lhs: spire.math.interval.Bound[A], rhs: spire.math.interval.Bound[A], emptyIsMin: Boolean)(implicit evidence$3: spire.algebra.Order[A])spire.math.interval.Bound[A]">minUpper</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval" title="Interval.this.type">lhs</a>.<a href="#spire.math;Interval.upperBound" title="=&gt; spire.math.interval.Bound[A]">upperBound</a>, <a href="#spire.math;Interval.intersect.rhs" title="spire.math.Interval[A]">rhs</a>.<a href="#spire.math;Interval.upperBound" title="=&gt; spire.math.interval.Bound[A]">upperBound</a>, true<span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="()List[spire.math.Interval[A]]" id="spire.math;Interval.unary_~">unary_~</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="List[spire.math.Interval[A]]">List</span><span class="delimiter">[</span>Interval<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    this match <span class="delimiter">{</span>
      case All<span class="delimiter">(</span><span class="delimiter">)</span> =&gt;
        <span title="scala.collection.immutable.Nil.type">Nil</span>
      case Empty<span class="delimiter">(</span><span class="delimiter">)</span> =&gt;
        <span title="(xs: spire.math.All[A]*)List[spire.math.All[A]]">List</span><span class="delimiter">(</span><a href="#spire.math.All.readResolve" title="()(implicit evidence$2: spire.algebra.Order[A])spire.math.All[A]">All</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case Above<span class="delimiter">(</span><span title="A">lower</span>, <a title="Int" id="spire.math;Interval.unary_~.lf">lf</a><span class="delimiter">)</span> =&gt;
        <span title="(xs: spire.math.Below[A]*)List[spire.math.Below[A]]">List</span><span class="delimiter">(</span><a href="#spire.math.Below.readResolve" title="(upper: A, flags: Int)(implicit evidence$4: spire.algebra.Order[A])spire.math.Below[A]">Below</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">lower</span>, <a href="#spire.math;Interval.lowerFlagToUpper" title="(flags: Int)Int">lowerFlagToUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.reverseLowerFlag" title="(flags: Int)Int">reverseLowerFlag</a><span class="delimiter">(</span><a href="#spire.math;Interval.unary_~.lf" title="Int">lf</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case Below<span class="delimiter">(</span><span title="A">upper</span>, <a title="Int" id="spire.math;Interval.unary_~.uf">uf</a><span class="delimiter">)</span> =&gt;
        <span title="(xs: spire.math.Above[A]*)List[spire.math.Above[A]]">List</span><span class="delimiter">(</span><a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">upper</span>, <a href="#spire.math;Interval.upperFlagToLower" title="(flags: Int)Int">upperFlagToLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.reverseUpperFlag" title="(flags: Int)Int">reverseUpperFlag</a><span class="delimiter">(</span><a href="#spire.math;Interval.unary_~.uf" title="Int">uf</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.unary_~.p">p</a><span class="delimiter">)</span> =&gt;
        <span title="(xs: spire.math.Interval[A]*)List[spire.math.Interval[A]]">List</span><span class="delimiter">(</span><a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.below" title="(a: A)(implicit evidence$19: spire.algebra.Order[A])spire.math.Interval[A]">below</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.unary_~.p" title="A">p</a><span class="delimiter">)</span>, <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.above" title="(a: A)(implicit evidence$18: spire.algebra.Order[A])spire.math.Interval[A]">above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.unary_~.p" title="A">p</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case Bounded<span class="delimiter">(</span><span title="A">lower</span>, <span title="A">upper</span>, <a title="Int" id="spire.math;Interval.unary_~.flags">flags</a><span class="delimiter">)</span> =&gt;
        val <a title="Int" id="spire.math;Interval.unary_~.lx">lx</a> = <a href="#spire.math;Interval.lowerFlagToUpper" title="(flags: Int)Int">lowerFlagToUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.reverseLowerFlag" title="(flags: Int)Int">reverseLowerFlag</a><span class="delimiter">(</span><a href="#spire.math;Interval.lowerFlag" title="(flags: Int)Int">lowerFlag</a><span class="delimiter">(</span><a href="#spire.math;Interval.unary_~.flags" title="Int">flags</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        val <a title="Int" id="spire.math;Interval.unary_~.ux">ux</a> = <a href="#spire.math;Interval.upperFlagToLower" title="(flags: Int)Int">upperFlagToLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.reverseUpperFlag" title="(flags: Int)Int">reverseUpperFlag</a><span class="delimiter">(</span><a href="#spire.math;Interval.upperFlag" title="(flags: Int)Int">upperFlag</a><span class="delimiter">(</span><a href="#spire.math;Interval.unary_~.flags" title="Int">flags</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="(xs: Product with Serializable with spire.math.Interval[A]*)List[Product with Serializable with spire.math.Interval[A]]">List</span><span class="delimiter">(</span><a href="#spire.math.Below.readResolve" title="(upper: A, flags: Int)(implicit evidence$4: spire.algebra.Order[A])spire.math.Below[A]">Below</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">lower</span>, <a href="#spire.math;Interval.unary_~.lx" title="Int">lx</a><span class="delimiter">)</span>, <a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">upper</span>, <a href="#spire.math;Interval.unary_~.ux" title="Int">ux</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  def <a title="(rhs: spire.math.Interval[A])List[spire.math.Interval[A]]" id="spire.math;Interval.--">--</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.--.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[spire.math.Interval[A]]">List</span><span class="delimiter">[</span>Interval<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.intersects" title="(rhs: spire.math.Interval[A])Boolean">intersects</a> <a href="#spire.math;Interval.--.rhs" title="spire.math.Interval[A]">rhs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="delimiter">(</span><a href="#spire.math;Interval.unary_~" title="()List[spire.math.Interval[A]]">~</a><a href="#spire.math;Interval.--.rhs" title="spire.math.Interval[A]">rhs</a><span class="delimiter">)</span>.<span title="(f: spire.math.Interval[A] =&gt; spire.math.Interval[A])(implicit bf: scala.collection.generic.CanBuildFrom[List[spire.math.Interval[A]],spire.math.Interval[A],List[spire.math.Interval[A]]])List[spire.math.Interval[A]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,spire.math.Interval[A],List[spire.math.Interval[A]]]" class="delimiter">(</span><a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.&" title="(rhs: spire.math.Interval[A])spire.math.Interval[A]">&amp;</a> <a href="#spire.math;Interval.--.$anonfun.x$1" title="spire.math.Interval[A]">_</a><span class="delimiter">)</span>.<span title="(p: spire.math.Interval[A] =&gt; Boolean)List[spire.math.Interval[A]]">filter</span><span class="delimiter">(</span><a href="#spire.math;Interval.--.$anonfun.x$2" title="spire.math.Interval[A]">_</a>.<a href="#spire.math;Interval.nonEmpty" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#spire.math;Interval" title="Interval.this.type">lhs</a>.<a href="#spire.math;Interval.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span title="scala.collection.immutable.Nil.type">Nil</span> else <span title="(xs: spire.math.Interval[A]*)List[spire.math.Interval[A]]">List</span><span class="delimiter">(</span><a href="#spire.math;Interval" title="spire.math.Interval[A]">lhs</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  def <a title="(t: A)(spire.math.Interval[A], spire.math.Interval[A])" id="spire.math;Interval.split">split</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.split.t">t</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span>: <span title="(spire.math.Interval[A], spire.math.Interval[A])" class="delimiter">(</span>Interval<span class="delimiter">[</span>A<span class="delimiter">]</span>, Interval<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> =
    <span title="(_1: spire.math.Interval[A], _2: spire.math.Interval[A])(spire.math.Interval[A], spire.math.Interval[A])" class="delimiter">(</span>this <a href="#spire.math;Interval.intersect" title="(rhs: spire.math.Interval[A])spire.math.Interval[A]">intersect</a> <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.below" title="(a: A)(implicit evidence$19: spire.algebra.Order[A])spire.math.Interval[A]">below</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.split.t" title="A">t</a><span class="delimiter">)</span>, this <a href="#spire.math;Interval.intersect" title="(rhs: spire.math.Interval[A])spire.math.Interval[A]">intersect</a> <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.above" title="(a: A)(implicit evidence$18: spire.algebra.Order[A])spire.math.Interval[A]">above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.split.t" title="A">t</a><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="(implicit ev: spire.algebra.AdditiveMonoid[A])(spire.math.Interval[A], spire.math.Interval[A])" id="spire.math;Interval.splitAtZero">splitAtZero</a><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveMonoid[A]" id="spire.math;Interval.splitAtZero.ev">ev</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(spire.math.Interval[A], spire.math.Interval[A])" class="delimiter">(</span>Interval<span class="delimiter">[</span>A<span class="delimiter">]</span>, Interval<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#spire.math;Interval.split" title="(t: A)(spire.math.Interval[A], spire.math.Interval[A])">split</a><span class="delimiter">(</span><a href="#spire.math;Interval.splitAtZero.ev" title="spire.algebra.AdditiveMonoid[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span>

  def <a title="[B](f: spire.math.Interval[A] =&gt; B)(implicit ev: spire.algebra.AdditiveMonoid[A])(B, B)" id="spire.math;Interval.mapAroundZero">mapAroundZero</a><span class="delimiter">[</span><a title="" id="spire.math;Interval.mapAroundZero;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="spire.math.Interval[A] =&gt; B" id="spire.math;Interval.mapAroundZero.f">f</a>: Interval<span class="delimiter">[</span>A<span class="delimiter">]</span> =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveMonoid[A]" id="spire.math;Interval.mapAroundZero.ev">ev</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(B, B)" class="delimiter">(</span>B, B<span class="delimiter">)</span> =
    <a href="#spire.math;Interval.splitAtZero" title="(implicit ev: spire.algebra.AdditiveMonoid[A])(spire.math.Interval[A], spire.math.Interval[A])">splitAtZero</a> match <span class="delimiter">{</span>
      case <span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.mapAroundZero.a">a</a>, <a title="spire.math.Interval[A]" id="spire.math;Interval.mapAroundZero.b">b</a><span class="delimiter">)</span> =&gt; <span title="(_1: B, _2: B)(B, B)" class="delimiter">(</span><a href="#spire.math;Interval.mapAroundZero.f" title="(v1: spire.math.Interval[A])B">f</a><span class="delimiter">(</span><a href="#spire.math;Interval.mapAroundZero.a" title="spire.math.Interval[A]">a</a><span class="delimiter">)</span>, <a href="#spire.math;Interval.mapAroundZero.f" title="(v1: spire.math.Interval[A])B">f</a><span class="delimiter">(</span><a href="#spire.math;Interval.mapAroundZero.b" title="spire.math.Interval[A]">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  def <a title="(rhs: spire.math.Interval[A])spire.math.Interval[A]" id="spire.math;Interval.|">|</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.|.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.union" title="(rhs: spire.math.Interval[A])spire.math.Interval[A]">union</a> <a href="#spire.math;Interval.|.rhs" title="spire.math.Interval[A]">rhs</a>

  def <a title="(rhs: spire.math.Interval[A])spire.math.Interval[A]" id="spire.math;Interval.union">union</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.union.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.fromBounds" title="(lower: spire.math.interval.Bound[A], upper: spire.math.interval.Bound[A])(implicit evidence$13: spire.algebra.Order[A])spire.math.Interval[A]">fromBounds</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="interval/Bound.scala.html#spire.math.interval.Bound.minLower" title="(lhs: spire.math.interval.Bound[A], rhs: spire.math.interval.Bound[A], emptyIsMin: Boolean)(implicit evidence$1: spire.algebra.Order[A])spire.math.interval.Bound[A]">minLower</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval" title="Interval.this.type">lhs</a>.<a href="#spire.math;Interval.lowerBound" title="=&gt; spire.math.interval.Bound[A]">lowerBound</a>, <a href="#spire.math;Interval.union.rhs" title="spire.math.Interval[A]">rhs</a>.<a href="#spire.math;Interval.lowerBound" title="=&gt; spire.math.interval.Bound[A]">lowerBound</a>, false<span class="delimiter">)</span>,
      <a href="interval/Bound.scala.html#spire.math.interval.Bound.maxUpper" title="(lhs: spire.math.interval.Bound[A], rhs: spire.math.interval.Bound[A], emptyIsMax: Boolean)(implicit evidence$4: spire.algebra.Order[A])spire.math.interval.Bound[A]">maxUpper</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval" title="Interval.this.type">lhs</a>.<a href="#spire.math;Interval.upperBound" title="=&gt; spire.math.interval.Bound[A]">upperBound</a>, <a href="#spire.math;Interval.union.rhs" title="spire.math.Interval[A]">rhs</a>.<a href="#spire.math;Interval.upperBound" title="=&gt; spire.math.interval.Bound[A]">upperBound</a>, false<span class="delimiter">)</span><span class="delimiter">)</span>

  override def <a title="()String" id="spire.math;Interval.toString">toString</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="String">String</span> = this match <span class="delimiter">{</span>
    case All<span class="delimiter">(</span><span class="delimiter">)</span> =&gt;
      <span title="String(&quot;(-∞, ∞)&quot;)" class="string">&quot;(-∞, ∞)&quot;</span>
    case Empty<span class="delimiter">(</span><span class="delimiter">)</span> =&gt;
      <span title="String(&quot;(Ø)&quot;)" class="string">&quot;(Ø)&quot;</span>
    case Above<span class="delimiter">(</span><span title="A">lower</span>, <span title="Int">flags</span><span class="delimiter">)</span> =&gt;
      if <span class="delimiter">(</span><a href="#spire.math;Interval.isClosedLower" title="(flags: Int)Boolean">isClosedLower</a><span class="delimiter">(</span><span title="Int">flags</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;[&quot;)">[$</span><span title="A">lower</span><span title="String(&quot;, ∞)&quot;)" class="string">, ∞)&quot;</span> else <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;(&quot;)">($</span><span title="A">lower</span><span title="String(&quot;, ∞)&quot;)" class="string">, ∞)&quot;</span>
    case Below<span class="delimiter">(</span><span title="A">upper</span>, <span title="Int">flags</span><span class="delimiter">)</span> =&gt;
      if <span class="delimiter">(</span><a href="#spire.math;Interval.isClosedUpper" title="(flags: Int)Boolean">isClosedUpper</a><span class="delimiter">(</span><span title="Int">flags</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;(-∞, &quot;)">(-∞, $</span><span title="A">upper</span><span title="String(&quot;]&quot;)" class="string">]&quot;</span> else <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;(-∞, &quot;)">(-∞, $</span><span title="A">upper</span><span title="String(&quot;)&quot;)" class="string">)&quot;</span>
    case Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.toString.p">p</a><span class="delimiter">)</span> =&gt;
      <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;[&quot;)">[$</span><a href="#spire.math;Interval.toString.p" title="A">p</a><span title="String(&quot;]&quot;)" class="string">]&quot;</span>
    case Bounded<span class="delimiter">(</span><span title="A">lower</span>, <span title="A">upper</span>, <span title="Int">flags</span><span class="delimiter">)</span> =&gt;
      val <a title="String" id="spire.math;Interval.toString.s1">s1</a> = if <span class="delimiter">(</span><a href="#spire.math;Interval.isClosedLower" title="(flags: Int)Boolean">isClosedLower</a><span class="delimiter">(</span><span title="Int">flags</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;[&quot;)">[$</span><span title="A">lower</span><span title="String(&quot;&quot;)" class="string">&quot;</span> else <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;(&quot;)">($</span><span title="A">lower</span><span title="String(&quot;&quot;)" class="string">&quot;</span>
      val <a title="String" id="spire.math;Interval.toString.s2">s2</a> = if <span class="delimiter">(</span><a href="#spire.math;Interval.isClosedUpper" title="(flags: Int)Boolean">isClosedUpper</a><span class="delimiter">(</span><span title="Int">flags</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;&quot;)">$</span><span title="A">upper</span><span title="String(&quot;]&quot;)" class="string">]&quot;</span> else <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;&quot;)">$</span><span title="A">upper</span><span title="String(&quot;)&quot;)" class="string">)&quot;</span>
      <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;&quot;)">$</span><a href="#spire.math;Interval.toString.s1" title="String">s1</a><span title="String(&quot;, &quot;)">, $</span><a href="#spire.math;Interval.toString.s2" title="String">s2</a><span title="String(&quot;&quot;)" class="string">&quot;</span>
  <span class="delimiter">}</span>

  def <a title="(implicit m: spire.algebra.AdditiveGroup[A])spire.math.Interval[A]" id="spire.math;Interval.abs">abs</a><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveGroup[A]" id="spire.math;Interval.abs.m">m</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup" title="spire.algebra.AdditiveGroup[A]">AdditiveGroup</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#spire.math;Interval.crossesZero" title="(implicit ev: spire.algebra.AdditiveMonoid[A])Boolean">crossesZero</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// only Bounded, Above or Below can cross zero</span>
      this match <span class="delimiter">{</span>
        case Bounded<span class="delimiter">(</span><a title="A" id="spire.math;Interval.abs.lower">lower</a>, <a title="A" id="spire.math;Interval.abs.upper">upper</a>, <a title="Int" id="spire.math;Interval.abs.fs">fs</a><span class="delimiter">)</span> =&gt;
          val <a title="A" id="spire.math;Interval.abs.x">x</a> = <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: A)A">-</a><a href="#spire.math;Interval.abs.m" title="spire.algebra.AdditiveGroup[A]">lower</a>
          if <span class="delimiter">(</span><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">x</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <a href="#spire.math;Interval.abs.upper" title="A">upper</a><span class="delimiter">)</span> <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.abs.m" title="spire.algebra.AdditiveGroup[A]">m</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a>, <a href="#spire.math;Interval.abs.x" title="A">x</a>, <a href="#spire.math;Interval.lowerFlagToUpper" title="(flags: Int)Int">lowerFlagToUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.abs.fs" title="Int">fs</a><span class="delimiter">)</span><span class="delimiter">)</span>
          else if <span class="delimiter">(</span><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <a href="#spire.math;Interval.abs.x" title="A">x</a><span class="delimiter">)</span> <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.abs.m" title="spire.algebra.AdditiveGroup[A]">m</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a>, <a href="#spire.math;Interval.abs.upper" title="A">upper</a>, <a href="#spire.math;Interval.upperFlag" title="(flags: Int)Int">upperFlag</a><span class="delimiter">(</span><a href="#spire.math;Interval.abs.fs" title="Int">fs</a><span class="delimiter">)</span><span class="delimiter">)</span>
          else <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.abs.m" title="spire.algebra.AdditiveGroup[A]">m</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a>, <a href="#spire.math;Interval.abs.x" title="A">x</a>, <a href="#spire.math;Interval.lowerFlagToUpper" title="(flags: Int)Int">lowerFlagToUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.abs.fs" title="Int">fs</a><span class="delimiter">)</span> <span title="(x: Int)Int">&amp;</span> <a href="#spire.math;Interval.upperFlag" title="(flags: Int)Int">upperFlag</a><span class="delimiter">(</span><a href="#spire.math;Interval.abs.fs" title="Int">fs</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case _ =&gt; <span class="comment">// Above or Below</span>
          <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.atOrAbove" title="(a: A)(implicit evidence$20: spire.algebra.Order[A])spire.math.Interval[A]">atOrAbove</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.abs.m" title="spire.algebra.AdditiveGroup[A]">m</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.math;Interval.hasBelow" title="(t: A)Boolean">hasBelow</a><span class="delimiter">(</span><a href="#spire.math;Interval.abs.m" title="spire.algebra.AdditiveGroup[A]">m</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.math;Interval.unary_-" title="()(implicit ev: spire.algebra.AdditiveGroup[A])spire.math.Interval[A]">-</a>this
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      this
    <span class="delimiter">}</span>

  <span class="comment">// for all a in A, and all b in B, (A vmin B) is the interval that contains all (a min b)</span>
  def <a title="(rhs: spire.math.Interval[A])(implicit m: spire.algebra.AdditiveMonoid[A])spire.math.Interval[A]" id="spire.math;Interval.vmin">vmin</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.vmin.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveMonoid[A]" id="spire.math;Interval.vmin.m">m</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.fromBounds" title="(lower: spire.math.interval.Bound[A], upper: spire.math.interval.Bound[A])(implicit evidence$13: spire.algebra.Order[A])spire.math.Interval[A]">fromBounds</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="interval/Bound.scala.html#spire.math.interval.Bound.minLower" title="(lhs: spire.math.interval.Bound[A], rhs: spire.math.interval.Bound[A], emptyIsMin: Boolean)(implicit evidence$1: spire.algebra.Order[A])spire.math.interval.Bound[A]">minLower</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval" title="Interval.this.type">lhs</a>.<a href="#spire.math;Interval.lowerBound" title="=&gt; spire.math.interval.Bound[A]">lowerBound</a>, <a href="#spire.math;Interval.vmin.rhs" title="spire.math.Interval[A]">rhs</a>.<a href="#spire.math;Interval.lowerBound" title="=&gt; spire.math.interval.Bound[A]">lowerBound</a>, true<span class="delimiter">)</span>,
      <a href="interval/Bound.scala.html#spire.math.interval.Bound.minUpper" title="(lhs: spire.math.interval.Bound[A], rhs: spire.math.interval.Bound[A], emptyIsMin: Boolean)(implicit evidence$3: spire.algebra.Order[A])spire.math.interval.Bound[A]">minUpper</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval" title="Interval.this.type">lhs</a>.<a href="#spire.math;Interval.upperBound" title="=&gt; spire.math.interval.Bound[A]">upperBound</a>, <a href="#spire.math;Interval.vmin.rhs" title="spire.math.Interval[A]">rhs</a>.<a href="#spire.math;Interval.upperBound" title="=&gt; spire.math.interval.Bound[A]">upperBound</a>, true<span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">// for all a in A, and all b in B, (A vmax B) is the interval that contains all (a max b)</span>
  def <a title="(rhs: spire.math.Interval[A])(implicit m: spire.algebra.AdditiveMonoid[A])spire.math.Interval[A]" id="spire.math;Interval.vmax">vmax</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.vmax.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveMonoid[A]" id="spire.math;Interval.vmax.m">m</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.fromBounds" title="(lower: spire.math.interval.Bound[A], upper: spire.math.interval.Bound[A])(implicit evidence$13: spire.algebra.Order[A])spire.math.Interval[A]">fromBounds</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="interval/Bound.scala.html#spire.math.interval.Bound.maxLower" title="(lhs: spire.math.interval.Bound[A], rhs: spire.math.interval.Bound[A], emptyIsMax: Boolean)(implicit evidence$2: spire.algebra.Order[A])spire.math.interval.Bound[A]">maxLower</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval" title="Interval.this.type">lhs</a>.<a href="#spire.math;Interval.lowerBound" title="=&gt; spire.math.interval.Bound[A]">lowerBound</a>, <a href="#spire.math;Interval.vmax.rhs" title="spire.math.Interval[A]">rhs</a>.<a href="#spire.math;Interval.lowerBound" title="=&gt; spire.math.interval.Bound[A]">lowerBound</a>, true<span class="delimiter">)</span>,
      <a href="interval/Bound.scala.html#spire.math.interval.Bound.maxUpper" title="(lhs: spire.math.interval.Bound[A], rhs: spire.math.interval.Bound[A], emptyIsMax: Boolean)(implicit evidence$4: spire.algebra.Order[A])spire.math.interval.Bound[A]">maxUpper</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval" title="Interval.this.type">lhs</a>.<a href="#spire.math;Interval.upperBound" title="=&gt; spire.math.interval.Bound[A]">upperBound</a>, <a href="#spire.math;Interval.vmax.rhs" title="spire.math.Interval[A]">rhs</a>.<a href="#spire.math;Interval.upperBound" title="=&gt; spire.math.interval.Bound[A]">upperBound</a>, true<span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="(rhs: spire.math.Interval[A])(f: (A, A) =&gt; A)spire.math.Interval[A]" id="spire.math;Interval.combine">combine</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.combine.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, A) =&gt; A" id="spire.math;Interval.combine.f">f</a>: <span class="delimiter">(</span>A, A<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="spire.math.interval.Bound[A]" id="spire.math;Interval.combine.lb">lb</a> = <a href="#spire.math;Interval" title="Interval.this.type">lhs</a>.<a href="#spire.math;Interval.lowerBound" title="=&gt; spire.math.interval.Bound[A]">lowerBound</a>.<a href="interval/Bound.scala.html#spire.math.interval;Bound.combine" title="(rhs: spire.math.interval.Bound[A])(f: (A, A) =&gt; A)spire.math.interval.Bound[A]">combine</a><span class="delimiter">(</span><a href="#spire.math;Interval.combine.rhs" title="spire.math.Interval[A]">rhs</a>.<a href="#spire.math;Interval.lowerBound" title="=&gt; spire.math.interval.Bound[A]">lowerBound</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.math;Interval.combine.f" title="(A, A) =&gt; A">f</a><span class="delimiter">)</span>
    val <a title="spire.math.interval.Bound[A]" id="spire.math;Interval.combine.ub">ub</a> = <a href="#spire.math;Interval" title="Interval.this.type">lhs</a>.<a href="#spire.math;Interval.upperBound" title="=&gt; spire.math.interval.Bound[A]">upperBound</a>.<a href="interval/Bound.scala.html#spire.math.interval;Bound.combine" title="(rhs: spire.math.interval.Bound[A])(f: (A, A) =&gt; A)spire.math.interval.Bound[A]">combine</a><span class="delimiter">(</span><a href="#spire.math;Interval.combine.rhs" title="spire.math.Interval[A]">rhs</a>.<a href="#spire.math;Interval.upperBound" title="=&gt; spire.math.interval.Bound[A]">upperBound</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.math;Interval.combine.f" title="(A, A) =&gt; A">f</a><span class="delimiter">)</span>
    <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.fromBounds" title="(lower: spire.math.interval.Bound[A], upper: spire.math.interval.Bound[A])(implicit evidence$13: spire.algebra.Order[A])spire.math.Interval[A]">fromBounds</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.combine.lb" title="spire.math.interval.Bound[A]">lb</a>, <a href="#spire.math;Interval.combine.ub" title="spire.math.interval.Bound[A]">ub</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(rhs: spire.math.Interval[A])(implicit ev: spire.algebra.AdditiveSemigroup[A])spire.math.Interval[A]" id="spire.math;Interval.+(b8d503f15a)">+</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.+(b8d503f15a).rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveSemigroup[A]" id="spire.math;Interval.+(b8d503f15a).ev">ev</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup" title="spire.algebra.AdditiveSemigroup[A]">AdditiveSemigroup</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#spire.math;Interval.combine" title="(rhs: spire.math.Interval[A])(f: (A, A) =&gt; A)spire.math.Interval[A]">combine</a><span class="delimiter">(</span><a href="#spire.math;Interval.+(b8d503f15a).rhs" title="spire.math.Interval[A]">rhs</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.math;Interval.+(b8d503f15a).ev" title="spire.algebra.AdditiveSemigroup[A]">_</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+</a> <a href="#spire.math;Interval.+(b8d503f15a).$anonfun.x$4" title="A">_</a><span class="delimiter">)</span>

  def <a title="(rhs: spire.math.Interval[A])(implicit ev: spire.algebra.AdditiveGroup[A])spire.math.Interval[A]" id="spire.math;Interval.-(be7874c038)">-</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.-(be7874c038).rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveGroup[A]" id="spire.math;Interval.-(be7874c038).ev">ev</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup" title="spire.algebra.AdditiveGroup[A]">AdditiveGroup</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.+(b8d503f15a)" title="(rhs: spire.math.Interval[A])(implicit ev: spire.algebra.AdditiveSemigroup[A])spire.math.Interval[A]">+</a> <span class="delimiter">(</span><a href="#spire.math;Interval.unary_-" title="()(implicit ev: spire.algebra.AdditiveGroup[A])spire.math.Interval[A]">-</a><a href="#spire.math;Interval.-(be7874c038).rhs" title="spire.math.Interval[A]">rhs</a><span class="delimiter">)</span>

  def <a title="(rhs: spire.math.Interval[A])(implicit ev: spire.algebra.Semiring[A])spire.math.Interval[A]" id="spire.math;Interval.*(74feccc19e)">*</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.*(74feccc19e).rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Semiring[A]" id="spire.math;Interval.*(74feccc19e).ev">ev</a>: <a href="../algebra/Semiring.scala.html#spire.algebra;Semiring" title="spire.algebra.Semiring[A]">Semiring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="A" id="spire.math;Interval.*(74feccc19e).z">z</a> = <a href="#spire.math;Interval.*(74feccc19e).ev" title="spire.algebra.Semiring[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a>

    def <a title="(lower1: A, lf1: Int, lower2: A, lf2: Int)Product with Serializable with spire.math.Interval[A]{def upperBound: spire.math.interval.Unbound[A]}" id="spire.math;Interval.*(74feccc19e).aboveAbove">aboveAbove</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.*(74feccc19e).aboveAbove.lower1">lower1</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="Int" id="spire.math;Interval.*(74feccc19e).aboveAbove.lf1">lf1</a>: <span title="Int">Int</span>, <a title="A" id="spire.math;Interval.*(74feccc19e).aboveAbove.lower2">lower2</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="Int" id="spire.math;Interval.*(74feccc19e).aboveAbove.lf2">lf2</a>: <span title="Int">Int</span><span class="delimiter">)</span> =
        if <span class="delimiter">(</span><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower1</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math;Interval.*(74feccc19e).z" title="A">z</a> <span title="(x: Boolean)Boolean">||</span> <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower2</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math;Interval.*(74feccc19e).z" title="A">z</a><span class="delimiter">)</span> <a href="#spire.math.All.readResolve" title="()(implicit evidence$2: spire.algebra.Order[A])spire.math.All[A]">All</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><span class="delimiter">)</span> else
          <a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(74feccc19e).ev" title="spire.algebra.Semiring[A]">lower1</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(74feccc19e).aboveAbove.lower2" title="A">lower2</a>, <a href="#spire.math;Interval.*(74feccc19e).aboveAbove.lf1" title="Int">lf1</a> <span title="(x: Int)Int">|</span> <a href="#spire.math;Interval.*(74feccc19e).aboveAbove.lf2" title="Int">lf2</a><span class="delimiter">)</span>

    def <a title="(upper1: A, uf1: Int, upper2: A, uf2: Int)Product with Serializable with spire.math.Interval[A]{def upperBound: spire.math.interval.Unbound[A]}" id="spire.math;Interval.*(74feccc19e).belowBelow">belowBelow</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.*(74feccc19e).belowBelow.upper1">upper1</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="Int" id="spire.math;Interval.*(74feccc19e).belowBelow.uf1">uf1</a>: <span title="Int">Int</span>, <a title="A" id="spire.math;Interval.*(74feccc19e).belowBelow.upper2">upper2</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="Int" id="spire.math;Interval.*(74feccc19e).belowBelow.uf2">uf2</a>: <span title="Int">Int</span><span class="delimiter">)</span> =
        if <span class="delimiter">(</span><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper1</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <a href="#spire.math;Interval.*(74feccc19e).z" title="A">z</a> <span title="(x: Boolean)Boolean">||</span> <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper2</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <a href="#spire.math;Interval.*(74feccc19e).z" title="A">z</a><span class="delimiter">)</span> <a href="#spire.math.All.readResolve" title="()(implicit evidence$2: spire.algebra.Order[A])spire.math.All[A]">All</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><span class="delimiter">)</span> else
          <a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(74feccc19e).ev" title="spire.algebra.Semiring[A]">upper1</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(74feccc19e).belowBelow.upper2" title="A">upper2</a>, <a href="#spire.math;Interval.upperFlagToLower" title="(flags: Int)Int">upperFlagToLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).belowBelow.uf1" title="Int">uf1</a><span class="delimiter">)</span> <span title="(x: Int)Int">|</span> <a href="#spire.math;Interval.upperFlagToLower" title="(flags: Int)Int">upperFlagToLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).belowBelow.uf2" title="Int">uf2</a><span class="delimiter">)</span><span class="delimiter">)</span>

    def <a title="(lower1: A, lf1: Int, upper2: A, uf2: Int)Product with Serializable with spire.math.Interval[A]{def lowerBound: spire.math.interval.Unbound[A]}" id="spire.math;Interval.*(74feccc19e).aboveBelow">aboveBelow</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.*(74feccc19e).aboveBelow.lower1">lower1</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="Int" id="spire.math;Interval.*(74feccc19e).aboveBelow.lf1">lf1</a>: <span title="Int">Int</span>, <a title="A" id="spire.math;Interval.*(74feccc19e).aboveBelow.upper2">upper2</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="Int" id="spire.math;Interval.*(74feccc19e).aboveBelow.uf2">uf2</a>: <span title="Int">Int</span><span class="delimiter">)</span> =
      if <span class="delimiter">(</span><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower1</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math;Interval.*(74feccc19e).z" title="A">z</a> <span title="(x: Boolean)Boolean">||</span> <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper2</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <a href="#spire.math;Interval.*(74feccc19e).z" title="A">z</a><span class="delimiter">)</span> <a href="#spire.math.All.readResolve" title="()(implicit evidence$2: spire.algebra.Order[A])spire.math.All[A]">All</a> <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><span class="delimiter">)</span> else
        <a href="#spire.math.Below.readResolve" title="(upper: A, flags: Int)(implicit evidence$4: spire.algebra.Order[A])spire.math.Below[A]">Below</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(74feccc19e).ev" title="spire.algebra.Semiring[A]">lower1</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(74feccc19e).aboveBelow.upper2" title="A">upper2</a>, <a href="#spire.math;Interval.lowerFlagToUpper" title="(flags: Int)Int">lowerFlagToUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).aboveBelow.lf1" title="Int">lf1</a><span class="delimiter">)</span> <span title="(x: Int)Int">|</span> <a href="#spire.math;Interval.*(74feccc19e).aboveBelow.uf2" title="Int">uf2</a><span class="delimiter">)</span>

    def <a title="(lower1: A, lf1: Int, lower2: A, upper2: A, flags2: Int)Product with Serializable with spire.math.Interval[A]" id="spire.math;Interval.*(74feccc19e).aboveBounded">aboveBounded</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.*(74feccc19e).aboveBounded.lower1">lower1</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="Int" id="spire.math;Interval.*(74feccc19e).aboveBounded.lf1">lf1</a>: <span title="Int">Int</span>, <a title="A" id="spire.math;Interval.*(74feccc19e).aboveBounded.lower2">lower2</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="A" id="spire.math;Interval.*(74feccc19e).aboveBounded.upper2">upper2</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="Int" id="spire.math;Interval.*(74feccc19e).aboveBounded.flags2">flags2</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      val hasBelowZero1 = <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower1</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="Boolean" id="spire.math;Interval.*(74feccc19e).aboveBounded.hasBelowZero1">&lt;</a> <a href="#spire.math;Interval.*(74feccc19e).z" title="A">z</a>
      val hasBelowZero2 = <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower2</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="Boolean" id="spire.math;Interval.*(74feccc19e).aboveBounded.hasBelowZero2">&lt;</a> <a href="#spire.math;Interval.*(74feccc19e).z" title="A">z</a>
      val hasAboveZero2 = <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper2</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="Boolean" id="spire.math;Interval.*(74feccc19e).aboveBounded.hasAboveZero2">&gt;</a> <a href="#spire.math;Interval.*(74feccc19e).z" title="A">z</a>
      if <span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).aboveBounded.hasBelowZero2" title="Boolean">hasBelowZero2</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Interval.*(74feccc19e).aboveBounded.hasAboveZero2" title="Boolean">hasAboveZero2</a><span class="delimiter">)</span> <a href="#spire.math.All.readResolve" title="()(implicit evidence$2: spire.algebra.Order[A])spire.math.All[A]">All</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><span class="delimiter">)</span> <span class="comment">// bounded interval crosses zero</span>

      else if <span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).aboveBounded.hasAboveZero2" title="Boolean">hasAboveZero2</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// bounded interval is fully above zero</span>
        if <span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).aboveBounded.hasBelowZero1" title="Boolean">hasBelowZero1</a><span class="delimiter">)</span> <span class="comment">// the minimal point is lower1(-) * upper2(+)</span>
          <a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(74feccc19e).ev" title="spire.algebra.Semiring[A]">lower1</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(74feccc19e).aboveBounded.upper2" title="A">upper2</a>, <a href="#spire.math;Interval.*(74feccc19e).aboveBounded.lf1" title="Int">lf1</a> <span title="(x: Int)Int">|</span> <a href="#spire.math;Interval.upperFlagToLower" title="(flags: Int)Int">upperFlagToLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).aboveBounded.flags2" title="Int">flags2</a><span class="delimiter">)</span><span class="delimiter">)</span>
        else <span class="comment">// the minimal point is lower1(+) * lower2(+)</span>
          <a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(74feccc19e).ev" title="spire.algebra.Semiring[A]">lower1</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(74feccc19e).aboveBounded.lower2" title="A">lower2</a>, <a href="#spire.math;Interval.*(74feccc19e).aboveBounded.lf1" title="Int">lf1</a> <span title="(x: Int)Int">|</span> <a href="#spire.math;Interval.lowerFlag" title="(flags: Int)Int">lowerFlag</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).aboveBounded.flags2" title="Int">flags2</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="delimiter">}</span> else <span class="delimiter">{</span> <span class="comment">// bounded interval is fully below zero</span>
        <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).aboveBounded.hasBelowZero2" title="Boolean">hasBelowZero2</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).aboveBounded.hasBelowZero1" title="Boolean">hasBelowZero1</a><span class="delimiter">)</span> <span class="comment">// the maximal point is lower1(-) * lower2(-)</span>
          <a href="#spire.math.Below.readResolve" title="(upper: A, flags: Int)(implicit evidence$4: spire.algebra.Order[A])spire.math.Below[A]">Below</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(74feccc19e).ev" title="spire.algebra.Semiring[A]">lower1</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(74feccc19e).aboveBounded.lower2" title="A">lower2</a>, <a href="#spire.math;Interval.lowerFlagToUpper" title="(flags: Int)Int">lowerFlagToUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).aboveBounded.lf1" title="Int">lf1</a><span class="delimiter">)</span> <span title="(x: Int)Int">|</span> <a href="#spire.math;Interval.lowerFlagToUpper" title="(flags: Int)Int">lowerFlagToUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).aboveBounded.flags2" title="Int">flags2</a><span class="delimiter">)</span><span class="delimiter">)</span>
        else <span class="comment">// the maximal point is lower1(+) * upper2(-)</span>
          <a href="#spire.math.Below.readResolve" title="(upper: A, flags: Int)(implicit evidence$4: spire.algebra.Order[A])spire.math.Below[A]">Below</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(74feccc19e).ev" title="spire.algebra.Semiring[A]">lower1</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(74feccc19e).aboveBounded.upper2" title="A">upper2</a>, <a href="#spire.math;Interval.lowerFlagToUpper" title="(flags: Int)Int">lowerFlagToUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).aboveBounded.lf1" title="Int">lf1</a><span class="delimiter">)</span> <span title="(x: Int)Int">|</span> <a href="#spire.math;Interval.upperFlag" title="(flags: Int)Int">upperFlag</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).aboveBounded.flags2" title="Int">flags2</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    def <a title="(upper1: A, uf1: Int, lower2: A, upper2: A, flags2: Int)Product with Serializable with spire.math.Interval[A]" id="spire.math;Interval.*(74feccc19e).belowBounded">belowBounded</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.*(74feccc19e).belowBounded.upper1">upper1</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="Int" id="spire.math;Interval.*(74feccc19e).belowBounded.uf1">uf1</a>: <span title="Int">Int</span>, <a title="A" id="spire.math;Interval.*(74feccc19e).belowBounded.lower2">lower2</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="A" id="spire.math;Interval.*(74feccc19e).belowBounded.upper2">upper2</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="Int" id="spire.math;Interval.*(74feccc19e).belowBounded.flags2">flags2</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      val hasAboveZero1 = <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper1</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="Boolean" id="spire.math;Interval.*(74feccc19e).belowBounded.hasAboveZero1">&gt;</a> <a href="#spire.math;Interval.*(74feccc19e).z" title="A">z</a>
      val hasBelowZero2 = <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower2</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="Boolean" id="spire.math;Interval.*(74feccc19e).belowBounded.hasBelowZero2">&lt;</a> <a href="#spire.math;Interval.*(74feccc19e).z" title="A">z</a>
      val hasAboveZero2 = <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper2</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="Boolean" id="spire.math;Interval.*(74feccc19e).belowBounded.hasAboveZero2">&gt;</a> <a href="#spire.math;Interval.*(74feccc19e).z" title="A">z</a>
      if <span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).belowBounded.hasBelowZero2" title="Boolean">hasBelowZero2</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Interval.*(74feccc19e).belowBounded.hasAboveZero2" title="Boolean">hasAboveZero2</a><span class="delimiter">)</span> <a href="#spire.math.All.readResolve" title="()(implicit evidence$2: spire.algebra.Order[A])spire.math.All[A]">All</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><span class="delimiter">)</span> <span class="comment">// bounded interval crosses zero</span>

      else if <span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).belowBounded.hasAboveZero2" title="Boolean">hasAboveZero2</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// bounded interval is fully above zero</span>
        if <span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).belowBounded.hasAboveZero1" title="Boolean">hasAboveZero1</a><span class="delimiter">)</span> <span class="comment">// the maximal point is upper1(+) * upper2(+)</span>
          <a href="#spire.math.Below.readResolve" title="(upper: A, flags: Int)(implicit evidence$4: spire.algebra.Order[A])spire.math.Below[A]">Below</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(74feccc19e).ev" title="spire.algebra.Semiring[A]">upper1</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(74feccc19e).belowBounded.upper2" title="A">upper2</a>, <a href="#spire.math;Interval.*(74feccc19e).belowBounded.uf1" title="Int">uf1</a> <span title="(x: Int)Int">|</span> <a href="#spire.math;Interval.upperFlag" title="(flags: Int)Int">upperFlag</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).belowBounded.flags2" title="Int">flags2</a><span class="delimiter">)</span><span class="delimiter">)</span>
        else <span class="comment">// the maximal point is upper1(+) * lower2(-)</span>
          <a href="#spire.math.Below.readResolve" title="(upper: A, flags: Int)(implicit evidence$4: spire.algebra.Order[A])spire.math.Below[A]">Below</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(74feccc19e).ev" title="spire.algebra.Semiring[A]">upper1</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(74feccc19e).belowBounded.lower2" title="A">lower2</a>, <a href="#spire.math;Interval.*(74feccc19e).belowBounded.uf1" title="Int">uf1</a> <span title="(x: Int)Int">|</span> <a href="#spire.math;Interval.lowerFlagToUpper" title="(flags: Int)Int">lowerFlagToUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).belowBounded.flags2" title="Int">flags2</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="delimiter">}</span> else <span class="delimiter">{</span> <span class="comment">// bounded interval is fully below zero</span>
        if <span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).belowBounded.hasAboveZero1" title="Boolean">hasAboveZero1</a><span class="delimiter">)</span> <span class="comment">// the minimal point is upper1(+) * lower2(-)</span>
          <a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(74feccc19e).ev" title="spire.algebra.Semiring[A]">upper1</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(74feccc19e).belowBounded.lower2" title="A">lower2</a>, <a href="#spire.math;Interval.upperFlagToLower" title="(flags: Int)Int">upperFlagToLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).belowBounded.uf1" title="Int">uf1</a><span class="delimiter">)</span> <span title="(x: Int)Int">|</span> <a href="#spire.math;Interval.lowerFlag" title="(flags: Int)Int">lowerFlag</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).belowBounded.flags2" title="Int">flags2</a><span class="delimiter">)</span><span class="delimiter">)</span>
        else <span class="comment">// the minimal point is upper1(-) * upper2(-)</span>
          <a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(74feccc19e).ev" title="spire.algebra.Semiring[A]">upper1</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(74feccc19e).belowBounded.upper2" title="A">upper2</a>, <a href="#spire.math;Interval.upperFlagToLower" title="(flags: Int)Int">upperFlagToLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).belowBounded.uf1" title="Int">uf1</a><span class="delimiter">)</span> <span title="(x: Int)Int">|</span> <a href="#spire.math;Interval.upperFlagToLower" title="(flags: Int)Int">upperFlagToLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).belowBounded.flags2" title="Int">flags2</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    def <a title="(bd1: spire.math.Bounded[A], bd2: spire.math.Bounded[A])spire.math.Interval[A]" id="spire.math;Interval.*(74feccc19e).boundedBounded">boundedBounded</a><span class="delimiter">(</span><a title="spire.math.Bounded[A]" id="spire.math;Interval.*(74feccc19e).boundedBounded.bd1">bd1</a>: <a href="#spire.math.Bounded.readResolve" title="spire.math.Bounded[A]">Bounded</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Bounded[A]" id="spire.math;Interval.*(74feccc19e).boundedBounded.bd2">bd2</a>: <a href="#spire.math.Bounded.readResolve" title="spire.math.Bounded[A]">Bounded</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      val <a title="spire.math.interval.ValueBound[A]" id="spire.math;Interval.*(74feccc19e).boundedBounded.lb1">lb1</a> = <a href="#spire.math;Interval.*(74feccc19e).boundedBounded.bd1" title="spire.math.Bounded[A]">bd1</a>.<a href="#spire.math;Bounded.lowerBound" title="=&gt; spire.math.interval.ValueBound[A]">lowerBound</a>
      val <a title="spire.math.interval.ValueBound[A]" id="spire.math;Interval.*(74feccc19e).boundedBounded.ub1">ub1</a> = <a href="#spire.math;Interval.*(74feccc19e).boundedBounded.bd1" title="spire.math.Bounded[A]">bd1</a>.<a href="#spire.math;Bounded.upperBound" title="=&gt; spire.math.interval.ValueBound[A]">upperBound</a>
      val <a title="spire.math.interval.ValueBound[A]" id="spire.math;Interval.*(74feccc19e).boundedBounded.lb2">lb2</a> = <a href="#spire.math;Interval.*(74feccc19e).boundedBounded.bd2" title="spire.math.Bounded[A]">bd2</a>.<a href="#spire.math;Bounded.lowerBound" title="=&gt; spire.math.interval.ValueBound[A]">lowerBound</a>
      val <a title="spire.math.interval.ValueBound[A]" id="spire.math;Interval.*(74feccc19e).boundedBounded.ub2">ub2</a> = <a href="#spire.math;Interval.*(74feccc19e).boundedBounded.bd2" title="spire.math.Bounded[A]">bd2</a>.<a href="#spire.math;Bounded.upperBound" title="=&gt; spire.math.interval.ValueBound[A]">upperBound</a>
      val ll = <span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).boundedBounded.lb1" title="spire.math.interval.ValueBound[A]">lb1</a> <a href="interval/Bound.scala.html#spire.math.interval;ValueBound.*~" title="spire.math.interval.ValueBound[A]" id="spire.math;Interval.*(74feccc19e).boundedBounded.ll">*~</a> <a href="#spire.math;Interval.*(74feccc19e).boundedBounded.lb2" title="spire.math.interval.ValueBound[A]">lb2</a><span class="delimiter">)</span>
      val lu = <span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).boundedBounded.lb1" title="spire.math.interval.ValueBound[A]">lb1</a> <a href="interval/Bound.scala.html#spire.math.interval;ValueBound.*~" title="spire.math.interval.ValueBound[A]" id="spire.math;Interval.*(74feccc19e).boundedBounded.lu">*~</a> <a href="#spire.math;Interval.*(74feccc19e).boundedBounded.ub2" title="spire.math.interval.ValueBound[A]">ub2</a><span class="delimiter">)</span>
      val ul = <span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).boundedBounded.ub1" title="spire.math.interval.ValueBound[A]">ub1</a> <a href="interval/Bound.scala.html#spire.math.interval;ValueBound.*~" title="spire.math.interval.ValueBound[A]" id="spire.math;Interval.*(74feccc19e).boundedBounded.ul">*~</a> <a href="#spire.math;Interval.*(74feccc19e).boundedBounded.lb2" title="spire.math.interval.ValueBound[A]">lb2</a><span class="delimiter">)</span>
      val uu = <span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).boundedBounded.ub1" title="spire.math.interval.ValueBound[A]">ub1</a> <a href="interval/Bound.scala.html#spire.math.interval;ValueBound.*~" title="spire.math.interval.ValueBound[A]" id="spire.math;Interval.*(74feccc19e).boundedBounded.uu">*~</a> <a href="#spire.math;Interval.*(74feccc19e).boundedBounded.ub2" title="spire.math.interval.ValueBound[A]">ub2</a><span class="delimiter">)</span>
      <a href="interval/Bound.scala.html#spire.math.interval.ValueBound" title="spire.math.interval.ValueBound.type">ValueBound</a>.<a href="interval/Bound.scala.html#spire.math.interval.ValueBound.union4" title="(v1: spire.math.interval.ValueBound[A], v2: spire.math.interval.ValueBound[A], v3: spire.math.interval.ValueBound[A], v4: spire.math.interval.ValueBound[A])(implicit evidence$23: spire.algebra.Order[A])spire.math.Interval[A]">union4</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(74feccc19e).boundedBounded.ll" title="spire.math.interval.ValueBound[A]">ll</a>, <a href="#spire.math;Interval.*(74feccc19e).boundedBounded.lu" title="spire.math.interval.ValueBound[A]">lu</a>, <a href="#spire.math;Interval.*(74feccc19e).boundedBounded.ul" title="spire.math.interval.ValueBound[A]">ul</a>, <a href="#spire.math;Interval.*(74feccc19e).boundedBounded.uu" title="spire.math.interval.ValueBound[A]">uu</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>


    <span title="(_1: spire.math.Interval[A], _2: spire.math.Interval[A])(spire.math.Interval[A], spire.math.Interval[A])" class="delimiter">(</span><a href="#spire.math;Interval" title="spire.math.Interval[A]">lhs</a>, <a href="#spire.math;Interval.*(74feccc19e).rhs" title="spire.math.Interval[A]">rhs</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case <span class="delimiter">(</span>Empty<span class="delimiter">(</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval" title="spire.math.Interval[A]">lhs</a>
      case <span class="delimiter">(</span>_, Empty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.*(74feccc19e).rhs" title="spire.math.Interval[A]">rhs</a>
      case <span class="delimiter">(</span>Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.*(74feccc19e).lv">lv</a><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.*(74feccc19e).rhs" title="spire.math.Interval[A]">rhs</a> <a href="#spire.math;Interval.*(4c77ef3e75)" title="(rhs: A)(implicit ev: spire.algebra.Semiring[A])spire.math.Interval[A]">*</a> <a href="#spire.math;Interval.*(74feccc19e).lv" title="A">lv</a> <span class="comment">// use multiplication by scalar</span>
      case <span class="delimiter">(</span>_, Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.*(74feccc19e).rv">rv</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.*(4c77ef3e75)" title="(rhs: A)(implicit ev: spire.algebra.Semiring[A])spire.math.Interval[A]">*</a> <a href="#spire.math;Interval.*(74feccc19e).rv" title="A">rv</a>
      <span class="comment">// now lhs and rhs are both intervals with more that one point</span>
      case <span class="delimiter">(</span>All<span class="delimiter">(</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval" title="spire.math.Interval[A]">lhs</a>
      case <span class="delimiter">(</span>_, All<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.*(74feccc19e).rhs" title="spire.math.Interval[A]">rhs</a>

      case <span class="delimiter">(</span>Above<span class="delimiter">(</span><span title="A">lower1</span>, <span title="Int">lf1</span><span class="delimiter">)</span>, Above<span class="delimiter">(</span><span title="A">lower2</span>, <span title="Int">lf2</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.*(74feccc19e).aboveAbove" title="(lower1: A, lf1: Int, lower2: A, lf2: Int)Product with Serializable with spire.math.Interval[A]{def upperBound: spire.math.interval.Unbound[A]}">aboveAbove</a><span class="delimiter">(</span><span title="A">lower1</span>, <span title="Int">lf1</span>, <span title="A">lower2</span>, <span title="Int">lf2</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Above<span class="delimiter">(</span><span title="A">lower1</span>, <span title="Int">lf1</span><span class="delimiter">)</span>, Below<span class="delimiter">(</span><span title="A">upper2</span>, <span title="Int">uf2</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.*(74feccc19e).aboveBelow" title="(lower1: A, lf1: Int, upper2: A, uf2: Int)Product with Serializable with spire.math.Interval[A]{def lowerBound: spire.math.interval.Unbound[A]}">aboveBelow</a><span class="delimiter">(</span><span title="A">lower1</span>, <span title="Int">lf1</span>, <span title="A">upper2</span>, <span title="Int">uf2</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Below<span class="delimiter">(</span><span title="A">upper1</span>, <span title="Int">uf1</span><span class="delimiter">)</span>, Above<span class="delimiter">(</span><span title="A">lower2</span>, <span title="Int">lf2</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.*(74feccc19e).aboveBelow" title="(lower1: A, lf1: Int, upper2: A, uf2: Int)Product with Serializable with spire.math.Interval[A]{def lowerBound: spire.math.interval.Unbound[A]}">aboveBelow</a><span class="delimiter">(</span><span title="A">lower2</span>, <span title="Int">lf2</span>, <span title="A">upper1</span>, <span title="Int">uf1</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Below<span class="delimiter">(</span><span title="A">upper1</span>, <span title="Int">uf1</span><span class="delimiter">)</span>, Below<span class="delimiter">(</span><span title="A">upper2</span>, <span title="Int">uf2</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.*(74feccc19e).belowBelow" title="(upper1: A, uf1: Int, upper2: A, uf2: Int)Product with Serializable with spire.math.Interval[A]{def upperBound: spire.math.interval.Unbound[A]}">belowBelow</a><span class="delimiter">(</span><span title="A">upper1</span>, <span title="Int">uf1</span>, <span title="A">upper2</span>, <span title="Int">uf2</span><span class="delimiter">)</span>

      case <span class="delimiter">(</span>Above<span class="delimiter">(</span><span title="A">lower1</span>, <span title="Int">lf1</span><span class="delimiter">)</span>, Bounded<span class="delimiter">(</span><span title="A">lower2</span>, <span title="A">upper2</span>, <span title="Int">flags2</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; 
        <a href="#spire.math;Interval.*(74feccc19e).aboveBounded" title="(lower1: A, lf1: Int, lower2: A, upper2: A, flags2: Int)Product with Serializable with spire.math.Interval[A]">aboveBounded</a><span class="delimiter">(</span><span title="A">lower1</span>, <span title="Int">lf1</span>, <span title="A">lower2</span>, <span title="A">upper2</span>, <span title="Int">flags2</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Bounded<span class="delimiter">(</span><span title="A">lower1</span>, <span title="A">upper1</span>, <span title="Int">flags1</span><span class="delimiter">)</span>, Above<span class="delimiter">(</span><span title="A">lower2</span>, <span title="Int">lf2</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <a href="#spire.math;Interval.*(74feccc19e).aboveBounded" title="(lower1: A, lf1: Int, lower2: A, upper2: A, flags2: Int)Product with Serializable with spire.math.Interval[A]">aboveBounded</a><span class="delimiter">(</span><span title="A">lower2</span>, <span title="Int">lf2</span>, <span title="A">lower1</span>, <span title="A">upper1</span>, <span title="Int">flags1</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Below<span class="delimiter">(</span><span title="A">upper1</span>, <span title="Int">uf1</span><span class="delimiter">)</span>, Bounded<span class="delimiter">(</span><span title="A">lower2</span>, <span title="A">upper2</span>, <span title="Int">flags2</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <a href="#spire.math;Interval.*(74feccc19e).belowBounded" title="(upper1: A, uf1: Int, lower2: A, upper2: A, flags2: Int)Product with Serializable with spire.math.Interval[A]">belowBounded</a><span class="delimiter">(</span><span title="A">upper1</span>, <span title="Int">uf1</span>, <span title="A">lower2</span>, <span title="A">upper2</span>, <span title="Int">flags2</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Bounded<span class="delimiter">(</span><span title="A">lower1</span>, <span title="A">upper1</span>, <span title="Int">flags1</span><span class="delimiter">)</span>, Below<span class="delimiter">(</span><span title="A">upper2</span>, <span title="Int">uf2</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <a href="#spire.math;Interval.*(74feccc19e).belowBounded" title="(upper1: A, uf1: Int, lower2: A, upper2: A, flags2: Int)Product with Serializable with spire.math.Interval[A]">belowBounded</a><span class="delimiter">(</span><span title="A">upper2</span>, <span title="Int">uf2</span>, <span title="A">lower1</span>, <span title="A">upper1</span>, <span title="Int">flags1</span><span class="delimiter">)</span>

      case <span class="delimiter">(</span><a title="spire.math.Bounded[A]" id="spire.math;Interval.*(74feccc19e).bd1">bd1</a>: <a href="#spire.math.Bounded.readResolve" title="spire.math.Bounded[A]">Bounded</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Bounded[A]" id="spire.math;Interval.*(74feccc19e).bd2">bd2</a>: <a href="#spire.math.Bounded.readResolve" title="spire.math.Bounded[A]">Bounded</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.*(74feccc19e).boundedBounded" title="(bd1: spire.math.Bounded[A], bd2: spire.math.Bounded[A])spire.math.Interval[A]">boundedBounded</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(74feccc19e).bd1" title="spire.math.Bounded[A]">bd1</a>, <a href="#spire.math;Interval.*(74feccc19e).bd2" title="spire.math.Bounded[A]">bd2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(implicit ev: spire.algebra.Field[A])spire.math.Interval[A]" id="spire.math;Interval.reciprocal">reciprocal</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.math;Interval.reciprocal.ev">ev</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="A" id="spire.math;Interval.reciprocal.z">z</a> = <a href="#spire.math;Interval.reciprocal.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a>
    def <a title="=&gt; Nothing" id="spire.math;Interval.reciprocal.error">error</a> = throw new java.lang.<span title="ArithmeticException">ArithmeticException</span><span class="delimiter">(</span><span title="String(&quot;/ by zero&quot;)" class="string">&quot;/ by zero&quot;</span><span class="delimiter">)</span>

    this match <span class="delimiter">{</span>
      case All<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.reciprocal.error" title="=&gt; Nothing">error</a>
      case Empty<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; this

      case Above<span class="delimiter">(</span><span title="A">lower</span>, <a title="Int" id="spire.math;Interval.reciprocal.lf">lf</a><span class="delimiter">)</span> =&gt;
        <span title="(_1: Int, _2: Boolean)(Int, Boolean)" class="delimiter">(</span><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower</a>.compare<a href="../algebra/Order.scala.html#spire.algebra;Order.compare" title="(x: A, y: A)Int" class="delimiter">(</a><a href="#spire.math;Interval.reciprocal.z" title="A">z</a><span class="delimiter">)</span>, <a href="#spire.math;Interval.isClosedLower" title="(flags: Int)Boolean">isClosedLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.reciprocal.lf" title="Int">lf</a><span class="delimiter">)</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case <span class="delimiter">(</span><span title="Int">x</span>, _<span class="delimiter">)</span> if <span title="Int">x</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> =&gt; <a href="#spire.math;Interval.reciprocal.error" title="=&gt; Nothing">error</a> <span class="comment">// crosses zero</span>
          case <span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, true<span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.reciprocal.error" title="=&gt; Nothing">error</a> <span class="comment">// contains zero</span>
          case <span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, false<span class="delimiter">)</span> =&gt; this
          case _ =&gt; <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.reciprocal.z" title="A">z</a>, <a href="#spire.math;Interval.reciprocal.ev" title="spire.algebra.Field[A]">lower</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.reciprocal" title="(x: A)A">reciprocal</a>, <span title="Int(1)" class="int">1</span> <span title="(x: Int)Int">|</span> <a href="#spire.math;Interval.lowerFlagToUpper" title="(flags: Int)Int">lowerFlagToUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.reciprocal.lf" title="Int">lf</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

      case Below<span class="delimiter">(</span><span title="A">upper</span>, <a title="Int" id="spire.math;Interval.reciprocal.uf">uf</a><span class="delimiter">)</span> =&gt;
        <span title="(_1: Int, _2: Boolean)(Int, Boolean)" class="delimiter">(</span><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper</a>.compare<a href="../algebra/Order.scala.html#spire.algebra;Order.compare" title="(x: A, y: A)Int" class="delimiter">(</a><a href="#spire.math;Interval.reciprocal.z" title="A">z</a><span class="delimiter">)</span>, <a href="#spire.math;Interval.isClosedUpper" title="(flags: Int)Boolean">isClosedUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.reciprocal.uf" title="Int">uf</a><span class="delimiter">)</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case <span class="delimiter">(</span><span title="Int">x</span>, _<span class="delimiter">)</span> if <span title="Int">x</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> =&gt; <a href="#spire.math;Interval.reciprocal.error" title="=&gt; Nothing">error</a> <span class="comment">// crosses zero</span>
          case <span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, true<span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.reciprocal.error" title="=&gt; Nothing">error</a> <span class="comment">// contains zero</span>
          case <span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, false<span class="delimiter">)</span> =&gt; this
          case _ =&gt; <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.reciprocal.ev" title="spire.algebra.Field[A]">upper</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.reciprocal" title="(x: A)A">reciprocal</a>, <a href="#spire.math;Interval.reciprocal.z" title="A">z</a>, <span title="Int(2)" class="int">2</span> <span title="(x: Int)Int">|</span> <a href="#spire.math;Interval.upperFlagToLower" title="(flags: Int)Int">upperFlagToLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.reciprocal.uf" title="Int">uf</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

      case Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.reciprocal.v">v</a><span class="delimiter">)</span> =&gt; <a href="#spire.math.Point.readResolve" title="(value: A)(implicit evidence$6: spire.algebra.Order[A])spire.math.Point[A]">Point</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.reciprocal.ev" title="spire.algebra.Field[A]">v</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.reciprocal" title="(x: A)A">reciprocal</a><span class="delimiter">)</span>

      case Bounded<span class="delimiter">(</span><span title="A">lower</span>, <span title="A">upper</span>, <a title="Int" id="spire.math;Interval.reciprocal.flags">flags</a><span class="delimiter">)</span> =&gt;
        <span title="(_1: Int, _2: Int, _3: Boolean, _4: Boolean)(Int, Int, Boolean, Boolean)" class="delimiter">(</span><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">lower</a>.compare<a href="../algebra/Order.scala.html#spire.algebra;Order.compare" title="(x: A, y: A)Int" class="delimiter">(</a><a href="#spire.math;Interval.reciprocal.z" title="A">z</a><span class="delimiter">)</span>, <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">upper</a>.compare<a href="../algebra/Order.scala.html#spire.algebra;Order.compare" title="(x: A, y: A)Int" class="delimiter">(</a><a href="#spire.math;Interval.reciprocal.z" title="A">z</a><span class="delimiter">)</span>, <a href="#spire.math;Interval.isClosedLower" title="(flags: Int)Boolean">isClosedLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.reciprocal.flags" title="Int">flags</a><span class="delimiter">)</span>, <a href="#spire.math;Interval.isClosedUpper" title="(flags: Int)Boolean">isClosedUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.reciprocal.flags" title="Int">flags</a><span class="delimiter">)</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case <span class="delimiter">(</span><span title="Int">x</span>, <a title="Int" id="spire.math;Interval.reciprocal.y">y</a>, _, _<span class="delimiter">)</span> if <span title="Int">x</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Interval.reciprocal.y" title="Int">y</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> =&gt; <a href="#spire.math;Interval.reciprocal.error" title="=&gt; Nothing">error</a> <span class="comment">// crosses zero</span>
          case <span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, _, true, _<span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.reciprocal.error" title="=&gt; Nothing">error</a> <span class="comment">// contains zero</span>
          case <span class="delimiter">(</span>_, <span title="Int(0)" class="int">0</span>, _, true<span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.reciprocal.error" title="=&gt; Nothing">error</a> <span class="comment">// contains zero</span>
          case <span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, _, false, _<span class="delimiter">)</span> =&gt; <a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.reciprocal.ev" title="spire.algebra.Field[A]">upper</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.reciprocal" title="(x: A)A">reciprocal</a>, <a href="#spire.math;Interval.upperFlagToLower" title="(flags: Int)Int">upperFlagToLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.reciprocal.flags" title="Int">flags</a><span class="delimiter">)</span><span class="delimiter">)</span>
          case <span class="delimiter">(</span>_, <span title="Int(0)" class="int">0</span>, _, false<span class="delimiter">)</span> =&gt; <a href="#spire.math.Below.readResolve" title="(upper: A, flags: Int)(implicit evidence$4: spire.algebra.Order[A])spire.math.Below[A]">Below</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.reciprocal.ev" title="spire.algebra.Field[A]">lower</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.reciprocal" title="(x: A)A">reciprocal</a>, <a href="#spire.math;Interval.lowerFlagToUpper" title="(flags: Int)Int">lowerFlagToUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.reciprocal.flags" title="Int">flags</a><span class="delimiter">)</span><span class="delimiter">)</span>
          case _ =&gt; <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.reciprocal.ev" title="spire.algebra.Field[A]">upper</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.reciprocal" title="(x: A)A">reciprocal</a>, <a href="#spire.math;Interval.reciprocal.ev" title="spire.algebra.Field[A]">lower</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.reciprocal" title="(x: A)A">reciprocal</a>, <a href="#spire.math;Interval.swapFlags" title="(flags: Int)Int">swapFlags</a><span class="delimiter">(</span><a href="#spire.math;Interval.reciprocal.flags" title="Int">flags</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(rhs: spire.math.Interval[A])(implicit ev: spire.algebra.Field[A])spire.math.Interval[A]" id="spire.math;Interval./(813d23b02c)">/</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval./(813d23b02c).rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.math;Interval./(813d23b02c).ev">ev</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <span title="(_1: spire.math.Interval[A], _2: spire.math.Interval[A])(spire.math.Interval[A], spire.math.Interval[A])" class="delimiter">(</span><a href="#spire.math;Interval" title="spire.math.Interval[A]">lhs</a>, <a href="#spire.math;Interval./(813d23b02c).rhs" title="spire.math.Interval[A]">rhs</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case <span class="delimiter">(</span>Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval./(813d23b02c).lv">lv</a><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval./(813d23b02c).rhs" title="spire.math.Interval[A]">rhs</a>.<a href="#spire.math;Interval.reciprocal" title="(implicit ev: spire.algebra.Field[A])spire.math.Interval[A]">reciprocal</a> <a href="#spire.math;Interval.*(4c77ef3e75)" title="(rhs: A)(implicit ev: spire.algebra.Semiring[A])spire.math.Interval[A]">*</a> <a href="#spire.math;Interval./(813d23b02c).lv" title="A">lv</a>
      case <span class="delimiter">(</span>_, Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval./(813d23b02c).rv">rv</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.*(4c77ef3e75)" title="(rhs: A)(implicit ev: spire.algebra.Semiring[A])spire.math.Interval[A]">*</a> <span class="delimiter">(</span><a href="#spire.math;Interval./(813d23b02c).ev" title="spire.algebra.Field[A]">rv</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.reciprocal" title="(x: A)A">reciprocal</a><span class="delimiter">)</span>
      case <span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.*(74feccc19e)" title="(rhs: spire.math.Interval[A])(implicit ev: spire.algebra.Semiring[A])spire.math.Interval[A]">*</a> <a href="#spire.math;Interval./(813d23b02c).rhs" title="spire.math.Interval[A]">rhs</a>.<a href="#spire.math;Interval.reciprocal" title="(implicit ev: spire.algebra.Field[A])spire.math.Interval[A]">reciprocal</a>
    <span class="delimiter">}</span>

  def <a title="(rhs: A)(implicit ev: spire.algebra.Field[A])spire.math.Interval[A]" id="spire.math;Interval./(3775dc880d)">/</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval./(3775dc880d).rhs">rhs</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.math;Interval./(3775dc880d).ev">ev</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.*(4c77ef3e75)" title="(rhs: A)(implicit ev: spire.algebra.Semiring[A])spire.math.Interval[A]">*</a> <a href="#spire.math;Interval./(3775dc880d).ev" title="spire.algebra.Field[A]">rhs</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.reciprocal" title="(x: A)A">reciprocal</a>

  def <a title="(rhs: A)(implicit ev: spire.algebra.AdditiveSemigroup[A])spire.math.Interval[A]" id="spire.math;Interval.+(b41b565b7a)">+</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.+(b41b565b7a).rhs">rhs</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveSemigroup[A]" id="spire.math;Interval.+(b41b565b7a).ev">ev</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup" title="spire.algebra.AdditiveSemigroup[A]">AdditiveSemigroup</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    this match <span class="delimiter">{</span>
      case Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.+(b41b565b7a).v">v</a><span class="delimiter">)</span> =&gt; <a href="#spire.math.Point.readResolve" title="(value: A)(implicit evidence$6: spire.algebra.Order[A])spire.math.Point[A]">Point</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.+(b41b565b7a).ev" title="spire.algebra.AdditiveSemigroup[A]">v</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+</a> <a href="#spire.math;Interval.+(b41b565b7a).rhs" title="A">rhs</a><span class="delimiter">)</span>
      case Bounded<span class="delimiter">(</span><span title="A">l</span>, <span title="A">u</span>, <a title="Int" id="spire.math;Interval.+(b41b565b7a).flags">flags</a><span class="delimiter">)</span> =&gt; <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.+(b41b565b7a).ev" title="spire.algebra.AdditiveSemigroup[A]">l</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+</a> <a href="#spire.math;Interval.+(b41b565b7a).rhs" title="A">rhs</a>, <a href="#spire.math;Interval.+(b41b565b7a).ev" title="spire.algebra.AdditiveSemigroup[A]">u</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+</a> <a href="#spire.math;Interval.+(b41b565b7a).rhs" title="A">rhs</a>, <a href="#spire.math;Interval.+(b41b565b7a).flags" title="Int">flags</a><span class="delimiter">)</span>
      case Above<span class="delimiter">(</span><span title="A">l</span>, <a title="Int" id="spire.math;Interval.+(b41b565b7a).lf">lf</a><span class="delimiter">)</span> =&gt; <a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.+(b41b565b7a).ev" title="spire.algebra.AdditiveSemigroup[A]">l</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+</a> <a href="#spire.math;Interval.+(b41b565b7a).rhs" title="A">rhs</a>, <a href="#spire.math;Interval.+(b41b565b7a).lf" title="Int">lf</a><span class="delimiter">)</span>
      case Below<span class="delimiter">(</span><span title="A">u</span>, <a title="Int" id="spire.math;Interval.+(b41b565b7a).uf">uf</a><span class="delimiter">)</span> =&gt; <a href="#spire.math.Below.readResolve" title="(upper: A, flags: Int)(implicit evidence$4: spire.algebra.Order[A])spire.math.Below[A]">Below</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.+(b41b565b7a).ev" title="spire.algebra.AdditiveSemigroup[A]">u</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+</a> <a href="#spire.math;Interval.+(b41b565b7a).rhs" title="A">rhs</a>, <a href="#spire.math;Interval.+(b41b565b7a).uf" title="Int">uf</a><span class="delimiter">)</span>
      case All<span class="delimiter">(</span><span class="delimiter">)</span> | Empty<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; this
    <span class="delimiter">}</span>

  def <a title="(rhs: A)(implicit ev: spire.algebra.AdditiveGroup[A])spire.math.Interval[A]" id="spire.math;Interval.-(09fb718b1b)">-</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.-(09fb718b1b).rhs">rhs</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveGroup[A]" id="spire.math;Interval.-(09fb718b1b).ev">ev</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup" title="spire.algebra.AdditiveGroup[A]">AdditiveGroup</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    this <a href="#spire.math;Interval.+(b41b565b7a)" title="(rhs: A)(implicit ev: spire.algebra.AdditiveSemigroup[A])spire.math.Interval[A]">+</a> <span class="delimiter">(</span><a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: A)A">-</a><a href="#spire.math;Interval.-(09fb718b1b).ev" title="spire.algebra.AdditiveGroup[A]">rhs</a><span class="delimiter">)</span>

  def <a title="()(implicit ev: spire.algebra.AdditiveGroup[A])spire.math.Interval[A]" id="spire.math;Interval.unary_-">unary_-</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveGroup[A]" id="spire.math;Interval.unary_-.ev">ev</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup" title="spire.algebra.AdditiveGroup[A]">AdditiveGroup</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    this match <span class="delimiter">{</span>
      case Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.unary_-.v">v</a><span class="delimiter">)</span> =&gt; <a href="#spire.math.Point.readResolve" title="(value: A)(implicit evidence$6: spire.algebra.Order[A])spire.math.Point[A]">Point</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: A)A">-</a><a href="#spire.math;Interval.unary_-.ev" title="spire.algebra.AdditiveGroup[A]">v</a><span class="delimiter">)</span>
      case Bounded<span class="delimiter">(</span><span title="A">l</span>, <span title="A">u</span>, <a title="Int" id="spire.math;Interval.unary_-.f">f</a><span class="delimiter">)</span> =&gt; <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: A)A">-</a><a href="#spire.math;Interval.unary_-.ev" title="spire.algebra.AdditiveGroup[A]">u</a>, <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: A)A">-</a><a href="#spire.math;Interval.unary_-.ev" title="spire.algebra.AdditiveGroup[A]">l</a>, <a href="#spire.math;Interval.swapFlags" title="(flags: Int)Int">swapFlags</a><span class="delimiter">(</span><a href="#spire.math;Interval.unary_-.f" title="Int">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case Above<span class="delimiter">(</span><span title="A">l</span>, <a title="Int" id="spire.math;Interval.unary_-.lf">lf</a><span class="delimiter">)</span> =&gt; <a href="#spire.math.Below.readResolve" title="(upper: A, flags: Int)(implicit evidence$4: spire.algebra.Order[A])spire.math.Below[A]">Below</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: A)A">-</a><a href="#spire.math;Interval.unary_-.ev" title="spire.algebra.AdditiveGroup[A]">l</a>, <a href="#spire.math;Interval.lowerFlagToUpper" title="(flags: Int)Int">lowerFlagToUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.unary_-.lf" title="Int">lf</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case Below<span class="delimiter">(</span><span title="A">u</span>, <a title="Int" id="spire.math;Interval.unary_-.uf">uf</a><span class="delimiter">)</span> =&gt; <a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: A)A">-</a><a href="#spire.math;Interval.unary_-.ev" title="spire.algebra.AdditiveGroup[A]">u</a>, <a href="#spire.math;Interval.upperFlagToLower" title="(flags: Int)Int">upperFlagToLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.unary_-.uf" title="Int">uf</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case All<span class="delimiter">(</span><span class="delimiter">)</span> | Empty<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; this
    <span class="delimiter">}</span>

  def <a title="(rhs: A)(implicit ev: spire.algebra.Semiring[A])spire.math.Interval[A]" id="spire.math;Interval.*(4c77ef3e75)">*</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.*(4c77ef3e75).rhs">rhs</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Semiring[A]" id="spire.math;Interval.*(4c77ef3e75).ev">ev</a>: <a href="../algebra/Semiring.scala.html#spire.algebra;Semiring" title="spire.algebra.Semiring[A]">Semiring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">rhs</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math;Interval.*(4c77ef3e75).ev" title="spire.algebra.Semiring[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      this match <span class="delimiter">{</span>
        case Point<span class="delimiter">(</span><span title="A">v</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Point.readResolve" title="(value: A)(implicit evidence$6: spire.algebra.Order[A])spire.math.Point[A]">Point</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(4c77ef3e75).ev" title="spire.algebra.Semiring[A]">v</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(4c77ef3e75).rhs" title="A">rhs</a><span class="delimiter">)</span>
        case Bounded<span class="delimiter">(</span><span title="A">l</span>, <span title="A">u</span>, <a title="Int" id="spire.math;Interval.*(4c77ef3e75).f">f</a><span class="delimiter">)</span> =&gt; <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(4c77ef3e75).ev" title="spire.algebra.Semiring[A]">u</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(4c77ef3e75).rhs" title="A">rhs</a>, <a href="#spire.math;Interval.*(4c77ef3e75).ev" title="spire.algebra.Semiring[A]">l</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(4c77ef3e75).rhs" title="A">rhs</a>, <a href="#spire.math;Interval.swapFlags" title="(flags: Int)Int">swapFlags</a><span class="delimiter">(</span><a href="#spire.math;Interval.*(4c77ef3e75).f" title="Int">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case Above<span class="delimiter">(</span><span title="A">l</span>, <span title="Int">lf</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Below.readResolve" title="(upper: A, flags: Int)(implicit evidence$4: spire.algebra.Order[A])spire.math.Below[A]">Below</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(4c77ef3e75).ev" title="spire.algebra.Semiring[A]">l</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(4c77ef3e75).rhs" title="A">rhs</a>, <a href="#spire.math;Interval.lowerFlagToUpper" title="(flags: Int)Int">lowerFlagToUpper</a><span class="delimiter">(</span><span title="Int">lf</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case Below<span class="delimiter">(</span><span title="A">u</span>, <span title="Int">uf</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(4c77ef3e75).ev" title="spire.algebra.Semiring[A]">u</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(4c77ef3e75).rhs" title="A">rhs</a>, <a href="#spire.math;Interval.upperFlagToLower" title="(flags: Int)Int">upperFlagToLower</a><span class="delimiter">(</span><span title="Int">uf</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case All<span class="delimiter">(</span><span class="delimiter">)</span> | Empty<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; this
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">rhs</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: A, y: A)Boolean">===</a> <a href="#spire.math;Interval.*(4c77ef3e75).ev" title="spire.algebra.Semiring[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.zero" title="(implicit o: spire.algebra.Order[A], implicit r: spire.algebra.Semiring[A])spire.math.Interval[A]">zero</a>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      this match <span class="delimiter">{</span>
        case Point<span class="delimiter">(</span><span title="A">v</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Point.readResolve" title="(value: A)(implicit evidence$6: spire.algebra.Order[A])spire.math.Point[A]">Point</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(4c77ef3e75).ev" title="spire.algebra.Semiring[A]">v</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(4c77ef3e75).rhs" title="A">rhs</a><span class="delimiter">)</span>
        case Bounded<span class="delimiter">(</span><span title="A">l</span>, <span title="A">u</span>, <a title="Int" id="spire.math;Interval.*(4c77ef3e75).flags">flags</a><span class="delimiter">)</span> =&gt; <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(4c77ef3e75).ev" title="spire.algebra.Semiring[A]">l</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(4c77ef3e75).rhs" title="A">rhs</a>, <a href="#spire.math;Interval.*(4c77ef3e75).ev" title="spire.algebra.Semiring[A]">u</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(4c77ef3e75).rhs" title="A">rhs</a>, <a href="#spire.math;Interval.*(4c77ef3e75).flags" title="Int">flags</a><span class="delimiter">)</span>
        case Above<span class="delimiter">(</span><span title="A">l</span>, <span title="Int">lf</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(4c77ef3e75).ev" title="spire.algebra.Semiring[A]">l</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(4c77ef3e75).rhs" title="A">rhs</a>, <span title="Int">lf</span><span class="delimiter">)</span>
        case Below<span class="delimiter">(</span><span title="A">u</span>, <span title="Int">uf</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Below.readResolve" title="(upper: A, flags: Int)(implicit evidence$4: spire.algebra.Order[A])spire.math.Below[A]">Below</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.*(4c77ef3e75).ev" title="spire.algebra.Semiring[A]">u</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.math;Interval.*(4c77ef3e75).rhs" title="A">rhs</a>, <span title="Int">uf</span><span class="delimiter">)</span>
        case All<span class="delimiter">(</span><span class="delimiter">)</span> | Empty<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; this
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  def <a title="(k: Int)(implicit r: spire.algebra.Ring[A])spire.math.Interval[A]" id="spire.math;Interval.pow">pow</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.pow.k">k</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.math;Interval.pow.r">r</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(b: spire.math.Interval[A], k: Int, extra: spire.math.Interval[A])spire.math.Interval[A]" id="spire.math;Interval.pow.loop">loop</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.pow.loop.b">b</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Int" id="spire.math;Interval.pow.loop.k">k</a>: <span title="Int">Int</span>, <a title="spire.math.Interval[A]" id="spire.math;Interval.pow.loop.extra">extra</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#spire.math;Interval.pow.loop.k" title="Int">k</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
        <a href="#spire.math;Interval.pow.loop.b" title="spire.math.Interval[A]">b</a> <a href="#spire.math;Interval.*(74feccc19e)" title="(rhs: spire.math.Interval[A])(implicit ev: spire.algebra.Semiring[A])spire.math.Interval[A]">*</a> <a href="#spire.math;Interval.pow.loop.extra" title="spire.math.Interval[A]">extra</a>
      else
        <a href="#spire.math;Interval.pow.loop" title="(b: spire.math.Interval[A], k: Int, extra: spire.math.Interval[A])spire.math.Interval[A]">loop</a><span class="delimiter">(</span><a href="#spire.math;Interval.pow.loop.b" title="spire.math.Interval[A]">b</a> <a href="#spire.math;Interval.*(74feccc19e)" title="(rhs: spire.math.Interval[A])(implicit ev: spire.algebra.Semiring[A])spire.math.Interval[A]">*</a> <a href="#spire.math;Interval.pow.loop.b" title="spire.math.Interval[A]">b</a>, <a href="#spire.math;Interval.pow.loop.k" title="Int">k</a> <span title="(x: Int)Int">&gt;&gt;&gt;</span> <span title="Int(1)" class="int">1</span>, if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math;Interval.pow.loop.k" title="Int">k</a> <span title="(x: Int)Int">&amp;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#spire.math;Interval.pow.loop.b" title="spire.math.Interval[A]">b</a> <a href="#spire.math;Interval.*(74feccc19e)" title="(rhs: spire.math.Interval[A])(implicit ev: spire.algebra.Semiring[A])spire.math.Interval[A]">*</a> <a href="#spire.math;Interval.pow.loop.extra" title="spire.math.Interval[A]">extra</a> else <a href="#spire.math;Interval.pow.loop.extra" title="spire.math.Interval[A]">extra</a><span class="delimiter">)</span>

    if <span class="delimiter">(</span><a href="#spire.math;Interval.pow.k" title="Int">k</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      throw new <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;negative exponent: &quot;)">negative exponent: $</span><a href="#spire.math;Interval.pow.k" title="Int">k</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.math;Interval.pow.k" title="Int">k</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.point" title="(a: A)(implicit evidence$9: spire.algebra.Order[A])spire.math.Interval[A]">point</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.pow.r" title="spire.algebra.Ring[A]">r</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; A">one</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.math;Interval.pow.k" title="Int">k</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      this
    <span class="delimiter">}</span> else if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math;Interval.pow.k" title="Int">k</a> <span title="(x: Int)Int">&amp;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="spire.math.Interval[A]" id="spire.math;Interval.pow.t">t</a> = <a href="#spire.math;Interval.abs" title="(implicit m: spire.algebra.AdditiveGroup[A])spire.math.Interval[A]">abs</a>
      <a href="#spire.math;Interval.pow.loop" title="(b: spire.math.Interval[A], k: Int, extra: spire.math.Interval[A])spire.math.Interval[A]">loop</a><span class="delimiter">(</span><a href="#spire.math;Interval.pow.t" title="spire.math.Interval[A]">t</a>, <a href="#spire.math;Interval.pow.k" title="Int">k</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>, <a href="#spire.math;Interval.pow.t" title="spire.math.Interval[A]">t</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <a href="#spire.math;Interval.pow.loop" title="(b: spire.math.Interval[A], k: Int, extra: spire.math.Interval[A])spire.math.Interval[A]">loop</a><span class="delimiter">(</span>this, <a href="#spire.math;Interval.pow.k" title="Int">k</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>, this<span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(k: Int)(implicit r: spire.algebra.Ring[A], implicit n: spire.algebra.NRoot[A])spire.math.Interval[A]" id="spire.math;Interval.nroot">nroot</a><span class="delimiter">(</span><a title="Int" id="spire.math;Interval.nroot.k">k</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.math;Interval.nroot.r">r</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[A]" id="spire.math;Interval.nroot.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[A]">NRoot</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.math;Interval.nroot.k" title="Int">k</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      this
    <span class="delimiter">}</span> else if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math;Interval.nroot.k" title="Int">k</a> <span title="(x: Int)Int">&amp;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Interval.hasBelow" title="(t: A)Boolean">hasBelow</a><span class="delimiter">(</span><a href="#spire.math;Interval.nroot.r" title="spire.algebra.Ring[A]">r</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      throw new <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="String(&quot;can\'t take even root of negative number&quot;)" class="string">&quot;can't take even root of negative number&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      this match <span class="delimiter">{</span>
        case All<span class="delimiter">(</span><span class="delimiter">)</span> | Empty<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; this
        case Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.nroot.v">v</a><span class="delimiter">)</span> =&gt; <a href="#spire.math.Point.readResolve" title="(value: A)(implicit evidence$6: spire.algebra.Order[A])spire.math.Point[A]">Point</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.nroot.n" title="spire.algebra.NRoot[A]">v</a>.nroot<a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.nroot" title="(a: A, n: Int)A" class="delimiter">(</a><a href="#spire.math;Interval.nroot.k" title="Int">k</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case Above<span class="delimiter">(</span><span title="A">l</span>, <a title="Int" id="spire.math;Interval.nroot.lf">lf</a><span class="delimiter">)</span> =&gt; <a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.nroot.n" title="spire.algebra.NRoot[A]">l</a>.nroot<a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.nroot" title="(a: A, n: Int)A" class="delimiter">(</a><a href="#spire.math;Interval.nroot.k" title="Int">k</a><span class="delimiter">)</span>, <a href="#spire.math;Interval.nroot.lf" title="Int">lf</a><span class="delimiter">)</span>
        case Below<span class="delimiter">(</span><span title="A">u</span>, <a title="Int" id="spire.math;Interval.nroot.uf">uf</a><span class="delimiter">)</span> =&gt; <a href="#spire.math.Below.readResolve" title="(upper: A, flags: Int)(implicit evidence$4: spire.algebra.Order[A])spire.math.Below[A]">Below</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.nroot.n" title="spire.algebra.NRoot[A]">u</a>.nroot<a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.nroot" title="(a: A, n: Int)A" class="delimiter">(</a><a href="#spire.math;Interval.nroot.k" title="Int">k</a><span class="delimiter">)</span>, <a href="#spire.math;Interval.nroot.uf" title="Int">uf</a><span class="delimiter">)</span>
        case Bounded<span class="delimiter">(</span><span title="A">l</span>, <span title="A">u</span>, <a title="Int" id="spire.math;Interval.nroot.flags">flags</a><span class="delimiter">)</span> =&gt; <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.nroot.n" title="spire.algebra.NRoot[A]">l</a>.nroot<a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.nroot" title="(a: A, n: Int)A" class="delimiter">(</a><a href="#spire.math;Interval.nroot.k" title="Int">k</a><span class="delimiter">)</span>, <a href="#spire.math;Interval.nroot.n" title="spire.algebra.NRoot[A]">u</a>.nroot<a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.nroot" title="(a: A, n: Int)A" class="delimiter">(</a><a href="#spire.math;Interval.nroot.k" title="Int">k</a><span class="delimiter">)</span>, <a href="#spire.math;Interval.nroot.flags" title="Int">flags</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(implicit r: spire.algebra.Ring[A], implicit n: spire.algebra.NRoot[A])spire.math.Interval[A]" id="spire.math;Interval.sqrt">sqrt</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.math;Interval.sqrt.r">r</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[A]" id="spire.math;Interval.sqrt.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[A]">NRoot</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;Interval.nroot" title="(k: Int)(implicit r: spire.algebra.Ring[A], implicit n: spire.algebra.NRoot[A])spire.math.Interval[A]">nroot</a><a href="#spire.math;Interval.sqrt.r" title="spire.algebra.Ring[A]" class="delimiter">(</a><span title="Int(2)" class="int">2</span><span class="delimiter">)</span>

  def <a title="(epsilon: A)(implicit r: spire.algebra.AdditiveGroup[A])Option[A]" id="spire.math;Interval.top">top</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.top.epsilon">epsilon</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveGroup[A]" id="spire.math;Interval.top.r">r</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup" title="spire.algebra.AdditiveGroup[A]">AdditiveGroup</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    this match <span class="delimiter">{</span>
      case Empty<span class="delimiter">(</span><span class="delimiter">)</span> | All<span class="delimiter">(</span><span class="delimiter">)</span> | Above<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
        <span title="None.type">None</span> <span class="comment">// TOCHECK: changed semantics, Empty().top == None</span>
      case Below<span class="delimiter">(</span><span title="A">upper</span>, <a title="Int" id="spire.math;Interval.top.uf">uf</a><span class="delimiter">)</span> =&gt;
        <span title="(x: A)Some[A]">Some</span><span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#spire.math;Interval.isOpenUpper" title="(flags: Int)Boolean">isOpenUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.top.uf" title="Int">uf</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#spire.math;Interval.top.r" title="spire.algebra.AdditiveGroup[A]">upper</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: A, y: A)A">-</a> <a href="#spire.math;Interval.top.epsilon" title="A">epsilon</a> else <span title="A">upper</span><span class="delimiter">)</span>
      case Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.top.v">v</a><span class="delimiter">)</span> =&gt;
        <span title="(x: A)Some[A]">Some</span><span class="delimiter">(</span><a href="#spire.math;Interval.top.v" title="A">v</a><span class="delimiter">)</span>
      case Bounded<span class="delimiter">(</span>_, <span title="A">upper</span>, <a title="Int" id="spire.math;Interval.top.flags">flags</a><span class="delimiter">)</span> =&gt;
        <span title="(x: A)Some[A]">Some</span><span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#spire.math;Interval.isOpenUpper" title="(flags: Int)Boolean">isOpenUpper</a><span class="delimiter">(</span><a href="#spire.math;Interval.top.flags" title="Int">flags</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#spire.math;Interval.top.r" title="spire.algebra.AdditiveGroup[A]">upper</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: A, y: A)A">-</a> <a href="#spire.math;Interval.top.epsilon" title="A">epsilon</a> else <span title="A">upper</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  def <a title="(min: A, epsilon: A)(implicit r: spire.algebra.AdditiveGroup[A])Option[A]" id="spire.math;Interval.bottom">bottom</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.bottom.min">min</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="A" id="spire.math;Interval.bottom.epsilon">epsilon</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveGroup[A]" id="spire.math;Interval.bottom.r">r</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup" title="spire.algebra.AdditiveGroup[A]">AdditiveGroup</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    this match <span class="delimiter">{</span>
      case Empty<span class="delimiter">(</span><span class="delimiter">)</span> | All<span class="delimiter">(</span><span class="delimiter">)</span> | Below<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
        <span title="None.type">None</span> <span class="comment">// TOCHECK: changed semantics, Empty().bottom == None</span>
      case Above<span class="delimiter">(</span><span title="A">lower</span>, <a title="Int" id="spire.math;Interval.bottom.lf">lf</a><span class="delimiter">)</span> =&gt;
        <span title="(x: A)Some[A]">Some</span><span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#spire.math;Interval.isOpenLower" title="(flags: Int)Boolean">isOpenLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.bottom.lf" title="Int">lf</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#spire.math;Interval.bottom.r" title="spire.algebra.AdditiveGroup[A]">lower</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+</a> <a href="#spire.math;Interval.bottom.epsilon" title="A">epsilon</a> else <span title="A">lower</span><span class="delimiter">)</span>
      case Point<span class="delimiter">(</span><a title="A" id="spire.math;Interval.bottom.v">v</a><span class="delimiter">)</span> =&gt;
        <span title="(x: A)Some[A]">Some</span><span class="delimiter">(</span><a href="#spire.math;Interval.bottom.v" title="A">v</a><span class="delimiter">)</span>
      case Bounded<span class="delimiter">(</span><span title="A">lower</span>, _, <a title="Int" id="spire.math;Interval.bottom.flags">flags</a><span class="delimiter">)</span> =&gt;
        <span title="(x: A)Some[A]">Some</span><span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#spire.math;Interval.isOpenLower" title="(flags: Int)Boolean">isOpenLower</a><span class="delimiter">(</span><a href="#spire.math;Interval.bottom.flags" title="Int">flags</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#spire.math;Interval.bottom.r" title="spire.algebra.AdditiveGroup[A]">lower</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+</a> <a href="#spire.math;Interval.bottom.epsilon" title="A">epsilon</a> else <span title="A">lower</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  import spire.random.<span class="delimiter">{</span>Dist, Uniform<span class="delimiter">}</span>

  def <a title="(min: A, max: A, epsilon: A)(implicit u: spire.random.Uniform[A], implicit r: spire.algebra.AdditiveGroup[A])spire.random.Dist[A]" id="spire.math;Interval.dist">dist</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.dist.min">min</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="A" id="spire.math;Interval.dist.max">max</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="A" id="spire.math;Interval.dist.epsilon">epsilon</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.random.Uniform[A]" id="spire.math;Interval.dist.u">u</a>: <a href="../random/Uniform.scala.html#spire.random;Uniform" title="spire.random.Uniform[A]">Uniform</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.algebra.AdditiveGroup[A]" id="spire.math;Interval.dist.r">r</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup" title="spire.algebra.AdditiveGroup[A]">AdditiveGroup</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../random/Dist.scala.html#spire.random;Dist" title="spire.random.Dist[A]">Dist</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="../random/Uniform.scala.html#spire.random;Uniform.apply" title="(min: A, max: A)spire.random.Dist[A]">u</a><span class="delimiter">(</span><a href="#spire.math;Interval.bottom" title="(min: A, epsilon: A)(implicit r: spire.algebra.AdditiveGroup[A])Option[A]">bottom</a><a href="#spire.math;Interval.dist.r" title="spire.algebra.AdditiveGroup[A]" class="delimiter">(</a><a href="#spire.math;Interval.dist.min" title="A">min</a>, <a href="#spire.math;Interval.dist.epsilon" title="A">epsilon</a><span class="delimiter">)</span>.<span title="(default: =&gt; A)A">getOrElse</span><span class="delimiter">(</span><a href="#spire.math;Interval.dist.min" title="A">min</a><span class="delimiter">)</span>, <a href="#spire.math;Interval.top" title="(epsilon: A)(implicit r: spire.algebra.AdditiveGroup[A])Option[A]">top</a><a href="#spire.math;Interval.dist.r" title="spire.algebra.AdditiveGroup[A]" class="delimiter">(</a><a href="#spire.math;Interval.dist.epsilon" title="A">epsilon</a><span class="delimiter">)</span>.<span title="(default: =&gt; A)A">getOrElse</span><span class="delimiter">(</span><a href="#spire.math;Interval.dist.max" title="A">max</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Apply the given polynomial to the interval.
   *
   * For every point contained in the interval, this method maps that
   * point through the given polynomial. The resulting interval is the
   * set of all the translated points. I.e.
   * 
   *     result = { p(x) | x ∈ interval }
   * 
   */</span>
  def <a title="(p: spire.math.Polynomial[A])(implicit ev: spire.algebra.Field[A])spire.math.Interval[A]" id="spire.math;Interval.translate">translate</a><span class="delimiter">(</span><a title="spire.math.Polynomial[A]" id="spire.math;Interval.translate.p">p</a>: <a href="Polynomial.scala.html#spire.math;Polynomial" title="spire.math.Polynomial[A]">Polynomial</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.math;Interval.translate.ev">ev</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="List[spire.math.poly.Term[spire.math.Interval[A]]]" id="spire.math;Interval.translate.terms2">terms2</a> = <a href="#spire.math;Interval.translate.p" title="spire.math.Polynomial[A]">p</a>.<a href="Polynomial.scala.html#spire.math;Polynomial.terms" title="(implicit ring: spire.algebra.Semiring[A], implicit eq: spire.algebra.Eq[A])List[spire.math.poly.Term[A]]">terms</a>.<span title="(f: spire.math.poly.Term[A] =&gt; spire.math.poly.Term[spire.math.Interval[A]])(implicit bf: scala.collection.generic.CanBuildFrom[List[spire.math.poly.Term[A]],spire.math.poly.Term[spire.math.Interval[A]],List[spire.math.poly.Term[spire.math.Interval[A]]]])List[spire.math.poly.Term[spire.math.Interval[A]]]">map</span> <a href="#spire.math;Interval.translate.terms2.$anonfun.x0$1" title="spire.math.poly.Term[spire.math.Interval[A]]" class="delimiter">{</a> case Term<span class="delimiter">(</span><a title="A" id="spire.math;Interval.translate.terms2.$anonfun.c">c</a>, <a title="Int" id="spire.math;Interval.translate.terms2.$anonfun.e">e</a><span class="delimiter">)</span> =&gt; <a href="poly/Term.scala.html#spire.math.poly;Term" title="(coeff: spire.math.Interval[A], exp: Int)spire.math.poly.Term[spire.math.Interval[A]]">Term</a><span class="delimiter">(</span><a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.point" title="(a: A)(implicit evidence$9: spire.algebra.Order[A])spire.math.Interval[A]">point</a><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math;Interval.translate.terms2.$anonfun.c" title="A">c</a><span class="delimiter">)</span>, <a href="#spire.math;Interval.translate.terms2.$anonfun.e" title="Int">e</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    val <a title="spire.math.poly.PolySparse[spire.math.Interval[A]]" id="spire.math;Interval.translate.p2">p2</a> = <a href="Polynomial.scala.html#spire.math.Polynomial.apply(c087709903)" title="(terms: Iterable[spire.math.poly.Term[spire.math.Interval[A]]])(implicit evidence$10: spire.algebra.Semiring[spire.math.Interval[A]], implicit evidence$11: spire.algebra.Eq[spire.math.Interval[A]], implicit evidence$12: scala.reflect.ClassTag[spire.math.Interval[A]])spire.math.poly.PolySparse[spire.math.Interval[A]]">Polynomial</a><a href="#spire.math.Interval.semiring" title="(implicit ev: spire.algebra.Ring[A], implicit o: spire.algebra.Order[A])spire.algebra.Semiring[spire.math.Interval[A]]" class="delimiter">(</a><a href="#spire.math;Interval.translate.terms2" title="List[spire.math.poly.Term[spire.math.Interval[A]]]">terms2</a><span class="delimiter">)</span>
    <a href="poly/PolySparse.scala.html#spire.math.poly;PolySparse.apply" title="(x: spire.math.Interval[A])(implicit ring: spire.algebra.Semiring[spire.math.Interval[A]])spire.math.Interval[A]">p2</a><a href="#spire.math.Interval.semiring" title="(implicit ev: spire.algebra.Ring[A], implicit o: spire.algebra.Order[A])spire.algebra.Semiring[spire.math.Interval[A]]" class="delimiter">(</a>this<span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// optional unicode operators</span>

  def <a title="(rhs: A)Boolean" id="spire.math;Interval.∋">∋</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.∋.rhs">rhs</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.contains" title="(t: A)Boolean">contains</a> <a href="#spire.math;Interval.∋.rhs" title="A">rhs</a>
  def <a title="(rhs: A)Boolean" id="spire.math;Interval.∌">∌</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.∌.rhs">rhs</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.contains" title="(t: A)Boolean">contains</a> <a href="#spire.math;Interval.∌.rhs" title="A">rhs</a><span class="delimiter">)</span>
  
  def <a title="(a: A)Boolean" id="spire.math;Interval.∈:">∈:</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.∈:.a">a</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.contains" title="(t: A)Boolean">contains</a> <a href="#spire.math;Interval.∈:.a" title="A">a</a>
  def <a title="(a: A)Boolean" id="spire.math;Interval.∉:">∉:</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.∉:.a">a</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.contains" title="(t: A)Boolean">contains</a> <a href="#spire.math;Interval.∉:.a" title="A">a</a><span class="delimiter">)</span>

  def <a title="(rhs: spire.math.Interval[A])spire.math.Interval[A]" id="spire.math;Interval.∩">∩</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.∩.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.intersect" title="(rhs: spire.math.Interval[A])spire.math.Interval[A]">intersect</a> <a href="#spire.math;Interval.∩.rhs" title="spire.math.Interval[A]">rhs</a>
  def <a title="(rhs: spire.math.Interval[A])spire.math.Interval[A]" id="spire.math;Interval.∪">∪</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.∪.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.union" title="(rhs: spire.math.Interval[A])spire.math.Interval[A]">union</a> <a href="#spire.math;Interval.∪.rhs" title="spire.math.Interval[A]">rhs</a>
  def <a title="(rhs: spire.math.Interval[A])List[spire.math.Interval[A]]" id="spire.math;Interval.\">\</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.\.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[spire.math.Interval[A]]">List</span><span class="delimiter">[</span>Interval<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.--" title="(rhs: spire.math.Interval[A])List[spire.math.Interval[A]]">--</a> <a href="#spire.math;Interval.\.rhs" title="spire.math.Interval[A]">rhs</a>
  
  def <a title="(rhs: spire.math.Interval[A])Boolean" id="spire.math;Interval.⊂">⊂</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.⊂.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.isProperSubsetOf" title="(rhs: spire.math.Interval[A])Boolean">isProperSubsetOf</a> <a href="#spire.math;Interval.⊂.rhs" title="spire.math.Interval[A]">rhs</a>
  def <a title="(rhs: spire.math.Interval[A])Boolean" id="spire.math;Interval.⊃">⊃</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.⊃.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.isProperSupersetOf" title="(rhs: spire.math.Interval[A])Boolean">isProperSupersetOf</a> <a href="#spire.math;Interval.⊃.rhs" title="spire.math.Interval[A]">rhs</a>
  
  def <a title="(rhs: spire.math.Interval[A])Boolean" id="spire.math;Interval.⊆">⊆</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.⊆.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.isSubsetOf" title="(rhs: spire.math.Interval[A])Boolean">isSubsetOf</a> <a href="#spire.math;Interval.⊆.rhs" title="spire.math.Interval[A]">rhs</a>
  def <a title="(rhs: spire.math.Interval[A])Boolean" id="spire.math;Interval.⊇">⊇</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math;Interval.⊇.rhs">rhs</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Interval" title="Interval.this.type">lhs</a> <a href="#spire.math;Interval.isSupersetOf" title="(rhs: spire.math.Interval[A])Boolean">isSupersetOf</a> <a href="#spire.math;Interval.⊇.rhs" title="spire.math.Interval[A]">rhs</a>

  <span class="comment">// xyz</span>

  <span class="comment">// find the &quot;first&quot; value in our iterator. if step is positive we</span>
  <span class="comment">// proceed from the lower bound up, and if negative from the upper</span>
  <span class="comment">// bound down. thus, we always use addition when dealing with the</span>
  <span class="comment">// step.</span>
  private<span class="delimiter">[</span>this<span class="delimiter">]</span> def <a title="(bound: spire.math.interval.Bound[A], step: A, unboundError: String)(implicit ev: spire.algebra.AdditiveMonoid[A])A" id="spire.math;Interval.getStart">getStart</a><span class="delimiter">(</span><a title="spire.math.interval.Bound[A]" id="spire.math;Interval.getStart.bound">bound</a>: <a href="interval/Bound.scala.html#spire.math.interval;Bound" title="spire.math.interval.Bound[A]">Bound</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A" id="spire.math;Interval.getStart.step">step</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="String" id="spire.math;Interval.getStart.unboundError">unboundError</a>: <span title="String">String</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveMonoid[A]" id="spire.math;Interval.getStart.ev">ev</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval;A" title="A">A</a> =
    <a href="#spire.math;Interval.getStart.bound" title="spire.math.interval.Bound[A]">bound</a> match <span class="delimiter">{</span>
      case EmptyBound<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.getStart.ev" title="spire.algebra.AdditiveMonoid[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a>
      case Open<span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.getStart.ev" title="spire.algebra.AdditiveMonoid[A]">x</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+</a> <a href="#spire.math;Interval.getStart.step" title="A">step</a>
      case Closed<span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span> =&gt; <span title="A">x</span>
      case Unbound<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; throw new <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><a href="#spire.math;Interval.getStart.unboundError" title="String">unboundError</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Build an Iterator[A] from an Interval[A] and a (step: A)
   * parameter.
   * 
   * A positive 'step' means we are proceeding from the lower bound
   * up, and a negative 'step' means we are proceeding from the upper
   * bound down. In each case, the interval must be bounded on the
   * side we are starting with (though it may be unbound on the
   * opposite side). A zero 'step' is not allowed.
   * 
   * The step is repeatedly added to the starting parameter as long as
   * the sum remains within the interval. This means that arithmetic
   * error can accumulate (e.g. with doubles). However, this method
   * does overflow checking to ensure that Intervals parameterized on
   * integer types will behave correctly.
   * 
   * Users who want to avoid using arithmetic error should consider
   * starting with an Interval[Rational], calling iterator with the
   * exact step desired, then mapping to the original type
   * (e.g. Double). For example:
   * 
   *     val ns = Interval.closed(Rational(0), Rational(5))
   *     val it = ns.iterator(Rational(1, 7)).map(_.toDouble)
   * 
   * This method provides some of the same functionality as Scala's
   * NumericRange class.
   */</span>
  def <a title="(step: A)(implicit ev: spire.algebra.AdditiveMonoid[A], implicit nt: spire.math.NumberTag[A])Iterator[A]" id="spire.math;Interval.iterator">iterator</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.iterator.step">step</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveMonoid[A]" id="spire.math;Interval.iterator.ev">ev</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.NumberTag[A]" id="spire.math;Interval.iterator.nt">nt</a>: <a href="NumberTag.scala.html#spire.math;NumberTag" title="spire.math.NumberTag[A]">NumberTag</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>

    <span class="comment">// build an iterator, using start, step, and continue.</span>
    <span class="comment">// this can be used in cases where we don't have to worry about</span>
    <span class="comment">// overflow (e.g. Double, or Rational).</span>
    def <a title="(start: A, continue: A =&gt; Boolean)Iterator[A]" id="spire.math;Interval.iterator.iter0">iter0</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.iterator.iter0.start">start</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="A =&gt; Boolean" id="spire.math;Interval.iterator.iter0.continue">continue</a>: A =&gt; Boolean<span class="delimiter">)</span>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span> =
      new <a title="&lt;$anon: Iterator[A]&gt; extends AnyRef with Iterator[A]" id="spire.math;Interval.iterator.iter0;$anon">Iterator</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
        var <a title="A" id="spire.math;Interval.iterator.iter0;$anon.x_=">x</a>: <a href="#spire.math;Interval;A" title="A">A</a> = <a href="#spire.math;Interval.iterator.iter0.start" title="A">start</a>
        def <a title="=&gt; Boolean" id="spire.math;Interval.iterator.iter0;$anon.hasNext">hasNext</a>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Interval.iterator.iter0.continue" title="(v1: A)Boolean">continue</a><span class="delimiter">(</span><a href="#spire.math;Interval.iterator.iter0;$anon.x_=" title="=&gt; A">x</a><span class="delimiter">)</span>
        def <a title="()A" id="spire.math;Interval.iterator.iter0;$anon.next">next</a>: <a href="#spire.math;Interval;A" title="A">A</a> = <span class="delimiter">{</span>
          val <a title="A" id="spire.math;Interval.iterator.iter0;$anon.next.r">r</a> = <a href="#spire.math;Interval.iterator.iter0;$anon.x_=" title="=&gt; A">x</a>
          <a href="#spire.math;Interval.iterator.iter0;$anon.x_=" title="(x$1: A)Unit">x</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+=</a> <a href="#spire.math;Interval.iterator.step" title="A">step</a>
          <a href="#spire.math;Interval.iterator.iter0;$anon.next.r" title="A">r</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

    <span class="comment">// build an iterator, using start, step, continue, and test.</span>
    <span class="comment">// test is used to detect overflow in cases where it can happen.</span>
    <span class="comment">// it won't always be necessary but there isn't currently a typeclass</span>
    <span class="comment">// that lets us know when we need to do it.</span>
    def <a title="(start: A, continue: A =&gt; Boolean, test: (A, A) =&gt; Boolean)Iterator[A]" id="spire.math;Interval.iterator.iter1">iter1</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.iterator.iter1.start">start</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="A =&gt; Boolean" id="spire.math;Interval.iterator.iter1.continue">continue</a>: A =&gt; Boolean, <a title="(A, A) =&gt; Boolean" id="spire.math;Interval.iterator.iter1.test">test</a>: <span class="delimiter">(</span>A, A<span class="delimiter">)</span> =&gt; Boolean<span class="delimiter">)</span>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span> =
      new <a title="&lt;$anon: Iterator[A]&gt; extends AnyRef with Iterator[A]" id="spire.math;Interval.iterator.iter1;$anon">Iterator</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
        var <a title="A" id="spire.math;Interval.iterator.iter1;$anon.x_=">x</a>: <a href="#spire.math;Interval;A" title="A">A</a> = <a href="#spire.math;Interval.iterator.iter1.start" title="A">start</a>
        var <a title="Boolean" id="spire.math;Interval.iterator.iter1;$anon.ok_=">ok</a>: <span title="Boolean">Boolean</span> = true
        def <a title="=&gt; Boolean" id="spire.math;Interval.iterator.iter1;$anon.hasNext">hasNext</a>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Interval.iterator.iter1;$anon.ok_=" title="=&gt; Boolean">ok</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Interval.iterator.iter1.continue" title="(v1: A)Boolean">continue</a><span class="delimiter">(</span><a href="#spire.math;Interval.iterator.iter1;$anon.x_=" title="=&gt; A">x</a><span class="delimiter">)</span>
        def <a title="()A" id="spire.math;Interval.iterator.iter1;$anon.next">next</a>: <a href="#spire.math;Interval;A" title="A">A</a> = <span class="delimiter">{</span>
          val <a title="A" id="spire.math;Interval.iterator.iter1;$anon.next.r">r</a> = <a href="#spire.math;Interval.iterator.iter1;$anon.x_=" title="=&gt; A">x</a>
          val next = <a href="#spire.math;Interval.iterator.ev" title="spire.algebra.AdditiveMonoid[A]">x</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="A" id="spire.math;Interval.iterator.iter1;$anon.next.next">+</a> <a href="#spire.math;Interval.iterator.step" title="A">step</a>
          if <span class="delimiter">(</span><a href="#spire.math;Interval.iterator.iter1.test" title="(v1: A, v2: A)Boolean">test</a><span class="delimiter">(</span><a href="#spire.math;Interval.iterator.iter1;$anon.x_=" title="=&gt; A">x</a>, <a href="#spire.math;Interval.iterator.iter1;$anon.next.next" title="A">next</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#spire.math;Interval.iterator.iter1;$anon.x_=" title="(x$1: A)Unit">x</a> = <a href="#spire.math;Interval.iterator.iter1;$anon.next.next" title="A">next</a> <span class="delimiter">}</span> else <span class="delimiter">{</span> <a href="#spire.math;Interval.iterator.iter1;$anon.ok_=" title="(x$1: Boolean)Unit">ok</a> = false <span class="delimiter">}</span>
          <a href="#spire.math;Interval.iterator.iter1;$anon.next.r" title="A">r</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

    def <a title="(start: A, safe: Boolean, continue: A =&gt; Boolean, test: (A, A) =&gt; Boolean)Iterator[A]" id="spire.math;Interval.iterator.iter">iter</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.iterator.iter.start">start</a>: <a href="#spire.math;Interval;A" title="A">A</a>, <a title="Boolean" id="spire.math;Interval.iterator.iter.safe">safe</a>: <span title="Boolean">Boolean</span>, <a title="A =&gt; Boolean" id="spire.math;Interval.iterator.iter.continue">continue</a>: A =&gt; Boolean, <a title="(A, A) =&gt; Boolean" id="spire.math;Interval.iterator.iter.test">test</a>: <span class="delimiter">(</span>A, A<span class="delimiter">)</span> =&gt; Boolean<span class="delimiter">)</span>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#spire.math;Interval.iterator.nt" title="spire.math.NumberTag[A]">nt</a>.<a href="NumberTag.scala.html#spire.math;NumberTag.overflows" title="=&gt; Boolean">overflows</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#spire.math;Interval.iterator.iter.safe" title="Boolean">safe</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#spire.math;Interval.iterator.iter1" title="(start: A, continue: A =&gt; Boolean, test: (A, A) =&gt; Boolean)Iterator[A]">iter1</a><span class="delimiter">(</span><a href="#spire.math;Interval.iterator.iter.start" title="A">start</a>, <a href="#spire.math;Interval.iterator.iter.continue" title="A =&gt; Boolean">continue</a>, <a href="#spire.math;Interval.iterator.iter.test" title="(A, A) =&gt; Boolean">test</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <a href="#spire.math;Interval.iterator.iter0" title="(start: A, continue: A =&gt; Boolean)Iterator[A]">iter0</a><span class="delimiter">(</span><a href="#spire.math;Interval.iterator.iter.start" title="A">start</a>, <a href="#spire.math;Interval.iterator.iter.continue" title="A =&gt; Boolean">continue</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="comment">// build the actual iterator, which primarily relies on figuring</span>
    <span class="comment">// out which &quot;direction&quot; we are moving (based on the sign of the</span>
    <span class="comment">// step) as well as what kind of limiting bounds we have.</span>
    if <span class="delimiter">(</span><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">step</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: A, y: A)Boolean">===</a> <a href="#spire.math;Interval.iterator.ev" title="spire.algebra.AdditiveMonoid[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      throw new <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="String(&quot;zero step&quot;)" class="string">&quot;zero step&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">step</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <a href="#spire.math;Interval.iterator.ev" title="spire.algebra.AdditiveMonoid[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <span title="A">x</span> = <a href="#spire.math;Interval.getStart" title="(bound: spire.math.interval.Bound[A], step: A, unboundError: String)(implicit ev: spire.algebra.AdditiveMonoid[A])A">getStart</a><a href="#spire.math;Interval.iterator.ev" title="spire.algebra.AdditiveMonoid[A]" class="delimiter">(</a><a href="#spire.math;Interval.lowerBound" title="=&gt; spire.math.interval.Bound[A]">lowerBound</a>, <a href="#spire.math;Interval.iterator.step" title="A">step</a>, <span title="String(&quot;positive step with no lower bound&quot;)" class="string">&quot;positive step with no lower bound&quot;</span><span class="delimiter">)</span>
      val <span title="(A, A) =&gt; Boolean">test</span> = <span class="delimiter">(</span>x1: <a href="#spire.math;Interval;A" title="A">A</a>, x2: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">x1</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math;Interval.iterator.test.$anonfun.x2" title="A">x2</a>
      <a href="#spire.math;Interval.upperBound" title="=&gt; spire.math.interval.Bound[A]">upperBound</a> match <span class="delimiter">{</span>
        case EmptyBound<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <span title="=&gt; collection.Iterator.type">Iterator</span>.<span title="=&gt; Iterator[Nothing]">empty</span>
        case Unbound<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.iterator.iter" title="(start: A, safe: Boolean, continue: A =&gt; Boolean, test: (A, A) =&gt; Boolean)Iterator[A]">iter</a><span class="delimiter">(</span><span title="A">x</span>, false, <a title="A" id="spire.math;Interval.iterator.$anonfun.x$5">_</a> =&gt; true, <span title="(A, A) =&gt; Boolean">test</span><span class="delimiter">)</span>
        case Closed<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.iterator.iter" title="(start: A, safe: Boolean, continue: A =&gt; Boolean, test: (A, A) =&gt; Boolean)Iterator[A]">iter</a><span class="delimiter">(</span><span title="A">x</span>, <a href="#spire.math;Interval.iterator.ev" title="spire.algebra.AdditiveMonoid[A]">y</a> <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">+</a> <a href="#spire.math;Interval.iterator.step" title="A">step</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <span title="A">y</span>, <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">_</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lteqv" title="(x: A, y: A)Boolean">&lt;=</a> <span title="A">y</span>, <span title="(A, A) =&gt; Boolean">test</span><span class="delimiter">)</span>
        case Open<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.iterator.iter" title="(start: A, safe: Boolean, continue: A =&gt; Boolean, test: (A, A) =&gt; Boolean)Iterator[A]">iter</a><span class="delimiter">(</span><span title="A">x</span>, <a href="#spire.math;Interval.iterator.ev" title="spire.algebra.AdditiveMonoid[A]">y</a> <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">+</a> <a href="#spire.math;Interval.iterator.step" title="A">step</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <span title="A">y</span>, <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">_</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <span title="A">y</span>, <span title="(A, A) =&gt; Boolean">test</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      val <span title="A">x</span> = <a href="#spire.math;Interval.getStart" title="(bound: spire.math.interval.Bound[A], step: A, unboundError: String)(implicit ev: spire.algebra.AdditiveMonoid[A])A">getStart</a><a href="#spire.math;Interval.iterator.ev" title="spire.algebra.AdditiveMonoid[A]" class="delimiter">(</a><a href="#spire.math;Interval.upperBound" title="=&gt; spire.math.interval.Bound[A]">upperBound</a>, <a href="#spire.math;Interval.iterator.step" title="A">step</a>, <span title="String(&quot;negative step with no lower bound&quot;)" class="string">&quot;negative step with no lower bound&quot;</span><span class="delimiter">)</span>
      val <span title="(A, A) =&gt; Boolean">test</span> = <span class="delimiter">(</span>x1: <a href="#spire.math;Interval;A" title="A">A</a>, x2: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">x1</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <a href="#spire.math;Interval.iterator.test.$anonfun.x2" title="A">x2</a>
      <a href="#spire.math;Interval.lowerBound" title="=&gt; spire.math.interval.Bound[A]">lowerBound</a> match <span class="delimiter">{</span>
        case EmptyBound<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <span title="=&gt; collection.Iterator.type">Iterator</span>.<span title="=&gt; Iterator[Nothing]">empty</span>
        case Unbound<span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.iterator.iter" title="(start: A, safe: Boolean, continue: A =&gt; Boolean, test: (A, A) =&gt; Boolean)Iterator[A]">iter</a><span class="delimiter">(</span><span title="A">x</span>, false, <a title="A" id="spire.math;Interval.iterator.$anonfun.x$8">_</a> =&gt; true, <span title="(A, A) =&gt; Boolean">test</span><span class="delimiter">)</span>
        case Closed<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.iterator.iter" title="(start: A, safe: Boolean, continue: A =&gt; Boolean, test: (A, A) =&gt; Boolean)Iterator[A]">iter</a><span class="delimiter">(</span><span title="A">x</span>, <a href="#spire.math;Interval.iterator.ev" title="spire.algebra.AdditiveMonoid[A]">y</a> <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">+</a> <a href="#spire.math;Interval.iterator.step" title="A">step</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <span title="A">y</span>, <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">_</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gteqv" title="(x: A, y: A)Boolean">&gt;=</a> <span title="A">y</span>, <span title="(A, A) =&gt; Boolean">test</span><span class="delimiter">)</span>
        case Open<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span> =&gt; <a href="#spire.math;Interval.iterator.iter" title="(start: A, safe: Boolean, continue: A =&gt; Boolean, test: (A, A) =&gt; Boolean)Iterator[A]">iter</a><span class="delimiter">(</span><span title="A">x</span>, <a href="#spire.math;Interval.iterator.ev" title="spire.algebra.AdditiveMonoid[A]">y</a> <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">+</a> <a href="#spire.math;Interval.iterator.step" title="A">step</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <span title="A">y</span>, <a href="#spire.math;Interval.order" title="spire.algebra.Order[A]">_</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">&gt;</a> <span title="A">y</span>, <span title="(A, A) =&gt; Boolean">test</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(step: A)(f: A =&gt; Unit)(implicit ev: spire.algebra.AdditiveMonoid[A], implicit nt: spire.math.NumberTag[A])Unit" id="spire.math;Interval.loop">loop</a><span class="delimiter">(</span><a title="A" id="spire.math;Interval.loop.step">step</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; Unit" id="spire.math;Interval.loop.f">f</a>: A =&gt; Unit<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveMonoid[A]" id="spire.math;Interval.loop.ev">ev</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.NumberTag[A]" id="spire.math;Interval.loop.nt">nt</a>: <a href="NumberTag.scala.html#spire.math;NumberTag" title="spire.math.NumberTag[A]">NumberTag</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#spire.math;Interval.iterator" title="(step: A)(implicit ev: spire.algebra.AdditiveMonoid[A], implicit nt: spire.math.NumberTag[A])Iterator[A]">iterator</a><a href="#spire.math;Interval.loop.ev" title="spire.algebra.AdditiveMonoid[A]" class="delimiter">(</a><a href="#spire.math;Interval.loop.step" title="A">step</a><span class="delimiter">)</span>.<span title="(f: A =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#spire.math;Interval.loop.f" title="A =&gt; Unit">f</a><span class="delimiter">)</span>

  def <a title="[B](init: B, step: A)(f: (B, A) =&gt; B)(implicit ev: spire.algebra.AdditiveMonoid[A], implicit nt: spire.math.NumberTag[A])B" id="spire.math;Interval.foldOver">foldOver</a><span class="delimiter">[</span><a title="" id="spire.math;Interval.foldOver;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="spire.math;Interval.foldOver.init">init</a>: <a href="#spire.math;Interval.foldOver;B" title="B">B</a>, <a title="A" id="spire.math;Interval.foldOver.step">step</a>: <a href="#spire.math;Interval;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, A) =&gt; B" id="spire.math;Interval.foldOver.f">f</a>: <span class="delimiter">(</span>B, A<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveMonoid[A]" id="spire.math;Interval.foldOver.ev">ev</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.NumberTag[A]" id="spire.math;Interval.foldOver.nt">nt</a>: <a href="NumberTag.scala.html#spire.math;NumberTag" title="spire.math.NumberTag[A]">NumberTag</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval.foldOver;B" title="B">B</a> =
    <a href="#spire.math;Interval.iterator" title="(step: A)(implicit ev: spire.algebra.AdditiveMonoid[A], implicit nt: spire.math.NumberTag[A])Iterator[A]">iterator</a><a href="#spire.math;Interval.foldOver.ev" title="spire.algebra.AdditiveMonoid[A]" class="delimiter">(</a><a href="#spire.math;Interval.foldOver.step" title="A">step</a><span class="delimiter">)</span>.<span title="(z: B)(op: (B, A) =&gt; B)B">foldLeft</span><span class="delimiter">(</span><a href="#spire.math;Interval.foldOver.init" title="B">init</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.math;Interval.foldOver.f" title="(B, A) =&gt; B">f</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

case class <a href="#spire.math;All.productElement.x$1" title="class All[A] extends spire.math.Interval[A] with Product with Serializable" id="spire.math.All.readResolve">All</a><span class="delimiter">[</span><a title="" id="spire.math;All;A">A</a>: Order<span class="delimiter">]</span> private<span class="delimiter">[</span>spire<span class="delimiter">]</span> <span class="delimiter">(</span><span class="delimiter">)</span> extends <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
  def <a title="=&gt; spire.math.interval.Unbound[A]" id="spire.math;All.lowerBound">lowerBound</a>: <a href="interval/Bound.scala.html#spire.math.interval;Unbound" title="spire.math.interval.Unbound[A]">Unbound</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="interval/Bound.scala.html#spire.math.interval;Unbound" title="()spire.math.interval.Unbound[A]">Unbound</a><span class="delimiter">(</span><span class="delimiter">)</span>
  def <a title="=&gt; spire.math.interval.Unbound[A]" id="spire.math;All.upperBound">upperBound</a>: <a href="interval/Bound.scala.html#spire.math.interval;Unbound" title="spire.math.interval.Unbound[A]">Unbound</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="interval/Bound.scala.html#spire.math.interval;Unbound" title="()spire.math.interval.Unbound[A]">Unbound</a><span class="delimiter">(</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

case class <a href="#spire.math;Above.productElement.x$1" title="class Above[A] extends spire.math.Interval[A] with Product with Serializable" id="spire.math.Above.readResolve">Above</a><span class="delimiter">[</span><a title="" id="spire.math;Above;A">A</a>: Order<span class="delimiter">]</span> private<span class="delimiter">[</span>spire<span class="delimiter">]</span> <span class="delimiter">(</span><a title="A" id="spire.math;Above.lower">lower</a>: <a href="#spire.math;Above;A" title="A">A</a>, <a title="Int" id="spire.math;Above.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span> extends <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
  def <a title="=&gt; spire.math.interval.ValueBound[A]" id="spire.math;Above.lowerBound">lowerBound</a>: <a href="interval/Bound.scala.html#spire.math.interval;ValueBound" title="spire.math.interval.ValueBound[A]">ValueBound</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = if <span class="delimiter">(</span><a href="#spire.math;Interval.isOpenLower" title="(flags: Int)Boolean">isOpenLower</a><span class="delimiter">(</span><a href="#spire.math;Above.flags" title="=&gt; Int">flags</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="interval/Bound.scala.html#spire.math.interval;Open" title="(a: A)spire.math.interval.Open[A]">Open</a><span class="delimiter">(</span><a href="#spire.math;Above.lower" title="=&gt; A">lower</a><span class="delimiter">)</span> else <a href="interval/Bound.scala.html#spire.math.interval;Closed" title="(a: A)spire.math.interval.Closed[A]">Closed</a><span class="delimiter">(</span><a href="#spire.math;Above.lower" title="=&gt; A">lower</a><span class="delimiter">)</span>
  def <a title="=&gt; spire.math.interval.Unbound[A]" id="spire.math;Above.upperBound">upperBound</a>: <a href="interval/Bound.scala.html#spire.math.interval;Unbound" title="spire.math.interval.Unbound[A]">Unbound</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="interval/Bound.scala.html#spire.math.interval;Unbound" title="()spire.math.interval.Unbound[A]">Unbound</a><span class="delimiter">(</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

case class <a href="#spire.math;Below.productElement.x$1" title="class Below[A] extends spire.math.Interval[A] with Product with Serializable" id="spire.math.Below.readResolve">Below</a><span class="delimiter">[</span><a title="" id="spire.math;Below;A">A</a>: Order<span class="delimiter">]</span> private<span class="delimiter">[</span>spire<span class="delimiter">]</span> <span class="delimiter">(</span><a title="A" id="spire.math;Below.upper">upper</a>: <a href="#spire.math;Below;A" title="A">A</a>, <a title="Int" id="spire.math;Below.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span> extends <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
  def <a title="=&gt; spire.math.interval.Unbound[A]" id="spire.math;Below.lowerBound">lowerBound</a>: <a href="interval/Bound.scala.html#spire.math.interval;Unbound" title="spire.math.interval.Unbound[A]">Unbound</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="interval/Bound.scala.html#spire.math.interval;Unbound" title="()spire.math.interval.Unbound[A]">Unbound</a><span class="delimiter">(</span><span class="delimiter">)</span>
  def <a title="=&gt; spire.math.interval.ValueBound[A]" id="spire.math;Below.upperBound">upperBound</a>: <a href="interval/Bound.scala.html#spire.math.interval;ValueBound" title="spire.math.interval.ValueBound[A]">ValueBound</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = if <span class="delimiter">(</span><a href="#spire.math;Interval.isOpenUpper" title="(flags: Int)Boolean">isOpenUpper</a><span class="delimiter">(</span><a href="#spire.math;Below.flags" title="=&gt; Int">flags</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="interval/Bound.scala.html#spire.math.interval;Open" title="(a: A)spire.math.interval.Open[A]">Open</a><span class="delimiter">(</span><a href="#spire.math;Below.upper" title="=&gt; A">upper</a><span class="delimiter">)</span> else <a href="interval/Bound.scala.html#spire.math.interval;Closed" title="(a: A)spire.math.interval.Closed[A]">Closed</a><span class="delimiter">(</span><a href="#spire.math;Below.upper" title="=&gt; A">upper</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">// Bounded, non-empty interval with lower &lt; upper</span>
case class <a href="#spire.math;Bounded.productElement.x$1" title="class Bounded[A] extends spire.math.Interval[A] with Product with Serializable" id="spire.math.Bounded.readResolve">Bounded</a><span class="delimiter">[</span><a title="" id="spire.math;Bounded;A">A</a>: Order<span class="delimiter">]</span> private<span class="delimiter">[</span>spire<span class="delimiter">]</span> <span class="delimiter">(</span><a title="A" id="spire.math;Bounded.lower">lower</a>: <a href="#spire.math;Bounded;A" title="A">A</a>, <a title="A" id="spire.math;Bounded.upper">upper</a>: <a href="#spire.math;Bounded;A" title="A">A</a>, <a title="Int" id="spire.math;Bounded.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span> extends <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span title="(requirement: Boolean)Unit">require</span><span class="delimiter">(</span><a href="#spire.math;Bounded.evidence$5" title="spire.algebra.Order[A]">lower</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math;Bounded.upper" title="=&gt; A">upper</a><span class="delimiter">)</span> <span class="comment">// TODO: remove after refactoring</span>

  def <a title="=&gt; spire.math.interval.ValueBound[A]" id="spire.math;Bounded.lowerBound">lowerBound</a>: <a href="interval/Bound.scala.html#spire.math.interval;ValueBound" title="spire.math.interval.ValueBound[A]">ValueBound</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = if <span class="delimiter">(</span><a href="#spire.math;Interval.isOpenLower" title="(flags: Int)Boolean">isOpenLower</a><span class="delimiter">(</span><a href="#spire.math;Bounded.flags" title="=&gt; Int">flags</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="interval/Bound.scala.html#spire.math.interval;Open" title="(a: A)spire.math.interval.Open[A]">Open</a><span class="delimiter">(</span><a href="#spire.math;Bounded.lower" title="=&gt; A">lower</a><span class="delimiter">)</span> else <a href="interval/Bound.scala.html#spire.math.interval;Closed" title="(a: A)spire.math.interval.Closed[A]">Closed</a><span class="delimiter">(</span><a href="#spire.math;Bounded.lower" title="=&gt; A">lower</a><span class="delimiter">)</span>
  def <a title="=&gt; spire.math.interval.ValueBound[A]" id="spire.math;Bounded.upperBound">upperBound</a>: <a href="interval/Bound.scala.html#spire.math.interval;ValueBound" title="spire.math.interval.ValueBound[A]">ValueBound</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = if <span class="delimiter">(</span><a href="#spire.math;Interval.isOpenUpper" title="(flags: Int)Boolean">isOpenUpper</a><span class="delimiter">(</span><a href="#spire.math;Bounded.flags" title="=&gt; Int">flags</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="interval/Bound.scala.html#spire.math.interval;Open" title="(a: A)spire.math.interval.Open[A]">Open</a><span class="delimiter">(</span><a href="#spire.math;Bounded.upper" title="=&gt; A">upper</a><span class="delimiter">)</span> else <a href="interval/Bound.scala.html#spire.math.interval;Closed" title="(a: A)spire.math.interval.Closed[A]">Closed</a><span class="delimiter">(</span><a href="#spire.math;Bounded.upper" title="=&gt; A">upper</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

case class <a href="#spire.math;Point.productElement.x$1" title="class Point[A] extends spire.math.Interval[A] with Product with Serializable" id="spire.math.Point.readResolve">Point</a><span class="delimiter">[</span><a title="" id="spire.math;Point;A">A</a>: Order<span class="delimiter">]</span> private<span class="delimiter">[</span>spire<span class="delimiter">]</span> <span class="delimiter">(</span><a title="A" id="spire.math;Point.value">value</a>: <a href="#spire.math;Point;A" title="A">A</a><span class="delimiter">)</span> extends <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
  def <a title="=&gt; spire.math.interval.Closed[A]" id="spire.math;Point.lowerBound">lowerBound</a>: <a href="interval/Bound.scala.html#spire.math.interval;Closed" title="spire.math.interval.Closed[A]">Closed</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="interval/Bound.scala.html#spire.math.interval;Closed" title="(a: A)spire.math.interval.Closed[A]">Closed</a><span class="delimiter">(</span><a href="#spire.math;Point.value" title="=&gt; A">value</a><span class="delimiter">)</span>
  def <a title="=&gt; spire.math.interval.Closed[A]" id="spire.math;Point.upperBound">upperBound</a>: <a href="interval/Bound.scala.html#spire.math.interval;Closed" title="spire.math.interval.Closed[A]">Closed</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="interval/Bound.scala.html#spire.math.interval;Closed" title="(a: A)spire.math.interval.Closed[A]">Closed</a><span class="delimiter">(</span><a href="#spire.math;Point.value" title="=&gt; A">value</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

case class <a href="#spire.math;Empty.productElement.x$1" title="class Empty[A] extends spire.math.Interval[A] with Product with Serializable" id="spire.math.Empty.readResolve">Empty</a><span class="delimiter">[</span><a title="" id="spire.math;Empty;A">A</a>: Order<span class="delimiter">]</span> private<span class="delimiter">[</span>spire<span class="delimiter">]</span> <span class="delimiter">(</span><span class="delimiter">)</span> extends <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
  def <a title="=&gt; spire.math.interval.EmptyBound[A]" id="spire.math;Empty.lowerBound">lowerBound</a>: <a href="interval/Bound.scala.html#spire.math.interval;EmptyBound" title="spire.math.interval.EmptyBound[A]">EmptyBound</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="interval/Bound.scala.html#spire.math.interval;EmptyBound" title="()spire.math.interval.EmptyBound[A]">EmptyBound</a><span class="delimiter">(</span><span class="delimiter">)</span>
  def <a title="=&gt; spire.math.interval.EmptyBound[A]" id="spire.math;Empty.upperBound">upperBound</a>: <a href="interval/Bound.scala.html#spire.math.interval;EmptyBound" title="spire.math.interval.EmptyBound[A]">EmptyBound</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="interval/Bound.scala.html#spire.math.interval;EmptyBound" title="()spire.math.interval.EmptyBound[A]">EmptyBound</a><span class="delimiter">(</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

object <a title="spire.math.Interval.type" id="spire.math.Interval">Interval</a> <a href="#spire.math.Interval" title="spire.math.Interval.type" class="delimiter">{</a>
  import interval._

  private<span class="delimiter">[</span>spire<span class="delimiter">]</span> def <a title="[A](lower: A, upper: A, flags: Int)(implicit evidence$8: spire.algebra.Order[A])spire.math.Interval[A]" id="spire.math.Interval.withFlags">withFlags</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.withFlags;A">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.math.Interval.withFlags.lower">lower</a>: <a href="#spire.math.Interval.withFlags;A" title="A">A</a>, <a title="A" id="spire.math.Interval.withFlags.upper">upper</a>: <a href="#spire.math.Interval.withFlags;A" title="A">A</a>, <a title="Int" id="spire.math.Interval.withFlags.flags">flags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#spire.math.Interval.withFlags.evidence$8" title="spire.algebra.Order[A]">lower</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math.Interval.withFlags.upper" title="A">upper</a><span class="delimiter">)</span>
      <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math.Interval.withFlags.evidence$8" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Interval.withFlags.lower" title="A">lower</a>, <a href="#spire.math.Interval.withFlags.upper" title="A">upper</a>, <a href="#spire.math.Interval.withFlags.flags" title="Int">flags</a><span class="delimiter">)</span>
    else if <span class="delimiter">(</span><a href="#spire.math.Interval.withFlags.evidence$8" title="spire.algebra.Order[A]">lower</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: A, y: A)Boolean">===</a> <a href="#spire.math.Interval.withFlags.upper" title="A">upper</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math.Interval.withFlags.flags" title="Int">flags</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      <a href="#spire.math.Point.readResolve" title="(value: A)(implicit evidence$6: spire.algebra.Order[A])spire.math.Point[A]">Point</a><a href="#spire.math.Interval.withFlags.evidence$8" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Interval.withFlags.lower" title="A">lower</a><span class="delimiter">)</span>
    else
      <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.empty" title="[A](implicit o: spire.algebra.Order[A])spire.math.Interval[A]">empty</a><a href="#spire.math.Interval.withFlags.evidence$8" title="(implicit o: spire.algebra.Order[A])spire.math.Interval[A]" class="delimiter">[</a><a href="#spire.math.Interval.withFlags;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="[A](implicit o: spire.algebra.Order[A])spire.math.Interval[A]" id="spire.math.Interval.empty">empty</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.empty;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.math.Interval.empty.o">o</a>: <a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Empty.readResolve" title="[A]()(implicit evidence$7: spire.algebra.Order[A])spire.math.Empty[A]">Empty</a><a href="#spire.math.Interval.empty.o" title="()(implicit evidence$7: spire.algebra.Order[A])spire.math.Empty[A]" class="delimiter">[</a><a href="#spire.math.Interval.empty;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="[A](a: A)(implicit evidence$9: spire.algebra.Order[A])spire.math.Interval[A]" id="spire.math.Interval.point">point</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.point;A">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.math.Interval.point.a">a</a>: <a href="#spire.math.Interval.point;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Point.readResolve" title="(value: A)(implicit evidence$6: spire.algebra.Order[A])spire.math.Point[A]">Point</a><a href="#spire.math.Interval.point.evidence$9" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Interval.point.a" title="A">a</a><span class="delimiter">)</span>

  def <a title="[A](implicit o: spire.algebra.Order[A], implicit r: spire.algebra.Semiring[A])spire.math.Interval[A]" id="spire.math.Interval.zero">zero</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.zero;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.math.Interval.zero.o">o</a>: <a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.algebra.Semiring[A]" id="spire.math.Interval.zero.r">r</a>: <a href="../algebra/Semiring.scala.html#spire.algebra;Semiring" title="spire.algebra.Semiring[A]">Semiring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Point.readResolve" title="(value: A)(implicit evidence$6: spire.algebra.Order[A])spire.math.Point[A]">Point</a><a href="#spire.math.Interval.zero.o" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Interval.zero.r" title="spire.algebra.Semiring[A]">r</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span>

  def <a title="[A](implicit evidence$10: spire.algebra.Order[A])spire.math.Interval[A]" id="spire.math.Interval.all">all</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.all;A">A</a>: Order<span class="delimiter">]</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.All.readResolve" title="[A]()(implicit evidence$2: spire.algebra.Order[A])spire.math.All[A]">All</a><span title="()(implicit evidence$2: spire.algebra.Order[A])spire.math.All[A]" class="delimiter">[</span><a href="#spire.math.Interval.all;A" title="A">A</a><span class="delimiter">]</span><a href="#spire.math.Interval.all.evidence$10" title="spire.algebra.Order[A]" class="delimiter">(</a><span class="delimiter">)</span>

  def <a title="[A](lower: A, upper: A)(implicit evidence$11: spire.algebra.Order[A])spire.math.Interval[A]" id="spire.math.Interval.apply(22f0cda0c5)">apply</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.apply(22f0cda0c5);A">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.math.Interval.apply(22f0cda0c5).lower">lower</a>: <a href="#spire.math.Interval.apply(22f0cda0c5);A" title="A">A</a>, <a title="A" id="spire.math.Interval.apply(22f0cda0c5).upper">upper</a>: <a href="#spire.math.Interval.apply(22f0cda0c5);A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Interval.closed" title="(lower: A, upper: A)(implicit evidence$14: spire.algebra.Order[A])spire.math.Interval[A]">closed</a><a href="#spire.math.Interval.apply(22f0cda0c5).evidence$11" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Interval.apply(22f0cda0c5).lower" title="A">lower</a>, <a href="#spire.math.Interval.apply(22f0cda0c5).upper" title="A">upper</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Return an Interval[Rational] that corresponds to the error bounds
   * for the given Double value.
   * 
   * The error bounds are represented as a closed interval, whose
   * lower point is midway between d and the adjacent Double value
   * below it. Similarly, the upper bound is the point midway between
   * d and the adjacent Double value above it.
   * 
   * There are three Double values that return &quot;special&quot; intervals:
   * 
   *    Infinity =&gt; Interval.above(Double.MaxValue)
   *   -Infinity =&gt; Interval.below(Double.MinValue)
   *         NaN =&gt; Interval.empty
   */</span>
  def <a title="(d: Double)spire.math.Interval[spire.math.Rational]" id="spire.math.Interval.errorBounds">errorBounds</a><span class="delimiter">(</span><a title="Double" id="spire.math.Interval.errorBounds.d">d</a>: <span title="Double">Double</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[spire.math.Rational]">Interval</a><span class="delimiter">[</span>Rational<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#spire.math.Interval.errorBounds.d" title="Double">d</a> <span title="(x: Double)Boolean">==</span> Double.<span title="Double(Infinity)">PositiveInfinity</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.above" title="(a: spire.math.Rational)(implicit evidence$18: spire.algebra.Order[spire.math.Rational])spire.math.Interval[spire.math.Rational]">above</a><a href="Rational.scala.html#spire.math;RationalInstances.RationalAlgebra" title="=&gt; spire.math.RationalAlgebra" class="delimiter">(</a>Double.<a href="Rational.scala.html#spire.math.Rational.apply(296059c6c7)" title="implicit spire.math.Rational.apply : (x: Double)spire.math.Rational">MaxValue</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.math.Interval.errorBounds.d" title="Double">d</a> <span title="(x: Double)Boolean">==</span> Double.<span title="Double(-Infinity)">NegativeInfinity</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.below" title="(a: spire.math.Rational)(implicit evidence$19: spire.algebra.Order[spire.math.Rational])spire.math.Interval[spire.math.Rational]">below</a><a href="Rational.scala.html#spire.math;RationalInstances.RationalAlgebra" title="=&gt; spire.math.RationalAlgebra" class="delimiter">(</a><span title="Double.type">Double</span>.<a href="Rational.scala.html#spire.math.Rational.apply(296059c6c7)" title="implicit spire.math.Rational.apply : (x: Double)spire.math.Rational">MinValue</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else if <span class="delimiter">(</span><span title="(x$1: Double)Boolean">isNaN</span><span class="delimiter">(</span><a href="#spire.math.Interval.errorBounds.d" title="Double">d</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.empty" title="[A](implicit o: spire.algebra.Order[A])spire.math.Interval[A]">empty</a><a href="Rational.scala.html#spire.math;RationalInstances.RationalAlgebra" title="(implicit o: spire.algebra.Order[spire.math.Rational])spire.math.Interval[spire.math.Rational]" class="delimiter">[</a><a href="Rational.scala.html#spire.math;Rational" title="spire.math.Rational">Rational</a><span class="delimiter">]</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      val <a title="spire.math.Rational" id="spire.math.Interval.errorBounds.n0">n0</a> = <a href="Rational.scala.html#spire.math.Rational.apply(296059c6c7)" title="implicit spire.math.Rational.apply : (x: Double)spire.math.Rational">Rational</a><span class="delimiter">(</span><span title="Math.type">Math</span>.<span title="(x$1: Double, x$2: Double)Double">nextAfter</span><span class="delimiter">(</span><a href="#spire.math.Interval.errorBounds.d" title="Double">d</a>, -<span title="Double(-1.0)" class="double">1.0</span><span class="delimiter">)</span><span class="delimiter">)</span>
      val <a title="spire.math.Rational" id="spire.math.Interval.errorBounds.n1">n1</a> = <a href="Rational.scala.html#spire.math.Rational.apply(296059c6c7)" title="implicit spire.math.Rational.apply : (x: Double)spire.math.Rational">Rational</a><span class="delimiter">(</span><a href="#spire.math.Interval.errorBounds.d" title="Double">d</a><span class="delimiter">)</span>
      val <a title="spire.math.Rational" id="spire.math.Interval.errorBounds.n2">n2</a> = <a href="Rational.scala.html#spire.math.Rational.apply(296059c6c7)" title="implicit spire.math.Rational.apply : (x: Double)spire.math.Rational">Rational</a><span class="delimiter">(</span><span title="Math.type">Math</span>.<span title="(x$1: Double)Double">nextUp</span><span class="delimiter">(</span><a href="#spire.math.Interval.errorBounds.d" title="Double">d</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#spire.math.Interval.apply(22f0cda0c5)" title="(lower: spire.math.Rational, upper: spire.math.Rational)(implicit evidence$11: spire.algebra.Order[spire.math.Rational])spire.math.Interval[spire.math.Rational]">Interval</a><a href="Rational.scala.html#spire.math;RationalInstances.RationalAlgebra" title="=&gt; spire.math.RationalAlgebra" class="delimiter">(</a><span class="delimiter">(</span><a href="#spire.math.Interval.errorBounds.n1" title="spire.math.Rational">n1</a> <a href="Rational.scala.html#spire.math;Rational.-" title="(rhs: spire.math.Rational)spire.math.Rational">-</a> <a href="#spire.math.Interval.errorBounds.n0" title="spire.math.Rational">n0</a><span class="delimiter">)</span> <a href="Rational.scala.html#spire.math;Rational./" title="(rhs: spire.math.Rational)spire.math.Rational">/</a> <a href="Rational.scala.html#spire.math.Rational.apply(b123343b6b)" title="implicit spire.math.Rational.apply : (x: Int)spire.math.Rational" class="int">2</a> <a href="Rational.scala.html#spire.math;Rational.+" title="(rhs: spire.math.Rational)spire.math.Rational">+</a> <a href="#spire.math.Interval.errorBounds.n0" title="spire.math.Rational">n0</a>, <span class="delimiter">(</span><a href="#spire.math.Interval.errorBounds.n2" title="spire.math.Rational">n2</a> <a href="Rational.scala.html#spire.math;Rational.-" title="(rhs: spire.math.Rational)spire.math.Rational">-</a> <a href="#spire.math.Interval.errorBounds.n1" title="spire.math.Rational">n1</a><span class="delimiter">)</span> <a href="Rational.scala.html#spire.math;Rational./" title="(rhs: spire.math.Rational)spire.math.Rational">/</a> <a href="Rational.scala.html#spire.math.Rational.apply(b123343b6b)" title="implicit spire.math.Rational.apply : (x: Int)spire.math.Rational" class="int">2</a> <a href="Rational.scala.html#spire.math;Rational.+" title="(rhs: spire.math.Rational)spire.math.Rational">+</a> <a href="#spire.math.Interval.errorBounds.n1" title="spire.math.Rational">n1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  @inline private<span class="delimiter">[</span>spire<span class="delimiter">]</span> final def <a title="=&gt; Int" id="spire.math.Interval.closedLowerFlags">closedLowerFlags</a> = <span title="Int(0)" class="int">0</span>
  @inline private<span class="delimiter">[</span>spire<span class="delimiter">]</span> final def <a title="=&gt; Int" id="spire.math.Interval.openLowerFlags">openLowerFlags</a> = <span title="Int(1)" class="int">1</span>
  @inline private<span class="delimiter">[</span>spire<span class="delimiter">]</span> final def <a title="=&gt; Int" id="spire.math.Interval.closedUpperFlags">closedUpperFlags</a> = <span title="Int(0)" class="int">0</span>
  @inline private<span class="delimiter">[</span>spire<span class="delimiter">]</span> final def <a title="=&gt; Int" id="spire.math.Interval.openUpperFlags">openUpperFlags</a> = <span title="Int(2)" class="int">2</span>

  <span class="comment">/**
   * Constructs an interval from bounds.
   * 
   * This method assumes that lower &lt; upper to avoid comparisons.
   * 
   * - When one of the arguments is Unbound, the result will be All,
   *   Above(x, _), or Below(y, _).
   * 
   * - When both arguments are Open/Closed (e.g. Open(x), Open(y)),
   *   then x &lt; y and the result will be a Bounded interval.
   * 
   * - If both arguments are EmptyBound, the result is Empty.
   * 
   * - Any other arguments are invalid.
   * 
   * This method cannot construct Point intervals.
   */</span>
  private<span class="delimiter">[</span>spire<span class="delimiter">]</span> def <a title="[A](lower: spire.math.interval.Bound[A], upper: spire.math.interval.Bound[A])(implicit evidence$12: spire.algebra.Order[A])spire.math.Interval[A]" id="spire.math.Interval.fromOrderedBounds">fromOrderedBounds</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.fromOrderedBounds;A">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="spire.math.interval.Bound[A]" id="spire.math.Interval.fromOrderedBounds.lower">lower</a>: <a href="interval/Bound.scala.html#spire.math.interval;Bound" title="spire.math.interval.Bound[A]">Bound</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.interval.Bound[A]" id="spire.math.Interval.fromOrderedBounds.upper">upper</a>: <a href="interval/Bound.scala.html#spire.math.interval;Bound" title="spire.math.interval.Bound[A]">Bound</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <span title="(_1: spire.math.interval.Bound[A], _2: spire.math.interval.Bound[A])(spire.math.interval.Bound[A], spire.math.interval.Bound[A])" class="delimiter">(</span><a href="#spire.math.Interval.fromOrderedBounds.lower" title="spire.math.interval.Bound[A]">lower</a>, <a href="#spire.math.Interval.fromOrderedBounds.upper" title="spire.math.interval.Bound[A]">upper</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case <span class="delimiter">(</span>EmptyBound<span class="delimiter">(</span><span class="delimiter">)</span>, EmptyBound<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.empty" title="(implicit o: spire.algebra.Order[A])spire.math.Interval[A]">empty</a>
      case <span class="delimiter">(</span>Closed<span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span>, Closed<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math.Interval.fromOrderedBounds.evidence$12" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">x</span>, <span title="A">y</span>, <a href="#spire.math.Interval.closedLowerFlags" title="=&gt; Int">closedLowerFlags</a> <span title="(x: Int)Int">|</span> <a href="#spire.math.Interval.closedUpperFlags" title="=&gt; Int">closedUpperFlags</a><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Open<span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span>, Open<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math.Interval.fromOrderedBounds.evidence$12" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">x</span>, <span title="A">y</span>, <a href="#spire.math.Interval.openLowerFlags" title="=&gt; Int">openLowerFlags</a> <span title="(x: Int)Int">|</span> <a href="#spire.math.Interval.openUpperFlags" title="=&gt; Int">openUpperFlags</a><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Unbound<span class="delimiter">(</span><span class="delimiter">)</span>, Open<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.below" title="(a: A)(implicit evidence$19: spire.algebra.Order[A])spire.math.Interval[A]">below</a><a href="#spire.math.Interval.fromOrderedBounds.evidence$12" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">y</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Open<span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span>, Unbound<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.above" title="(a: A)(implicit evidence$18: spire.algebra.Order[A])spire.math.Interval[A]">above</a><a href="#spire.math.Interval.fromOrderedBounds.evidence$12" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">x</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Unbound<span class="delimiter">(</span><span class="delimiter">)</span>, Closed<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.atOrBelow" title="(a: A)(implicit evidence$21: spire.algebra.Order[A])spire.math.Interval[A]">atOrBelow</a><a href="#spire.math.Interval.fromOrderedBounds.evidence$12" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">y</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Closed<span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span>, Unbound<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.atOrAbove" title="(a: A)(implicit evidence$20: spire.algebra.Order[A])spire.math.Interval[A]">atOrAbove</a><a href="#spire.math.Interval.fromOrderedBounds.evidence$12" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">x</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Closed<span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span>, Open<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math.Interval.fromOrderedBounds.evidence$12" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">x</span>, <span title="A">y</span>, <a href="#spire.math.Interval.closedLowerFlags" title="=&gt; Int">closedLowerFlags</a> <span title="(x: Int)Int">|</span> <a href="#spire.math.Interval.openUpperFlags" title="=&gt; Int">openUpperFlags</a><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Open<span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span>, Closed<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math.Interval.fromOrderedBounds.evidence$12" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">x</span>, <span title="A">y</span>, <a href="#spire.math.Interval.openLowerFlags" title="=&gt; Int">openLowerFlags</a> <span title="(x: Int)Int">|</span> <a href="#spire.math.Interval.closedUpperFlags" title="=&gt; Int">closedUpperFlags</a><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Unbound<span class="delimiter">(</span><span class="delimiter">)</span>, Unbound<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.all" title="(implicit evidence$10: spire.algebra.Order[A])spire.math.Interval[A]">all</a>
      case <span class="delimiter">(</span>EmptyBound<span class="delimiter">(</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> | <span class="delimiter">(</span>_, EmptyBound<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        throw new <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="String(&quot;invalid empty bound&quot;)" class="string">&quot;invalid empty bound&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  def <a title="[A](lower: spire.math.interval.Bound[A], upper: spire.math.interval.Bound[A])(implicit evidence$13: spire.algebra.Order[A])spire.math.Interval[A]" id="spire.math.Interval.fromBounds">fromBounds</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.fromBounds;A">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="spire.math.interval.Bound[A]" id="spire.math.Interval.fromBounds.lower">lower</a>: <a href="interval/Bound.scala.html#spire.math.interval;Bound" title="spire.math.interval.Bound[A]">Bound</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.interval.Bound[A]" id="spire.math.Interval.fromBounds.upper">upper</a>: <a href="interval/Bound.scala.html#spire.math.interval;Bound" title="spire.math.interval.Bound[A]">Bound</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <span title="(_1: spire.math.interval.Bound[A], _2: spire.math.interval.Bound[A])(spire.math.interval.Bound[A], spire.math.interval.Bound[A])" class="delimiter">(</span><a href="#spire.math.Interval.fromBounds.lower" title="spire.math.interval.Bound[A]">lower</a>, <a href="#spire.math.Interval.fromBounds.upper" title="spire.math.interval.Bound[A]">upper</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case <span class="delimiter">(</span>EmptyBound<span class="delimiter">(</span><span class="delimiter">)</span>, EmptyBound<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.empty" title="(implicit o: spire.algebra.Order[A])spire.math.Interval[A]">empty</a>
      case <span class="delimiter">(</span>Closed<span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span>, Closed<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.closed" title="(lower: A, upper: A)(implicit evidence$14: spire.algebra.Order[A])spire.math.Interval[A]">closed</a><a href="#spire.math.Interval.fromBounds.evidence$13" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">x</span>, <span title="A">y</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Open<span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span>, Open<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.open" title="(lower: A, upper: A)(implicit evidence$15: spire.algebra.Order[A])spire.math.Interval[A]">open</a><a href="#spire.math.Interval.fromBounds.evidence$13" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">x</span>, <span title="A">y</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Unbound<span class="delimiter">(</span><span class="delimiter">)</span>, Open<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.below" title="(a: A)(implicit evidence$19: spire.algebra.Order[A])spire.math.Interval[A]">below</a><a href="#spire.math.Interval.fromBounds.evidence$13" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">y</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Open<span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span>, Unbound<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.above" title="(a: A)(implicit evidence$18: spire.algebra.Order[A])spire.math.Interval[A]">above</a><a href="#spire.math.Interval.fromBounds.evidence$13" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">x</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Unbound<span class="delimiter">(</span><span class="delimiter">)</span>, Closed<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.atOrBelow" title="(a: A)(implicit evidence$21: spire.algebra.Order[A])spire.math.Interval[A]">atOrBelow</a><a href="#spire.math.Interval.fromBounds.evidence$13" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">y</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Closed<span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span>, Unbound<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.atOrAbove" title="(a: A)(implicit evidence$20: spire.algebra.Order[A])spire.math.Interval[A]">atOrAbove</a><a href="#spire.math.Interval.fromBounds.evidence$13" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">x</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Closed<span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span>, Open<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.openUpper" title="(lower: A, upper: A)(implicit evidence$17: spire.algebra.Order[A])spire.math.Interval[A]">openUpper</a><a href="#spire.math.Interval.fromBounds.evidence$13" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">x</span>, <span title="A">y</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Open<span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span>, Closed<span class="delimiter">(</span><span title="A">y</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.openLower" title="(lower: A, upper: A)(implicit evidence$16: spire.algebra.Order[A])spire.math.Interval[A]">openLower</a><a href="#spire.math.Interval.fromBounds.evidence$13" title="spire.algebra.Order[A]" class="delimiter">(</a><span title="A">x</span>, <span title="A">y</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>Unbound<span class="delimiter">(</span><span class="delimiter">)</span>, Unbound<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval.all" title="(implicit evidence$10: spire.algebra.Order[A])spire.math.Interval[A]">all</a>
      case <span class="delimiter">(</span>EmptyBound<span class="delimiter">(</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> | <span class="delimiter">(</span>_, EmptyBound<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        throw new <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="String(&quot;invalid empty bound&quot;)" class="string">&quot;invalid empty bound&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  def <a title="[A](lower: A, upper: A)(implicit evidence$14: spire.algebra.Order[A])spire.math.Interval[A]" id="spire.math.Interval.closed">closed</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.closed;A">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.math.Interval.closed.lower">lower</a>: <a href="#spire.math.Interval.closed;A" title="A">A</a>, <a title="A" id="spire.math.Interval.closed.upper">upper</a>: <a href="#spire.math.Interval.closed;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val c = <a href="#spire.math.Interval.closed.evidence$14" title="spire.algebra.Order[A]">lower</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.compare" title="Int" id="spire.math.Interval.closed.c">compare</a> <a href="#spire.math.Interval.closed.upper" title="A">upper</a>
    if <span class="delimiter">(</span><a href="#spire.math.Interval.closed.c" title="Int">c</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math.Interval.closed.evidence$14" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Interval.closed.lower" title="A">lower</a>, <a href="#spire.math.Interval.closed.upper" title="A">upper</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
    else if <span class="delimiter">(</span><a href="#spire.math.Interval.closed.c" title="Int">c</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#spire.math.Point.readResolve" title="(value: A)(implicit evidence$6: spire.algebra.Order[A])spire.math.Point[A]">Point</a><a href="#spire.math.Interval.closed.evidence$14" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Interval.closed.lower" title="A">lower</a><span class="delimiter">)</span>
    else <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.empty" title="[A](implicit o: spire.algebra.Order[A])spire.math.Interval[A]">empty</a><a href="#spire.math.Interval.closed.evidence$14" title="(implicit o: spire.algebra.Order[A])spire.math.Interval[A]" class="delimiter">[</a><a href="#spire.math.Interval.closed;A" title="A">A</a><span class="delimiter">]</span>
  <span class="delimiter">}</span>
  def <a title="[A](lower: A, upper: A)(implicit evidence$15: spire.algebra.Order[A])spire.math.Interval[A]" id="spire.math.Interval.open">open</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.open;A">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.math.Interval.open.lower">lower</a>: <a href="#spire.math.Interval.open;A" title="A">A</a>, <a title="A" id="spire.math.Interval.open.upper">upper</a>: <a href="#spire.math.Interval.open;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#spire.math.Interval.open.evidence$15" title="spire.algebra.Order[A]">lower</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math.Interval.open.upper" title="A">upper</a><span class="delimiter">)</span> <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math.Interval.open.evidence$15" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Interval.open.lower" title="A">lower</a>, <a href="#spire.math.Interval.open.upper" title="A">upper</a>, <span title="Int(3)" class="int">3</span><span class="delimiter">)</span> else <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.empty" title="[A](implicit o: spire.algebra.Order[A])spire.math.Interval[A]">empty</a><a href="#spire.math.Interval.open.evidence$15" title="(implicit o: spire.algebra.Order[A])spire.math.Interval[A]" class="delimiter">[</a><a href="#spire.math.Interval.open;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="[A](lower: A, upper: A)(implicit evidence$16: spire.algebra.Order[A])spire.math.Interval[A]" id="spire.math.Interval.openLower">openLower</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.openLower;A">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.math.Interval.openLower.lower">lower</a>: <a href="#spire.math.Interval.openLower;A" title="A">A</a>, <a title="A" id="spire.math.Interval.openLower.upper">upper</a>: <a href="#spire.math.Interval.openLower;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#spire.math.Interval.openLower.evidence$16" title="spire.algebra.Order[A]">lower</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math.Interval.openLower.upper" title="A">upper</a><span class="delimiter">)</span> <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math.Interval.openLower.evidence$16" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Interval.openLower.lower" title="A">lower</a>, <a href="#spire.math.Interval.openLower.upper" title="A">upper</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> else <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.empty" title="[A](implicit o: spire.algebra.Order[A])spire.math.Interval[A]">empty</a><a href="#spire.math.Interval.openLower.evidence$16" title="(implicit o: spire.algebra.Order[A])spire.math.Interval[A]" class="delimiter">[</a><a href="#spire.math.Interval.openLower;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="[A](lower: A, upper: A)(implicit evidence$17: spire.algebra.Order[A])spire.math.Interval[A]" id="spire.math.Interval.openUpper">openUpper</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.openUpper;A">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.math.Interval.openUpper.lower">lower</a>: <a href="#spire.math.Interval.openUpper;A" title="A">A</a>, <a title="A" id="spire.math.Interval.openUpper.upper">upper</a>: <a href="#spire.math.Interval.openUpper;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#spire.math.Interval.openUpper.evidence$17" title="spire.algebra.Order[A]">lower</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">&lt;</a> <a href="#spire.math.Interval.openUpper.upper" title="A">upper</a><span class="delimiter">)</span> <a href="#spire.math.Bounded.readResolve" title="(lower: A, upper: A, flags: Int)(implicit evidence$5: spire.algebra.Order[A])spire.math.Bounded[A]">Bounded</a><a href="#spire.math.Interval.openUpper.evidence$17" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Interval.openUpper.lower" title="A">lower</a>, <a href="#spire.math.Interval.openUpper.upper" title="A">upper</a>, <span title="Int(2)" class="int">2</span><span class="delimiter">)</span> else <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.empty" title="[A](implicit o: spire.algebra.Order[A])spire.math.Interval[A]">empty</a><a href="#spire.math.Interval.openUpper.evidence$17" title="(implicit o: spire.algebra.Order[A])spire.math.Interval[A]" class="delimiter">[</a><a href="#spire.math.Interval.openUpper;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="[A](a: A)(implicit evidence$18: spire.algebra.Order[A])spire.math.Interval[A]" id="spire.math.Interval.above">above</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.above;A">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.math.Interval.above.a">a</a>: <a href="#spire.math.Interval.above;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math.Interval.above.evidence$18" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Interval.above.a" title="A">a</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
  def <a title="[A](a: A)(implicit evidence$19: spire.algebra.Order[A])spire.math.Interval[A]" id="spire.math.Interval.below">below</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.below;A">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.math.Interval.below.a">a</a>: <a href="#spire.math.Interval.below;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Below.readResolve" title="(upper: A, flags: Int)(implicit evidence$4: spire.algebra.Order[A])spire.math.Below[A]">Below</a><a href="#spire.math.Interval.below.evidence$19" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Interval.below.a" title="A">a</a>, <span title="Int(2)" class="int">2</span><span class="delimiter">)</span>
  def <a title="[A](a: A)(implicit evidence$20: spire.algebra.Order[A])spire.math.Interval[A]" id="spire.math.Interval.atOrAbove">atOrAbove</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.atOrAbove;A">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.math.Interval.atOrAbove.a">a</a>: <a href="#spire.math.Interval.atOrAbove;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Above.readResolve" title="(lower: A, flags: Int)(implicit evidence$3: spire.algebra.Order[A])spire.math.Above[A]">Above</a><a href="#spire.math.Interval.atOrAbove.evidence$20" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Interval.atOrAbove.a" title="A">a</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
  def <a title="[A](a: A)(implicit evidence$21: spire.algebra.Order[A])spire.math.Interval[A]" id="spire.math.Interval.atOrBelow">atOrBelow</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.atOrBelow;A">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.math.Interval.atOrBelow.a">a</a>: <a href="#spire.math.Interval.atOrBelow;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Below.readResolve" title="(upper: A, flags: Int)(implicit evidence$4: spire.algebra.Order[A])spire.math.Below[A]">Below</a><a href="#spire.math.Interval.atOrBelow.evidence$21" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Interval.atOrBelow.a" title="A">a</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>

  private val <a title="scala.util.matching.Regex" id="spire.math.Interval.NullRe">NullRe</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;^ *\\( *Ø *\\) *$&quot;</span>.<span title="=&gt; scala.util.matching.Regex">r</span>
  private val <a title="scala.util.matching.Regex" id="spire.math.Interval.SingleRe">SingleRe</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;^ *\\[ *([^,]+) *\\] *$&quot;</span>.<span title="=&gt; scala.util.matching.Regex">r</span>
  private val <a title="scala.util.matching.Regex" id="spire.math.Interval.PairRe">PairRe</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;^ *(\\[|\\() *(.+?) *, *(.+?) *(\\]|\\)) *$&quot;</span>.<span title="=&gt; scala.util.matching.Regex">r</span>

  def <a title="(s: String)spire.math.Interval[spire.math.Rational]" id="spire.math.Interval.apply(52f1e6555d)">apply</a><span class="delimiter">(</span><a title="String" id="spire.math.Interval.apply(52f1e6555d).s">s</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[spire.math.Rational]">Interval</a><span class="delimiter">[</span>Rational<span class="delimiter">]</span> =
    <a href="#spire.math.Interval.apply(52f1e6555d).s" title="String">s</a> match <span class="delimiter">{</span>
      case <a href="#spire.math.Interval.NullRe" title="(s: CharSequence)Option[List[String]]">NullRe</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.empty" title="[A](implicit o: spire.algebra.Order[A])spire.math.Interval[A]">empty</a><a href="Rational.scala.html#spire.math;RationalInstances.RationalAlgebra" title="(implicit o: spire.algebra.Order[spire.math.Rational])spire.math.Interval[spire.math.Rational]" class="delimiter">[</a><a href="Rational.scala.html#spire.math;Rational" title="spire.math.Rational">Rational</a><span class="delimiter">]</span>
      case <a href="#spire.math.Interval.SingleRe" title="(s: CharSequence)Option[List[String]]">SingleRe</a><span class="delimiter">(</span><span title="String">x</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.point" title="(a: spire.math.Rational)(implicit evidence$9: spire.algebra.Order[spire.math.Rational])spire.math.Interval[spire.math.Rational]">point</a><a href="Rational.scala.html#spire.math;RationalInstances.RationalAlgebra" title="=&gt; spire.math.RationalAlgebra" class="delimiter">(</a><a href="Rational.scala.html#spire.math.Rational.apply(3d5d5650e1)" title="(r: String)spire.math.Rational">Rational</a><span class="delimiter">(</span><span title="String">x</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case <a href="#spire.math.Interval.PairRe" title="(s: CharSequence)Option[List[String]]">PairRe</a><span class="delimiter">(</span><a title="String" id="spire.math.Interval.apply(52f1e6555d).left">left</a>, <span title="String">x</span>, <span title="String">y</span>, <a title="String" id="spire.math.Interval.apply(52f1e6555d).right">right</a><span class="delimiter">)</span> =&gt;
        <span title="(_1: String, _2: String, _3: String, _4: String)(String, String, String, String)" class="delimiter">(</span><a href="#spire.math.Interval.apply(52f1e6555d).left" title="String">left</a>, <span title="String">x</span>, <span title="String">y</span>, <a href="#spire.math.Interval.apply(52f1e6555d).right" title="String">right</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case <span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;-∞&quot;)" class="string">&quot;-∞&quot;</span>, <span title="String(&quot;∞&quot;)" class="string">&quot;∞&quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.all" title="[A](implicit evidence$10: spire.algebra.Order[A])spire.math.Interval[A]">all</a><a href="Rational.scala.html#spire.math;RationalInstances.RationalAlgebra" title="(implicit evidence$10: spire.algebra.Order[spire.math.Rational])spire.math.Interval[spire.math.Rational]" class="delimiter">[</a><a href="Rational.scala.html#spire.math;Rational" title="spire.math.Rational">Rational</a><span class="delimiter">]</span>
          case <span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;-∞&quot;)" class="string">&quot;-∞&quot;</span>, <span title="String">y</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.below" title="(a: spire.math.Rational)(implicit evidence$19: spire.algebra.Order[spire.math.Rational])spire.math.Interval[spire.math.Rational]">below</a><a href="Rational.scala.html#spire.math;RationalInstances.RationalAlgebra" title="=&gt; spire.math.RationalAlgebra" class="delimiter">(</a><a href="Rational.scala.html#spire.math.Rational.apply(3d5d5650e1)" title="(r: String)spire.math.Rational">Rational</a><span class="delimiter">(</span><span title="String">y</span><span class="delimiter">)</span><span class="delimiter">)</span>
          case <span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;-∞&quot;)" class="string">&quot;-∞&quot;</span>, <span title="String">y</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.atOrBelow" title="(a: spire.math.Rational)(implicit evidence$21: spire.algebra.Order[spire.math.Rational])spire.math.Interval[spire.math.Rational]">atOrBelow</a><a href="Rational.scala.html#spire.math;RationalInstances.RationalAlgebra" title="=&gt; spire.math.RationalAlgebra" class="delimiter">(</a><a href="Rational.scala.html#spire.math.Rational.apply(3d5d5650e1)" title="(r: String)spire.math.Rational">Rational</a><span class="delimiter">(</span><span title="String">y</span><span class="delimiter">)</span><span class="delimiter">)</span>
          case <span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String">x</span>, <span title="String(&quot;∞&quot;)" class="string">&quot;∞&quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.above" title="(a: spire.math.Rational)(implicit evidence$18: spire.algebra.Order[spire.math.Rational])spire.math.Interval[spire.math.Rational]">above</a><a href="Rational.scala.html#spire.math;RationalInstances.RationalAlgebra" title="=&gt; spire.math.RationalAlgebra" class="delimiter">(</a><a href="Rational.scala.html#spire.math.Rational.apply(3d5d5650e1)" title="(r: String)spire.math.Rational">Rational</a><span class="delimiter">(</span><span title="String">x</span><span class="delimiter">)</span><span class="delimiter">)</span>
          case <span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String">x</span>, <span title="String(&quot;∞&quot;)" class="string">&quot;∞&quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.atOrAbove" title="(a: spire.math.Rational)(implicit evidence$20: spire.algebra.Order[spire.math.Rational])spire.math.Interval[spire.math.Rational]">atOrAbove</a><a href="Rational.scala.html#spire.math;RationalInstances.RationalAlgebra" title="=&gt; spire.math.RationalAlgebra" class="delimiter">(</a><a href="Rational.scala.html#spire.math.Rational.apply(3d5d5650e1)" title="(r: String)spire.math.Rational">Rational</a><span class="delimiter">(</span><span title="String">x</span><span class="delimiter">)</span><span class="delimiter">)</span>
          case <span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String">x</span>, <span title="String">y</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.closed" title="(lower: spire.math.Rational, upper: spire.math.Rational)(implicit evidence$14: spire.algebra.Order[spire.math.Rational])spire.math.Interval[spire.math.Rational]">closed</a><a href="Rational.scala.html#spire.math;RationalInstances.RationalAlgebra" title="=&gt; spire.math.RationalAlgebra" class="delimiter">(</a><a href="Rational.scala.html#spire.math.Rational.apply(3d5d5650e1)" title="(r: String)spire.math.Rational">Rational</a><span class="delimiter">(</span><span title="String">x</span><span class="delimiter">)</span>, <a href="Rational.scala.html#spire.math.Rational.apply(3d5d5650e1)" title="(r: String)spire.math.Rational">Rational</a><span class="delimiter">(</span><span title="String">y</span><span class="delimiter">)</span><span class="delimiter">)</span>
          case <span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String">x</span>, <span title="String">y</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.open" title="(lower: spire.math.Rational, upper: spire.math.Rational)(implicit evidence$15: spire.algebra.Order[spire.math.Rational])spire.math.Interval[spire.math.Rational]">open</a><a href="Rational.scala.html#spire.math;RationalInstances.RationalAlgebra" title="=&gt; spire.math.RationalAlgebra" class="delimiter">(</a><a href="Rational.scala.html#spire.math.Rational.apply(3d5d5650e1)" title="(r: String)spire.math.Rational">Rational</a><span class="delimiter">(</span><span title="String">x</span><span class="delimiter">)</span>, <a href="Rational.scala.html#spire.math.Rational.apply(3d5d5650e1)" title="(r: String)spire.math.Rational">Rational</a><span class="delimiter">(</span><span title="String">y</span><span class="delimiter">)</span><span class="delimiter">)</span>
          case <span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String">x</span>, <span title="String">y</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.openUpper" title="(lower: spire.math.Rational, upper: spire.math.Rational)(implicit evidence$17: spire.algebra.Order[spire.math.Rational])spire.math.Interval[spire.math.Rational]">openUpper</a><a href="Rational.scala.html#spire.math;RationalInstances.RationalAlgebra" title="=&gt; spire.math.RationalAlgebra" class="delimiter">(</a><a href="Rational.scala.html#spire.math.Rational.apply(3d5d5650e1)" title="(r: String)spire.math.Rational">Rational</a><span class="delimiter">(</span><span title="String">x</span><span class="delimiter">)</span>, <a href="Rational.scala.html#spire.math.Rational.apply(3d5d5650e1)" title="(r: String)spire.math.Rational">Rational</a><span class="delimiter">(</span><span title="String">y</span><span class="delimiter">)</span><span class="delimiter">)</span>
          case <span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String">x</span>, <span title="String">y</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span> =&gt; <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.openLower" title="(lower: spire.math.Rational, upper: spire.math.Rational)(implicit evidence$16: spire.algebra.Order[spire.math.Rational])spire.math.Interval[spire.math.Rational]">openLower</a><a href="Rational.scala.html#spire.math;RationalInstances.RationalAlgebra" title="=&gt; spire.math.RationalAlgebra" class="delimiter">(</a><a href="Rational.scala.html#spire.math.Rational.apply(3d5d5650e1)" title="(r: String)spire.math.Rational">Rational</a><span class="delimiter">(</span><span title="String">x</span><span class="delimiter">)</span>, <a href="Rational.scala.html#spire.math.Rational.apply(3d5d5650e1)" title="(r: String)spire.math.Rational">Rational</a><span class="delimiter">(</span><span title="String">y</span><span class="delimiter">)</span><span class="delimiter">)</span>
          case _ =&gt; throw new <span title="NumberFormatException">NumberFormatException</span><span class="delimiter">(</span><span title="String(&quot;Impossible: &quot;)" class="string">&quot;Impossible: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#spire.math.Interval.apply(52f1e6555d).s" title="String">s</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      case _ =&gt; throw new <span title="NumberFormatException">NumberFormatException</span><span class="delimiter">(</span><span title="String(&quot;For input string: &quot;)" class="string">&quot;For input string: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#spire.math.Interval.apply(52f1e6555d).s" title="String">s</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  implicit def <a title="[A](implicit evidence$22: spire.algebra.Eq[A])spire.algebra.Eq[spire.math.Interval[A]]" id="spire.math.Interval.eq(97c5774e42)">eq</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.eq(97c5774e42);A">A</a>: Eq<span class="delimiter">]</span>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[spire.math.Interval[A]]">Eq</a><span class="delimiter">[</span>Interval<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    new <a title="&lt;$anon: spire.algebra.Eq[spire.math.Interval[A]]&gt; extends AnyRef with spire.algebra.Eq[spire.math.Interval[A]]" id="spire.math.Interval.eq(97c5774e42);$anon">Eq</a><span class="delimiter">[</span>Interval<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="(x: spire.math.Interval[A], y: spire.math.Interval[A])Boolean" id="spire.math.Interval.eq(97c5774e42);$anon.eqv">eqv</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math.Interval.eq(97c5774e42);$anon.eqv.x">x</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Interval[A]" id="spire.math.Interval.eq(97c5774e42);$anon.eqv.y">y</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.math.Interval.eq(97c5774e42);$anon.eqv.x" title="spire.math.Interval[A]">x</a> <span title="(x$1: Any)Boolean">==</span> <a href="#spire.math.Interval.eq(97c5774e42);$anon.eqv.y" title="spire.math.Interval[A]">y</a>
    <span class="delimiter">}</span>

  implicit def <a title="[A](implicit ev: spire.algebra.Ring[A], implicit o: spire.algebra.Order[A])spire.algebra.Semiring[spire.math.Interval[A]]" id="spire.math.Interval.semiring">semiring</a><span class="delimiter">[</span><a title="" id="spire.math.Interval.semiring;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.math.Interval.semiring.ev">ev</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.algebra.Order[A]" id="spire.math.Interval.semiring.o">o</a>: <a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../algebra/Semiring.scala.html#spire.algebra;Semiring" title="spire.algebra.Semiring[spire.math.Interval[A]]">Semiring</a><span class="delimiter">[</span>Interval<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    new <a title="&lt;$anon: spire.algebra.Semiring[spire.math.Interval[A]]&gt; extends AnyRef with spire.algebra.Semiring[spire.math.Interval[A]]" id="spire.math.Interval.semiring;$anon">Semiring</a><span class="delimiter">[</span>Interval<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="=&gt; spire.math.Interval[A]" id="spire.math.Interval.semiring;$anon.zero">zero</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Interval" title="spire.math.Interval.type">Interval</a>.<a href="#spire.math.Interval.point" title="(a: A)(implicit evidence$9: spire.algebra.Order[A])spire.math.Interval[A]">point</a><a href="#spire.math.Interval.semiring.o" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Interval.semiring.ev" title="spire.algebra.Ring[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span>
      def <a title="(x: spire.math.Interval[A], y: spire.math.Interval[A])spire.math.Interval[A]" id="spire.math.Interval.semiring;$anon.plus">plus</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math.Interval.semiring;$anon.plus.x">x</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Interval[A]" id="spire.math.Interval.semiring;$anon.plus.y">y</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Interval.semiring;$anon.plus.x" title="spire.math.Interval[A]">x</a> <a href="#spire.math;Interval.+(b8d503f15a)" title="(rhs: spire.math.Interval[A])(implicit ev: spire.algebra.AdditiveSemigroup[A])spire.math.Interval[A]">+</a> <a href="#spire.math.Interval.semiring;$anon.plus.y" title="spire.math.Interval[A]">y</a>
      def <a title="(x: spire.math.Interval[A], y: spire.math.Interval[A])spire.math.Interval[A]" id="spire.math.Interval.semiring;$anon.times">times</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math.Interval.semiring;$anon.times.x">x</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Interval[A]" id="spire.math.Interval.semiring;$anon.times.y">y</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Interval.semiring;$anon.times.x" title="spire.math.Interval[A]">x</a> <a href="#spire.math;Interval.*(74feccc19e)" title="(rhs: spire.math.Interval[A])(implicit ev: spire.algebra.Semiring[A])spire.math.Interval[A]">*</a> <a href="#spire.math.Interval.semiring;$anon.times.y" title="spire.math.Interval[A]">y</a>
      override def <a title="(x: spire.math.Interval[A], k: Int)spire.math.Interval[A]" id="spire.math.Interval.semiring;$anon.pow">pow</a><span class="delimiter">(</span><a title="spire.math.Interval[A]" id="spire.math.Interval.semiring;$anon.pow.x">x</a>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Int" id="spire.math.Interval.semiring;$anon.pow.k">k</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Interval.semiring;$anon.pow.x" title="spire.math.Interval[A]">x</a>.<a href="#spire.math;Interval.pow" title="(k: Int)(implicit r: spire.algebra.Ring[A])spire.math.Interval[A]">pow</a><a href="#spire.math.Interval.semiring.ev" title="spire.algebra.Ring[A]" class="delimiter">(</a><a href="#spire.math.Interval.semiring;$anon.pow.k" title="Int">k</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
