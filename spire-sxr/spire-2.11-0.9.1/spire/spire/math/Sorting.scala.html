<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>spire/spire/math/Sorting.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package spire.math

import scala.annotation.tailrec
import scala.reflect.ClassTag
import scala.<span class="delimiter">{</span>specialized =&gt; spec<span class="delimiter">}</span>

import spire.algebra.Order

<span class="comment">/**
 *  Interface for a sorting strategy object.
 */</span>
trait <a title="trait Sort extends Any" id="spire.math;Sort">Sort</a> extends <span title="Any">Any</span> <span class="delimiter">{</span>
  def <a title="[A](data: Array[A])(implicit evidence$1: spire.algebra.Order[A], implicit evidence$2: scala.reflect.ClassTag[A])Unit" id="spire.math;Sort.sort">sort</a><span class="delimiter">[</span>@spec <a title="" id="spire.math;Sort.sort;A">A</a>: Order: ClassTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.math;Sort.sort.data">data</a>:<span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Simple implementation of insertion sort.
 *
 * Works for small arrays but due to O(n^2) complexity is not generally good.
 */</span>
object <a title="spire.math.InsertionSort.type" id="spire.math.InsertionSort">InsertionSort</a> extends <a href="#spire.math;Sort" title="spire.math.Sort">Sort</a> <span class="delimiter">{</span>
  final def <a title="[A](data: Array[A])(implicit evidence$3: spire.algebra.Order[A], implicit evidence$4: scala.reflect.ClassTag[A])Unit" id="spire.math.InsertionSort.sort(5661d2fa73)">sort</a><span class="delimiter">[</span>@spec <a title="" id="spire.math.InsertionSort.sort(5661d2fa73);A">A</a>:Order:ClassTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.math.InsertionSort.sort(5661d2fa73).data">data</a>:<span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#spire.math.InsertionSort.sort(6e2fd08924)" title="(data: Array[A], start: Int, end: Int)(implicit o: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.math.InsertionSort.sort(5661d2fa73).evidence$3" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.InsertionSort.sort(5661d2fa73).data" title="Array[A]">data</a>, <span title="Int(0)" class="int">0</span>, <a href="#spire.math.InsertionSort.sort(5661d2fa73).data" title="Array[A]">data</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span>

  final def <a title="[A](data: Array[A], start: Int, end: Int)(implicit o: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Unit" id="spire.math.InsertionSort.sort(6e2fd08924)">sort</a><span class="delimiter">[</span>@spec <a title="" id="spire.math.InsertionSort.sort(6e2fd08924);A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.math.InsertionSort.sort(6e2fd08924).data">data</a>:<span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Int" id="spire.math.InsertionSort.sort(6e2fd08924).start">start</a>:<span title="Int">Int</span>, <a title="Int" id="spire.math.InsertionSort.sort(6e2fd08924).end">end</a>:<span title="Int">Int</span><span class="delimiter">)</span>
    <span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.math.InsertionSort.sort(6e2fd08924).o">o</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.reflect.ClassTag[A]" id="spire.math.InsertionSort.sort(6e2fd08924).ct">ct</a>:<span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    var i = <a href="#spire.math.InsertionSort.sort(6e2fd08924).start" title="Int">start</a> <a title="Int" id="spire.math.InsertionSort.sort(6e2fd08924).i">+</a> <span title="Int(1)" class="int">1</span>
    while <span class="delimiter">(</span><a href="#spire.math.InsertionSort.sort(6e2fd08924).i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.math.InsertionSort.sort(6e2fd08924).end" title="Int">end</a><span class="delimiter">)</span> <a href="#spire.math.InsertionSort.sort(6e2fd08924).while$2" title="()Unit" class="delimiter">{</a>
      val <a title="A" id="spire.math.InsertionSort.sort(6e2fd08924).item">item</a> = <a href="#spire.math.InsertionSort.sort(6e2fd08924).data" title="(i: Int)A">data</a><span class="delimiter">(</span><a href="#spire.math.InsertionSort.sort(6e2fd08924).i" title="Int">i</a><span class="delimiter">)</span>
      var <a title="Int" id="spire.math.InsertionSort.sort(6e2fd08924).hole">hole</a> = <a href="#spire.math.InsertionSort.sort(6e2fd08924).i" title="Int">i</a>
      while <span class="delimiter">(</span><a href="#spire.math.InsertionSort.sort(6e2fd08924).hole" title="Int">hole</a> <span title="(x: Int)Boolean">&gt;</span> <a href="#spire.math.InsertionSort.sort(6e2fd08924).start" title="Int">start</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math.InsertionSort.sort(6e2fd08924).o" title="spire.algebra.Order[A]">o</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">gt</a><span class="delimiter">(</span><a href="#spire.math.InsertionSort.sort(6e2fd08924).data" title="(i: Int)A">data</a><span class="delimiter">(</span><a href="#spire.math.InsertionSort.sort(6e2fd08924).hole" title="Int">hole</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>, <a href="#spire.math.InsertionSort.sort(6e2fd08924).item" title="A">item</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#spire.math.InsertionSort.sort(6e2fd08924).while$1" title="()Unit" class="delimiter">{</a>
        <a href="#spire.math.InsertionSort.sort(6e2fd08924).data" title="(i: Int, x: A)Unit">data</a><span class="delimiter">(</span><a href="#spire.math.InsertionSort.sort(6e2fd08924).hole" title="Int">hole</a><span class="delimiter">)</span> = <a href="#spire.math.InsertionSort.sort(6e2fd08924).data" title="(i: Int)A">data</a><span class="delimiter">(</span><a href="#spire.math.InsertionSort.sort(6e2fd08924).hole" title="Int">hole</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
        <a href="#spire.math.InsertionSort.sort(6e2fd08924).hole" title="Int">hole</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
      <span class="delimiter">}</span>
      <a href="#spire.math.InsertionSort.sort(6e2fd08924).data" title="(i: Int, x: A)Unit">data</a><span class="delimiter">(</span><a href="#spire.math.InsertionSort.sort(6e2fd08924).hole" title="Int">hole</a><span class="delimiter">)</span> = <a href="#spire.math.InsertionSort.sort(6e2fd08924).item" title="A">item</a>
      <a href="#spire.math.InsertionSort.sort(6e2fd08924).i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * In-place merge sort implementation. This sort is stable but does mutate
 * the given array. It is an in-place sort but it does allocate a temporary
 * array of the same size as the input. It uses InsertionSort for sorting very
 * small arrays.
 */</span>
object <a title="spire.math.MergeSort.type" id="spire.math.MergeSort">MergeSort</a> extends <a href="#spire.math;Sort" title="spire.math.Sort">Sort</a> <span class="delimiter">{</span>
  @inline final def <a title="=&gt; Int" id="spire.math.MergeSort.startWidth">startWidth</a> = <span title="Int(8)" class="int">8</span>
  @inline final def <a title="=&gt; Int" id="spire.math.MergeSort.startStep">startStep</a> = <span title="Int(16)" class="int">16</span>

  final def <a title="[A](data: Array[A])(implicit evidence$5: spire.algebra.Order[A], implicit evidence$6: scala.reflect.ClassTag[A])Unit" id="spire.math.MergeSort.sort">sort</a><span class="delimiter">[</span>@spec <a title="" id="spire.math.MergeSort.sort;A">A</a>:Order:ClassTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.math.MergeSort.sort.data">data</a>:<span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="Int" id="spire.math.MergeSort.sort.len">len</a> = <a href="#spire.math.MergeSort.sort.data" title="Array[A]">data</a>.<span title="=&gt; Int">length</span>

    if <span class="delimiter">(</span><a href="#spire.math.MergeSort.sort.len" title="Int">len</a> <span title="(x: Int)Boolean">&lt;=</span> <a href="#spire.math.MergeSort.startStep" title="=&gt; Int">startStep</a><span class="delimiter">)</span> return <a href="#spire.math.InsertionSort" title="spire.math.InsertionSort.type">InsertionSort</a>.<a href="#spire.math.InsertionSort.sort(5661d2fa73)" title="(data: Array[A])(implicit evidence$3: spire.algebra.Order[A], implicit evidence$4: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.math.MergeSort.sort.evidence$5" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.MergeSort.sort.data" title="Array[A]">data</a><span class="delimiter">)</span>

    var <a title="Array[A]" id="spire.math.MergeSort.sort.buf1">buf1</a>:<span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.MergeSort.sort.data" title="Array[A]">data</a>
    var <a title="Array[A]" id="spire.math.MergeSort.sort.buf2">buf2</a>:<span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = new Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.math.MergeSort.sort.len" title="Int">len</a><span class="delimiter">)</span>
    var <a title="Array[A]" id="spire.math.MergeSort.sort.tmp">tmp</a>:<span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = null

    var <a title="Int" id="spire.math.MergeSort.sort.i">i</a> = <span title="Int(0)" class="int">0</span>
    var limit = <a href="#spire.math.MergeSort.sort.len" title="Int">len</a> <a title="Int" id="spire.math.MergeSort.sort.limit">-</a> <a href="#spire.math.MergeSort.startWidth" title="=&gt; Int">startWidth</a>
    while <span class="delimiter">(</span><a href="#spire.math.MergeSort.sort.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.math.MergeSort.sort.limit" title="Int">limit</a><span class="delimiter">)</span> <a href="#spire.math.MergeSort.sort.while$3" title="()Unit" class="delimiter">{</a> <a href="#spire.math.InsertionSort" title="spire.math.InsertionSort.type">InsertionSort</a>.<a href="#spire.math.InsertionSort.sort(6e2fd08924)" title="(data: Array[A], start: Int, end: Int)(implicit o: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.math.MergeSort.sort.evidence$5" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.MergeSort.sort.data" title="Array[A]">data</a>, <a href="#spire.math.MergeSort.sort.i" title="Int">i</a>, <a href="#spire.math.MergeSort.sort.i" title="Int">i</a> <span title="(x: Int)Int">+</span> <a href="#spire.math.MergeSort.startWidth" title="=&gt; Int">startWidth</a><span class="delimiter">)</span>; <a href="#spire.math.MergeSort.sort.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <a href="#spire.math.MergeSort.startWidth" title="=&gt; Int">startWidth</a> <span class="delimiter">}</span>
    if <span class="delimiter">(</span><a href="#spire.math.MergeSort.sort.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.math.MergeSort.sort.len" title="Int">len</a><span class="delimiter">)</span> <a href="#spire.math.InsertionSort" title="spire.math.InsertionSort.type">InsertionSort</a>.<a href="#spire.math.InsertionSort.sort(6e2fd08924)" title="(data: Array[A], start: Int, end: Int)(implicit o: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.math.MergeSort.sort.evidence$5" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.MergeSort.sort.data" title="Array[A]">data</a>, <a href="#spire.math.MergeSort.sort.i" title="Int">i</a>, <a href="#spire.math.MergeSort.sort.len" title="Int">len</a><span class="delimiter">)</span>
    var <a title="Int" id="spire.math.MergeSort.sort.width">width</a> = <a href="#spire.math.MergeSort.startWidth" title="=&gt; Int">startWidth</a>
    var <a title="Int" id="spire.math.MergeSort.sort.step">step</a> = <a href="#spire.math.MergeSort.startStep" title="=&gt; Int">startStep</a>
    while <span class="delimiter">(</span><a href="#spire.math.MergeSort.sort.width" title="Int">width</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.math.MergeSort.sort.len" title="Int">len</a><span class="delimiter">)</span> <a href="#spire.math.MergeSort.sort.while$6" title="()Unit" class="delimiter">{</a>
      <a href="#spire.math.MergeSort.sort.i" title="Int">i</a> = <span title="Int(0)" class="int">0</span>
      <a href="#spire.math.MergeSort.sort.limit" title="Int">limit</a> = <a href="#spire.math.MergeSort.sort.len" title="Int">len</a> <span title="(x: Int)Int">-</span> <a href="#spire.math.MergeSort.sort.step" title="Int">step</a>
      while <span class="delimiter">(</span><a href="#spire.math.MergeSort.sort.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.math.MergeSort.sort.limit" title="Int">limit</a><span class="delimiter">)</span> <a href="#spire.math.MergeSort.sort.while$4" title="()Unit" class="delimiter">{</a>
        <a href="#spire.math.MergeSort.merge" title="(in: Array[A], out: Array[A], start: Int, mid: Int, end: Int)(implicit o: spire.algebra.Order[A])Unit">merge</a><a href="#spire.math.MergeSort.sort.evidence$5" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.MergeSort.sort.buf1" title="Array[A]">buf1</a>, <a href="#spire.math.MergeSort.sort.buf2" title="Array[A]">buf2</a>, <a href="#spire.math.MergeSort.sort.i" title="Int">i</a>, <a href="#spire.math.MergeSort.sort.i" title="Int">i</a> <span title="(x: Int)Int">+</span> <a href="#spire.math.MergeSort.sort.width" title="Int">width</a>, <a href="#spire.math.MergeSort.sort.i" title="Int">i</a> <span title="(x: Int)Int">+</span> <a href="#spire.math.MergeSort.sort.step" title="Int">step</a><span class="delimiter">)</span>; <a href="#spire.math.MergeSort.sort.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <a href="#spire.math.MergeSort.sort.step" title="Int">step</a>
      <span class="delimiter">}</span>
      while <span class="delimiter">(</span><a href="#spire.math.MergeSort.sort.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.math.MergeSort.sort.len" title="Int">len</a><span class="delimiter">)</span> <a href="#spire.math.MergeSort.sort.while$5" title="()Unit" class="delimiter">{</a>
        <a href="#spire.math.MergeSort.merge" title="(in: Array[A], out: Array[A], start: Int, mid: Int, end: Int)(implicit o: spire.algebra.Order[A])Unit">merge</a><a href="#spire.math.MergeSort.sort.evidence$5" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.MergeSort.sort.buf1" title="Array[A]">buf1</a>, <a href="#spire.math.MergeSort.sort.buf2" title="Array[A]">buf2</a>, <a href="#spire.math.MergeSort.sort.i" title="Int">i</a>, <a href="package.scala.html#spire.math.package.min(8c1ad44065)" title="(x: Int, y: Int)Int">min</a><span class="delimiter">(</span><a href="#spire.math.MergeSort.sort.i" title="Int">i</a> <span title="(x: Int)Int">+</span> <a href="#spire.math.MergeSort.sort.width" title="Int">width</a>, <a href="#spire.math.MergeSort.sort.len" title="Int">len</a><span class="delimiter">)</span>, <a href="#spire.math.MergeSort.sort.len" title="Int">len</a><span class="delimiter">)</span>; <a href="#spire.math.MergeSort.sort.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <a href="#spire.math.MergeSort.sort.step" title="Int">step</a>
      <span class="delimiter">}</span>
      <a href="#spire.math.MergeSort.sort.tmp" title="Array[A]">tmp</a> = <a href="#spire.math.MergeSort.sort.buf2" title="Array[A]">buf2</a>
      <a href="#spire.math.MergeSort.sort.buf2" title="Array[A]">buf2</a> = <a href="#spire.math.MergeSort.sort.buf1" title="Array[A]">buf1</a>
      <a href="#spire.math.MergeSort.sort.buf1" title="Array[A]">buf1</a> = <a href="#spire.math.MergeSort.sort.tmp" title="Array[A]">tmp</a>

      <a href="#spire.math.MergeSort.sort.width" title="Int">width</a> <span title="(x: Int)Int">*=</span> <span title="Int(2)" class="int">2</span>
      <a href="#spire.math.MergeSort.sort.step" title="Int">step</a> <span title="(x: Int)Int">*=</span> <span title="Int(2)" class="int">2</span>
    <span class="delimiter">}</span>

    if <span class="delimiter">(</span><a href="#spire.math.MergeSort.sort.buf1" title="Array[A]">buf1</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#spire.math.MergeSort.sort.data" title="Array[A]">data</a><span class="delimiter">)</span> <span title="System.type">System</span>.<span title="(x$1: Any, x$2: Int, x$3: Any, x$4: Int, x$5: Int)Unit">arraycopy</span><span class="delimiter">(</span><a href="#spire.math.MergeSort.sort.buf1" title="Array[A]">buf1</a>, <span title="Int(0)" class="int">0</span>, <a href="#spire.math.MergeSort.sort.data" title="Array[A]">data</a>, <span title="Int(0)" class="int">0</span>, <a href="#spire.math.MergeSort.sort.len" title="Int">len</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Helper method for mergeSort, used to do a single &quot;merge&quot; between two
   * sections of the input array. The start, mid and end parameters denote the
   * left and right ranges of the input to merge, as well as the area of the
   * ouput to write to.
   */</span>
  @inline final def <a title="[A](in: Array[A], out: Array[A], start: Int, mid: Int, end: Int)(implicit o: spire.algebra.Order[A])Unit" id="spire.math.MergeSort.merge">merge</a><span class="delimiter">[</span>@spec <a title="" id="spire.math.MergeSort.merge;A">A</a><span class="delimiter">]</span>
    <span class="delimiter">(</span><a title="Array[A]" id="spire.math.MergeSort.merge.in">in</a>:<span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.math.MergeSort.merge.out">out</a>:<span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Int" id="spire.math.MergeSort.merge.start">start</a>:<span title="Int">Int</span>, <a title="Int" id="spire.math.MergeSort.merge.mid">mid</a>:<span title="Int">Int</span>, <a title="Int" id="spire.math.MergeSort.merge.end">end</a>:<span title="Int">Int</span><span class="delimiter">)</span>
    <span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.math.MergeSort.merge.o">o</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    var <a title="Int" id="spire.math.MergeSort.merge.ii">ii</a> = <a href="#spire.math.MergeSort.merge.start" title="Int">start</a>
    var <a title="Int" id="spire.math.MergeSort.merge.jj">jj</a> = <a href="#spire.math.MergeSort.merge.mid" title="Int">mid</a>
    var <a title="Int" id="spire.math.MergeSort.merge.kk">kk</a> = <a href="#spire.math.MergeSort.merge.start" title="Int">start</a>
    while <span class="delimiter">(</span><a href="#spire.math.MergeSort.merge.kk" title="Int">kk</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.math.MergeSort.merge.end" title="Int">end</a><span class="delimiter">)</span> <a href="#spire.math.MergeSort.merge.while$7" title="()Unit" class="delimiter">{</a>
      if <span class="delimiter">(</span><a href="#spire.math.MergeSort.merge.ii" title="Int">ii</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.math.MergeSort.merge.mid" title="Int">mid</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#spire.math.MergeSort.merge.jj" title="Int">jj</a> <span title="(x: Int)Boolean">&gt;=</span> <a href="#spire.math.MergeSort.merge.end" title="Int">end</a> <span title="(x: Boolean)Boolean">||</span> <a href="#spire.math.MergeSort.merge.o" title="spire.algebra.Order[A]">o</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.lteqv" title="(x: A, y: A)Boolean">lteqv</a><span class="delimiter">(</span><a href="#spire.math.MergeSort.merge.in" title="(i: Int)A">in</a><span class="delimiter">(</span><a href="#spire.math.MergeSort.merge.ii" title="Int">ii</a><span class="delimiter">)</span>, <a href="#spire.math.MergeSort.merge.in" title="(i: Int)A">in</a><span class="delimiter">(</span><a href="#spire.math.MergeSort.merge.jj" title="Int">jj</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#spire.math.MergeSort.merge.out" title="(i: Int, x: A)Unit">out</a><span class="delimiter">(</span><a href="#spire.math.MergeSort.merge.kk" title="Int">kk</a><span class="delimiter">)</span> = <a href="#spire.math.MergeSort.merge.in" title="(i: Int)A">in</a><span class="delimiter">(</span><a href="#spire.math.MergeSort.merge.ii" title="Int">ii</a><span class="delimiter">)</span>; <a href="#spire.math.MergeSort.merge.ii" title="Int">ii</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <a href="#spire.math.MergeSort.merge.out" title="(i: Int, x: A)Unit">out</a><span class="delimiter">(</span><a href="#spire.math.MergeSort.merge.kk" title="Int">kk</a><span class="delimiter">)</span> = <a href="#spire.math.MergeSort.merge.in" title="(i: Int)A">in</a><span class="delimiter">(</span><a href="#spire.math.MergeSort.merge.jj" title="Int">jj</a><span class="delimiter">)</span>; <a href="#spire.math.MergeSort.merge.jj" title="Int">jj</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
      <span class="delimiter">}</span>
      <a href="#spire.math.MergeSort.merge.kk" title="Int">kk</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * In-place quicksort implementation. It is not stable, but does not allocate
 * extra space (other than stack). Like MergeSort, it uses InsertionSort for
 * sorting very small arrays.
 */</span>
object <a title="spire.math.QuickSort.type" id="spire.math.QuickSort">QuickSort</a> <a href="#spire.math.QuickSort" title="spire.math.QuickSort.type" class="delimiter">{</a>
  @inline final def <a title="=&gt; Int" id="spire.math.QuickSort.limit">limit</a> = <span title="Int(16)" class="int">16</span>

  final def <a title="[A](data: Array[A])(implicit evidence$7: spire.algebra.Order[A], implicit evidence$8: scala.reflect.ClassTag[A])Unit" id="spire.math.QuickSort.sort">sort</a><span class="delimiter">[</span>@spec <a title="" id="spire.math.QuickSort.sort;A">A</a>:Order:ClassTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.math.QuickSort.sort.data">data</a>:<span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math.QuickSort.qsort" title="(data: Array[A], left: Int, right: Int)(implicit o: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Unit">qsort</a><a href="#spire.math.QuickSort.sort.evidence$7" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.QuickSort.sort.data" title="Array[A]">data</a>, <span title="Int(0)" class="int">0</span>, <a href="#spire.math.QuickSort.sort.data" title="Array[A]">data</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

  final def <a title="[A](data: Array[A], left: Int, right: Int)(implicit o: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Unit" id="spire.math.QuickSort.qsort">qsort</a><span class="delimiter">[</span>@spec <a title="" id="spire.math.QuickSort.qsort;A">A</a><span class="delimiter">]</span>
    <span class="delimiter">(</span><a title="Array[A]" id="spire.math.QuickSort.qsort.data">data</a>:<span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Int" id="spire.math.QuickSort.qsort.left">left</a>: <span title="Int">Int</span>, <a title="Int" id="spire.math.QuickSort.qsort.right">right</a>: <span title="Int">Int</span><span class="delimiter">)</span>
    <span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.math.QuickSort.qsort.o">o</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.reflect.ClassTag[A]" id="spire.math.QuickSort.qsort.ct">ct</a>:<span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    if <span class="delimiter">(</span><a href="#spire.math.QuickSort.qsort.right" title="Int">right</a> <span title="(x: Int)Int">-</span> <a href="#spire.math.QuickSort.qsort.left" title="Int">left</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.math.QuickSort.limit" title="=&gt; Int">limit</a><span class="delimiter">)</span> return <a href="#spire.math.InsertionSort" title="spire.math.InsertionSort.type">InsertionSort</a>.<a href="#spire.math.InsertionSort.sort(6e2fd08924)" title="(data: Array[A], start: Int, end: Int)(implicit o: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.math.QuickSort.qsort.o" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.QuickSort.qsort.data" title="Array[A]">data</a>, <a href="#spire.math.QuickSort.qsort.left" title="Int">left</a>, <a href="#spire.math.QuickSort.qsort.right" title="Int">right</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

    val pivot = <a href="#spire.math.QuickSort.qsort.left" title="Int">left</a> <a title="Int" id="spire.math.QuickSort.qsort.pivot">+</a> <span class="delimiter">(</span><a href="#spire.math.QuickSort.qsort.right" title="Int">right</a> <span title="(x: Int)Int">-</span> <a href="#spire.math.QuickSort.qsort.left" title="Int">left</a><span class="delimiter">)</span> <span title="(x: Int)Int">/</span> <span title="Int(2)" class="int">2</span>
    val <a title="Int" id="spire.math.QuickSort.qsort.next">next</a> = <a href="#spire.math.QuickSort.partition" title="(data: Array[A], left: Int, right: Int, pivot: Int)(implicit o: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Int">partition</a><a href="#spire.math.QuickSort.qsort.o" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.QuickSort.qsort.data" title="Array[A]">data</a>, <a href="#spire.math.QuickSort.qsort.left" title="Int">left</a>, <a href="#spire.math.QuickSort.qsort.right" title="Int">right</a>, <a href="#spire.math.QuickSort.qsort.pivot" title="Int">pivot</a><span class="delimiter">)</span>
    <a href="#spire.math.QuickSort.qsort" title="(data: Array[A], left: Int, right: Int)(implicit o: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Unit">qsort</a><a href="#spire.math.QuickSort.qsort.o" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.QuickSort.qsort.data" title="Array[A]">data</a>, <a href="#spire.math.QuickSort.qsort.left" title="Int">left</a>, <a href="#spire.math.QuickSort.qsort.next" title="Int">next</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    <a href="#spire.math.QuickSort.qsort" title="(data: Array[A], left: Int, right: Int)(implicit o: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Unit">qsort</a><a href="#spire.math.QuickSort.qsort.o" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.QuickSort.qsort.data" title="Array[A]">data</a>, <a href="#spire.math.QuickSort.qsort.next" title="Int">next</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <a href="#spire.math.QuickSort.qsort.right" title="Int">right</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  final def <a title="[A](data: Array[A], left: Int, right: Int, pivot: Int)(implicit o: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Int" id="spire.math.QuickSort.partition">partition</a><span class="delimiter">[</span>@spec <a title="" id="spire.math.QuickSort.partition;A">A</a><span class="delimiter">]</span>
    <span class="delimiter">(</span><a title="Array[A]" id="spire.math.QuickSort.partition.data">data</a>:<span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Int" id="spire.math.QuickSort.partition.left">left</a>:<span title="Int">Int</span>, <a title="Int" id="spire.math.QuickSort.partition.right">right</a>:<span title="Int">Int</span>, <a title="Int" id="spire.math.QuickSort.partition.pivot">pivot</a>:<span title="Int">Int</span><span class="delimiter">)</span>
    <span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.math.QuickSort.partition.o">o</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.reflect.ClassTag[A]" id="spire.math.QuickSort.partition.ct">ct</a>:<span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>

    val <a title="A" id="spire.math.QuickSort.partition.value">value</a> = <a href="#spire.math.QuickSort.partition.data" title="(i: Int)A">data</a><span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.pivot" title="Int">pivot</a><span class="delimiter">)</span>

    <span class="comment">//swap(pivot, right)</span>
    var <a title="A" id="spire.math.QuickSort.partition.tmp">tmp</a> = <a href="#spire.math.QuickSort.partition.data" title="(i: Int)A">data</a><span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.pivot" title="Int">pivot</a><span class="delimiter">)</span>; <a href="#spire.math.QuickSort.partition.data" title="(i: Int, x: A)Unit">data</a><span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.pivot" title="Int">pivot</a><span class="delimiter">)</span> = <a href="#spire.math.QuickSort.partition.data" title="(i: Int)A">data</a><span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.right" title="Int">right</a><span class="delimiter">)</span>; <a href="#spire.math.QuickSort.partition.data" title="(i: Int, x: A)Unit">data</a><span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.right" title="Int">right</a><span class="delimiter">)</span> = <a href="#spire.math.QuickSort.partition.tmp" title="A">tmp</a>

    var <a title="Int" id="spire.math.QuickSort.partition.store">store</a> = <a href="#spire.math.QuickSort.partition.left" title="Int">left</a>
    var <a title="Int" id="spire.math.QuickSort.partition.i">i</a> = <a href="#spire.math.QuickSort.partition.left" title="Int">left</a>
    while <span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.math.QuickSort.partition.right" title="Int">right</a><span class="delimiter">)</span> <a href="#spire.math.QuickSort.partition.while$8" title="()Unit" class="delimiter">{</a>
      if <span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.o" title="spire.algebra.Order[A]">o</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">lt</a><span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.data" title="(i: Int)A">data</a><span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.i" title="Int">i</a><span class="delimiter">)</span>, <a href="#spire.math.QuickSort.partition.value" title="A">value</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">//swap(i, store)</span>
        <a href="#spire.math.QuickSort.partition.tmp" title="A">tmp</a> = <a href="#spire.math.QuickSort.partition.data" title="(i: Int)A">data</a><span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.i" title="Int">i</a><span class="delimiter">)</span>; <a href="#spire.math.QuickSort.partition.data" title="(i: Int, x: A)Unit">data</a><span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.i" title="Int">i</a><span class="delimiter">)</span> = <a href="#spire.math.QuickSort.partition.data" title="(i: Int)A">data</a><span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.store" title="Int">store</a><span class="delimiter">)</span>; <a href="#spire.math.QuickSort.partition.data" title="(i: Int, x: A)Unit">data</a><span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.store" title="Int">store</a><span class="delimiter">)</span> = <a href="#spire.math.QuickSort.partition.tmp" title="A">tmp</a>
        <a href="#spire.math.QuickSort.partition.store" title="Int">store</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
      <span class="delimiter">}</span>
      <a href="#spire.math.QuickSort.partition.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <span class="delimiter">}</span>
    <span class="comment">//swap(store, right)</span>
    <a href="#spire.math.QuickSort.partition.tmp" title="A">tmp</a> = <a href="#spire.math.QuickSort.partition.data" title="(i: Int)A">data</a><span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.store" title="Int">store</a><span class="delimiter">)</span>; <a href="#spire.math.QuickSort.partition.data" title="(i: Int, x: A)Unit">data</a><span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.store" title="Int">store</a><span class="delimiter">)</span> = <a href="#spire.math.QuickSort.partition.data" title="(i: Int)A">data</a><span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.right" title="Int">right</a><span class="delimiter">)</span>; <a href="#spire.math.QuickSort.partition.data" title="(i: Int, x: A)Unit">data</a><span class="delimiter">(</span><a href="#spire.math.QuickSort.partition.right" title="Int">right</a><span class="delimiter">)</span> = <a href="#spire.math.QuickSort.partition.tmp" title="A">tmp</a>
    <a href="#spire.math.QuickSort.partition.store" title="Int">store</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">// TODO: it would be nice to try implementing some hybrid sorts, for instance</span>
<span class="comment">// Tim Peters' sort algorithm.</span>

<span class="comment">/**
 * Object providing in-place sorting capability for arrays.
 *
 * Sorting.sort() uses quickSort() by default (in-place, not stable, generally
 * fastest but might hit bad cases where it's O(n^2)). Also provides
 * mergeSort() (in-place, stable, uses extra memory, still pretty fast) and
 * insertionSort(), which is slow except for small arrays.
 */</span>
object <a title="spire.math.Sorting.type" id="spire.math.Sorting">Sorting</a> <a href="#spire.math.Sorting" title="spire.math.Sorting.type" class="delimiter">{</a>
  final def <a title="[A](data: Array[A])(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit" id="spire.math.Sorting.sort">sort</a><span class="delimiter">[</span>@spec <a title="" id="spire.math.Sorting.sort;A">A</a>:Order:ClassTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.math.Sorting.sort.data">data</a>:<span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math.QuickSort" title="spire.math.QuickSort.type">QuickSort</a>.<a href="#spire.math.QuickSort.sort" title="(data: Array[A])(implicit evidence$7: spire.algebra.Order[A], implicit evidence$8: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.math.Sorting.sort.evidence$9" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Sorting.sort.data" title="Array[A]">data</a><span class="delimiter">)</span>

  final def <a title="[A](data: Array[A])(implicit evidence$11: spire.algebra.Order[A], implicit evidence$12: scala.reflect.ClassTag[A])Unit" id="spire.math.Sorting.insertionSort">insertionSort</a><span class="delimiter">[</span>@spec <a title="" id="spire.math.Sorting.insertionSort;A">A</a>:Order:ClassTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.math.Sorting.insertionSort.data">data</a>:<span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math.InsertionSort" title="spire.math.InsertionSort.type">InsertionSort</a>.<a href="#spire.math.InsertionSort.sort(5661d2fa73)" title="(data: Array[A])(implicit evidence$3: spire.algebra.Order[A], implicit evidence$4: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.math.Sorting.insertionSort.evidence$11" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Sorting.insertionSort.data" title="Array[A]">data</a><span class="delimiter">)</span>
  final def <a title="[A](data: Array[A])(implicit evidence$13: spire.algebra.Order[A], implicit evidence$14: scala.reflect.ClassTag[A])Unit" id="spire.math.Sorting.mergeSort">mergeSort</a><span class="delimiter">[</span>@spec <a title="" id="spire.math.Sorting.mergeSort;A">A</a>:Order:ClassTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.math.Sorting.mergeSort.data">data</a>:<span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math.MergeSort" title="spire.math.MergeSort.type">MergeSort</a>.<a href="#spire.math.MergeSort.sort" title="(data: Array[A])(implicit evidence$5: spire.algebra.Order[A], implicit evidence$6: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.math.Sorting.mergeSort.evidence$13" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.math.Sorting.mergeSort.data" title="Array[A]">data</a><span class="delimiter">)</span>
  final def <a title="[K](data: Array[K])(implicit evidence$15: spire.algebra.Order[K], implicit evidence$16: scala.reflect.ClassTag[K])Unit" id="spire.math.Sorting.quickSort">quickSort</a><span class="delimiter">[</span>@spec <a title="" id="spire.math.Sorting.quickSort;K">K</a>:Order:ClassTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[K]" id="spire.math.Sorting.quickSort.data">data</a>:<span title="Array[K]">Array</span><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math.QuickSort" title="spire.math.QuickSort.type">QuickSort</a>.<a href="#spire.math.QuickSort.sort" title="(data: Array[K])(implicit evidence$7: spire.algebra.Order[K], implicit evidence$8: scala.reflect.ClassTag[K])Unit">sort</a><a href="#spire.math.Sorting.quickSort.evidence$15" title="spire.algebra.Order[K]" class="delimiter">(</a><a href="#spire.math.Sorting.quickSort.data" title="Array[K]">data</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
