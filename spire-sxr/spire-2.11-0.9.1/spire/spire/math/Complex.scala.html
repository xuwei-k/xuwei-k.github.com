<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>spire/spire/math/Complex.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package spire.math

import spire.algebra._

import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.field" title="spire.syntax.field.type">field</a>._
import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.isReal" title="spire.syntax.isReal.type">isReal</a>._
import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.nroot" title="spire.syntax.nroot.type">nroot</a>._
import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.order" title="spire.syntax.order.type">order</a>._

import scala.<span class="delimiter">{</span>specialized =&gt; spec<span class="delimiter">}</span>
import scala.annotation.tailrec
import scala.math.<span class="delimiter">{</span>ScalaNumber, ScalaNumericConversions, ScalaNumericAnyConversions<span class="delimiter">}</span>
import java.lang.Math


object <a title="spire.math.Complex.type" id="spire.math.Complex.readResolve">Complex</a> extends <a href="#spire.math;ComplexInstances" title="spire.math.ComplexInstances">ComplexInstances</a> <span class="delimiter">{</span>
  def <a title="[T](implicit T: spire.algebra.Rig[T])spire.math.Complex[T]" id="spire.math.Complex.i">i</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math.Complex.i;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Rig[T]" id="spire.math.Complex.i.T">T</a>: <a href="../algebra/Rig.scala.html#spire.algebra;Rig" title="spire.algebra.Rig[T]">Rig</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> =
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math.Complex.i.T" title="spire.algebra.Rig[T]">T</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a>, <a href="#spire.math.Complex.i.T" title="spire.algebra.Rig[T]">T</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; T">one</a><span class="delimiter">)</span>

  def <a title="[T](implicit T: spire.algebra.Rig[T])spire.math.Complex[T]" id="spire.math.Complex.one">one</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math.Complex.one;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Rig[T]" id="spire.math.Complex.one.T">T</a>: <a href="../algebra/Rig.scala.html#spire.algebra;Rig" title="spire.algebra.Rig[T]">Rig</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> =
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math.Complex.one.T" title="spire.algebra.Rig[T]">T</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; T">one</a>, <a href="#spire.math.Complex.one.T" title="spire.algebra.Rig[T]">T</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span>

  def <a title="[T](implicit T: spire.algebra.Semiring[T])spire.math.Complex[T]" id="spire.math.Complex.zero">zero</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math.Complex.zero;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Semiring[T]" id="spire.math.Complex.zero.T">T</a>: <a href="../algebra/Semiring.scala.html#spire.algebra;Semiring" title="spire.algebra.Semiring[T]">Semiring</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> =
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math.Complex.zero.T" title="spire.algebra.Semiring[T]">T</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a>, <a href="#spire.math.Complex.zero.T" title="spire.algebra.Semiring[T]">T</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span>

  def <a title="[T](n: Int)(implicit f: spire.algebra.Ring[T])spire.math.Complex[T]" id="spire.math.Complex.fromInt">fromInt</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math.Complex.fromInt;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="spire.math.Complex.fromInt.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[T]" id="spire.math.Complex.fromInt.f">f</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[T]">Ring</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> =
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math.Complex.fromInt.f" title="spire.algebra.Ring[T]">f</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)T">fromInt</a><span class="delimiter">(</span><a href="#spire.math.Complex.fromInt.n" title="Int">n</a><span class="delimiter">)</span>, <a href="#spire.math.Complex.fromInt.f" title="spire.algebra.Ring[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span>

  implicit def <a title="implicit spire.math.Complex.intToComplex : (n: Int)spire.math.Complex[Double]" id="spire.math.Complex.intToComplex">intToComplex</a><span class="delimiter">(</span><a title="Int" id="spire.math.Complex.intToComplex.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[Double]">Complex</a><span class="delimiter">(</span><a href="#spire.math.Complex.intToComplex.n" title="Int">n</a>.<span title="=&gt; Double">toDouble</span>, <span title="Double(0.0)" class="double">0.0</span><span class="delimiter">)</span>
  implicit def <a title="implicit spire.math.Complex.longToComplex : (n: Long)spire.math.Complex[Double]" id="spire.math.Complex.longToComplex">longToComplex</a><span class="delimiter">(</span><a title="Long" id="spire.math.Complex.longToComplex.n">n</a>: <span title="Long">Long</span><span class="delimiter">)</span> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[Double]">Complex</a><span class="delimiter">(</span><a href="#spire.math.Complex.longToComplex.n" title="Long">n</a>.<span title="=&gt; Double">toDouble</span>, <span title="Double(0.0)" class="double">0.0</span><span class="delimiter">)</span>
  implicit def <a title="implicit spire.math.Complex.floatToComplex : (n: Float)spire.math.Complex[Float]" id="spire.math.Complex.floatToComplex">floatToComplex</a><span class="delimiter">(</span><a title="Float" id="spire.math.Complex.floatToComplex.n">n</a>: <span title="Float">Float</span><span class="delimiter">)</span> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[Float]">Complex</a><span class="delimiter">(</span><a href="#spire.math.Complex.floatToComplex.n" title="Float">n</a>, <span title="Float(0.0)" class="float">0.0F</span><span class="delimiter">)</span>
  implicit def <a title="implicit spire.math.Complex.doubleToComplex : (n: Double)spire.math.Complex[Double]" id="spire.math.Complex.doubleToComplex">doubleToComplex</a><span class="delimiter">(</span><a title="Double" id="spire.math.Complex.doubleToComplex.n">n</a>: <span title="Double">Double</span><span class="delimiter">)</span> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[Double]">Complex</a><span class="delimiter">(</span><a href="#spire.math.Complex.doubleToComplex.n" title="Double">n</a>, <span title="Double(0.0)" class="double">0.0</span><span class="delimiter">)</span>

  implicit def <a title="implicit spire.math.Complex.bigIntToComplex : (n: BigInt)spire.math.Complex[BigDecimal]" id="spire.math.Complex.bigIntToComplex">bigIntToComplex</a><span class="delimiter">(</span><a title="BigInt" id="spire.math.Complex.bigIntToComplex.n">n</a>: <span title="BigInt">BigInt</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[BigDecimal]">Complex</a><span class="delimiter">[</span>BigDecimal<span class="delimiter">]</span> =
    <a href="#spire.math.Complex.bigDecimalToComplex" title="implicit spire.math.Complex.bigDecimalToComplex : (n: BigDecimal)spire.math.Complex[BigDecimal]">bigDecimalToComplex</a><span class="delimiter">(</span><span title="(x: scala.math.BigInt)scala.math.BigDecimal">BigDecimal</span><span class="delimiter">(</span><a href="#spire.math.Complex.bigIntToComplex.n" title="BigInt">n</a><span class="delimiter">)</span><span class="delimiter">)</span>

  implicit def <a title="implicit spire.math.Complex.bigDecimalToComplex : (n: BigDecimal)spire.math.Complex[BigDecimal]" id="spire.math.Complex.bigDecimalToComplex">bigDecimalToComplex</a><span class="delimiter">(</span><a title="BigDecimal" id="spire.math.Complex.bigDecimalToComplex.n">n</a>: <span title="BigDecimal">BigDecimal</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[BigDecimal]">Complex</a><span class="delimiter">[</span>BigDecimal<span class="delimiter">]</span> = <span class="delimiter">{</span>
    implicit val <a title="java.math.MathContext" id="spire.math.Complex.bigDecimalToComplex.mc">mc</a> = <a href="#spire.math.Complex.bigDecimalToComplex.n" title="BigDecimal">n</a>.<span title="=&gt; java.math.MathContext">mc</span>
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[scala.math.BigDecimal]">Complex</a><span class="delimiter">(</span><a href="#spire.math.Complex.bigDecimalToComplex.n" title="BigDecimal">n</a>, <span title="(i: Int)scala.math.BigDecimal">BigDecimal</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="[T](magnitude: T, angle: T)(implicit evidence$1: spire.algebra.Field[T], implicit evidence$2: spire.algebra.Trig[T])spire.math.Complex[T]" id="spire.math.Complex.polar">polar</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math.Complex.polar;T">T</a>: Field: Trig<span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="spire.math.Complex.polar.magnitude">magnitude</a>: <a href="#spire.math.Complex.polar;T" title="T">T</a>, <a title="T" id="spire.math.Complex.polar.angle">angle</a>: <a href="#spire.math.Complex.polar;T" title="T">T</a><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math.Complex.polar.evidence$1" title="spire.algebra.Field[T]">magnitude</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="../algebra/Trig.scala.html#spire.algebra.Trig.apply" title="[A](implicit t: spire.algebra.Trig[A])spire.algebra.Trig[A]">Trig</a><a href="#spire.math.Complex.polar.evidence$2" title="(implicit t: spire.algebra.Trig[T])spire.algebra.Trig[T]" class="delimiter">[</a><a href="#spire.math.Complex.polar;T" title="T">T</a><span class="delimiter">]</span>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.cos" title="(a: T)T">cos</a><span class="delimiter">(</span><a href="#spire.math.Complex.polar.angle" title="T">angle</a><span class="delimiter">)</span>, <a href="#spire.math.Complex.polar.evidence$1" title="spire.algebra.Field[T]">magnitude</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="../algebra/Trig.scala.html#spire.algebra.Trig.apply" title="[A](implicit t: spire.algebra.Trig[A])spire.algebra.Trig[A]">Trig</a><a href="#spire.math.Complex.polar.evidence$2" title="(implicit t: spire.algebra.Trig[T])spire.algebra.Trig[T]" class="delimiter">[</a><a href="#spire.math.Complex.polar;T" title="T">T</a><span class="delimiter">]</span>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.sin" title="(a: T)T">sin</a><span class="delimiter">(</span><a href="#spire.math.Complex.polar.angle" title="T">angle</a><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="[T](real: T)(implicit evidence$3: spire.algebra.Semiring[T])spire.math.Complex[T]" id="spire.math.Complex.apply(649289f1e7)">apply</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math.Complex.apply(649289f1e7);T">T</a>: Semiring<span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="spire.math.Complex.apply(649289f1e7).real">real</a>: <a href="#spire.math.Complex.apply(649289f1e7);T" title="T">T</a><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math.Complex.apply(649289f1e7).real" title="T">real</a>, <a href="../algebra/Semiring.scala.html#spire.algebra.Semiring.apply" title="[A](implicit r: spire.algebra.Semiring[A])spire.algebra.Semiring[A]">Semiring</a><a href="#spire.math.Complex.apply(649289f1e7).evidence$3" title="(implicit r: spire.algebra.Semiring[T])spire.algebra.Semiring[T]" class="delimiter">[</a><a href="#spire.math.Complex.apply(649289f1e7);T" title="T">T</a><span class="delimiter">]</span>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span>

  def <a title="[T](n: Int, x: Int)(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit r: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math.Complex.rootOfUnity">rootOfUnity</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math.Complex.rootOfUnity;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="spire.math.Complex.rootOfUnity.n">n</a>: <span title="Int">Int</span>, <a title="Int" id="spire.math.Complex.rootOfUnity.x">x</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math.Complex.rootOfUnity.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math.Complex.rootOfUnity.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math.Complex.rootOfUnity.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.math.Complex.rootOfUnity.x" title="Int">x</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> return <a href="#spire.math.Complex.one" title="[T](implicit T: spire.algebra.Rig[T])spire.math.Complex[T]">one</a><a href="#spire.math.Complex.rootOfUnity.f" title="(implicit T: spire.algebra.Rig[T])spire.math.Complex[T]" class="delimiter">[</a><a href="#spire.math.Complex.rootOfUnity;T" title="T">T</a><span class="delimiter">]</span>

    if <span class="delimiter">(</span><a href="#spire.math.Complex.rootOfUnity.n" title="Int">n</a> <span title="(x: Int)Int">%</span> <span title="Int(2)" class="int">2</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#spire.math.Complex.rootOfUnity.x" title="Int">x</a> <span title="(x: Int)Boolean">==</span> <a href="#spire.math.Complex.rootOfUnity.n" title="Int">n</a> <span title="(x: Int)Int">/</span> <span title="Int(2)" class="int">2</span><span class="delimiter">)</span> return <a href="#spire.math;Complex.unary_-" title="(implicit r: spire.algebra.Rng[T])spire.math.Complex[T]">-</a><a href="#spire.math.Complex.one" title="[T](implicit T: spire.algebra.Rig[T])spire.math.Complex[T]">one</a><a href="#spire.math.Complex.rootOfUnity.f" title="(implicit T: spire.algebra.Rig[T])spire.math.Complex[T]" class="delimiter">[</a><a href="#spire.math.Complex.rootOfUnity;T" title="T">T</a><span class="delimiter">]</span>
      if <span class="delimiter">(</span><a href="#spire.math.Complex.rootOfUnity.n" title="Int">n</a> <span title="(x: Int)Int">%</span> <span title="Int(4)" class="int">4</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#spire.math.Complex.rootOfUnity.x" title="Int">x</a> <span title="(x: Int)Boolean">==</span> <a href="#spire.math.Complex.rootOfUnity.n" title="Int">n</a> <span title="(x: Int)Int">/</span> <span title="Int(4)" class="int">4</span><span class="delimiter">)</span> return <a href="#spire.math.Complex.i" title="[T](implicit T: spire.algebra.Rig[T])spire.math.Complex[T]">i</a><a href="#spire.math.Complex.rootOfUnity.f" title="(implicit T: spire.algebra.Rig[T])spire.math.Complex[T]" class="delimiter">[</a><a href="#spire.math.Complex.rootOfUnity;T" title="T">T</a><span class="delimiter">]</span>
        if <span class="delimiter">(</span><a href="#spire.math.Complex.rootOfUnity.x" title="Int">x</a> <span title="(x: Int)Boolean">==</span> <a href="#spire.math.Complex.rootOfUnity.n" title="Int">n</a> <span title="(x: Int)Int">*</span> <span title="Int(3)" class="int">3</span> <span title="(x: Int)Int">/</span> <span title="Int(4)" class="int">4</span><span class="delimiter">)</span> return <a href="#spire.math;Complex.unary_-" title="(implicit r: spire.algebra.Rng[T])spire.math.Complex[T]">-</a><a href="#spire.math.Complex.i" title="[T](implicit T: spire.algebra.Rig[T])spire.math.Complex[T]">i</a><a href="#spire.math.Complex.rootOfUnity.f" title="(implicit T: spire.algebra.Rig[T])spire.math.Complex[T]" class="delimiter">[</a><a href="#spire.math.Complex.rootOfUnity;T" title="T">T</a><span class="delimiter">]</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="#spire.math.Complex.polar" title="(magnitude: T, angle: T)(implicit evidence$1: spire.algebra.Field[T], implicit evidence$2: spire.algebra.Trig[T])spire.math.Complex[T]">polar</a><a href="#spire.math.Complex.rootOfUnity.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math.Complex.rootOfUnity.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; T">one</a>, <span class="delimiter">(</span><a href="#spire.math.Complex.rootOfUnity.t" title="spire.algebra.Trig[T]">t</a>.<a href="#spire.math.Complex.rootOfUnity.f" title="spire.algebra.Field[T]">pi</a> <a href="#spire.math.Complex.rootOfUnity.f" title="spire.algebra.Field[T]">*</a> <span title="Int(2)" class="int">2</span> <a href="#spire.math.Complex.rootOfUnity.f" title="spire.algebra.Field[T]">*</a> <a href="#spire.math.Complex.rootOfUnity.x" title="Int">x</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <a href="#spire.math.Complex.rootOfUnity.n" title="Int">n</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="[T](n: Int)(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit r: spire.algebra.IsReal[T])Array[spire.math.Complex[T]]" id="spire.math.Complex.rootsOfUnity">rootsOfUnity</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math.Complex.rootsOfUnity;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="spire.math.Complex.rootsOfUnity.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math.Complex.rootsOfUnity.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math.Complex.rootsOfUnity.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math.Complex.rootsOfUnity.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[spire.math.Complex[T]]">Array</span><span class="delimiter">[</span>Complex<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[spire.math.Complex[T]]" id="spire.math.Complex.rootsOfUnity.roots">roots</a> = new <span title="Array[spire.math.Complex[T]]">Array</span><span class="delimiter">[</span>Complex<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.math.Complex.rootsOfUnity.n" title="Int">n</a><span class="delimiter">)</span>
    var <a title="spire.math.Complex[T]" id="spire.math.Complex.rootsOfUnity.sum">sum</a> = <a href="#spire.math.Complex.one" title="[T](implicit T: spire.algebra.Rig[T])spire.math.Complex[T]">one</a><a href="#spire.math.Complex.rootsOfUnity.f" title="(implicit T: spire.algebra.Rig[T])spire.math.Complex[T]" class="delimiter">[</a><a href="#spire.math.Complex.rootsOfUnity;T" title="T">T</a><span class="delimiter">]</span>
    <a href="#spire.math.Complex.rootsOfUnity.roots" title="(i: Int, x: spire.math.Complex[T])Unit">roots</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> = <a href="#spire.math.Complex.rootsOfUnity.sum" title="spire.math.Complex[T]">sum</a>

    val <a title="Int" id="spire.math.Complex.rootsOfUnity.west">west</a> = if <span class="delimiter">(</span><a href="#spire.math.Complex.rootsOfUnity.n" title="Int">n</a> <span title="(x: Int)Int">%</span> <span title="Int(2)" class="int">2</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#spire.math.Complex.rootsOfUnity.n" title="Int">n</a> <span title="(x: Int)Int">/</span> <span title="Int(2)" class="int">2</span> else -<span title="Int(-1)" class="int">1</span>
    val <a title="Int" id="spire.math.Complex.rootsOfUnity.north">north</a> = if <span class="delimiter">(</span><a href="#spire.math.Complex.rootsOfUnity.n" title="Int">n</a> <span title="(x: Int)Int">%</span> <span title="Int(4)" class="int">4</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#spire.math.Complex.rootsOfUnity.n" title="Int">n</a> <span title="(x: Int)Int">/</span> <span title="Int(4)" class="int">4</span> else -<span title="Int(-1)" class="int">1</span>
    val <a title="Int" id="spire.math.Complex.rootsOfUnity.south">south</a> = if <span class="delimiter">(</span><a href="#spire.math.Complex.rootsOfUnity.n" title="Int">n</a> <span title="(x: Int)Int">%</span> <span title="Int(4)" class="int">4</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="Int(3)" class="int">3</span> <span title="(x: Int)Int">*</span> <a href="#spire.math.Complex.rootsOfUnity.n" title="Int">n</a> <span title="(x: Int)Int">/</span> <span title="Int(4)" class="int">4</span> else -<span title="Int(-1)" class="int">1</span>

    var <a title="Int" id="spire.math.Complex.rootsOfUnity.x">x</a> = <span title="Int(1)" class="int">1</span>
    val last = <a href="#spire.math.Complex.rootsOfUnity.n" title="Int">n</a> <a title="Int" id="spire.math.Complex.rootsOfUnity.last">-</a> <span title="Int(1)" class="int">1</span>
    while <span class="delimiter">(</span><a href="#spire.math.Complex.rootsOfUnity.x" title="Int">x</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.math.Complex.rootsOfUnity.last" title="Int">last</a><span class="delimiter">)</span> <a href="#spire.math.Complex.rootsOfUnity.while$1" title="()Unit" class="delimiter">{</a>
      val <a title="spire.math.Complex[T]" id="spire.math.Complex.rootsOfUnity.c">c</a> = <a href="#spire.math.Complex.rootsOfUnity.x" title="Int">x</a> match <span class="delimiter">{</span>
        case <a href="#spire.math.Complex.rootsOfUnity.north" title="Int">`north`</a> =&gt; <a href="#spire.math.Complex.i" title="[T](implicit T: spire.algebra.Rig[T])spire.math.Complex[T]">i</a><a href="#spire.math.Complex.rootsOfUnity.f" title="(implicit T: spire.algebra.Rig[T])spire.math.Complex[T]" class="delimiter">[</a><a href="#spire.math.Complex.rootsOfUnity;T" title="T">T</a><span class="delimiter">]</span>
        case <a href="#spire.math.Complex.rootsOfUnity.west" title="Int">`west`</a> =&gt; <a href="#spire.math;Complex.unary_-" title="(implicit r: spire.algebra.Rng[T])spire.math.Complex[T]">-</a><a href="#spire.math.Complex.one" title="[T](implicit T: spire.algebra.Rig[T])spire.math.Complex[T]">one</a><a href="#spire.math.Complex.rootsOfUnity.f" title="(implicit T: spire.algebra.Rig[T])spire.math.Complex[T]" class="delimiter">[</a><a href="#spire.math.Complex.rootsOfUnity;T" title="T">T</a><span class="delimiter">]</span>
        case <a href="#spire.math.Complex.rootsOfUnity.south" title="Int">`south`</a> =&gt; <a href="#spire.math;Complex.unary_-" title="(implicit r: spire.algebra.Rng[T])spire.math.Complex[T]">-</a><a href="#spire.math.Complex.i" title="[T](implicit T: spire.algebra.Rig[T])spire.math.Complex[T]">i</a><a href="#spire.math.Complex.rootsOfUnity.f" title="(implicit T: spire.algebra.Rig[T])spire.math.Complex[T]" class="delimiter">[</a><a href="#spire.math.Complex.rootsOfUnity;T" title="T">T</a><span class="delimiter">]</span>
        case _ =&gt; <a href="#spire.math.Complex.polar" title="(magnitude: T, angle: T)(implicit evidence$1: spire.algebra.Field[T], implicit evidence$2: spire.algebra.Trig[T])spire.math.Complex[T]">polar</a><a href="#spire.math.Complex.rootsOfUnity.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math.Complex.rootsOfUnity.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; T">one</a>, <span class="delimiter">(</span><a href="#spire.math.Complex.rootsOfUnity.t" title="spire.algebra.Trig[T]">t</a>.<a href="#spire.math.Complex.rootsOfUnity.f" title="spire.algebra.Field[T]">pi</a> <a href="#spire.math.Complex.rootsOfUnity.f" title="spire.algebra.Field[T]">*</a> <span title="Int(2)" class="int">2</span> <a href="#spire.math.Complex.rootsOfUnity.f" title="spire.algebra.Field[T]">*</a> <a href="#spire.math.Complex.rootsOfUnity.x" title="Int">x</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <a href="#spire.math.Complex.rootsOfUnity.n" title="Int">n</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#spire.math.Complex.rootsOfUnity.roots" title="(i: Int, x: spire.math.Complex[T])Unit">roots</a><span class="delimiter">(</span><a href="#spire.math.Complex.rootsOfUnity.x" title="Int">x</a><span class="delimiter">)</span> = <a href="#spire.math.Complex.rootsOfUnity.c" title="spire.math.Complex[T]">c</a>
      <a href="#spire.math.Complex.rootsOfUnity.sum" title="spire.math.Complex[T]">sum</a> <a href="#spire.math;Complex.+(cb068cef3f)" title="(b: spire.math.Complex[T])(implicit r: spire.algebra.Semiring[T])spire.math.Complex[T]">+=</a> <a href="#spire.math.Complex.rootsOfUnity.c" title="spire.math.Complex[T]">c</a>
      <a href="#spire.math.Complex.rootsOfUnity.x" title="Int">x</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <span class="delimiter">}</span>

    <a href="#spire.math.Complex.rootsOfUnity.roots" title="(i: Int, x: spire.math.Complex[T])Unit">roots</a><span class="delimiter">(</span><a href="#spire.math.Complex.rootsOfUnity.last" title="Int">last</a><span class="delimiter">)</span> = <a href="#spire.math.Complex.zero" title="[T](implicit T: spire.algebra.Semiring[T])spire.math.Complex[T]">zero</a><a href="#spire.math.Complex.rootsOfUnity.f" title="(implicit T: spire.algebra.Semiring[T])spire.math.Complex[T]" class="delimiter">[</a><a href="#spire.math.Complex.rootsOfUnity;T" title="T">T</a><span class="delimiter">]</span> <a href="#spire.math;Complex.-(e1c0640f17)" title="(b: spire.math.Complex[T])(implicit r: spire.algebra.Rng[T])spire.math.Complex[T]">-</a> <a href="#spire.math.Complex.rootsOfUnity.sum" title="spire.math.Complex[T]">sum</a>
    <a href="#spire.math.Complex.rootsOfUnity.roots" title="Array[spire.math.Complex[T]]">roots</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
final case class <a href="#spire.math;Complex.copy$default$1" title="[T](real: T, imag: T)spire.math.Complex[T]" id="spire.math;Complex.canEqual">Complex</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math;Complex.copy$default$2;T">T</a><span class="delimiter">]</span><span title="Product" class="delimiter">(</span><a title="T" id="spire.math;Complex.copy$default$1">real</a>: <a href="#spire.math;Complex.copy$default$2;T" title="T">T</a>, <a title="T" id="spire.math;Complex.copy$default$2">imag</a>: <a href="#spire.math;Complex.copy$default$2;T" title="T">T</a><span class="delimiter">)</span>
    extends <a href="#spire.math;Complex.canEqual" title="scala.math.ScalaNumber">ScalaNumber</a> with <span title="scala.math.ScalaNumericConversions">ScalaNumericConversions</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span> lhs =&gt;

  import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.order" title="spire.syntax.order.type">order</a>._

  <span class="comment">/**
   * This returns the sign of `real` if it is not 0, otherwise it returns the
   * sign of `imag`.
   */</span>
  def <a title="(implicit o: spire.algebra.IsReal[T])Int" id="spire.math;Complex.signum">signum</a><span class="delimiter">(</span>implicit <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.signum.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.math;Complex.signum.o" title="spire.algebra.IsReal[T]">real</a>.<a href="../algebra/Signed.scala.html#spire.algebra;Signed.signum" title="(a: T)Int">signum</a> match <span class="delimiter">{</span>
    case <span title="Int(0)" class="int">0</span> =&gt; <a href="#spire.math;Complex.signum.o" title="spire.algebra.IsReal[T]">imag</a>.<a href="../algebra/Signed.scala.html#spire.algebra;Signed.signum" title="(a: T)Int">signum</a>
    case <a title="Int" id="spire.math;Complex.signum.n">n</a> =&gt; <a href="#spire.math;Complex.signum.n" title="Int">n</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This implements sgn(z), which (except for z=0) observes:
   *
   * `sgn(z) = z / abs(z) = abs(z) / z`
   */</span>
  def <a title="(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T], implicit n: spire.algebra.NRoot[T])spire.math.Complex[T]" id="spire.math;Complex.complexSignum">complexSignum</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.complexSignum.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.complexSignum.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.complexSignum.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#spire.math;Complex.isZero" title="(implicit o: spire.algebra.IsReal[T])Boolean">isZero</a><span class="delimiter">)</span> this else this <a href="#spire.math;Complex./(a07fe4b95c)" title="(rhs: T)(implicit r: spire.algebra.Field[T])spire.math.Complex[T]">/</a> <a href="#spire.math;Complex.abs" title="(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T], implicit n: spire.algebra.NRoot[T])T">abs</a>

  def <a title="(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T], implicit n: spire.algebra.NRoot[T])T" id="spire.math;Complex.abs">abs</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.abs.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.abs.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.abs.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.copy$default$2;T" title="T">T</a> =
    <span class="delimiter">(</span><a href="#spire.math;Complex.abs.f" title="spire.algebra.Field[T]">real</a> <a href="#spire.math;Complex.abs.f" title="spire.algebra.Field[T]">*</a> <a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a> <a href="#spire.math;Complex.abs.n" title="spire.algebra.NRoot[T]">+</a> <a href="#spire.math;Complex.abs.f" title="spire.algebra.Field[T]">imag</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span>.<a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.sqrt" title="(a: T)T">sqrt</a>

  def <a title="(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])T" id="spire.math;Complex.arg">arg</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.arg.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.arg.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.arg.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.copy$default$2;T" title="T">T</a> =
    if <span class="delimiter">(</span><a href="#spire.math;Complex.isZero" title="(implicit o: spire.algebra.IsReal[T])Boolean">isZero</a><span class="delimiter">)</span> <a href="#spire.math;Complex.arg.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a> else <a href="#spire.math;Complex.arg.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.atan2" title="(y: T, x: T)T">atan2</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a>, <a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>

  def <a title="(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit o: spire.algebra.Order[T])T" id="spire.math;Complex.norm">norm</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.norm.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.norm.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Order[T]" id="spire.math;Complex.norm.o">o</a>: <a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[T]">Order</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.copy$default$2;T" title="T">T</a> = <a href="package.scala.html#spire.math.package.hypot" title="(x: T, y: T)(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit o: spire.algebra.Order[T])T">hypot</a><a href="#spire.math;Complex.norm.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span>

  def <a title="(implicit f: spire.algebra.Rng[T])spire.math.Complex[T]" id="spire.math;Complex.conjugate">conjugate</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Rng[T]" id="spire.math;Complex.conjugate.f">f</a>: <a href="../algebra/Rng.scala.html#spire.algebra;Rng" title="spire.algebra.Rng[T]">Rng</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a>, <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: T)T">-</a><a href="#spire.math;Complex.conjugate.f" title="spire.algebra.Rng[T]">imag</a><span class="delimiter">)</span>

  def <a title="=&gt; (T, T)" id="spire.math;Complex.asTuple">asTuple</a>: <span title="(T, T)" class="delimiter">(</span>T, T<span class="delimiter">)</span> = <span title="(_1: T, _2: T)(T, T)" class="delimiter">(</span><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span>
  def <a title="(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])(T, T)" id="spire.math;Complex.asPolarTuple">asPolarTuple</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.asPolarTuple.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.asPolarTuple.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.asPolarTuple.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.asPolarTuple.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(T, T)" class="delimiter">(</span>T, T<span class="delimiter">)</span> = <span title="(_1: T, _2: T)(T, T)" class="delimiter">(</span><a href="#spire.math;Complex.abs" title="(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T], implicit n: spire.algebra.NRoot[T])T">abs</a>, <a href="#spire.math;Complex.arg" title="(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])T">arg</a><span class="delimiter">)</span>

  def <a title="(implicit o: spire.algebra.IsReal[T])Boolean" id="spire.math;Complex.isZero">isZero</a><span class="delimiter">(</span>implicit <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.isZero.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Complex.isZero.o" title="spire.algebra.IsReal[T]">real</a>.<a href="../algebra/Signed.scala.html#spire.algebra;Signed.isSignZero" title="(a: T)Boolean">isSignZero</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Complex.isZero.o" title="spire.algebra.IsReal[T]">imag</a>.<a href="../algebra/Signed.scala.html#spire.algebra;Signed.isSignZero" title="(a: T)Boolean">isSignZero</a>
  def <a title="(implicit o: spire.algebra.IsReal[T])Boolean" id="spire.math;Complex.isImaginary">isImaginary</a><span class="delimiter">(</span>implicit <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.isImaginary.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Complex.isImaginary.o" title="spire.algebra.IsReal[T]">real</a>.<a href="../algebra/Signed.scala.html#spire.algebra;Signed.isSignZero" title="(a: T)Boolean">isSignZero</a>
  def <a title="(implicit o: spire.algebra.IsReal[T])Boolean" id="spire.math;Complex.isReal">isReal</a><span class="delimiter">(</span>implicit <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.isReal.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Complex.isReal.o" title="spire.algebra.IsReal[T]">imag</a>.<a href="../algebra/Signed.scala.html#spire.algebra;Signed.isSignZero" title="(a: T)Boolean">isSignZero</a>

  def <a title="(b: spire.math.Complex[T])(implicit o: spire.algebra.Eq[T])Boolean" id="spire.math;Complex.eqv">eqv</a><span class="delimiter">(</span><a title="spire.math.Complex[T]" id="spire.math;Complex.eqv.b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Eq[T]" id="spire.math;Complex.eqv.o">o</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[T]">Eq</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Complex.eqv.o" title="spire.algebra.Eq[T]">real</a> <a href="../algebra/Eq.scala.html#spire.algebra;Eq.eqv" title="(x: T, y: T)Boolean">===</a> <a href="#spire.math;Complex.eqv.b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Complex.eqv.o" title="spire.algebra.Eq[T]">imag</a> <a href="../algebra/Eq.scala.html#spire.algebra;Eq.eqv" title="(x: T, y: T)Boolean">===</a> <a href="#spire.math;Complex.eqv.b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a>
  def <a title="(b: spire.math.Complex[T])(implicit o: spire.algebra.Eq[T])Boolean" id="spire.math;Complex.neqv">neqv</a><span class="delimiter">(</span><a title="spire.math.Complex[T]" id="spire.math;Complex.neqv.b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Eq[T]" id="spire.math;Complex.neqv.o">o</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[T]">Eq</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Complex.neqv.o" title="spire.algebra.Eq[T]">real</a> <a href="../algebra/Eq.scala.html#spire.algebra;Eq.neqv" title="(x: T, y: T)Boolean">=!=</a> <a href="#spire.math;Complex.neqv.b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a> <span title="(x: Boolean)Boolean">||</span> <a href="#spire.math;Complex.neqv.o" title="spire.algebra.Eq[T]">imag</a> <a href="../algebra/Eq.scala.html#spire.algebra;Eq.neqv" title="(x: T, y: T)Boolean">=!=</a> <a href="#spire.math;Complex.neqv.b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a>

  def <a title="(implicit r: spire.algebra.Rng[T])spire.math.Complex[T]" id="spire.math;Complex.unary_-">unary_-</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Rng[T]" id="spire.math;Complex.unary_-.r">r</a>: <a href="../algebra/Rng.scala.html#spire.algebra;Rng" title="spire.algebra.Rng[T]">Rng</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: T)T">-</a><a href="#spire.math;Complex.unary_-.r" title="spire.algebra.Rng[T]">real</a>, <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: T)T">-</a><a href="#spire.math;Complex.unary_-.r" title="spire.algebra.Rng[T]">imag</a><span class="delimiter">)</span>

  def <a title="(rhs: T)(implicit r: spire.algebra.Semiring[T])spire.math.Complex[T]" id="spire.math;Complex.+(1cd9316a8d)">+</a><span class="delimiter">(</span><a title="T" id="spire.math;Complex.+(1cd9316a8d).rhs">rhs</a>: <a href="#spire.math;Complex.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Semiring[T]" id="spire.math;Complex.+(1cd9316a8d).r">r</a>: <a href="../algebra/Semiring.scala.html#spire.algebra;Semiring" title="spire.algebra.Semiring[T]">Semiring</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.+(1cd9316a8d).r" title="spire.algebra.Semiring[T]">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: T, y: T)T">+</a> <a href="#spire.math;Complex.+(1cd9316a8d).rhs" title="T">rhs</a>, <a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span>
  def <a title="(rhs: T)(implicit r: spire.algebra.Rng[T])spire.math.Complex[T]" id="spire.math;Complex.-(0609254e6c)">-</a><span class="delimiter">(</span><a title="T" id="spire.math;Complex.-(0609254e6c).rhs">rhs</a>: <a href="#spire.math;Complex.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Rng[T]" id="spire.math;Complex.-(0609254e6c).r">r</a>: <a href="../algebra/Rng.scala.html#spire.algebra;Rng" title="spire.algebra.Rng[T]">Rng</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.-(0609254e6c).r" title="spire.algebra.Rng[T]">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: T, y: T)T">-</a> <a href="#spire.math;Complex.-(0609254e6c).rhs" title="T">rhs</a>, <a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span>
  def <a title="(rhs: T)(implicit r: spire.algebra.Semiring[T])spire.math.Complex[T]" id="spire.math;Complex.*(1cd9316a8d)">*</a><span class="delimiter">(</span><a title="T" id="spire.math;Complex.*(1cd9316a8d).rhs">rhs</a>: <a href="#spire.math;Complex.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Semiring[T]" id="spire.math;Complex.*(1cd9316a8d).r">r</a>: <a href="../algebra/Semiring.scala.html#spire.algebra;Semiring" title="spire.algebra.Semiring[T]">Semiring</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.*(1cd9316a8d).r" title="spire.algebra.Semiring[T]">real</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.*(1cd9316a8d).rhs" title="T">rhs</a>, <a href="#spire.math;Complex.*(1cd9316a8d).r" title="spire.algebra.Semiring[T]">imag</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.*(1cd9316a8d).rhs" title="T">rhs</a><span class="delimiter">)</span>
  def <a title="(rhs: T)(implicit r: spire.algebra.Field[T])spire.math.Complex[T]" id="spire.math;Complex./(a07fe4b95c)">/</a><span class="delimiter">(</span><a title="T" id="spire.math;Complex./(a07fe4b95c).rhs">rhs</a>: <a href="#spire.math;Complex.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex./(a07fe4b95c).r">r</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex./(a07fe4b95c).r" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <a href="#spire.math;Complex./(a07fe4b95c).rhs" title="T">rhs</a>, <a href="#spire.math;Complex./(a07fe4b95c).r" title="spire.algebra.Field[T]">imag</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <a href="#spire.math;Complex./(a07fe4b95c).rhs" title="T">rhs</a><span class="delimiter">)</span>

  <span class="comment">// TODO: instead of floor should be round-toward-zero</span>

  def <a title="(rhs: T)(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex./~(fbaaf31336)">/~</a><span class="delimiter">(</span><a title="T" id="spire.math;Complex./~(fbaaf31336).rhs">rhs</a>: <a href="#spire.math;Complex.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex./~(fbaaf31336).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex./~(fbaaf31336).o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">(</span>this <a href="#spire.math;Complex./(a07fe4b95c)" title="(rhs: T)(implicit r: spire.algebra.Field[T])spire.math.Complex[T]">/</a> <a href="#spire.math;Complex./~(fbaaf31336).rhs" title="T">rhs</a><span class="delimiter">)</span>.<a href="#spire.math;Complex.floor" title="(implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]">floor</a>
  def <a title="(rhs: T)(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.%(fbaaf31336)">%</a><span class="delimiter">(</span><a title="T" id="spire.math;Complex.%(fbaaf31336).rhs">rhs</a>: <a href="#spire.math;Complex.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.%(fbaaf31336).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.%(fbaaf31336).o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = this <a href="#spire.math;Complex.-(e1c0640f17)" title="(b: spire.math.Complex[T])(implicit r: spire.algebra.Rng[T])spire.math.Complex[T]">-</a> <span class="delimiter">(</span>this <a href="#spire.math;Complex./~(fbaaf31336)" title="(rhs: T)(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]">/~</a> <a href="#spire.math;Complex.%(fbaaf31336).rhs" title="T">rhs</a><span class="delimiter">)</span> <a href="#spire.math;Complex.*(1cd9316a8d)" title="(rhs: T)(implicit r: spire.algebra.Semiring[T])spire.math.Complex[T]">*</a> <a href="#spire.math;Complex.%(fbaaf31336).rhs" title="T">rhs</a>
  def <a title="(rhs: T)(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T])(spire.math.Complex[T], spire.math.Complex[T])" id="spire.math;Complex./%(53502d7199)">/%</a><span class="delimiter">(</span><a title="T" id="spire.math;Complex./%(53502d7199).rhs">rhs</a>: <a href="#spire.math;Complex.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex./%(53502d7199).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex./%(53502d7199).o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(spire.math.Complex[T], spire.math.Complex[T])" class="delimiter">(</span>Complex<span class="delimiter">[</span>T<span class="delimiter">]</span>, Complex<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val q = this <a href="#spire.math;Complex./~(fbaaf31336)" title="spire.math.Complex[T]" id="spire.math;Complex./%(53502d7199).q">/~</a> <a href="#spire.math;Complex./%(53502d7199).rhs" title="T">rhs</a>
    <span title="(_1: spire.math.Complex[T], _2: spire.math.Complex[T])(spire.math.Complex[T], spire.math.Complex[T])" class="delimiter">(</span><a href="#spire.math;Complex./%(53502d7199).q" title="spire.math.Complex[T]">q</a>, this <a href="#spire.math;Complex.-(e1c0640f17)" title="(b: spire.math.Complex[T])(implicit r: spire.algebra.Rng[T])spire.math.Complex[T]">-</a> <a href="#spire.math;Complex./%(53502d7199).q" title="spire.math.Complex[T]">q</a> <a href="#spire.math;Complex.*(1cd9316a8d)" title="(rhs: T)(implicit r: spire.algebra.Semiring[T])spire.math.Complex[T]">*</a> <a href="#spire.math;Complex./%(53502d7199).rhs" title="T">rhs</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(e: T)(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.**(81db72dccc)">**</a><span class="delimiter">(</span><a title="T" id="spire.math;Complex.**(81db72dccc).e">e</a>: <a href="#spire.math;Complex.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.**(81db72dccc).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.**(81db72dccc).n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.**(81db72dccc).t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.**(81db72dccc).o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = this <a href="#spire.math;Complex.pow(81db72dccc)" title="(e: T)(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]">pow</a> <a href="#spire.math;Complex.**(81db72dccc).e" title="T">e</a>
  def <a title="(e: T)(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.pow(81db72dccc)">pow</a><span class="delimiter">(</span><a title="T" id="spire.math;Complex.pow(81db72dccc).e">e</a>: <a href="#spire.math;Complex.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.pow(81db72dccc).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.pow(81db72dccc).n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.pow(81db72dccc).t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.pow(81db72dccc).o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#spire.math;Complex.pow(81db72dccc).o" title="spire.algebra.IsReal[T]">e</a>.<a href="../algebra/Signed.scala.html#spire.algebra;Signed.isSignZero" title="(a: T)Boolean">isSignZero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.math.Complex.readResolve" title="spire.math.Complex.type">Complex</a>.<a href="#spire.math.Complex.one" title="[T](implicit T: spire.algebra.Rig[T])spire.math.Complex[T]">one</a><a href="#spire.math;Complex.pow(81db72dccc).f" title="(implicit T: spire.algebra.Rig[T])spire.math.Complex[T]" class="delimiter">[</a><a href="#spire.math;Complex.copy$default$2;T" title="T">T</a><span class="delimiter">]</span>
    <span class="delimiter">}</span> else if <span class="delimiter">(</span>this.<a href="#spire.math;Complex.isZero" title="(implicit o: spire.algebra.IsReal[T])Boolean">isZero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#spire.math;Complex.pow(81db72dccc).o" title="spire.algebra.IsReal[T]">e</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: T, y: T)Boolean">&lt;</a> <a href="#spire.math;Complex.pow(81db72dccc).f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span>
        throw new <span title="Exception">Exception</span><span class="delimiter">(</span><span title="String(&quot;raising 0 to negative/complex power&quot;)" class="string">&quot;raising 0 to negative/complex power&quot;</span><span class="delimiter">)</span>
      <a href="#spire.math.Complex.readResolve" title="spire.math.Complex.type">Complex</a>.<a href="#spire.math.Complex.zero" title="[T](implicit T: spire.algebra.Semiring[T])spire.math.Complex[T]">zero</a><a href="#spire.math;Complex.pow(81db72dccc).f" title="(implicit T: spire.algebra.Semiring[T])spire.math.Complex[T]" class="delimiter">[</a><a href="#spire.math;Complex.copy$default$2;T" title="T">T</a><span class="delimiter">]</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <a href="#spire.math.Complex.readResolve" title="spire.math.Complex.type">Complex</a>.<a href="#spire.math.Complex.polar" title="(magnitude: T, angle: T)(implicit evidence$1: spire.algebra.Field[T], implicit evidence$2: spire.algebra.Trig[T])spire.math.Complex[T]">polar</a><a href="#spire.math;Complex.pow(81db72dccc).f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.pow(81db72dccc).n" title="spire.algebra.NRoot[T]">abs</a> <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.fpow" title="(a: T, b: T)T">fpow</a> <a href="#spire.math;Complex.pow(81db72dccc).e" title="T">e</a>, <a href="#spire.math;Complex.pow(81db72dccc).f" title="spire.algebra.Field[T]">arg</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.pow(81db72dccc).e" title="T">e</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  def <a title="(b: spire.math.Complex[T])(implicit r: spire.algebra.Semiring[T])spire.math.Complex[T]" id="spire.math;Complex.+(cb068cef3f)">+</a><span class="delimiter">(</span><a title="spire.math.Complex[T]" id="spire.math;Complex.+(cb068cef3f).b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Semiring[T]" id="spire.math;Complex.+(cb068cef3f).r">r</a>: <a href="../algebra/Semiring.scala.html#spire.algebra;Semiring" title="spire.algebra.Semiring[T]">Semiring</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.+(cb068cef3f).r" title="spire.algebra.Semiring[T]">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: T, y: T)T">+</a> <a href="#spire.math;Complex.+(cb068cef3f).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Complex.+(cb068cef3f).r" title="spire.algebra.Semiring[T]">imag</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: T, y: T)T">+</a> <a href="#spire.math;Complex.+(cb068cef3f).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span>

  def <a title="(b: spire.math.Complex[T])(implicit r: spire.algebra.Rng[T])spire.math.Complex[T]" id="spire.math;Complex.-(e1c0640f17)">-</a><span class="delimiter">(</span><a title="spire.math.Complex[T]" id="spire.math;Complex.-(e1c0640f17).b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Rng[T]" id="spire.math;Complex.-(e1c0640f17).r">r</a>: <a href="../algebra/Rng.scala.html#spire.algebra;Rng" title="spire.algebra.Rng[T]">Rng</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.-(e1c0640f17).r" title="spire.algebra.Rng[T]">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: T, y: T)T">-</a> <a href="#spire.math;Complex.-(e1c0640f17).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Complex.-(e1c0640f17).r" title="spire.algebra.Rng[T]">imag</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: T, y: T)T">-</a> <a href="#spire.math;Complex.-(e1c0640f17).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span>

  def <a title="(b: spire.math.Complex[T])(implicit r: spire.algebra.Rng[T])spire.math.Complex[T]" id="spire.math;Complex.*(e1c0640f17)">*</a><span class="delimiter">(</span><a title="spire.math.Complex[T]" id="spire.math;Complex.*(e1c0640f17).b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Rng[T]" id="spire.math;Complex.*(e1c0640f17).r">r</a>: <a href="../algebra/Rng.scala.html#spire.algebra;Rng" title="spire.algebra.Rng[T]">Rng</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.*(e1c0640f17).r" title="spire.algebra.Rng[T]">real</a> <a href="#spire.math;Complex.*(e1c0640f17).r" title="spire.algebra.Rng[T]">*</a> <a href="#spire.math;Complex.*(e1c0640f17).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: T, y: T)T">-</a> <a href="#spire.math;Complex.*(e1c0640f17).r" title="spire.algebra.Rng[T]">imag</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.*(e1c0640f17).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a>, <a href="#spire.math;Complex.*(e1c0640f17).r" title="spire.algebra.Rng[T]">imag</a> <a href="#spire.math;Complex.*(e1c0640f17).r" title="spire.algebra.Rng[T]">*</a> <a href="#spire.math;Complex.*(e1c0640f17).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: T, y: T)T">+</a> <a href="#spire.math;Complex.*(e1c0640f17).r" title="spire.algebra.Rng[T]">real</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.*(e1c0640f17).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span>

  def <a title="(b: spire.math.Complex[T])(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex./(7edf8f59b2)">/</a><span class="delimiter">(</span><a title="spire.math.Complex[T]" id="spire.math;Complex./(7edf8f59b2).b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex./(7edf8f59b2).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex./(7edf8f59b2).o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="T" id="spire.math;Complex./(7edf8f59b2).abs_breal">abs_breal</a> = <a href="#spire.math;Complex./(7edf8f59b2).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex./(7edf8f59b2).o" title="spire.algebra.IsReal[T]">real</a>.<a href="../algebra/Signed.scala.html#spire.algebra;Signed.abs" title="(a: T)T">abs</a>
    val <a title="T" id="spire.math;Complex./(7edf8f59b2).abs_bimag">abs_bimag</a> = <a href="#spire.math;Complex./(7edf8f59b2).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex./(7edf8f59b2).o" title="spire.algebra.IsReal[T]">imag</a>.<a href="../algebra/Signed.scala.html#spire.algebra;Signed.abs" title="(a: T)T">abs</a>

    if <span class="delimiter">(</span><a href="#spire.math;Complex./(7edf8f59b2).o" title="spire.algebra.IsReal[T]">abs_breal</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.gteqv" title="(x: T, y: T)Boolean">&gt;=</a> <a href="#spire.math;Complex./(7edf8f59b2).abs_bimag" title="T">abs_bimag</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#spire.math;Complex./(7edf8f59b2).o" title="spire.algebra.IsReal[T]">abs_breal</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: T, y: T)Boolean">===</a> <a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span> throw new <span title="Exception">Exception</span><span class="delimiter">(</span><span title="String(&quot;/ by zero&quot;)" class="string">&quot;/ by zero&quot;</span><span class="delimiter">)</span>
      val ratio = <a href="#spire.math;Complex./(7edf8f59b2).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">imag</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="T">/</a> <a href="#spire.math;Complex./(7edf8f59b2).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a>
      val denom = <a href="#spire.math;Complex./(7edf8f59b2).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="T">+</a> <a href="#spire.math;Complex./(7edf8f59b2).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">imag</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <span title="T">ratio</span>
      new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">real</a> <a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">+</a> <a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">imag</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <span title="T">ratio</span><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <span title="T">denom</span>, <span class="delimiter">(</span><a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">imag</a> <a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">-</a> <a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <span title="T">ratio</span><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <span title="T">denom</span><span class="delimiter">)</span>

    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#spire.math;Complex./(7edf8f59b2).o" title="spire.algebra.IsReal[T]">abs_bimag</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: T, y: T)Boolean">===</a> <a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span> throw new <span title="Exception">Exception</span><span class="delimiter">(</span><span title="String(&quot;/ by zero&quot;)" class="string">&quot;/ by zero&quot;</span><span class="delimiter">)</span>
      val ratio = <a href="#spire.math;Complex./(7edf8f59b2).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="T">/</a> <a href="#spire.math;Complex./(7edf8f59b2).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a>
      val denom = <a href="#spire.math;Complex./(7edf8f59b2).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">real</a> <a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">*</a> <span title="T">ratio</span> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="T">+</a> <a href="#spire.math;Complex./(7edf8f59b2).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a>
      new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">real</a> <a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">*</a> <span title="T">ratio</span> <a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">+</a> <a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <span title="T">denom</span>, <span class="delimiter">(</span><a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">imag</a> <a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">*</a> <span title="T">ratio</span> <a href="#spire.math;Complex./(7edf8f59b2).f" title="spire.algebra.Field[T]">-</a> <a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a><span title="T">denom</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(b: spire.math.Complex[T])(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex./~(7edf8f59b2)">/~</a><span class="delimiter">(</span><a title="spire.math.Complex[T]" id="spire.math;Complex./~(7edf8f59b2).b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex./~(7edf8f59b2).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex./~(7edf8f59b2).o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val d = this <a href="#spire.math;Complex./(7edf8f59b2)" title="spire.math.Complex[T]" id="spire.math;Complex./~(7edf8f59b2).d">/</a> <a href="#spire.math;Complex./~(7edf8f59b2).b" title="spire.math.Complex[T]">b</a>
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex./~(7edf8f59b2).d" title="spire.math.Complex[T]">d</a>.<a href="#spire.math;Complex./~(7edf8f59b2).o" title="spire.algebra.IsReal[T]">real</a>.<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.floor" title="(a: T)T">floor</a>, <a href="#spire.math;Complex./~(7edf8f59b2).d" title="spire.math.Complex[T]">d</a>.<a href="#spire.math;Complex./~(7edf8f59b2).o" title="spire.algebra.IsReal[T]">imag</a>.<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.floor" title="(a: T)T">floor</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(b: spire.math.Complex[T])(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.%(7edf8f59b2)">%</a><span class="delimiter">(</span><a title="spire.math.Complex[T]" id="spire.math;Complex.%(7edf8f59b2).b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.%(7edf8f59b2).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.%(7edf8f59b2).o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = this <a href="#spire.math;Complex.-(e1c0640f17)" title="(b: spire.math.Complex[T])(implicit r: spire.algebra.Rng[T])spire.math.Complex[T]">-</a> <span class="delimiter">(</span>this <a href="#spire.math;Complex./~(7edf8f59b2)" title="(b: spire.math.Complex[T])(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]">/~</a> <a href="#spire.math;Complex.%(7edf8f59b2).b" title="spire.math.Complex[T]">b</a><span class="delimiter">)</span> <a href="#spire.math;Complex.*(e1c0640f17)" title="(b: spire.math.Complex[T])(implicit r: spire.algebra.Rng[T])spire.math.Complex[T]">*</a> <a href="#spire.math;Complex.%(7edf8f59b2).b" title="spire.math.Complex[T]">b</a>

  def <a title="(b: spire.math.Complex[T])(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T])(spire.math.Complex[T], spire.math.Complex[T])" id="spire.math;Complex./%(add12d81ce)">/%</a><span class="delimiter">(</span><a title="spire.math.Complex[T]" id="spire.math;Complex./%(add12d81ce).b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex./%(add12d81ce).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex./%(add12d81ce).o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(spire.math.Complex[T], spire.math.Complex[T])" class="delimiter">(</span>Complex<span class="delimiter">[</span>T<span class="delimiter">]</span>, Complex<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val q = this <a href="#spire.math;Complex./~(7edf8f59b2)" title="spire.math.Complex[T]" id="spire.math;Complex./%(add12d81ce).q">/~</a> <a href="#spire.math;Complex./%(add12d81ce).b" title="spire.math.Complex[T]">b</a>
    <span title="(_1: spire.math.Complex[T], _2: spire.math.Complex[T])(spire.math.Complex[T], spire.math.Complex[T])" class="delimiter">(</span><a href="#spire.math;Complex./%(add12d81ce).q" title="spire.math.Complex[T]">q</a>, this <a href="#spire.math;Complex.-(e1c0640f17)" title="(b: spire.math.Complex[T])(implicit r: spire.algebra.Rng[T])spire.math.Complex[T]">-</a> <a href="#spire.math;Complex./%(add12d81ce).q" title="spire.math.Complex[T]">q</a> <a href="#spire.math;Complex.*(e1c0640f17)" title="(b: spire.math.Complex[T])(implicit r: spire.algebra.Rng[T])spire.math.Complex[T]">*</a> <a href="#spire.math;Complex./%(add12d81ce).b" title="spire.math.Complex[T]">b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(b: Int)(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.**(bbcd1ea568)">**</a><span class="delimiter">(</span><a title="Int" id="spire.math;Complex.**(bbcd1ea568).b">b</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.**(bbcd1ea568).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.**(bbcd1ea568).n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.**(bbcd1ea568).t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.**(bbcd1ea568).o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;Complex.pow(bbcd1ea568)" title="(b: Int)(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]">pow</a><a href="#spire.math;Complex.**(bbcd1ea568).f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.**(bbcd1ea568).b" title="Int">b</a><span class="delimiter">)</span>

  def <a title="(k: Int)(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.nroot">nroot</a><span class="delimiter">(</span><a title="Int" id="spire.math;Complex.nroot.k">k</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.nroot.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.nroot.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.nroot.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.nroot.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#spire.math;Complex.isZero" title="(implicit o: spire.algebra.IsReal[T])Boolean">isZero</a><span class="delimiter">)</span> <a href="#spire.math.Complex.readResolve" title="spire.math.Complex.type">Complex</a>.<a href="#spire.math.Complex.zero" title="(implicit T: spire.algebra.Semiring[T])spire.math.Complex[T]">zero</a> else <a href="#spire.math;Complex.pow(9622b5e32c)" title="(b: spire.math.Complex[T])(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]">pow</a><a href="#spire.math;Complex.nroot.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.canEqual" title="(real: T, imag: T)spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.nroot.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)T">fromInt</a><a href="#spire.math;Complex.nroot.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.nroot.k" title="Int">k</a><span class="delimiter">)</span>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.reciprocal" title="(x: T)T">reciprocal</a>, <a href="#spire.math;Complex.nroot.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="(b: Int)(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.pow(bbcd1ea568)">pow</a><span class="delimiter">(</span><a title="Int" id="spire.math;Complex.pow(bbcd1ea568).b">b</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.pow(bbcd1ea568).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.pow(bbcd1ea568).n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.pow(bbcd1ea568).t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.pow(bbcd1ea568).o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#spire.math;Complex.isZero" title="(implicit o: spire.algebra.IsReal[T])Boolean">isZero</a><span class="delimiter">)</span> <a href="#spire.math.Complex.readResolve" title="spire.math.Complex.type">Complex</a>.<a href="#spire.math.Complex.zero" title="(implicit T: spire.algebra.Semiring[T])spire.math.Complex[T]">zero</a> else <a href="#spire.math.Complex.readResolve" title="spire.math.Complex.type">Complex</a>.<a href="#spire.math.Complex.polar" title="(magnitude: T, angle: T)(implicit evidence$1: spire.algebra.Field[T], implicit evidence$2: spire.algebra.Trig[T])spire.math.Complex[T]">polar</a><a href="#spire.math;Complex.pow(bbcd1ea568).f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.pow(bbcd1ea568).f" title="spire.algebra.Field[T]">abs</a>.pow<a href="../algebra/Rig.scala.html#spire.algebra;Rig.pow" title="(a: T, n: Int)T" class="delimiter">(</a><a href="#spire.math;Complex.pow(bbcd1ea568).b" title="Int">b</a><span class="delimiter">)</span>, <a href="#spire.math;Complex.pow(bbcd1ea568).f" title="spire.algebra.Field[T]">arg</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.pow(bbcd1ea568).b" title="Int">b</a><span class="delimiter">)</span>

  def <a title="(b: spire.math.Complex[T])(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.**(9622b5e32c)">**</a><span class="delimiter">(</span><a title="spire.math.Complex[T]" id="spire.math;Complex.**(9622b5e32c).b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.**(9622b5e32c).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.**(9622b5e32c).n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.**(9622b5e32c).t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.**(9622b5e32c).o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;Complex.pow(9622b5e32c)" title="(b: spire.math.Complex[T])(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]">pow</a><a href="#spire.math;Complex.**(9622b5e32c).f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.**(9622b5e32c).b" title="spire.math.Complex[T]">b</a><span class="delimiter">)</span>

  def <a title="(b: spire.math.Complex[T])(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.pow(9622b5e32c)">pow</a><span class="delimiter">(</span><a title="spire.math.Complex[T]" id="spire.math;Complex.pow(9622b5e32c).b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.pow(9622b5e32c).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.pow(9622b5e32c).n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.pow(9622b5e32c).t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.pow(9622b5e32c).o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#spire.math;Complex.pow(9622b5e32c).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.isZero" title="(implicit o: spire.algebra.IsReal[T])Boolean">isZero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.math.Complex.readResolve" title="spire.math.Complex.type">Complex</a>.<a href="#spire.math.Complex.one" title="[T](implicit T: spire.algebra.Rig[T])spire.math.Complex[T]">one</a><a href="#spire.math;Complex.pow(9622b5e32c).f" title="(implicit T: spire.algebra.Rig[T])spire.math.Complex[T]" class="delimiter">[</a><a href="#spire.math;Complex.copy$default$2;T" title="T">T</a><span class="delimiter">]</span>
    <span class="delimiter">}</span> else if <span class="delimiter">(</span>this.<a href="#spire.math;Complex.isZero" title="(implicit o: spire.algebra.IsReal[T])Boolean">isZero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#spire.math;Complex.pow(9622b5e32c).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.pow(9622b5e32c).o" title="spire.algebra.IsReal[T]">imag</a> <a href="../algebra/Eq.scala.html#spire.algebra;Eq.neqv" title="(x: T, y: T)Boolean">=!=</a> <a href="#spire.math;Complex.pow(9622b5e32c).f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a> <span title="(x: Boolean)Boolean">||</span> <a href="#spire.math;Complex.pow(9622b5e32c).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.pow(9622b5e32c).o" title="spire.algebra.IsReal[T]">real</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: T, y: T)Boolean">&lt;</a> <a href="#spire.math;Complex.pow(9622b5e32c).f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span>
        throw new <span title="Exception">Exception</span><span class="delimiter">(</span><span title="String(&quot;raising 0 to negative/complex power&quot;)" class="string">&quot;raising 0 to negative/complex power&quot;</span><span class="delimiter">)</span>
      <a href="#spire.math.Complex.readResolve" title="spire.math.Complex.type">Complex</a>.<a href="#spire.math.Complex.zero" title="[T](implicit T: spire.algebra.Semiring[T])spire.math.Complex[T]">zero</a><a href="#spire.math;Complex.pow(9622b5e32c).f" title="(implicit T: spire.algebra.Semiring[T])spire.math.Complex[T]" class="delimiter">[</a><a href="#spire.math;Complex.copy$default$2;T" title="T">T</a><span class="delimiter">]</span>
    <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.math;Complex.pow(9622b5e32c).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.pow(9622b5e32c).o" title="spire.algebra.IsReal[T]">imag</a> <a href="../algebra/Eq.scala.html#spire.algebra;Eq.neqv" title="(x: T, y: T)Boolean">=!=</a> <a href="#spire.math;Complex.pow(9622b5e32c).f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val len = <span class="delimiter">(</span><a href="#spire.math;Complex.pow(9622b5e32c).n" title="spire.algebra.NRoot[T]">abs</a> <a href="#spire.math;Complex.pow(9622b5e32c).f" title="spire.algebra.Field[T]">fpow</a> <a href="#spire.math;Complex.pow(9622b5e32c).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="T" id="spire.math;Complex.pow(9622b5e32c).len">/</a> <a href="#spire.math;Complex.pow(9622b5e32c).t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.exp" title="(a: T)T">exp</a><span class="delimiter">(</span><a href="#spire.math;Complex.pow(9622b5e32c).f" title="spire.algebra.Field[T]">arg</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.pow(9622b5e32c).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span>
      val phase = <a href="#spire.math;Complex.pow(9622b5e32c).f" title="spire.algebra.Field[T]">arg</a> <a href="#spire.math;Complex.pow(9622b5e32c).f" title="spire.algebra.Field[T]">*</a> <a href="#spire.math;Complex.pow(9622b5e32c).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="T" id="spire.math;Complex.pow(9622b5e32c).phase">+</a> <a href="#spire.math;Complex.pow(9622b5e32c).t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.log" title="(a: T)T">log</a><a href="#spire.math;Complex.pow(9622b5e32c).f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.abs" title="(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T], implicit n: spire.algebra.NRoot[T])T">abs</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.pow(9622b5e32c).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a>
      <a href="#spire.math.Complex.readResolve" title="spire.math.Complex.type">Complex</a>.<a href="#spire.math.Complex.polar" title="(magnitude: T, angle: T)(implicit evidence$1: spire.algebra.Field[T], implicit evidence$2: spire.algebra.Trig[T])spire.math.Complex[T]">polar</a><a href="#spire.math;Complex.pow(9622b5e32c).f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.pow(9622b5e32c).len" title="T">len</a>, <a href="#spire.math;Complex.pow(9622b5e32c).phase" title="T">phase</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <a href="#spire.math.Complex.readResolve" title="spire.math.Complex.type">Complex</a>.<a href="#spire.math.Complex.polar" title="(magnitude: T, angle: T)(implicit evidence$1: spire.algebra.Field[T], implicit evidence$2: spire.algebra.Trig[T])spire.math.Complex[T]">polar</a><a href="#spire.math;Complex.pow(9622b5e32c).f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.pow(9622b5e32c).n" title="spire.algebra.NRoot[T]">abs</a> <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.fpow" title="(a: T, b: T)T">fpow</a> <a href="#spire.math;Complex.pow(9622b5e32c).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Complex.pow(9622b5e32c).f" title="spire.algebra.Field[T]">arg</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.pow(9622b5e32c).b" title="spire.math.Complex[T]">b</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">// we are going with the &quot;principal value&quot; definition of Log.</span>
  def <a title="(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.log">log</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.log.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.log.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.log.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.log.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.math;Complex.isZero" title="(implicit o: spire.algebra.IsReal[T])Boolean">isZero</a><span class="delimiter">)</span> throw new <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="String(&quot;log(0) undefined&quot;)" class="string">&quot;log(0) undefined&quot;</span><span class="delimiter">)</span>
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.log.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.log" title="(a: T)T">log</a><span class="delimiter">(</span><a href="#spire.math;Complex.abs" title="(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T], implicit n: spire.algebra.NRoot[T])T">abs</a><span class="delimiter">)</span>, <a href="#spire.math;Complex.arg" title="(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])T">arg</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(implicit f: spire.algebra.Field[T], implicit n0: spire.algebra.NRoot[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.sqrt">sqrt</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.sqrt.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.sqrt.n0">n0</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.sqrt.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.math;Complex.isZero" title="(implicit o: spire.algebra.IsReal[T])Boolean">isZero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.math.Complex.readResolve" title="spire.math.Complex.type">Complex</a>.<a href="#spire.math.Complex.zero" title="[T](implicit T: spire.algebra.Semiring[T])spire.math.Complex[T]">zero</a><a href="#spire.math;Complex.sqrt.f" title="(implicit T: spire.algebra.Semiring[T])spire.math.Complex[T]" class="delimiter">[</a><a href="#spire.math;Complex.copy$default$2;T" title="T">T</a><span class="delimiter">]</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      val <a title="T" id="spire.math;Complex.sqrt.two">two</a> = <a href="#spire.math;Complex.sqrt.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)T">fromInt</a><span class="delimiter">(</span><span title="Int(2)" class="int">2</span><span class="delimiter">)</span>
      val <a title="T" id="spire.math;Complex.sqrt.a">a</a> = <span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math;Complex.sqrt.f" title="spire.algebra.Field[T]">abs</a> <a href="#spire.math;Complex.sqrt.f" title="spire.algebra.Field[T]">+</a> <a href="#spire.math;Complex.sqrt.o" title="spire.algebra.IsReal[T]">real</a>.<a href="../algebra/Signed.scala.html#spire.algebra;Signed.abs" title="(a: T)T">abs</a><span class="delimiter">)</span> <a href="#spire.math;Complex.sqrt.n0" title="spire.algebra.NRoot[T]">/</a> <a href="#spire.math;Complex.sqrt.two" title="T">two</a><span class="delimiter">)</span>.<a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.sqrt" title="(a: T)T">sqrt</a>
      <a href="#spire.math;Complex.sqrt.o" title="spire.algebra.IsReal[T]">imag</a>.<a href="../algebra/Signed.scala.html#spire.algebra;Signed.signum" title="(a: T)Int">signum</a> match <span class="delimiter">{</span>
        case <span title="Int(0)" class="int">0</span> =&gt;
          if <span class="delimiter">(</span><a href="#spire.math;Complex.sqrt.o" title="spire.algebra.IsReal[T]">real</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: T, y: T)Boolean">&lt;</a> <a href="#spire.math;Complex.sqrt.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span> <a href="#spire.math;Complex.canEqual" title="(real: T, imag: T)spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.sqrt.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a>, <a href="#spire.math;Complex.sqrt.a" title="T">a</a><span class="delimiter">)</span> else <a href="#spire.math;Complex.canEqual" title="(real: T, imag: T)spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.sqrt.a" title="T">a</a>, <a href="#spire.math;Complex.sqrt.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span>
        case <a title="Int" id="spire.math;Complex.sqrt.n">n</a> =&gt;
          val <a title="T" id="spire.math;Complex.sqrt.b">b</a> = <span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math;Complex.sqrt.f" title="spire.algebra.Field[T]">abs</a> <a href="#spire.math;Complex.sqrt.f" title="spire.algebra.Field[T]">-</a> <a href="#spire.math;Complex.sqrt.o" title="spire.algebra.IsReal[T]">real</a>.<a href="../algebra/Signed.scala.html#spire.algebra;Signed.abs" title="(a: T)T">abs</a><span class="delimiter">)</span> <a href="#spire.math;Complex.sqrt.n0" title="spire.algebra.NRoot[T]">/</a> <a href="#spire.math;Complex.sqrt.two" title="T">two</a><span class="delimiter">)</span>.<a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.sqrt" title="(a: T)T">sqrt</a>
          if <span class="delimiter">(</span><a href="#spire.math;Complex.sqrt.n" title="Int">n</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#spire.math;Complex.canEqual" title="(real: T, imag: T)spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.sqrt.a" title="T">a</a>, <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: T)T">-</a><a href="#spire.math;Complex.sqrt.f" title="spire.algebra.Field[T]">b</a><span class="delimiter">)</span> else <a href="#spire.math;Complex.canEqual" title="(real: T, imag: T)spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.sqrt.a" title="T">a</a>, <a href="#spire.math;Complex.sqrt.b" title="T">b</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.floor">floor</a><span class="delimiter">(</span>implicit <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.floor.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.floor.o" title="spire.algebra.IsReal[T]">real</a>.<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.floor" title="(a: T)T">floor</a>, <a href="#spire.math;Complex.floor.o" title="spire.algebra.IsReal[T]">imag</a>.<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.floor" title="(a: T)T">floor</a><span class="delimiter">)</span>
  def <a title="(implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.ceil">ceil</a><span class="delimiter">(</span>implicit <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.ceil.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.ceil.o" title="spire.algebra.IsReal[T]">real</a>.<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.ceil" title="(a: T)T">ceil</a>, <a href="#spire.math;Complex.ceil.o" title="spire.algebra.IsReal[T]">imag</a>.<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.ceil" title="(a: T)T">ceil</a><span class="delimiter">)</span>
  def <a title="(implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.round">round</a><span class="delimiter">(</span>implicit <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.round.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.round.o" title="spire.algebra.IsReal[T]">real</a>.<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.round" title="(a: T)T">round</a>, <a href="#spire.math;Complex.round.o" title="spire.algebra.IsReal[T]">imag</a>.<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.round" title="(a: T)T">round</a><span class="delimiter">)</span>

  <span class="comment">// acos(z) = -i*(log(z + i*(sqrt(1 - z*z))))</span>
  def <a title="(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.acos">acos</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.acos.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.acos.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.acos.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.acos.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val z2 = this <a href="#spire.math;Complex.*(e1c0640f17)" title="spire.math.Complex[T]" id="spire.math;Complex.acos.z2">*</a> this
    val <a title="spire.math.Complex[T]" id="spire.math;Complex.acos.s">s</a> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.acos.f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Complex.acos.f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: T, y: T)T">-</a> <a href="#spire.math;Complex.acos.z2" title="spire.math.Complex[T]">z2</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a>, <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: T)T">-</a><a href="#spire.math;Complex.acos.z2" title="spire.math.Complex[T]">z2</a>.<a href="#spire.math;Complex.acos.f" title="spire.algebra.Field[T]">imag</a><span class="delimiter">)</span>.<a href="#spire.math;Complex.sqrt" title="(implicit f: spire.algebra.Field[T], implicit n0: spire.algebra.NRoot[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]">sqrt</a>
    val <a title="spire.math.Complex[T]" id="spire.math;Complex.acos.l">l</a> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.acos.f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: T, y: T)T">+</a> <a href="#spire.math;Complex.acos.s" title="spire.math.Complex[T]">s</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a>, <a href="#spire.math;Complex.acos.f" title="spire.algebra.Field[T]">imag</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: T, y: T)T">+</a> <a href="#spire.math;Complex.acos.s" title="spire.math.Complex[T]">s</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>.<a href="#spire.math;Complex.log" title="(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]">log</a>
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.acos.l" title="spire.math.Complex[T]">l</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a>, <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: T)T">-</a><a href="#spire.math;Complex.acos.l" title="spire.math.Complex[T]">l</a>.<a href="#spire.math;Complex.acos.f" title="spire.algebra.Field[T]">real</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// asin(z) = -i*(log(sqrt(1 - z*z) + i*z))</span>
  def <a title="(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.asin">asin</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.asin.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.asin.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.asin.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.asin.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val z2 = this <a href="#spire.math;Complex.*(e1c0640f17)" title="spire.math.Complex[T]" id="spire.math;Complex.asin.z2">*</a> this
    val <a title="spire.math.Complex[T]" id="spire.math;Complex.asin.s">s</a> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.asin.f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Complex.asin.f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: T, y: T)T">-</a> <a href="#spire.math;Complex.asin.z2" title="spire.math.Complex[T]">z2</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a>, <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: T)T">-</a><a href="#spire.math;Complex.asin.z2" title="spire.math.Complex[T]">z2</a>.<a href="#spire.math;Complex.asin.f" title="spire.algebra.Field[T]">imag</a><span class="delimiter">)</span>.<a href="#spire.math;Complex.sqrt" title="(implicit f: spire.algebra.Field[T], implicit n0: spire.algebra.NRoot[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]">sqrt</a>
    val <a title="spire.math.Complex[T]" id="spire.math;Complex.asin.l">l</a> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.asin.s" title="spire.math.Complex[T]">s</a>.<a href="#spire.math;Complex.asin.f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: T, y: T)T">+</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: T)T">-</a><a href="#spire.math;Complex.asin.f" title="spire.algebra.Field[T]">imag</a>, <a href="#spire.math;Complex.asin.s" title="spire.math.Complex[T]">s</a>.<a href="#spire.math;Complex.asin.f" title="spire.algebra.Field[T]">imag</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: T, y: T)T">+</a> <a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>.<a href="#spire.math;Complex.log" title="(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]">log</a>
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.asin.l" title="spire.math.Complex[T]">l</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a>, <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: T)T">-</a><a href="#spire.math;Complex.asin.l" title="spire.math.Complex[T]">l</a>.<a href="#spire.math;Complex.asin.f" title="spire.algebra.Field[T]">real</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// atan(z) = (i/2) log((i + z)/(i - z))</span>
  def <a title="(implicit f: spire.algebra.Field[T], implicit r: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]" id="spire.math;Complex.atan">atan</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.atan.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Complex.atan.r">r</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.atan.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Complex.atan.o">o</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="spire.math.Complex[T]" id="spire.math;Complex.atan.n">n</a> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Complex.atan.f" title="spire.algebra.Field[T]">imag</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: T, y: T)T">+</a> <a href="#spire.math;Complex.atan.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; T">one</a><span class="delimiter">)</span>
    val <a title="spire.math.Complex[T]" id="spire.math;Complex.atan.d">d</a> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: T)T">-</a><a href="#spire.math;Complex.atan.f" title="spire.algebra.Field[T]">real</a>, <a href="#spire.math;Complex.atan.f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Complex.atan.f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: T, y: T)T">-</a> <a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span>
    val <a title="spire.math.Complex[T]" id="spire.math;Complex.atan.l">l</a> = <span class="delimiter">(</span><a href="#spire.math;Complex.atan.n" title="spire.math.Complex[T]">n</a> <a href="#spire.math;Complex./(7edf8f59b2)" title="(b: spire.math.Complex[T])(implicit f: spire.algebra.Field[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]">/</a> <a href="#spire.math;Complex.atan.d" title="spire.math.Complex[T]">d</a><span class="delimiter">)</span>.<a href="#spire.math;Complex.log" title="(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit o: spire.algebra.IsReal[T])spire.math.Complex[T]">log</a>
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.atan.l" title="spire.math.Complex[T]">l</a>.<a href="#spire.math;Complex.atan.f" title="spire.algebra.Field[T]">imag</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <a href="#spire.math;Complex.atan.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)T">fromInt</a><span class="delimiter">(</span>-<span title="Int(-2)" class="int">2</span><span class="delimiter">)</span>, <a href="#spire.math;Complex.atan.l" title="spire.math.Complex[T]">l</a>.<a href="#spire.math;Complex.atan.f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <a href="#spire.math;Complex.atan.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)T">fromInt</a><span class="delimiter">(</span><span title="Int(2)" class="int">2</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// exp(a+ci) = (exp(a) * cos(c)) + (exp(a) * sin(c))i</span>
  def <a title="(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T])spire.math.Complex[T]" id="spire.math;Complex.exp">exp</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.exp.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.exp.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.exp.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.exp" title="(a: T)T">exp</a><a href="#spire.math;Complex.exp.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.exp.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.cos" title="(a: T)T">cos</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span>, <a href="#spire.math;Complex.exp.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.exp" title="(a: T)T">exp</a><a href="#spire.math;Complex.exp.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.exp.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.sin" title="(a: T)T">sin</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">// sin(a+ci) = (sin(a) * cosh(c)) + (cos(a) * sinh(c))i</span>
  def <a title="(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T])spire.math.Complex[T]" id="spire.math;Complex.sin">sin</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.sin.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.sin.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.sin.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.sin" title="(a: T)T">sin</a><a href="#spire.math;Complex.sin.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.sin.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.cosh" title="(x: T)T">cosh</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span>, <a href="#spire.math;Complex.sin.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.cos" title="(a: T)T">cos</a><a href="#spire.math;Complex.sin.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.sin.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.sinh" title="(x: T)T">sinh</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">// sinh(a+ci) = (sinh(a) * cos(c)) + (cosh(a) * sin(c))i</span>
  def <a title="(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T])spire.math.Complex[T]" id="spire.math;Complex.sinh">sinh</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.sinh.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.sinh.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.sinh.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.sinh" title="(x: T)T">sinh</a><a href="#spire.math;Complex.sinh.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.sinh.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.cos" title="(a: T)T">cos</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span>, <a href="#spire.math;Complex.sinh.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.cosh" title="(x: T)T">cosh</a><a href="#spire.math;Complex.sinh.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.sinh.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.sin" title="(a: T)T">sin</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">// cos(a+ci) = (cos(a) * cosh(c)) - (sin(a) * sinh(c))i</span>
  def <a title="(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T])spire.math.Complex[T]" id="spire.math;Complex.cos">cos</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.cos.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.cos.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.cos.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.cos" title="(a: T)T">cos</a><a href="#spire.math;Complex.cos.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.cos.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.cosh" title="(x: T)T">cosh</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span>, <a href="#spire.math;Complex.cos.f" title="spire.algebra.Field[T]">-</a><a href="#spire.math;Complex.cos.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.sin" title="(a: T)T">sin</a><a href="#spire.math;Complex.cos.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.cos.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.sinh" title="(x: T)T">sinh</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">// cosh(a+ci) = (cosh(a) * cos(c)) + (sinh(a) * sin(c))i</span>
  def <a title="(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T])spire.math.Complex[T]" id="spire.math;Complex.cosh">cosh</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.cosh.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.cosh.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.cosh.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.cosh" title="(x: T)T">cosh</a><a href="#spire.math;Complex.cosh.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.cosh.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.cos" title="(a: T)T">cos</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span>, <a href="#spire.math;Complex.cosh.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.sinh" title="(x: T)T">sinh</a><a href="#spire.math;Complex.cosh.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Complex.cosh.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.sin" title="(a: T)T">sin</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">// tan(a+ci) = (sin(a+a) + sinh(c+c)i) / (cos(a+a) + cosh(c+c))</span>
  def <a title="(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T])spire.math.Complex[T]" id="spire.math;Complex.tan">tan</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.tan.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.tan.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val r2 = <a href="#spire.math;Complex.tan.f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="T" id="spire.math;Complex.tan.r2">+</a> <a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a>
    val i2 = <a href="#spire.math;Complex.tan.f" title="spire.algebra.Field[T]">imag</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="T" id="spire.math;Complex.tan.i2">+</a> <a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a>
    val d = <a href="#spire.math;Complex.tan.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.cos" title="(a: T)T">cos</a><a href="#spire.math;Complex.tan.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.tan.r2" title="T">r2</a><span class="delimiter">)</span> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="T" id="spire.math;Complex.tan.d">+</a> <a href="#spire.math;Complex.tan.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.cosh" title="(x: T)T">cosh</a><span class="delimiter">(</span><a href="#spire.math;Complex.tan.i2" title="T">i2</a><span class="delimiter">)</span>
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.tan.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.sin" title="(a: T)T">sin</a><a href="#spire.math;Complex.tan.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.tan.r2" title="T">r2</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <a href="#spire.math;Complex.tan.d" title="T">d</a>, <a href="#spire.math;Complex.tan.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.sinh" title="(x: T)T">sinh</a><a href="#spire.math;Complex.tan.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.tan.i2" title="T">i2</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <a href="#spire.math;Complex.tan.d" title="T">d</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// tanh(a+ci) = (sinh(a+a) + sin(c+c)i) / (cosh(a+a) + cos(c+c))</span>
  def <a title="(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T])spire.math.Complex[T]" id="spire.math;Complex.tanh">tanh</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Complex.tanh.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Complex.tanh.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val r2 = <a href="#spire.math;Complex.tanh.f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="T" id="spire.math;Complex.tanh.r2">+</a> <a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a>
    val i2 = <a href="#spire.math;Complex.tanh.f" title="spire.algebra.Field[T]">imag</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="T" id="spire.math;Complex.tanh.i2">+</a> <a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a>
    val d = <a href="#spire.math;Complex.tanh.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.cos" title="(a: T)T">cos</a><a href="#spire.math;Complex.tanh.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.tanh.r2" title="T">r2</a><span class="delimiter">)</span> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="T" id="spire.math;Complex.tanh.d">+</a> <a href="#spire.math;Complex.tanh.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.cosh" title="(x: T)T">cosh</a><span class="delimiter">(</span><a href="#spire.math;Complex.tanh.i2" title="T">i2</a><span class="delimiter">)</span>
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[T]">Complex</a><span class="delimiter">(</span><a href="#spire.math;Complex.tanh.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.sinh" title="(x: T)T">sinh</a><a href="#spire.math;Complex.tanh.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.tanh.r2" title="T">r2</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <a href="#spire.math;Complex.tanh.d" title="T">d</a>, <a href="#spire.math;Complex.tanh.t" title="spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.sin" title="(a: T)T">sin</a><a href="#spire.math;Complex.tanh.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Complex.tanh.i2" title="T">i2</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <a href="#spire.math;Complex.tanh.d" title="T">d</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// junky ScalaNumber stuff</span>
  def <a title="()Float" id="spire.math;Complex.floatValue">floatValue</a>: <span title="Float">Float</span> = <a href="#spire.math;Complex.doubleValue" title="()Double">doubleValue</a>.<span title="=&gt; Float">toFloat</span>
  def <a title="()Double" id="spire.math;Complex.doubleValue">doubleValue</a>: <span title="Double">Double</span> = <a href="package.scala.html#spire.math.package.anyToDouble" title="(n: Any)Double">anyToDouble</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>
  override def <a title="()Byte" id="spire.math;Complex.byteValue">byteValue</a>: <span title="Byte">Byte</span> = <a href="#spire.math;Complex.longValue" title="()Long">longValue</a>.<span title="=&gt; Byte">toByte</span>
  override def <a title="()Short" id="spire.math;Complex.shortValue">shortValue</a>: <span title="Short">Short</span> = <a href="#spire.math;Complex.longValue" title="()Long">longValue</a>.<span title="=&gt; Short">toShort</span>
  def <a title="()Int" id="spire.math;Complex.intValue">intValue</a>: <span title="Int">Int</span> = <a href="#spire.math;Complex.longValue" title="()Long">longValue</a>.<span title="=&gt; Int">toInt</span>
  override def <a title="()Long" id="spire.math;Complex.longValue">longValue</a>: <span title="Long">Long</span> = <a href="package.scala.html#spire.math.package.anyToLong" title="(n: Any)Long">anyToLong</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>

  def <a title="()Object" id="spire.math;Complex.underlying">underlying</a>: <span title="Object">Object</span> = this

  def <a title="()Boolean" id="spire.math;Complex.isWhole">isWhole</a>: <span title="Boolean">Boolean</span> =
    <a href="package.scala.html#spire.math.package.anyIsZero" title="(n: Any)Boolean">anyIsZero</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="package.scala.html#spire.math.package.anyIsWhole" title="(n: Any)Boolean">anyIsWhole</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>

  override final def <a title="=&gt; Boolean" id="spire.math;Complex.isValidInt">isValidInt</a>: <span title="Boolean">Boolean</span> =
    <a href="package.scala.html#spire.math.package.anyIsZero" title="(n: Any)Boolean">anyIsZero</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="package.scala.html#spire.math.package.anyIsValidInt" title="(n: Any)Boolean">anyIsValidInt</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>

  <span class="comment">// important to keep in sync with Quaternion[_]</span>
  override def <a title="()Int" id="spire.math;Complex.hashCode">hashCode</a>: <span title="Int">Int</span> =
    if <span class="delimiter">(</span><a href="package.scala.html#spire.math.package.anyIsZero" title="(n: Any)Boolean">anyIsZero</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a>.<span title="()Int">##</span>
    else <span class="delimiter">(</span><span title="Int(19)" class="int">19</span> <span title="(x: Int)Int">*</span> <a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a>.<span title="()Int">##</span><span class="delimiter">)</span> <span title="(x: Int)Int">+</span> <span class="delimiter">(</span><span title="Int(41)" class="int">41</span> <span title="(x: Int)Int">*</span> <a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a>.<span title="()Int">##</span><span class="delimiter">)</span> <span title="(x: Int)Int">+</span> <span title="Int(97)" class="int">97</span>

  <span class="comment">// not typesafe, so this is the best we can do :(</span>
  override def <a title="(that: Any)Boolean" id="spire.math;Complex.equals">equals</a><span class="delimiter">(</span><span title="Any">that</span>: <span title="Any">Any</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="Any">that</span> match <span class="delimiter">{</span>
    case <span title="spire.math.Complex[_]">that</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[_]">Complex</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt;
      <a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a> <span title="(x$1: Any)Boolean">==</span> <span title="spire.math.Complex[_]">that</span>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; _">real</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a> <span title="(x$1: Any)Boolean">==</span> <span title="spire.math.Complex[_]">that</span>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; _">imag</a>
    case <span title="spire.math.Quaternion[_]">that</span>: <a href="Quaternion.scala.html#spire.math;Quaternion" title="spire.math.Quaternion[_]">Quaternion</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt;
      <a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a> <span title="(x$1: Any)Boolean">==</span> <span title="spire.math.Quaternion[_]">that</span>.<a href="Quaternion.scala.html#spire.math;Quaternion.r" title="=&gt; _">r</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a> <span title="(x$1: Any)Boolean">==</span> <span title="spire.math.Quaternion[_]">that</span>.<a href="Quaternion.scala.html#spire.math;Quaternion.i" title="=&gt; _">i</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="package.scala.html#spire.math.package.anyIsZero" title="(n: Any)Boolean">anyIsZero</a><span class="delimiter">(</span><span title="spire.math.Quaternion[_]">that</span>.<a href="Quaternion.scala.html#spire.math;Quaternion.j" title="=&gt; _">j</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="package.scala.html#spire.math.package.anyIsZero" title="(n: Any)Boolean">anyIsZero</a><span class="delimiter">(</span><span title="spire.math.Quaternion[_]">that</span>.<a href="Quaternion.scala.html#spire.math;Quaternion.k" title="=&gt; _">k</a><span class="delimiter">)</span>
    case <span title="Any">that</span> =&gt;
      <a href="package.scala.html#spire.math.package.anyIsZero" title="(n: Any)Boolean">anyIsZero</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a> <span title="(x$1: Any)Boolean">==</span> <span title="Any">that</span>
  <span class="delimiter">}</span>

  override def <a title="()String" id="spire.math;Complex.toString">toString</a>: <span title="String">String</span> = <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;(&quot;)">($</span><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a><span title="String(&quot; + &quot;)"> + $</span><span class="delimiter">{</span><a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a><span class="delimiter">}</span><span title="String(&quot;i)&quot;)" class="string">i)&quot;</span>

  def <a title="(implicit ev: spire.algebra.AdditiveMonoid[T])spire.math.Quaternion[T]" id="spire.math;Complex.toQuaternion">toQuaternion</a><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveMonoid[T]" id="spire.math;Complex.toQuaternion.ev">ev</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[T]">AdditiveMonoid</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Quaternion.scala.html#spire.math;Quaternion" title="spire.math.Quaternion[T]">Quaternion</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="Quaternion.scala.html#spire.math;Quaternion" title="(r: T, i: T, j: T, k: T)spire.math.Quaternion[T]">Quaternion</a><span class="delimiter">(</span><a href="#spire.math;Complex.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Complex.copy$default$2" title="=&gt; T">imag</a>, <a href="#spire.math;Complex.toQuaternion.ev" title="spire.algebra.AdditiveMonoid[T]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a>, <a href="#spire.math;Complex.toQuaternion.ev" title="spire.algebra.AdditiveMonoid[T]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span>
<span class="delimiter">}</span>


object <a title="spire.math.FloatComplex.type" id="spire.math.FloatComplex">FloatComplex</a> <a href="#spire.math.FloatComplex" title="spire.math.FloatComplex.type" class="delimiter">{</a>
  import <a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<span class="delimiter">{</span>encode<span class="delimiter">}</span>

  final def <a title="(real: Float, imag: Float)spire.math.FloatComplex" id="spire.math.FloatComplex.apply(f4d7c4c3d6)">apply</a><span class="delimiter">(</span><a title="Float" id="spire.math.FloatComplex.apply(f4d7c4c3d6).real">real</a>: <span title="Float">Float</span>, <a title="Float" id="spire.math.FloatComplex.apply(f4d7c4c3d6).imag">imag</a>: <span title="Float">Float</span><span class="delimiter">)</span>: <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a> =
    new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><a href="#spire.math.FloatComplex.apply(f4d7c4c3d6).real" title="Float">real</a>, <a href="#spire.math.FloatComplex.apply(f4d7c4c3d6).imag" title="Float">imag</a><span class="delimiter">)</span><span class="delimiter">)</span>

  final def <a title="(real: Double, imag: Double)spire.math.FloatComplex" id="spire.math.FloatComplex.apply(6c02c06c0d)">apply</a><span class="delimiter">(</span><a title="Double" id="spire.math.FloatComplex.apply(6c02c06c0d).real">real</a>: <span title="Double">Double</span>, <a title="Double" id="spire.math.FloatComplex.apply(6c02c06c0d).imag">imag</a>: <span title="Double">Double</span><span class="delimiter">)</span> =
    new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><a href="#spire.math.FloatComplex.apply(6c02c06c0d).real" title="Double">real</a>.<span title="=&gt; Float">toFloat</span>, <a href="#spire.math.FloatComplex.apply(6c02c06c0d).imag" title="Double">imag</a>.<span title="=&gt; Float">toFloat</span><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="(magnitude: Float, angle: Float)spire.math.FloatComplex" id="spire.math.FloatComplex.polar">polar</a><span class="delimiter">(</span><a title="Float" id="spire.math.FloatComplex.polar.magnitude">magnitude</a>: <span title="Float">Float</span>, <a title="Float" id="spire.math.FloatComplex.polar.angle">angle</a>: <span title="Float">Float</span><span class="delimiter">)</span> =
    new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.polar" title="(magnitude: Float, angle: Float)Long">polar</a><span class="delimiter">(</span><a href="#spire.math.FloatComplex.polar.magnitude" title="Float">magnitude</a>, <a href="#spire.math.FloatComplex.polar.angle" title="Float">angle</a><span class="delimiter">)</span><span class="delimiter">)</span>

  final val <a title="spire.math.FloatComplex" id="spire.math.FloatComplex.i">i</a> = new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><span title="Long(4575657221408423936L)" class="long">4575657221408423936L</span><span class="delimiter">)</span>
  final val <a title="spire.math.FloatComplex" id="spire.math.FloatComplex.one">one</a> = new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><span title="Long(1065353216L)" class="long">1065353216L</span><span class="delimiter">)</span>
  final val <a title="spire.math.FloatComplex" id="spire.math.FloatComplex.zero">zero</a> = new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><span title="Long(0L)" class="long">0L</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Value class which encodes two floating point values in a Long.
 *
 * We get (basically) unboxed complex numbers using this hack.
 * The underlying implementation lives in the FastComplex object.
 */</span>
class <a href="#spire.math;FloatComplex.u" title="class FloatComplex extends AnyVal" id="spire.math;FloatComplex.equals">FloatComplex</a><a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex" class="delimiter">(</a>val <a title="Long" id="spire.math;FloatComplex.u">u</a>: <span title="Long">Long</span><span class="delimiter">)</span> extends <a href="#spire.math;FloatComplex.equals" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  override final def <a title="()String" id="spire.math;FloatComplex.toString">toString</a>: <span title="String">String</span> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;(%s+%si)&quot;</span> <span title="(args: Any*)String">format</span> <span class="delimiter">(</span><a href="#spire.math;FloatComplex.real" title="=&gt; Float">real</a>, <a href="#spire.math;FloatComplex.imag" title="=&gt; Float">imag</a><span class="delimiter">)</span>

  final def <a title="=&gt; Float" id="spire.math;FloatComplex.real">real</a>: <span title="Float">Float</span> = <a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span>
  final def <a title="=&gt; Float" id="spire.math;FloatComplex.imag">imag</a>: <span title="Float">Float</span> = <a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span>
  final def <a title="=&gt; String" id="spire.math;FloatComplex.repr">repr</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;FloatComplex(%s, %s)&quot;</span> <span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#spire.math;FloatComplex.real" title="=&gt; Float">real</a>, <a href="#spire.math;FloatComplex.imag" title="=&gt; Float">imag</a><span class="delimiter">)</span>
  final def <a title="=&gt; Float" id="spire.math;FloatComplex.abs">abs</a>: <span title="Float">Float</span> = <a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.abs" title="(d: Long)Float">abs</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span>
  final def <a title="=&gt; Float" id="spire.math;FloatComplex.angle">angle</a>: <span title="Float">Float</span> = <a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.angle" title="(d: Long)Float">angle</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span>
  final def <a title="=&gt; spire.math.FloatComplex" id="spire.math;FloatComplex.conjugate">conjugate</a> = new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.conjugate" title="(d: Long)Long">conjugate</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span><span class="delimiter">)</span>
  final def <a title="=&gt; Boolean" id="spire.math;FloatComplex.isWhole">isWhole</a>: <span title="Boolean">Boolean</span> = <a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.isWhole" title="(d: Long)Boolean">isWhole</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span>
  final def <a title="=&gt; Int" id="spire.math;FloatComplex.signum">signum</a>: <span title="Int">Int</span> = <a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.signum" title="(d: Long)Int">signum</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span>
  final def <a title="=&gt; spire.math.FloatComplex" id="spire.math;FloatComplex.complexSignum">complexSignum</a> = new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.complexSignum" title="(d: Long)Long">complexSignum</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span><span class="delimiter">)</span>
  final def <a title="=&gt; spire.math.FloatComplex" id="spire.math;FloatComplex.negate">negate</a> = new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.negate" title="(a: Long)Long">negate</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span><span class="delimiter">)</span>

  final def <a title="(b: spire.math.FloatComplex)spire.math.FloatComplex" id="spire.math;FloatComplex.+">+</a><span class="delimiter">(</span><a title="spire.math.FloatComplex" id="spire.math;FloatComplex.+.b">b</a>: <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">)</span> = new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.add" title="(a: Long, b: Long)Long">add</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a>, <a href="#spire.math;FloatComplex.+.b" title="spire.math.FloatComplex">b</a>.<a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span><span class="delimiter">)</span>
  final def <a title="(b: spire.math.FloatComplex)spire.math.FloatComplex" id="spire.math;FloatComplex.-">-</a><span class="delimiter">(</span><a title="spire.math.FloatComplex" id="spire.math;FloatComplex.-.b">b</a>: <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">)</span> = new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.subtract" title="(a: Long, b: Long)Long">subtract</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a>, <a href="#spire.math;FloatComplex.-.b" title="spire.math.FloatComplex">b</a>.<a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span><span class="delimiter">)</span>
  final def <a title="(b: spire.math.FloatComplex)spire.math.FloatComplex" id="spire.math;FloatComplex.*">*</a><span class="delimiter">(</span><a title="spire.math.FloatComplex" id="spire.math;FloatComplex.*.b">b</a>: <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">)</span> = new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.multiply" title="(a: Long, b: Long)Long">multiply</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a>, <a href="#spire.math;FloatComplex.*.b" title="spire.math.FloatComplex">b</a>.<a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span><span class="delimiter">)</span>
  final def <a title="(b: spire.math.FloatComplex)spire.math.FloatComplex" id="spire.math;FloatComplex./">/</a><span class="delimiter">(</span><a title="spire.math.FloatComplex" id="spire.math;FloatComplex./.b">b</a>: <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">)</span> = new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.divide" title="(a: Long, b: Long)Long">divide</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a>, <a href="#spire.math;FloatComplex./.b" title="spire.math.FloatComplex">b</a>.<a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span><span class="delimiter">)</span>
  final def <a title="(b: spire.math.FloatComplex)spire.math.FloatComplex" id="spire.math;FloatComplex./~">/~</a><span class="delimiter">(</span><a title="spire.math.FloatComplex" id="spire.math;FloatComplex./~.b">b</a>: <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">)</span> = new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.quot" title="(a: Long, b: Long)Long">quot</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a>, <a href="#spire.math;FloatComplex./~.b" title="spire.math.FloatComplex">b</a>.<a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span><span class="delimiter">)</span>
  final def <a title="(b: spire.math.FloatComplex)spire.math.FloatComplex" id="spire.math;FloatComplex.%">%</a><span class="delimiter">(</span><a title="spire.math.FloatComplex" id="spire.math;FloatComplex.%.b">b</a>: <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">)</span> = new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.mod" title="(a: Long, b: Long)Long">mod</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a>, <a href="#spire.math;FloatComplex.%.b" title="spire.math.FloatComplex">b</a>.<a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span><span class="delimiter">)</span>

  final def <a title="(b: spire.math.FloatComplex)(spire.math.FloatComplex, spire.math.FloatComplex)" id="spire.math;FloatComplex./%">/%</a><span class="delimiter">(</span><a title="spire.math.FloatComplex" id="spire.math;FloatComplex./%.b">b</a>: <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">)</span> = <a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.quotmod" title="(a: Long, b: Long)(Long, Long)">quotmod</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a>, <a href="#spire.math;FloatComplex./%.b" title="spire.math.FloatComplex">b</a>.<a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
    case <span class="delimiter">(</span><a title="Long" id="spire.math;FloatComplex./%.q">q</a>, <a title="Long" id="spire.math;FloatComplex./%.m">m</a><span class="delimiter">)</span> =&gt; <span title="(_1: spire.math.FloatComplex, _2: spire.math.FloatComplex)(spire.math.FloatComplex, spire.math.FloatComplex)" class="delimiter">(</span>new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex./%.q" title="Long">q</a><span class="delimiter">)</span>, new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex./%.m" title="Long">m</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  final def <a title="(b: spire.math.FloatComplex)spire.math.FloatComplex" id="spire.math;FloatComplex.pow(0933627c36)">pow</a><span class="delimiter">(</span><a title="spire.math.FloatComplex" id="spire.math;FloatComplex.pow(0933627c36).b">b</a>: <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">)</span> = new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.pow" title="(a: Long, b: Long)Long">pow</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a>, <a href="#spire.math;FloatComplex.pow(0933627c36).b" title="spire.math.FloatComplex">b</a>.<a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a><span class="delimiter">)</span><span class="delimiter">)</span>
  final def <a title="(b: spire.math.FloatComplex)spire.math.FloatComplex" id="spire.math;FloatComplex.**(0933627c36)">**</a><span class="delimiter">(</span><a title="spire.math.FloatComplex" id="spire.math;FloatComplex.**(0933627c36).b">b</a>: <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">)</span> = <a href="#spire.math;FloatComplex.pow(0933627c36)" title="(b: spire.math.FloatComplex)spire.math.FloatComplex">pow</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.**(0933627c36).b" title="spire.math.FloatComplex">b</a><span class="delimiter">)</span>

  final def <a title="(b: Int)spire.math.FloatComplex" id="spire.math;FloatComplex.pow(76a234c740)">pow</a><span class="delimiter">(</span><a title="Int" id="spire.math;FloatComplex.pow(76a234c740).b">b</a>: <span title="Int">Int</span><span class="delimiter">)</span> = new <a href="#spire.math;FloatComplex.equals" title="spire.math.FloatComplex">FloatComplex</a><span class="delimiter">(</span><a href="#spire.math.FastComplex" title="spire.math.FastComplex.type">FastComplex</a>.<a href="#spire.math.FastComplex.pow" title="(a: Long, b: Long)Long">pow</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.u" title="=&gt; Long">u</a>, <a href="#spire.math.FastComplex.apply(59e04a740b)" title="(real: Float, imag: Float)Long">FastComplex</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.pow(76a234c740).b" title="Int">b</a>.<span title="=&gt; Float">toFloat</span>, <span title="Float(0.0)" class="float">0.0F</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  final def <a title="(b: Int)spire.math.FloatComplex" id="spire.math;FloatComplex.**(76a234c740)">**</a><span class="delimiter">(</span><a title="Int" id="spire.math;FloatComplex.**(76a234c740).b">b</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#spire.math;FloatComplex.pow(76a234c740)" title="(b: Int)spire.math.FloatComplex">pow</a><span class="delimiter">(</span><a href="#spire.math;FloatComplex.**(76a234c740).b" title="Int">b</a><span class="delimiter">)</span>
<span class="delimiter">}</span>


<span class="comment">/**
 * FastComplex is an ugly, beautiful hack.
 *
 * The basic idea is to encode two 32-bit Floats into a single 64-bit Long.
 * The lower-32 bits are the &quot;real&quot; Float and the upper-32 are the &quot;imaginary&quot;
 * Float.
 *
 * Since we're overloading the meaning of Long, all the operations have to be
 * defined on the FastComplex object, meaning the syntax for using this is a
 * bit ugly. To add to the ugly beauty of the whole thing I could imagine
 * defining implicit operators on Long like +@, -@, *@, /@, etc.
 *
 * You might wonder why it's even worth doing this. The answer is that when
 * you need to allocate an array of e.g. 10-20 million complex numbers, the GC
 * overhead of using *any* object is HUGE. Since we can't build our own
 * &quot;pass-by-value&quot; types on the JVM we are stuck doing an encoding like this.
 *
 * Here are some profiling numbers for summing an array of complex numbers,
 * timed against a concrete case class implementation using Float (in ms):
 *
 *  size | encoded |  class
 *    1M |     5.1 |    5.8
 *    5M |    28.5 |   91.7
 *   10M |    67.7 |  828.1
 *   20M |   228.0 | 2687.0
 *
 * Not bad, eh?
 */</span>
object <a title="spire.math.FastComplex.type" id="spire.math.FastComplex">FastComplex</a> <a href="#spire.math.FastComplex" title="spire.math.FastComplex.type" class="delimiter">{</a>
  import java.lang.<span title="Math.type">Math</span>.<span class="delimiter">{</span>atan2, cos, sin, sqrt<span class="delimiter">}</span>

  <span class="comment">// note the superstitious use of @inline and final everywhere</span>

  final def <a title="(real: Float, imag: Float)Long" id="spire.math.FastComplex.apply(59e04a740b)">apply</a><span class="delimiter">(</span><a title="Float" id="spire.math.FastComplex.apply(59e04a740b).real">real</a>: <span title="Float">Float</span>, <a title="Float" id="spire.math.FastComplex.apply(59e04a740b).imag">imag</a>: <span title="Float">Float</span><span class="delimiter">)</span> = <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.apply(59e04a740b).real" title="Float">real</a>, <a href="#spire.math.FastComplex.apply(59e04a740b).imag" title="Float">imag</a><span class="delimiter">)</span>
  final def <a title="(real: Double, imag: Double)Long" id="spire.math.FastComplex.apply(485f1dc88c)">apply</a><span class="delimiter">(</span><a title="Double" id="spire.math.FastComplex.apply(485f1dc88c).real">real</a>: <span title="Double">Double</span>, <a title="Double" id="spire.math.FastComplex.apply(485f1dc88c).imag">imag</a>: <span title="Double">Double</span><span class="delimiter">)</span> = <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.apply(485f1dc88c).real" title="Double">real</a>.<span title="=&gt; Float">toFloat</span>, <a href="#spire.math.FastComplex.apply(485f1dc88c).imag" title="Double">imag</a>.<span title="=&gt; Float">toFloat</span><span class="delimiter">)</span>

  <span class="comment">// encode a float as some bits</span>
  @inline final def <a title="(n: Float)Int" id="spire.math.FastComplex.bits(fdb5fccf68)">bits</a><span class="delimiter">(</span><a title="Float" id="spire.math.FastComplex.bits(fdb5fccf68).n">n</a>: <span title="Float">Float</span><span class="delimiter">)</span>: <span title="Int">Int</span> = java.lang.<span title="Float.type">Float</span>.<span title="(x$1: Float)Int">floatToRawIntBits</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.bits(fdb5fccf68).n" title="Float">n</a><span class="delimiter">)</span>

  <span class="comment">// decode some bits into a float</span>
  @inline final def <a title="(n: Int)Float" id="spire.math.FastComplex.bits(cd38a09772)">bits</a><span class="delimiter">(</span><a title="Int" id="spire.math.FastComplex.bits(cd38a09772).n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Float">Float</span> = java.lang.<span title="Float.type">Float</span>.<span title="(x$1: Int)Float">intBitsToFloat</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.bits(cd38a09772).n" title="Int">n</a><span class="delimiter">)</span>

  <span class="comment">// get the real part of the complex number</span>
  @inline final def <a title="(d: Long)Float" id="spire.math.FastComplex.real">real</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.real.d">d</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Float">Float</span> = <a href="#spire.math.FastComplex.bits(cd38a09772)" title="(n: Int)Float">bits</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.real.d" title="Long">d</a> <span title="(x: Int)Long">&amp;</span> <span title="Int(-1)" class="int">0xffffffff</span><span class="delimiter">)</span>.<span title="=&gt; Int">toInt</span><span class="delimiter">)</span>

  <span class="comment">// get the imaginary part of the complex number</span>
  @inline final def <a title="(d: Long)Float" id="spire.math.FastComplex.imag">imag</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.imag.d">d</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Float">Float</span> = <a href="#spire.math.FastComplex.bits(cd38a09772)" title="(n: Int)Float">bits</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.imag.d" title="Long">d</a> <span title="(x: Int)Long">&gt;&gt;&gt;</span> <span title="Int(32)" class="int">32</span><span class="delimiter">)</span>.<span title="=&gt; Int">toInt</span><span class="delimiter">)</span>

  <span class="comment">// define some handy constants</span>
  final val <a title="Long" id="spire.math.FastComplex.i">i</a> = <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><span title="Float(0.0)" class="float">0.0F</span>, <span title="Float(1.0)" class="float">1.0F</span><span class="delimiter">)</span>
  final val <a title="Long" id="spire.math.FastComplex.one">one</a> = <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><span title="Float(1.0)" class="float">1.0F</span>, <span title="Float(0.0)" class="float">0.0F</span><span class="delimiter">)</span>
  final val <a title="Long" id="spire.math.FastComplex.zero">zero</a> = <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><span title="Float(0.0)" class="float">0.0F</span>, <span title="Float(0.0)" class="float">0.0F</span><span class="delimiter">)</span>

  <span class="comment">// encode two floats representing a complex number</span>
  @inline final def <a title="(real: Float, imag: Float)Long" id="spire.math.FastComplex.encode">encode</a><span class="delimiter">(</span><a title="Float" id="spire.math.FastComplex.encode.real">real</a>: <span title="Float">Float</span>, <a title="Float" id="spire.math.FastComplex.encode.imag">imag</a>: <span title="Float">Float</span><span class="delimiter">)</span>: <span title="Long">Long</span> =
    <span class="delimiter">(</span><a href="#spire.math.FastComplex.bits(fdb5fccf68)" title="(n: Float)Int">bits</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.encode.real" title="Float">real</a><span class="delimiter">)</span> <span title="(x: Long)Long">&amp;</span> <span title="Long(4294967295L)" class="long">0xffffffffL</span><span class="delimiter">)</span> <span title="(x: Long)Long">|</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.bits(fdb5fccf68)" title="(n: Float)Int">bits</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.encode.imag" title="Float">imag</a><span class="delimiter">)</span> <span title="(x: Long)Long">&amp;</span> <span title="Long(4294967295L)" class="long">0xffffffffL</span><span class="delimiter">)</span> <span title="(x: Int)Long">&lt;&lt;</span> <span title="Int(32)" class="int">32</span><span class="delimiter">)</span>

  <span class="comment">// encode two floats representing a complex number in polar form</span>
  @inline final def <a title="(magnitude: Float, angle: Float)Long" id="spire.math.FastComplex.polar">polar</a><span class="delimiter">(</span><a title="Float" id="spire.math.FastComplex.polar.magnitude">magnitude</a>: <span title="Float">Float</span>, <a title="Float" id="spire.math.FastComplex.polar.angle">angle</a>: <span title="Float">Float</span><span class="delimiter">)</span>: <span title="Long">Long</span> =
    <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.polar.magnitude" title="Float">magnitude</a> <span title="(x: Float)Float">*</span> <span title="(x$1: Double)Double">cos</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.polar.angle" title="=&gt; Double">angle</a><span class="delimiter">)</span>.<span title="=&gt; Float">toFloat</span>, <a href="#spire.math.FastComplex.polar.magnitude" title="Float">magnitude</a> <span title="(x: Float)Float">*</span> <span title="(x$1: Double)Double">sin</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.polar.angle" title="=&gt; Double">angle</a><span class="delimiter">)</span>.<span title="=&gt; Float">toFloat</span><span class="delimiter">)</span>

  <span class="comment">// decode should be avoided in fast code because it allocates a Tuple2.</span>
  final def <a title="(d: Long)(Float, Float)" id="spire.math.FastComplex.decode">decode</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.decode.d">d</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="(Float, Float)" class="delimiter">(</span>Float, Float<span class="delimiter">)</span> = <span title="(_1: Float, _2: Float)(Float, Float)" class="delimiter">(</span><a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.decode.d" title="Long">d</a><span class="delimiter">)</span>, <a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.decode.d" title="Long">d</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">// produces a string representation of the Long/(Float,Float)</span>
  final def <a title="(d: Long)String" id="spire.math.FastComplex.toRepr">toRepr</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.toRepr.d">d</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="String">String</span> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;FastComplex(%s -&gt; %s)&quot;</span> <span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.toRepr.d" title="Long">d</a>, <a href="#spire.math.FastComplex.decode" title="(d: Long)(Float, Float)">decode</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.toRepr.d" title="Long">d</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">// get the magnitude/absolute value</span>
  final def <a title="(d: Long)Float" id="spire.math.FastComplex.abs">abs</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.abs.d">d</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Float">Float</span> = <span class="delimiter">{</span>
    val <a title="Float" id="spire.math.FastComplex.abs.re">re</a> = <a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.abs.d" title="Long">d</a><span class="delimiter">)</span>
    val <a title="Float" id="spire.math.FastComplex.abs.im">im</a> = <a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.abs.d" title="Long">d</a><span class="delimiter">)</span>
    java.lang.<span title="Math.type">Math</span>.<span title="(x$1: Double)Double">sqrt</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.abs.re" title="Float">re</a> <span title="(x: Float)Float">*</span> <a href="#spire.math.FastComplex.abs.re" title="Float">re</a> <span title="=&gt; Double">+</span> <a href="#spire.math.FastComplex.abs.im" title="Float">im</a> <span title="(x: Float)Float">*</span> <a href="#spire.math.FastComplex.abs.im" title="Float">im</a><span class="delimiter">)</span>.<span title="=&gt; Float">toFloat</span>
  <span class="delimiter">}</span>

  <span class="comment">// get the angle/argument</span>
  final def <a title="(d: Long)Float" id="spire.math.FastComplex.angle">angle</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.angle.d">d</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Float">Float</span> = <span title="(x$1: Double, x$2: Double)Double">atan2</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span title="=&gt; Double" class="delimiter">(</span><a href="#spire.math.FastComplex.angle.d" title="Long">d</a><span class="delimiter">)</span>, <a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span title="=&gt; Double" class="delimiter">(</span><a href="#spire.math.FastComplex.angle.d" title="Long">d</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; Float">toFloat</span>

  <span class="comment">// get the complex conjugate</span>
  final def <a title="(d: Long)Long" id="spire.math.FastComplex.conjugate">conjugate</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.conjugate.d">d</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Long">Long</span> = <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.conjugate.d" title="Long">d</a><span class="delimiter">)</span>, <span title="=&gt; Float">-</span><a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.conjugate.d" title="Long">d</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">// see if the complex number is a whole value</span>
  final def <a title="(d: Long)Boolean" id="spire.math.FastComplex.isWhole">isWhole</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.isWhole.d">d</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.isWhole.d" title="Long">d</a><span class="delimiter">)</span> <span title="(x: Float)Float">%</span> <span title="Float(1.0)" class="float">1.0F</span> <span title="(x: Float)Boolean">==</span> <span title="Float(0.0)" class="float">0.0F</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.isWhole.d" title="Long">d</a><span class="delimiter">)</span> <span title="(x: Float)Float">%</span> <span title="Float(1.0)" class="float">1.0F</span> <span title="(x: Float)Boolean">==</span> <span title="Float(0.0)" class="float">0.0F</span>

  <span class="comment">// get the sign of the complex number</span>
  final def <a title="(d: Long)Int" id="spire.math.FastComplex.signum">signum</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.signum.d">d</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span title="implicit scala.LowPriorityImplicits.floatWrapper : (x: Float)scala.runtime.RichFloat" class="delimiter">(</span><a href="#spire.math.FastComplex.signum.d" title="Long">d</a><span class="delimiter">)</span> <span title="(y: Float)Int">compare</span> <span title="Float(0.0)" class="float">0.0F</span>

  <span class="comment">// get the complex sign of the complex number</span>
  final def <a title="(d: Long)Long" id="spire.math.FastComplex.complexSignum">complexSignum</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.complexSignum.d">d</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Long">Long</span> = <span class="delimiter">{</span>
    val <a title="Float" id="spire.math.FastComplex.complexSignum.m">m</a> = <a href="#spire.math.FastComplex.abs" title="(d: Long)Float">abs</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.complexSignum.d" title="Long">d</a><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#spire.math.FastComplex.complexSignum.m" title="Float">m</a> <span title="(x: Float)Boolean">==</span> <span title="Float(0.0)" class="float">0.0F</span><span class="delimiter">)</span> <a href="#spire.math.FastComplex.zero" title="=&gt; Long">zero</a> else <a href="#spire.math.FastComplex.divide" title="(a: Long, b: Long)Long">divide</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.complexSignum.d" title="Long">d</a>, <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.complexSignum.m" title="Float">m</a>, <span title="Float(0.0)" class="float">0.0F</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// negation</span>
  final def <a title="(a: Long)Long" id="spire.math.FastComplex.negate">negate</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.negate.a">a</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Long">Long</span> = <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><span title="=&gt; Float">-</span><a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.negate.a" title="Long">a</a><span class="delimiter">)</span>, <span title="=&gt; Float">-</span><a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.negate.a" title="Long">a</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">// addition</span>
  final def <a title="(a: Long, b: Long)Long" id="spire.math.FastComplex.add">add</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.add.a">a</a>: <span title="Long">Long</span>, <a title="Long" id="spire.math.FastComplex.add.b">b</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Long">Long</span> = <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.add.a" title="Long">a</a><span class="delimiter">)</span> <span title="(x: Float)Float">+</span> <a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.add.b" title="Long">b</a><span class="delimiter">)</span>, <a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.add.a" title="Long">a</a><span class="delimiter">)</span> <span title="(x: Float)Float">+</span> <a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.add.b" title="Long">b</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">// subtraction</span>
  final def <a title="(a: Long, b: Long)Long" id="spire.math.FastComplex.subtract">subtract</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.subtract.a">a</a>: <span title="Long">Long</span>, <a title="Long" id="spire.math.FastComplex.subtract.b">b</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Long">Long</span> = <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.subtract.a" title="Long">a</a><span class="delimiter">)</span> <span title="(x: Float)Float">-</span> <a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.subtract.b" title="Long">b</a><span class="delimiter">)</span>, <a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.subtract.a" title="Long">a</a><span class="delimiter">)</span> <span title="(x: Float)Float">-</span> <a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.subtract.b" title="Long">b</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">// multiplication</span>
  final def <a title="(a: Long, b: Long)Long" id="spire.math.FastComplex.multiply">multiply</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.multiply.a">a</a>: <span title="Long">Long</span>, <a title="Long" id="spire.math.FastComplex.multiply.b">b</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Long">Long</span> = <span class="delimiter">{</span>
    val <a title="Float" id="spire.math.FastComplex.multiply.re_a">re_a</a> = <a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.multiply.a" title="Long">a</a><span class="delimiter">)</span>
    val <a title="Float" id="spire.math.FastComplex.multiply.im_a">im_a</a> = <a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.multiply.a" title="Long">a</a><span class="delimiter">)</span>
    val <a title="Float" id="spire.math.FastComplex.multiply.re_b">re_b</a> = <a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.multiply.b" title="Long">b</a><span class="delimiter">)</span>
    val <a title="Float" id="spire.math.FastComplex.multiply.im_b">im_b</a> = <a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.multiply.b" title="Long">b</a><span class="delimiter">)</span>
    <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.multiply.re_a" title="Float">re_a</a> <span title="(x: Float)Float">*</span> <a href="#spire.math.FastComplex.multiply.re_b" title="Float">re_b</a> <span title="(x: Float)Float">-</span> <a href="#spire.math.FastComplex.multiply.im_a" title="Float">im_a</a> <span title="(x: Float)Float">*</span> <a href="#spire.math.FastComplex.multiply.im_b" title="Float">im_b</a>, <a href="#spire.math.FastComplex.multiply.im_a" title="Float">im_a</a> <span title="(x: Float)Float">*</span> <a href="#spire.math.FastComplex.multiply.re_b" title="Float">re_b</a> <span title="(x: Float)Float">+</span> <a href="#spire.math.FastComplex.multiply.re_a" title="Float">re_a</a> <span title="(x: Float)Float">*</span> <a href="#spire.math.FastComplex.multiply.im_b" title="Float">im_b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// division</span>
  final def <a title="(a: Long, b: Long)Long" id="spire.math.FastComplex.divide">divide</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.divide.a">a</a>: <span title="Long">Long</span>, <a title="Long" id="spire.math.FastComplex.divide.b">b</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Long">Long</span> = <span class="delimiter">{</span>
    val <a title="Float" id="spire.math.FastComplex.divide.re_a">re_a</a> = <a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.divide.a" title="Long">a</a><span class="delimiter">)</span>
    val <a title="Float" id="spire.math.FastComplex.divide.im_a">im_a</a> = <a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.divide.a" title="Long">a</a><span class="delimiter">)</span>
    val <a title="Float" id="spire.math.FastComplex.divide.re_b">re_b</a> = <a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.divide.b" title="Long">b</a><span class="delimiter">)</span>
    val <a title="Float" id="spire.math.FastComplex.divide.im_b">im_b</a> = <a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.divide.b" title="Long">b</a><span class="delimiter">)</span>

    val <a title="Float" id="spire.math.FastComplex.divide.abs_re_b">abs_re_b</a> = <span title="Math.type">Math</span>.<span title="(x$1: Float)Float">abs</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.divide.re_b" title="Float">re_b</a><span class="delimiter">)</span>
    val <a title="Float" id="spire.math.FastComplex.divide.abs_im_b">abs_im_b</a> = <span title="Math.type">Math</span>.<span title="(x$1: Float)Float">abs</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.divide.im_b" title="Float">im_b</a><span class="delimiter">)</span>

    if <span class="delimiter">(</span><a href="#spire.math.FastComplex.divide.abs_re_b" title="Float">abs_re_b</a> <span title="(x: Float)Boolean">&gt;=</span> <a href="#spire.math.FastComplex.divide.abs_im_b" title="Float">abs_im_b</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#spire.math.FastComplex.divide.abs_re_b" title="Float">abs_re_b</a> <span title="(x: Float)Boolean">==</span> <span title="Float(0.0)" class="float">0.0F</span><span class="delimiter">)</span> throw new <span title="ArithmeticException">ArithmeticException</span><span class="delimiter">(</span><span title="String(&quot;/0&quot;)" class="string">&quot;/0&quot;</span><span class="delimiter">)</span>
      val ratio = <a href="#spire.math.FastComplex.divide.im_b" title="Float">im_b</a> <span title="Float">/</span> <a href="#spire.math.FastComplex.divide.re_b" title="Float">re_b</a>
      val denom = <a href="#spire.math.FastComplex.divide.re_b" title="Float">re_b</a> <span title="Float">+</span> <a href="#spire.math.FastComplex.divide.im_b" title="Float">im_b</a> <span title="(x: Float)Float">*</span> <span title="Float">ratio</span>
      <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.divide.re_a" title="Float">re_a</a> <span title="(x: Float)Float">+</span> <a href="#spire.math.FastComplex.divide.im_a" title="Float">im_a</a> <span title="(x: Float)Float">*</span> <span title="Float">ratio</span><span class="delimiter">)</span> <span title="(x: Float)Float">/</span> <span title="Float">denom</span>, <span class="delimiter">(</span><a href="#spire.math.FastComplex.divide.im_a" title="Float">im_a</a> <span title="(x: Float)Float">-</span> <a href="#spire.math.FastComplex.divide.re_a" title="Float">re_a</a> <span title="(x: Float)Float">*</span> <span title="Float">ratio</span><span class="delimiter">)</span> <span title="(x: Float)Float">/</span> <span title="Float">denom</span><span class="delimiter">)</span>

    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#spire.math.FastComplex.divide.abs_im_b" title="Float">abs_im_b</a> <span title="(x: Float)Boolean">==</span> <span title="Float(0.0)" class="float">0.0F</span><span class="delimiter">)</span> throw new <span title="ArithmeticException">ArithmeticException</span><span class="delimiter">(</span><span title="String(&quot;/0&quot;)" class="string">&quot;/0&quot;</span><span class="delimiter">)</span>
      val ratio = <a href="#spire.math.FastComplex.divide.re_b" title="Float">re_b</a> <span title="Float">/</span> <a href="#spire.math.FastComplex.divide.im_b" title="Float">im_b</a>
      val denom = <a href="#spire.math.FastComplex.divide.re_b" title="Float">re_b</a> <span title="(x: Float)Float">*</span> <span title="Float">ratio</span> <span title="Float">+</span> <a href="#spire.math.FastComplex.divide.im_b" title="Float">im_b</a>
      <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.divide.re_a" title="Float">re_a</a> <span title="(x: Float)Float">*</span> <span title="Float">ratio</span> <span title="(x: Float)Float">+</span> <a href="#spire.math.FastComplex.divide.im_a" title="Float">im_a</a><span class="delimiter">)</span> <span title="(x: Float)Float">/</span> <span title="Float">denom</span>, <span class="delimiter">(</span><a href="#spire.math.FastComplex.divide.im_a" title="Float">im_a</a> <span title="(x: Float)Float">*</span> <span title="Float">ratio</span> <span title="(x: Float)Float">-</span> <a href="#spire.math.FastComplex.divide.re_a" title="Float">re_a</a><span class="delimiter">)</span> <span title="(x: Float)Float">/</span> <span title="Float">denom</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  final def <a title="(a: Long, b: Long)Long" id="spire.math.FastComplex.quot">quot</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.quot.a">a</a>: <span title="Long">Long</span>, <a title="Long" id="spire.math.FastComplex.quot.b">b</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Long">Long</span> =
    <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><span title="Math.type">Math</span>.<span title="(x$1: Double)Double">floor</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span title="=&gt; Double" class="delimiter">(</span><a href="#spire.math.FastComplex.divide" title="(a: Long, b: Long)Long">divide</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.quot.a" title="Long">a</a>, <a href="#spire.math.FastComplex.quot.b" title="Long">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; Float">toFloat</span>, <span title="Float(0.0)" class="float">0.0F</span><span class="delimiter">)</span>

  final def <a title="(a: Long, b: Long)Long" id="spire.math.FastComplex.mod">mod</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.mod.a">a</a>: <span title="Long">Long</span>, <a title="Long" id="spire.math.FastComplex.mod.b">b</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Long">Long</span> = <a href="#spire.math.FastComplex.subtract" title="(a: Long, b: Long)Long">subtract</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.mod.a" title="Long">a</a>, <a href="#spire.math.FastComplex.multiply" title="(a: Long, b: Long)Long">multiply</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.mod.b" title="Long">b</a>, <a href="#spire.math.FastComplex.quot" title="(a: Long, b: Long)Long">quot</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.mod.a" title="Long">a</a>, <a href="#spire.math.FastComplex.mod.b" title="Long">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  final def <a title="(a: Long, b: Long)(Long, Long)" id="spire.math.FastComplex.quotmod">quotmod</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.quotmod.a">a</a>: <span title="Long">Long</span>, <a title="Long" id="spire.math.FastComplex.quotmod.b">b</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="(Long, Long)" class="delimiter">(</span>Long, Long<span class="delimiter">)</span> = <span class="delimiter">{</span>
    val <a title="Long" id="spire.math.FastComplex.quotmod.q">q</a> = <a href="#spire.math.FastComplex.quot" title="(a: Long, b: Long)Long">quot</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.quotmod.a" title="Long">a</a>, <a href="#spire.math.FastComplex.quotmod.b" title="Long">b</a><span class="delimiter">)</span>
    <span title="(_1: Long, _2: Long)(Long, Long)" class="delimiter">(</span><a href="#spire.math.FastComplex.quotmod.q" title="Long">q</a>, <a href="#spire.math.FastComplex.subtract" title="(a: Long, b: Long)Long">subtract</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.quotmod.a" title="Long">a</a>, <a href="#spire.math.FastComplex.multiply" title="(a: Long, b: Long)Long">multiply</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.quotmod.b" title="Long">b</a>, <a href="#spire.math.FastComplex.quot" title="(a: Long, b: Long)Long">quot</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.quotmod.a" title="Long">a</a>, <a href="#spire.math.FastComplex.quotmod.b" title="Long">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// exponentiation</span>
  final def <a title="(a: Long, b: Long)Long" id="spire.math.FastComplex.pow">pow</a><span class="delimiter">(</span><a title="Long" id="spire.math.FastComplex.pow.a">a</a>: <span title="Long">Long</span>, <a title="Long" id="spire.math.FastComplex.pow.b">b</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Long">Long</span> = if <span class="delimiter">(</span><a href="#spire.math.FastComplex.pow.b" title="Long">b</a> <span title="(x: Long)Boolean">==</span> <a href="#spire.math.FastComplex.zero" title="=&gt; Long">zero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#spire.math.FastComplex.encode" title="(real: Float, imag: Float)Long">encode</a><span class="delimiter">(</span><span title="Float(1.0)" class="float">1.0F</span>, <span title="Float(0.0)" class="float">0.0F</span><span class="delimiter">)</span>

  <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.math.FastComplex.pow.a" title="Long">a</a> <span title="(x: Long)Boolean">==</span> <a href="#spire.math.FastComplex.zero" title="=&gt; Long">zero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.pow.b" title="Long">b</a><span class="delimiter">)</span> <span title="(x: Float)Boolean">!=</span> <span title="Float(0.0)" class="float">0.0F</span> <span title="(x: Boolean)Boolean">||</span> <a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.pow.b" title="Long">b</a><span class="delimiter">)</span> <span title="(x: Float)Boolean">&lt;</span> <span title="Float(0.0)" class="float">0.0F</span><span class="delimiter">)</span>
      throw new <span title="Exception">Exception</span><span class="delimiter">(</span><span title="String(&quot;raising 0 to negative/complex power&quot;)" class="string">&quot;raising 0 to negative/complex power&quot;</span><span class="delimiter">)</span>
    <a href="#spire.math.FastComplex.zero" title="=&gt; Long">zero</a>

  <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.pow.b" title="Long">b</a><span class="delimiter">)</span> <span title="(x: Float)Boolean">!=</span> <span title="Float(0.0)" class="float">0.0F</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="Float" id="spire.math.FastComplex.pow.im_b">im_b</a> = <a href="#spire.math.FastComplex.imag" title="(d: Long)Float">imag</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.pow.b" title="Long">b</a><span class="delimiter">)</span>
    val <a title="Float" id="spire.math.FastComplex.pow.re_b">re_b</a> = <a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.pow.b" title="Long">b</a><span class="delimiter">)</span>
    val <span title="Float">len</span> = <span class="delimiter">(</span><span title="Math.type">Math</span>.<span title="(x$1: Double, x$2: Double)Double">pow</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.abs" title="(d: Long)Float">abs</a><span title="=&gt; Double" class="delimiter">(</span><a href="#spire.math.FastComplex.pow.a" title="Long">a</a><span class="delimiter">)</span>, <a href="#spire.math.FastComplex.pow.re_b" title="=&gt; Double">re_b</a><span class="delimiter">)</span> <span title="(x: Double)Double">/</span> <a href="package.scala.html#spire.math.package.exp(c3da5261a3)" title="(n: Double)Double">exp</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.angle" title="(d: Long)Float">angle</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.pow.a" title="Long">a</a><span class="delimiter">)</span> <span title="=&gt; Double">*</span> <a href="#spire.math.FastComplex.pow.im_b" title="Float">im_b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; Float">toFloat</span>
    val <span title="Float">phase</span> = <span class="delimiter">(</span><a href="#spire.math.FastComplex.angle" title="(d: Long)Float">angle</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.pow.a" title="Long">a</a><span class="delimiter">)</span> <span title="(x: Float)Float">*</span> <a href="#spire.math.FastComplex.pow.re_b" title="Float">re_b</a> <span title="(x: Double)Double">+</span> <a href="package.scala.html#spire.math.package.log(c3da5261a3)" title="(n: Double)Double">log</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.abs" title="(d: Long)Float">abs</a><span title="=&gt; Double" class="delimiter">(</span><a href="#spire.math.FastComplex.pow.a" title="Long">a</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Float)Double">*</span> <a href="#spire.math.FastComplex.pow.im_b" title="Float">im_b</a><span class="delimiter">)</span>.<span title="=&gt; Float">toFloat</span>
    <a href="#spire.math.FastComplex.polar" title="(magnitude: Float, angle: Float)Long">polar</a><span class="delimiter">(</span><span title="Float">len</span>, <span title="Float">phase</span><span class="delimiter">)</span>

  <span class="delimiter">}</span> else <span class="delimiter">{</span>
    val <span title="Float">len</span> = <span title="Math.type">Math</span>.<span title="(x$1: Double, x$2: Double)Double">pow</span><span class="delimiter">(</span><a href="#spire.math.FastComplex.abs" title="(d: Long)Float">abs</a><span title="=&gt; Double" class="delimiter">(</span><a href="#spire.math.FastComplex.pow.a" title="Long">a</a><span class="delimiter">)</span>, <a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span title="=&gt; Double" class="delimiter">(</span><a href="#spire.math.FastComplex.pow.b" title="Long">b</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; Float">toFloat</span>
    val <span title="Float">phase</span> = <span class="delimiter">(</span><a href="#spire.math.FastComplex.angle" title="(d: Long)Float">angle</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.pow.a" title="Long">a</a><span class="delimiter">)</span> <span title="(x: Float)Float">*</span> <a href="#spire.math.FastComplex.real" title="(d: Long)Float">real</a><span class="delimiter">(</span><a href="#spire.math.FastComplex.pow.b" title="Long">b</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; Float">toFloat</span>
    <a href="#spire.math.FastComplex.polar" title="(magnitude: Float, angle: Float)Long">polar</a><span class="delimiter">(</span><span title="Float">len</span>, <span title="Float">phase</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

trait <a title="trait ComplexInstances0 extends AnyRef" id="spire.math;ComplexInstances0">ComplexInstances0</a> <span title="Unit" class="delimiter">{</span>
  implicit def <a title="[A](implicit evidence$4: spire.algebra.Ring[A], implicit evidence$5: spire.algebra.IsReal[A])spire.algebra.Ring[spire.math.Complex[A]]" id="spire.math;ComplexInstances0.ComplexRing">ComplexRing</a><span class="delimiter">[</span><a title="" id="spire.math;ComplexInstances0.ComplexRing;A">A</a>: Ring: IsReal<span class="delimiter">]</span>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[spire.math.Complex[A]]">Ring</a><span class="delimiter">[</span>Complex<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = new <a href="#spire.math;ComplexIsRingImpl" title="spire.math.ComplexIsRingImpl[A]">ComplexIsRingImpl</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
<span class="delimiter">}</span>

trait <a title="trait ComplexInstances1 extends AnyRef with spire.math.ComplexInstances0" id="spire.math;ComplexInstances1">ComplexInstances1</a> extends <a href="#spire.math;ComplexInstances0" title="spire.math.ComplexInstances0">ComplexInstances0</a> <span class="delimiter">{</span>
  implicit def <a title="[A](implicit evidence$6: spire.algebra.Field[A], implicit evidence$7: spire.algebra.IsReal[A])spire.algebra.Field[spire.math.Complex[A]]" id="spire.math;ComplexInstances1.ComplexField">ComplexField</a><span class="delimiter">[</span><a title="" id="spire.math;ComplexInstances1.ComplexField;A">A</a>: Field: IsReal<span class="delimiter">]</span>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[spire.math.Complex[A]]">Field</a><span class="delimiter">[</span>Complex<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = new <a href="#spire.math;ComplexIsFieldImpl" title="spire.math.ComplexIsFieldImpl[A]">ComplexIsFieldImpl</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
<span class="delimiter">}</span>

trait <a title="trait ComplexInstances extends AnyRef with spire.math.ComplexInstances1" id="spire.math;ComplexInstances">ComplexInstances</a> extends <a href="#spire.math;ComplexInstances1" title="spire.math.ComplexInstances1">ComplexInstances1</a> <span class="delimiter">{</span>
  implicit def <a title="[A](implicit evidence$8: spire.math.Fractional[A], implicit evidence$9: spire.algebra.Trig[A], implicit evidence$10: spire.algebra.IsReal[A])spire.math.ComplexAlgebra[A]" id="spire.math;ComplexInstances.ComplexAlgebra">ComplexAlgebra</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math;ComplexInstances.ComplexAlgebra;A">A</a>: Fractional: Trig: IsReal<span class="delimiter">]</span> =
    new <a href="#spire.math;ComplexAlgebra" title="spire.math.ComplexAlgebra[A]">ComplexAlgebra</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  implicit def <a title="[A](implicit evidence$11: spire.algebra.Eq[A])spire.algebra.Eq[spire.math.Complex[A]]" id="spire.math;ComplexInstances.ComplexEq">ComplexEq</a><span class="delimiter">[</span><a title="" id="spire.math;ComplexInstances.ComplexEq;A">A</a>: Eq<span class="delimiter">]</span>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[spire.math.Complex[A]]">Eq</a><span class="delimiter">[</span>Complex<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = new <a href="#spire.math;ComplexEq" title="spire.math.ComplexEq[A]">ComplexEq</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
<span class="delimiter">}</span>

private<span class="delimiter">[</span>math<span class="delimiter">]</span> trait <a title="trait ComplexIsRing[A] extends AnyRef with spire.algebra.Ring[spire.math.Complex[A]]" id="spire.math;ComplexIsRing">ComplexIsRing</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math;ComplexIsRing;A">A</a><span class="delimiter">]</span> extends <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[spire.math.Complex[A]]">Ring</a><span class="delimiter">[</span>Complex<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  implicit def <a title="=&gt; spire.algebra.Ring[A]" id="spire.math;ComplexIsRing.algebra">algebra</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.IsReal[A]" id="spire.math;ComplexIsRing.order">order</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[A]">IsReal</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  override def <a title="(a: spire.math.Complex[A], b: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsRing.minus">minus</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsRing.minus.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Complex[A]" id="spire.math;ComplexIsRing.minus.b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsRing.minus.a" title="spire.math.Complex[A]">a</a> <a href="#spire.math;Complex.-(e1c0640f17)" title="(b: spire.math.Complex[A])(implicit r: spire.algebra.Rng[A])spire.math.Complex[A]">-</a> <a href="#spire.math;ComplexIsRing.minus.b" title="spire.math.Complex[A]">b</a>
  def <a title="(a: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsRing.negate">negate</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsRing.negate.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;Complex.unary_-" title="(implicit r: spire.algebra.Rng[A])spire.math.Complex[A]">-</a><a href="#spire.math;ComplexIsRing.negate.a" title="spire.math.Complex[A]">a</a>
  def <a title="=&gt; spire.math.Complex[A]" id="spire.math;ComplexIsRing.one">one</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Complex.readResolve" title="spire.math.Complex.type">Complex</a>.<a href="#spire.math.Complex.one" title="(implicit T: spire.algebra.Rig[A])spire.math.Complex[A]">one</a>
  def <a title="(a: spire.math.Complex[A], b: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsRing.plus">plus</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsRing.plus.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Complex[A]" id="spire.math;ComplexIsRing.plus.b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsRing.plus.a" title="spire.math.Complex[A]">a</a> <a href="#spire.math;Complex.+(cb068cef3f)" title="(b: spire.math.Complex[A])(implicit r: spire.algebra.Semiring[A])spire.math.Complex[A]">+</a> <a href="#spire.math;ComplexIsRing.plus.b" title="spire.math.Complex[A]">b</a>
  override def <a title="(a: spire.math.Complex[A], b: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsRing.times">times</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsRing.times.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Complex[A]" id="spire.math;ComplexIsRing.times.b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsRing.times.a" title="spire.math.Complex[A]">a</a> <a href="#spire.math;Complex.*(e1c0640f17)" title="(b: spire.math.Complex[A])(implicit r: spire.algebra.Rng[A])spire.math.Complex[A]">*</a> <a href="#spire.math;ComplexIsRing.times.b" title="spire.math.Complex[A]">b</a>
  def <a title="=&gt; spire.math.Complex[A]" id="spire.math;ComplexIsRing.zero">zero</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Complex.readResolve" title="spire.math.Complex.type">Complex</a>.<a href="#spire.math.Complex.zero" title="(implicit T: spire.algebra.Semiring[A])spire.math.Complex[A]">zero</a>

  override def <a title="(n: Int)spire.math.Complex[A]" id="spire.math;ComplexIsRing.fromInt">fromInt</a><span class="delimiter">(</span><a title="Int" id="spire.math;ComplexIsRing.fromInt.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Complex.readResolve" title="spire.math.Complex.type">Complex</a>.<a href="#spire.math.Complex.fromInt" title="[T](n: Int)(implicit f: spire.algebra.Ring[T])spire.math.Complex[T]">fromInt</a><span title="(n: Int)(implicit f: spire.algebra.Ring[A])spire.math.Complex[A]" class="delimiter">[</span><a href="#spire.math;ComplexIsRing;A" title="A">A</a><span class="delimiter">]</span><a href="#spire.math;ComplexIsRing.algebra" title="=&gt; spire.algebra.Ring[A]" class="delimiter">(</a><a href="#spire.math;ComplexIsRing.fromInt.n" title="Int">n</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

private<span class="delimiter">[</span>math<span class="delimiter">]</span> trait <a title="trait ComplexIsField[A] extends AnyRef with spire.math.ComplexIsRing[A] with spire.algebra.Field[spire.math.Complex[A]]" id="spire.math;ComplexIsField">ComplexIsField</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float,Double<span class="delimiter">)</span> <a title="" id="spire.math;ComplexIsField;A">A</a><span class="delimiter">]</span> extends <a href="#spire.math;ComplexIsRing" title="spire.math.ComplexIsRing[A]">ComplexIsRing</a><span class="delimiter">[</span>A<span class="delimiter">]</span> with <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[spire.math.Complex[A]]">Field</a><span class="delimiter">[</span>Complex<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>

  implicit def <a title="=&gt; spire.algebra.Field[A]" id="spire.math;ComplexIsField.algebra">algebra</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  override def <a title="(n: Double)spire.math.Complex[A]" id="spire.math;ComplexIsField.fromDouble">fromDouble</a><span class="delimiter">(</span><a title="Double" id="spire.math;ComplexIsField.fromDouble.n">n</a>: <span title="Double">Double</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math.Complex.apply(649289f1e7)" title="(real: A)(implicit evidence$3: spire.algebra.Semiring[A])spire.math.Complex[A]">Complex</a><a href="#spire.math;ComplexIsField.algebra" title="=&gt; spire.algebra.Field[A]" class="delimiter">(</a><a href="#spire.math;ComplexIsField.algebra" title="=&gt; spire.algebra.Field[A]">algebra</a>.<a href="../algebra/Field.scala.html#spire.algebra;Field.fromDouble" title="(a: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.math;ComplexIsField.fromDouble.n" title="Double">n</a><span class="delimiter">)</span><span class="delimiter">)</span>
  def <a title="(a: spire.math.Complex[A], b: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsField.div">div</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsField.div.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Complex[A]" id="spire.math;ComplexIsField.div.b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math;ComplexIsField.div.a" title="spire.math.Complex[A]">a</a> <a href="#spire.math;Complex./(7edf8f59b2)" title="(b: spire.math.Complex[A])(implicit f: spire.algebra.Field[A], implicit o: spire.algebra.IsReal[A])spire.math.Complex[A]">/</a> <a href="#spire.math;ComplexIsField.div.b" title="spire.math.Complex[A]">b</a>
  def <a title="(a: spire.math.Complex[A], b: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsField.quot">quot</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsField.quot.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Complex[A]" id="spire.math;ComplexIsField.quot.b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math;ComplexIsField.quot.a" title="spire.math.Complex[A]">a</a> <a href="#spire.math;Complex./~(7edf8f59b2)" title="(b: spire.math.Complex[A])(implicit f: spire.algebra.Field[A], implicit o: spire.algebra.IsReal[A])spire.math.Complex[A]">/~</a> <a href="#spire.math;ComplexIsField.quot.b" title="spire.math.Complex[A]">b</a>
  def <a title="(a: spire.math.Complex[A], b: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsField.mod">mod</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsField.mod.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Complex[A]" id="spire.math;ComplexIsField.mod.b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math;ComplexIsField.mod.a" title="spire.math.Complex[A]">a</a> <a href="#spire.math;Complex.%(7edf8f59b2)" title="(b: spire.math.Complex[A])(implicit f: spire.algebra.Field[A], implicit o: spire.algebra.IsReal[A])spire.math.Complex[A]">%</a> <a href="#spire.math;ComplexIsField.mod.b" title="spire.math.Complex[A]">b</a>
  override def <a title="(a: spire.math.Complex[A], b: spire.math.Complex[A])(spire.math.Complex[A], spire.math.Complex[A])" id="spire.math;ComplexIsField.quotmod">quotmod</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsField.quotmod.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Complex[A]" id="spire.math;ComplexIsField.quotmod.b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math;ComplexIsField.quotmod.a" title="spire.math.Complex[A]">a</a> <a href="#spire.math;Complex./%(add12d81ce)" title="(b: spire.math.Complex[A])(implicit f: spire.algebra.Field[A], implicit o: spire.algebra.IsReal[A])(spire.math.Complex[A], spire.math.Complex[A])">/%</a> <a href="#spire.math;ComplexIsField.quotmod.b" title="spire.math.Complex[A]">b</a>
  def <a title="(a: spire.math.Complex[A], b: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsField.gcd">gcd</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsField.gcd.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Complex[A]" id="spire.math;ComplexIsField.gcd.b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    @tailrec def <a title="(a: spire.math.Complex[A], b: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsField.gcd._gcd">_gcd</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsField.gcd._gcd.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Complex[A]" id="spire.math;ComplexIsField.gcd._gcd.b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#spire.math;ComplexIsField.gcd._gcd.b" title="spire.math.Complex[A]">b</a>.<a href="#spire.math;Complex.isZero" title="(implicit o: spire.algebra.IsReal[A])Boolean">isZero</a><span class="delimiter">)</span> <a href="#spire.math;ComplexIsField.gcd._gcd.a" title="spire.math.Complex[A]">a</a> else <a href="#spire.math;ComplexIsField.gcd._gcd" title="(a: spire.math.Complex[A], b: spire.math.Complex[A])spire.math.Complex[A]">_gcd</a><span class="delimiter">(</span><a href="#spire.math;ComplexIsField.gcd._gcd.b" title="spire.math.Complex[A]">b</a>, <a href="#spire.math;ComplexIsField.gcd._gcd.a" title="spire.math.Complex[A]">a</a> <a href="#spire.math;Complex.-(e1c0640f17)" title="(b: spire.math.Complex[A])(implicit r: spire.algebra.Rng[A])spire.math.Complex[A]">-</a> <span class="delimiter">(</span><a href="#spire.math;ComplexIsField.gcd._gcd.a" title="spire.math.Complex[A]">a</a> <a href="#spire.math;Complex./(7edf8f59b2)" title="(b: spire.math.Complex[A])(implicit f: spire.algebra.Field[A], implicit o: spire.algebra.IsReal[A])spire.math.Complex[A]">/</a> <a href="#spire.math;ComplexIsField.gcd._gcd.b" title="spire.math.Complex[A]">b</a><span class="delimiter">)</span>.<a href="#spire.math;Complex.round" title="(implicit o: spire.algebra.IsReal[A])spire.math.Complex[A]">round</a> <a href="#spire.math;Complex.*(e1c0640f17)" title="(b: spire.math.Complex[A])(implicit r: spire.algebra.Rng[A])spire.math.Complex[A]">*</a> <a href="#spire.math;ComplexIsField.gcd._gcd.b" title="spire.math.Complex[A]">b</a><span class="delimiter">)</span>
    <a href="#spire.math;ComplexIsField.gcd._gcd" title="(a: spire.math.Complex[A], b: spire.math.Complex[A])spire.math.Complex[A]">_gcd</a><span class="delimiter">(</span><a href="#spire.math;ComplexIsField.gcd.a" title="spire.math.Complex[A]">a</a>, <a href="#spire.math;ComplexIsField.gcd.b" title="spire.math.Complex[A]">b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

private<span class="delimiter">[</span>math<span class="delimiter">]</span> trait <a title="trait ComplexIsTrig[A] extends AnyRef with spire.algebra.Trig[spire.math.Complex[A]]" id="spire.math;ComplexIsTrig">ComplexIsTrig</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math;ComplexIsTrig;A">A</a><span class="delimiter">]</span> extends <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[spire.math.Complex[A]]">Trig</a><span class="delimiter">[</span>Complex<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  implicit def <a title="=&gt; spire.algebra.Field[A]" id="spire.math;ComplexIsTrig.algebra">algebra</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.NRoot[A]" id="spire.math;ComplexIsTrig.nroot">nroot</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[A]">NRoot</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.Trig[A]" id="spire.math;ComplexIsTrig.trig">trig</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[A]">Trig</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.IsReal[A]" id="spire.math;ComplexIsTrig.order">order</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[A]">IsReal</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  def <a title="=&gt; spire.math.Complex[A]" id="spire.math;ComplexIsTrig.e">e</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.math;ComplexIsTrig.trig" title="=&gt; spire.algebra.Trig[A]">trig</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.e" title="=&gt; A">e</a>, <a href="#spire.math;ComplexIsTrig.algebra" title="=&gt; spire.algebra.Field[A]">algebra</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span>
  def <a title="=&gt; spire.math.Complex[A]" id="spire.math;ComplexIsTrig.pi">pi</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.math;ComplexIsTrig.trig" title="=&gt; spire.algebra.Trig[A]">trig</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.pi" title="=&gt; A">pi</a>, <a href="#spire.math;ComplexIsTrig.algebra" title="=&gt; spire.algebra.Field[A]">algebra</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span>

  def <a title="(a: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.exp">exp</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.exp.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsTrig.exp.a" title="spire.math.Complex[A]">a</a>.<a href="#spire.math;Complex.exp" title="(implicit f: spire.algebra.Field[A], implicit t: spire.algebra.Trig[A])spire.math.Complex[A]">exp</a>
  def <a title="(a: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.expm1">expm1</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.expm1.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsTrig.expm1.a" title="spire.math.Complex[A]">a</a>.<a href="#spire.math;Complex.exp" title="(implicit f: spire.algebra.Field[A], implicit t: spire.algebra.Trig[A])spire.math.Complex[A]">exp</a> <a href="#spire.math;Complex.-(0609254e6c)" title="(rhs: A)(implicit r: spire.algebra.Rng[A])spire.math.Complex[A]">-</a> <a href="#spire.math;ComplexIsTrig.algebra" title="=&gt; spire.algebra.Field[A]">algebra</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; A">one</a>
  def <a title="(a: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.log">log</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.log.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsTrig.log.a" title="spire.math.Complex[A]">a</a>.<a href="#spire.math;Complex.log" title="(implicit f: spire.algebra.Field[A], implicit n: spire.algebra.NRoot[A], implicit t: spire.algebra.Trig[A], implicit o: spire.algebra.IsReal[A])spire.math.Complex[A]">log</a>
  def <a title="(a: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.log1p">log1p</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.log1p.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">(</span><a href="#spire.math;ComplexIsTrig.log1p.a" title="spire.math.Complex[A]">a</a> <a href="#spire.math;Complex.+(1cd9316a8d)" title="(rhs: A)(implicit r: spire.algebra.Semiring[A])spire.math.Complex[A]">+</a> <a href="#spire.math;ComplexIsTrig.algebra" title="=&gt; spire.algebra.Field[A]">algebra</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; A">one</a><span class="delimiter">)</span>.<a href="#spire.math;Complex.log" title="(implicit f: spire.algebra.Field[A], implicit n: spire.algebra.NRoot[A], implicit t: spire.algebra.Trig[A], implicit o: spire.algebra.IsReal[A])spire.math.Complex[A]">log</a>

  def <a title="(a: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.sin">sin</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.sin.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsTrig.sin.a" title="spire.math.Complex[A]">a</a>.<a href="#spire.math;Complex.sin" title="(implicit f: spire.algebra.Field[A], implicit t: spire.algebra.Trig[A])spire.math.Complex[A]">sin</a>
  def <a title="(a: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.cos">cos</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.cos.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsTrig.cos.a" title="spire.math.Complex[A]">a</a>.<a href="#spire.math;Complex.cos" title="(implicit f: spire.algebra.Field[A], implicit t: spire.algebra.Trig[A])spire.math.Complex[A]">cos</a>
  def <a title="(a: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.tan">tan</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.tan.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsTrig.tan.a" title="spire.math.Complex[A]">a</a>.<a href="#spire.math;Complex.tan" title="(implicit f: spire.algebra.Field[A], implicit t: spire.algebra.Trig[A])spire.math.Complex[A]">tan</a>

  def <a title="(a: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.asin">asin</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.asin.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsTrig.asin.a" title="spire.math.Complex[A]">a</a>.<a href="#spire.math;Complex.sin" title="(implicit f: spire.algebra.Field[A], implicit t: spire.algebra.Trig[A])spire.math.Complex[A]">sin</a>
  def <a title="(a: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.acos">acos</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.acos.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsTrig.acos.a" title="spire.math.Complex[A]">a</a>.<a href="#spire.math;Complex.cos" title="(implicit f: spire.algebra.Field[A], implicit t: spire.algebra.Trig[A])spire.math.Complex[A]">cos</a>
  def <a title="(a: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.atan">atan</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.atan.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsTrig.atan.a" title="spire.math.Complex[A]">a</a>.<a href="#spire.math;Complex.tan" title="(implicit f: spire.algebra.Field[A], implicit t: spire.algebra.Trig[A])spire.math.Complex[A]">tan</a>
  def <a title="(y: spire.math.Complex[A], x: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.atan2">atan2</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.atan2.y">y</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.atan2.x">x</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    new <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">(</span><a href="#spire.math;ComplexIsTrig.atan2.x" title="spire.math.Complex[A]">x</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; A">real</a>, <a href="#spire.math;ComplexIsTrig.atan2.y" title="spire.math.Complex[A]">y</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; A">imag</a><span class="delimiter">)</span>.<a href="#spire.math;Complex.atan" title="(implicit f: spire.algebra.Field[A], implicit r: spire.algebra.NRoot[A], implicit t: spire.algebra.Trig[A], implicit o: spire.algebra.IsReal[A])spire.math.Complex[A]">atan</a>

  def <a title="(x: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.sinh">sinh</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.sinh.x">x</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsTrig.sinh.x" title="spire.math.Complex[A]">x</a>.<a href="#spire.math;Complex.sinh" title="(implicit f: spire.algebra.Field[A], implicit t: spire.algebra.Trig[A])spire.math.Complex[A]">sinh</a>
  def <a title="(x: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.cosh">cosh</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.cosh.x">x</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsTrig.cosh.x" title="spire.math.Complex[A]">x</a>.<a href="#spire.math;Complex.cosh" title="(implicit f: spire.algebra.Field[A], implicit t: spire.algebra.Trig[A])spire.math.Complex[A]">cosh</a>
  def <a title="(x: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.tanh">tanh</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.tanh.x">x</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsTrig.tanh.x" title="spire.math.Complex[A]">x</a>.<a href="#spire.math;Complex.tanh" title="(implicit f: spire.algebra.Field[A], implicit t: spire.algebra.Trig[A])spire.math.Complex[A]">tanh</a>

  def <a title="(a: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.toRadians">toRadians</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.toRadians.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsTrig.toRadians.a" title="spire.math.Complex[A]">a</a>
  def <a title="(a: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsTrig.toDegrees">toDegrees</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsTrig.toDegrees.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsTrig.toDegrees.a" title="spire.math.Complex[A]">a</a>
<span class="delimiter">}</span>

private<span class="delimiter">[</span>math<span class="delimiter">]</span> trait <a title="trait ComplexIsNRoot[A] extends AnyRef with spire.algebra.NRoot[spire.math.Complex[A]]" id="spire.math;ComplexIsNRoot">ComplexIsNRoot</a><span class="delimiter">[</span><a title="" id="spire.math;ComplexIsNRoot;A">A</a><span class="delimiter">]</span> extends <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[spire.math.Complex[A]]">NRoot</a><span class="delimiter">[</span>Complex<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  implicit def <a title="=&gt; spire.algebra.Field[A]" id="spire.math;ComplexIsNRoot.algebra">algebra</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.NRoot[A]" id="spire.math;ComplexIsNRoot.nroot(d25f92e17c)">nroot</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[A]">NRoot</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.Trig[A]" id="spire.math;ComplexIsNRoot.trig">trig</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[A]">Trig</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.IsReal[A]" id="spire.math;ComplexIsNRoot.order">order</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[A]">IsReal</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  def <a title="(a: spire.math.Complex[A], k: Int)spire.math.Complex[A]" id="spire.math;ComplexIsNRoot.nroot(c730cd0edc)">nroot</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsNRoot.nroot(c730cd0edc).a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Int" id="spire.math;ComplexIsNRoot.nroot(c730cd0edc).k">k</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsNRoot.nroot(c730cd0edc).a" title="spire.math.Complex[A]">a</a>.<a href="#spire.math;Complex.nroot" title="(k: Int)(implicit f: spire.algebra.Field[A], implicit n: spire.algebra.NRoot[A], implicit t: spire.algebra.Trig[A], implicit o: spire.algebra.IsReal[A])spire.math.Complex[A]">nroot</a><a href="#spire.math;ComplexIsNRoot.algebra" title="=&gt; spire.algebra.Field[A]" class="delimiter">(</a><a href="#spire.math;ComplexIsNRoot.nroot(c730cd0edc).k" title="Int">k</a><span class="delimiter">)</span>
  override def <a title="(a: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsNRoot.sqrt">sqrt</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsNRoot.sqrt.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsNRoot.sqrt.a" title="spire.math.Complex[A]">a</a>.<a href="#spire.math;Complex.sqrt" title="(implicit f: spire.algebra.Field[A], implicit n0: spire.algebra.NRoot[A], implicit o: spire.algebra.IsReal[A])spire.math.Complex[A]">sqrt</a>
  def <a title="(a: spire.math.Complex[A], b: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsNRoot.fpow">fpow</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsNRoot.fpow.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Complex[A]" id="spire.math;ComplexIsNRoot.fpow.b">b</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexIsNRoot.fpow.a" title="spire.math.Complex[A]">a</a>.<a href="#spire.math;Complex.pow(9622b5e32c)" title="(b: spire.math.Complex[A])(implicit f: spire.algebra.Field[A], implicit n: spire.algebra.NRoot[A], implicit t: spire.algebra.Trig[A], implicit o: spire.algebra.IsReal[A])spire.math.Complex[A]">pow</a><a href="#spire.math;ComplexIsNRoot.algebra" title="=&gt; spire.algebra.Field[A]" class="delimiter">(</a><a href="#spire.math;ComplexIsNRoot.fpow.b" title="spire.math.Complex[A]">b</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

private<span class="delimiter">[</span>math<span class="delimiter">]</span> trait <a title="trait ComplexIsSigned[A] extends AnyRef with spire.algebra.Signed[spire.math.Complex[A]]" id="spire.math;ComplexIsSigned">ComplexIsSigned</a><span class="delimiter">[</span><a title="" id="spire.math;ComplexIsSigned;A">A</a><span class="delimiter">]</span> extends <a href="../algebra/Signed.scala.html#spire.algebra;Signed" title="spire.algebra.Signed[spire.math.Complex[A]]">Signed</a><span class="delimiter">[</span>Complex<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  implicit def <a title="=&gt; spire.algebra.Field[A]" id="spire.math;ComplexIsSigned.algebra">algebra</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.NRoot[A]" id="spire.math;ComplexIsSigned.nroot">nroot</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[A]">NRoot</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.IsReal[A]" id="spire.math;ComplexIsSigned.order">order</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[A]">IsReal</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  def <a title="(a: spire.math.Complex[A])Int" id="spire.math;ComplexIsSigned.signum">signum</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsSigned.signum.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.math;ComplexIsSigned.signum.a" title="spire.math.Complex[A]">a</a>.<a href="#spire.math;Complex.signum" title="(implicit o: spire.algebra.IsReal[A])Int">signum</a>
  def <a title="(a: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexIsSigned.abs">abs</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexIsSigned.abs.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;Complex.canEqual" title="[T](real: T, imag: T)spire.math.Complex[T]">Complex</a><span title="(real: A, imag: A)spire.math.Complex[A]" class="delimiter">[</span><a href="#spire.math;ComplexIsSigned;A" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.math;ComplexIsSigned.abs.a" title="spire.math.Complex[A]">a</a>.<a href="#spire.math;Complex.abs" title="(implicit f: spire.algebra.Field[A], implicit o: spire.algebra.IsReal[A], implicit n: spire.algebra.NRoot[A])A">abs</a>, <a href="#spire.math;ComplexIsSigned.algebra" title="=&gt; spire.algebra.Field[A]">algebra</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">1L</span><span class="delimiter">)</span>
private<span class="delimiter">[</span>math<span class="delimiter">]</span> class <a title="class ComplexEq[A] extends AnyRef with spire.algebra.Eq[spire.math.Complex[A]] with Serializable" id="spire.math;ComplexEq">ComplexEq</a><span class="delimiter">[</span><a title="" id="spire.math;ComplexEq;A">A</a>: Eq<span class="delimiter">]</span> extends <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[spire.math.Complex[A]]">Eq</a><span class="delimiter">[</span>Complex<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="(x: spire.math.Complex[A], y: spire.math.Complex[A])Boolean" id="spire.math;ComplexEq.eqv">eqv</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexEq.eqv.x">x</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Complex[A]" id="spire.math;ComplexEq.eqv.y">y</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math;ComplexEq.eqv.x" title="spire.math.Complex[A]">x</a> <a href="#spire.math;Complex.eqv" title="(b: spire.math.Complex[A])(implicit o: spire.algebra.Eq[A])Boolean">eqv</a> <a href="#spire.math;ComplexEq.eqv.y" title="spire.math.Complex[A]">y</a>
  override def <a title="(x: spire.math.Complex[A], y: spire.math.Complex[A])Boolean" id="spire.math;ComplexEq.neqv">neqv</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexEq.neqv.x">x</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Complex[A]" id="spire.math;ComplexEq.neqv.y">y</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math;ComplexEq.neqv.x" title="spire.math.Complex[A]">x</a> <a href="#spire.math;Complex.neqv" title="(b: spire.math.Complex[A])(implicit o: spire.algebra.Eq[A])Boolean">neqv</a> <a href="#spire.math;ComplexEq.neqv.y" title="spire.math.Complex[A]">y</a>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">1L</span><span class="delimiter">)</span>
private<span class="delimiter">[</span>math<span class="delimiter">]</span> final class <a title="class ComplexIsRingImpl[A] extends AnyRef with spire.math.ComplexIsRing[A] with Serializable" id="spire.math;ComplexIsRingImpl">ComplexIsRingImpl</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float,Double<span class="delimiter">)</span> <a title="" id="spire.math;ComplexIsRingImpl;A">A</a><span class="delimiter">]</span><a href="#spire.math;ComplexIsRingImpl" title="spire.math.ComplexIsRingImpl[A]" class="delimiter">(</a>implicit
    val <a title="spire.algebra.Ring[A]" id="spire.math;ComplexIsRingImpl.algebra">algebra</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, val <a title="spire.algebra.IsReal[A]" id="spire.math;ComplexIsRingImpl.order">order</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[A]">IsReal</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#spire.math;ComplexIsRing" title="spire.math.ComplexIsRing[A]">ComplexIsRing</a><span class="delimiter">[</span>A<span class="delimiter">]</span> with <span title="Serializable">Serializable</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">1L</span><span class="delimiter">)</span>
private<span class="delimiter">[</span>math<span class="delimiter">]</span> final class <a title="class ComplexIsFieldImpl[A] extends AnyRef with spire.math.ComplexIsField[A] with Serializable" id="spire.math;ComplexIsFieldImpl">ComplexIsFieldImpl</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float,Double<span class="delimiter">)</span> <a title="" id="spire.math;ComplexIsFieldImpl;A">A</a><span class="delimiter">]</span><a href="#spire.math;ComplexIsFieldImpl" title="spire.math.ComplexIsFieldImpl[A]" class="delimiter">(</a>implicit
    val <a title="spire.algebra.Field[A]" id="spire.math;ComplexIsFieldImpl.algebra">algebra</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, val <a title="spire.algebra.IsReal[A]" id="spire.math;ComplexIsFieldImpl.order">order</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[A]">IsReal</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#spire.math;ComplexIsField" title="spire.math.ComplexIsField[A]">ComplexIsField</a><span class="delimiter">[</span>A<span class="delimiter">]</span> with <span title="Serializable">Serializable</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">1L</span><span class="delimiter">)</span>
private<span class="delimiter">[</span>math<span class="delimiter">]</span> class <a title="class ComplexAlgebra[A] extends AnyRef with spire.math.ComplexIsField[A] with spire.math.ComplexIsTrig[A] with spire.math.ComplexIsNRoot[A] with spire.math.ComplexIsSigned[A] with spire.algebra.InnerProductSpace[spire.math.Complex[A],A] with spire.algebra.FieldAlgebra[spire.math.Complex[A],A] with Serializable" id="spire.math;ComplexAlgebra">ComplexAlgebra</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math;ComplexAlgebra;A">A</a><span class="delimiter">]</span><a href="#spire.math;ComplexAlgebra" title="spire.math.ComplexAlgebra[A]" class="delimiter">(</a>implicit
      val <a title="spire.algebra.Field[A]" id="spire.math;ComplexAlgebra.algebra">algebra</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, val <a title="spire.algebra.NRoot[A]" id="spire.math;ComplexAlgebra.nroot">nroot</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[A]">NRoot</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, val <a title="spire.algebra.Trig[A]" id="spire.math;ComplexAlgebra.trig">trig</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[A]">Trig</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, val <a title="spire.algebra.IsReal[A]" id="spire.math;ComplexAlgebra.order">order</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[A]">IsReal</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>
    extends <a href="#spire.math;ComplexIsField" title="spire.math.ComplexIsField[A]">ComplexIsField</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
    with <a href="#spire.math;ComplexIsTrig" title="spire.math.ComplexIsTrig[A]">ComplexIsTrig</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
    with <a href="#spire.math;ComplexIsNRoot" title="spire.math.ComplexIsNRoot[A]">ComplexIsNRoot</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
    with <a href="#spire.math;ComplexIsSigned" title="spire.math.ComplexIsSigned[A]">ComplexIsSigned</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
    with <a href="../algebra/InnerProductSpace.scala.html#spire.algebra;InnerProductSpace" title="spire.algebra.InnerProductSpace[spire.math.Complex[A],A]">InnerProductSpace</a><span class="delimiter">[</span>Complex<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span>
    with <a href="../algebra/RingAlgebra.scala.html#spire.algebra;FieldAlgebra" title="spire.algebra.FieldAlgebra[spire.math.Complex[A],A]">FieldAlgebra</a><span class="delimiter">[</span>Complex<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span>
    with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="=&gt; spire.algebra.Field[A]" id="spire.math;ComplexAlgebra.scalar">scalar</a> = <a href="#spire.math;ComplexAlgebra.algebra" title="=&gt; spire.algebra.Field[A]">algebra</a>
  def <a title="(a: A, v: spire.math.Complex[A])spire.math.Complex[A]" id="spire.math;ComplexAlgebra.timesl">timesl</a><span class="delimiter">(</span><a title="A" id="spire.math;ComplexAlgebra.timesl.a">a</a>: <a href="#spire.math;ComplexAlgebra;A" title="A">A</a>, <a title="spire.math.Complex[A]" id="spire.math;ComplexAlgebra.timesl.v">v</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;Complex.canEqual" title="(real: A, imag: A)spire.math.Complex[A]">Complex</a><span class="delimiter">(</span><a href="#spire.math;ComplexAlgebra.timesl.a" title="A">a</a>, <a href="#spire.math;ComplexAlgebra.scalar" title="=&gt; spire.algebra.Field[A]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span> <a href="#spire.math;Complex.*(e1c0640f17)" title="(b: spire.math.Complex[A])(implicit r: spire.algebra.Rng[A])spire.math.Complex[A]">*</a> <a href="#spire.math;ComplexAlgebra.timesl.v" title="spire.math.Complex[A]">v</a>
  def <a title="(x: spire.math.Complex[A], y: spire.math.Complex[A])A" id="spire.math;ComplexAlgebra.dot">dot</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexAlgebra.dot.x">x</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.Complex[A]" id="spire.math;ComplexAlgebra.dot.y">y</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;ComplexAlgebra;A" title="A">A</a> =
    <a href="#spire.math;ComplexAlgebra.scalar" title="=&gt; spire.algebra.Field[A]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">plus</a><span class="delimiter">(</span><a href="#spire.math;ComplexAlgebra.scalar" title="=&gt; spire.algebra.Field[A]">scalar</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">times</a><span class="delimiter">(</span><a href="#spire.math;ComplexAlgebra.dot.x" title="spire.math.Complex[A]">x</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; A">real</a>, <a href="#spire.math;ComplexAlgebra.dot.y" title="spire.math.Complex[A]">y</a>.<a href="#spire.math;Complex.copy$default$1" title="=&gt; A">real</a><span class="delimiter">)</span>, <a href="#spire.math;ComplexAlgebra.scalar" title="=&gt; spire.algebra.Field[A]">scalar</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">times</a><span class="delimiter">(</span><a href="#spire.math;ComplexAlgebra.dot.x" title="spire.math.Complex[A]">x</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; A">imag</a>, <a href="#spire.math;ComplexAlgebra.dot.y" title="spire.math.Complex[A]">y</a>.<a href="#spire.math;Complex.copy$default$2" title="=&gt; A">imag</a><span class="delimiter">)</span><span class="delimiter">)</span>
  override def <a title="(a: spire.math.Complex[A], b: Int)spire.math.Complex[A]" id="spire.math;ComplexAlgebra.pow">pow</a><span class="delimiter">(</span><a title="spire.math.Complex[A]" id="spire.math;ComplexAlgebra.pow.a">a</a>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Int" id="spire.math;ComplexAlgebra.pow.b">b</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.math;Complex.canEqual" title="spire.math.Complex[A]">Complex</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.math;ComplexAlgebra.pow.a" title="spire.math.Complex[A]">a</a>.<a href="#spire.math;Complex.pow(bbcd1ea568)" title="(b: Int)(implicit f: spire.algebra.Field[A], implicit n: spire.algebra.NRoot[A], implicit t: spire.algebra.Trig[A], implicit o: spire.algebra.IsReal[A])spire.math.Complex[A]">pow</a><a href="#spire.math;ComplexAlgebra.algebra" title="=&gt; spire.algebra.Field[A]" class="delimiter">(</a><a href="#spire.math;ComplexAlgebra.pow.b" title="Int">b</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
