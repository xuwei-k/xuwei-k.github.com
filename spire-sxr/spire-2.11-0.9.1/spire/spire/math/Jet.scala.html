<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>spire/spire/math/Jet.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package spire.math

import scala.annotation.tailrec
import scala.math._
import scala.reflect._
import scala.<span class="delimiter">{</span>specialized =&gt; sp<span class="delimiter">}</span>

import spire.algebra._
import spire.std.ArraySupport
import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.isReal" title="spire.syntax.isReal.type">isReal</a>._
import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.nroot" title="spire.syntax.nroot.type">nroot</a>._
import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.vectorSpace" title="spire.syntax.vectorSpace.type">vectorSpace</a>._

<span class="comment">/**
 * Used to implicitly define the dimensionality of the Jet space.
 * @param dimension the number of dimensions.
 */</span>
case class <a title="class JetDim extends AnyRef with Product with Serializable" id="spire.math.JetDim.readResolve">JetDim</a><a href="#spire.math.JetDim.readResolve" title="Product" class="delimiter">(</a><a title="Int" id="spire.math;JetDim.dimension">dimension</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span title="(requirement: Boolean)Unit">require</span><span class="delimiter">(</span><a href="#spire.math;JetDim.dimension" title="=&gt; Int">dimension</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * ==Overview==
 * A simple implementation of N-dimensional dual numbers, for automatically
 * computing exact derivatives of functions. This code (and documentation) closely follow
 * the one in Google's &quot;Ceres&quot; library of non-linear least-squares solvers
 * (see &lt;a href=&quot;http://code.google.com/p/ceres-solver&quot;&gt;Sameer Agarwal, Keir Mierle, and others: Ceres Solver.&lt;/a&gt;)
 *
 * While a complete treatment of the mechanics of automatic differentiation is
 * beyond the scope of this header (see
 * http://en.wikipedia.org/wiki/Automatic_differentiation for details), the
 * basic idea is to extend normal arithmetic with an extra element &quot;h&quot; such
 * that h != 0, but h^2^ = 0.
 * Dual numbers are extensions of the real numbers analogous to complex numbers:
 * whereas complex numbers augment the reals by introducing an imaginary unit i
 * such that i^2^ = -1, dual numbers introduce an &quot;infinitesimal&quot; unit h such
 * that h^2^ = 0.
 * Analogously to a complex number c = x + y*i, a dual number d = x * y*h has
 * two components: the &quot;real&quot; component x, and an &quot;infinitesimal&quot; component y.
 * Surprisingly, this leads to a convenient method for computing exact
 * derivatives without needing to manipulate complicated symbolic expressions.

 * For example, consider the function
 * {{{
 *   f(x) = x * x ,
 * }}}
 * evaluated at 10. Using normal arithmetic, f(10) = 100, and df/dx(10) = 20.
 * Next, augment 10 with an infinitesimal h to get:
 * {{{
 *   f(10 + h) = (10 + h) * (10 + h)
 *             = 100 + 2 * 10 * h + h * h
 *             = 100 + 20 * h       +---
 *                     +-----       |
 *                     |            +--- This is zero
 *                     |
 *                     +----------------- This is df/dx
 * }}}
 * Note that the derivative of f with respect to x is simply the infinitesimal
 * component of the value of f(x + h). So, in order to take the derivative of
 * any function, it is only necessary to replace the numeric &quot;object&quot; used in
 * the function with one extended with infinitesimals. The class Jet, defined in
 * this header, is one such example of this, where substitution is done with
 * generics.
 *
 * To handle derivatives of functions taking multiple arguments, different
 * infinitesimals are used, one for each variable to take the derivative of. For
 * example, consider a scalar function of two scalar parameters x and y:
 * {{{
 *   f(x, y) = x * x + x * y
 * }}}
 * Following the technique above, to compute the derivatives df/dx and df/dy for
 * f(1, 3) involves doing two evaluations of f, the first time replacing x with
 * x + h, the second time replacing y with y + h.
 *
 * For df/dx:
 * {{{
 *   f(1 + h, y) = (1 + h) * (1 + h) + (1 + h) * 3
 *               = 1 + 2 * h + 3 + 3 * h
 *               = 4 + 5 * h
 *
 *   Therefore df/dx = 5
 * }}}
 * For df/dy:
 * {{{
 *   f(1, 3 + h) = 1 * 1 + 1 * (3 + h)
 *               = 1 + 3 + h
 *               = 4 + h
 *
 *   Therefore df/dy = 1
 * }}}
 * To take the gradient of f with the implementation of dual numbers (&quot;jets&quot;) in
 * this file, it is necessary to create a single jet type which has components
 * for the derivative in x and y, and pass them to a routine computing function f.
 * It is convenient to use a generic version of f, that can be called also with non-jet numbers
 * for standard evaluation:
 * {{{
 *   def f[@specialized(Double) T : Field](x: T, y: T): T = x * x + x * y
 *
 *   val xValue = 9.47892774
 *   val yValue = 0.287740

 *   // The &quot;2&quot; means there should be 2 dual number components.
 *   implicit val dimension = JetDim(2)
 *   val x: Jet[Double] = xValue + Jet.h[Double](0);  // Pick the 0th dual number for x.
 *   val y: Jet[Double] = yValue + Jet.h[Double](1);  // Pick the 1th dual number for y.
 *
 *   val z: Jet[Double] = f(x, y);
 *   println(&quot;df/dx = &quot; + z.infinitesimal(0) + &quot;, df/dy = &quot; + z.infinitesimal(1));
 * }}}
 *
 * For the more mathematically inclined, this file implements first-order
 * &quot;jets&quot;. A 1st order jet is an element of the ring
 *{{{
 *   T[N] = T[t_1, ..., t_N] / (t_1, ..., t_N)^2
 *}}}
 * which essentially means that each jet consists of a &quot;scalar&quot; value 'a' from T
 * and a 1st order perturbation vector 'v' of length N:
 *{{{
 *   x = a + \sum_i v[i] t_i
 *}}}
 * A shorthand is to write an element as x = a + u, where u is the perturbation.
 * Then, the main point about the arithmetic of jets is that the product of
 * perturbations is zero:
 * {{{
 *   (a + u) * (b + v) = ab + av + bu + uv
 *                     = ab + (av + bu) + 0
 * }}}
 * which is what operator* implements below. Addition is simpler:
 * {{{
 *   (a + u) + (b + v) = (a + b) + (u + v).
 * }}}
 * The only remaining question is how to evaluate the function of a jet, for
 * which we use the chain rule:
 * {{{
 *   f(a + u) = f(a) + f'(a) u
 * }}}
 * where f'(a) is the (scalar) derivative of f at a.
 *
 * By pushing these things through generics, we can write routines that at same time
 * evaluate mathematical functions and compute their derivatives through automatic differentiation.
 */</span>
object <a title="spire.math.Jet.type" id="spire.math.Jet.readResolve">Jet</a> extends <a href="#spire.math;JetInstances" title="spire.math.JetInstances">JetInstances</a> <span class="delimiter">{</span>
  <span class="comment">// No-arg c.tor makes a zero Jet</span>
  def <a title="[T]()(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit s: spire.algebra.Semiring[T])spire.math.Jet[T]" id="spire.math.Jet.apply(1ef6183108)">apply</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math.Jet.apply(1ef6183108);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[T]" id="spire.math.Jet.apply(1ef6183108).c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.JetDim" id="spire.math.Jet.apply(1ef6183108).d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a>, <a title="spire.algebra.Semiring[T]" id="spire.math.Jet.apply(1ef6183108).s">s</a>: <a href="../algebra/Semiring.scala.html#spire.algebra;Semiring" title="spire.algebra.Semiring[T]">Semiring</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>
      : <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math.Jet.apply(fce0152b15)" title="(real: T)(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit s: spire.algebra.Semiring[T])spire.math.Jet[T]">Jet</a><a href="#spire.math.Jet.apply(1ef6183108).c" title="scala.reflect.ClassTag[T]" class="delimiter">(</a><a href="#spire.math.Jet.apply(1ef6183108).s" title="spire.algebra.Semiring[T]">s</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span>

  <span class="comment">// From real.</span>
  def <a title="[T](real: T)(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit s: spire.algebra.Semiring[T])spire.math.Jet[T]" id="spire.math.Jet.apply(fce0152b15)">apply</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math.Jet.apply(fce0152b15);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="spire.math.Jet.apply(fce0152b15).real">real</a>: <a href="#spire.math.Jet.apply(fce0152b15);T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[T]" id="spire.math.Jet.apply(fce0152b15).c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.JetDim" id="spire.math.Jet.apply(fce0152b15).d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a>, <a title="spire.algebra.Semiring[T]" id="spire.math.Jet.apply(fce0152b15).s">s</a>: <a href="../algebra/Semiring.scala.html#spire.algebra;Semiring" title="spire.algebra.Semiring[T]">Semiring</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>
      : <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math.Jet.apply(fce0152b15).real" title="T">real</a>, <span title="Array.type">Array</span>.<span title="[T](n: Int)(elem: =&gt; T)(implicit evidence$9: scala.reflect.ClassTag[T])Array[T]">fill</span><span title="(n: Int)(elem: =&gt; T)(implicit evidence$9: scala.reflect.ClassTag[T])Array[T]" class="delimiter">[</span><a href="#spire.math.Jet.apply(fce0152b15);T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.math.Jet.apply(fce0152b15).d" title="spire.math.JetDim">d</a>.<a href="#spire.math;JetDim.dimension" title="=&gt; Int">dimension</a><span class="delimiter">)</span><a href="#spire.math.Jet.apply(fce0152b15).c" title="scala.reflect.ClassTag[T]" class="delimiter">(</a><a href="#spire.math.Jet.apply(fce0152b15).s" title="spire.algebra.Semiring[T]">s</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">// From real, to compute k-th partial derivative.</span>
  def <a title="[T](a: T, k: Int)(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit r: spire.algebra.Rig[T])spire.math.Jet[T]" id="spire.math.Jet.apply(6f4ebbf315)">apply</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math.Jet.apply(6f4ebbf315);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="spire.math.Jet.apply(6f4ebbf315).a">a</a>: <a href="#spire.math.Jet.apply(6f4ebbf315);T" title="T">T</a>, <a title="Int" id="spire.math.Jet.apply(6f4ebbf315).k">k</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[T]" id="spire.math.Jet.apply(6f4ebbf315).c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.JetDim" id="spire.math.Jet.apply(6f4ebbf315).d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a>, <a title="spire.algebra.Rig[T]" id="spire.math.Jet.apply(6f4ebbf315).r">r</a>: <a href="../algebra/Rig.scala.html#spire.algebra;Rig" title="spire.algebra.Rig[T]">Rig</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>
      : <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[T]" id="spire.math.Jet.apply(6f4ebbf315).v">v</a> = <span title="Array.type">Array</span>.<span title="[T](n: Int)(elem: =&gt; T)(implicit evidence$9: scala.reflect.ClassTag[T])Array[T]">fill</span><span title="(n: Int)(elem: =&gt; T)(implicit evidence$9: scala.reflect.ClassTag[T])Array[T]" class="delimiter">[</span><a href="#spire.math.Jet.apply(6f4ebbf315);T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.math.Jet.apply(6f4ebbf315).d" title="spire.math.JetDim">d</a>.<a href="#spire.math;JetDim.dimension" title="=&gt; Int">dimension</a><span class="delimiter">)</span><a href="#spire.math.Jet.apply(6f4ebbf315).c" title="scala.reflect.ClassTag[T]" class="delimiter">(</a><a href="#spire.math.Jet.apply(6f4ebbf315).r" title="spire.algebra.Rig[T]">r</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span>
    <a href="#spire.math.Jet.apply(6f4ebbf315).v" title="(i: Int, x: T)Unit">v</a><span class="delimiter">(</span><a href="#spire.math.Jet.apply(6f4ebbf315).k" title="Int">k</a><span class="delimiter">)</span> = <a href="#spire.math.Jet.apply(6f4ebbf315).r" title="spire.algebra.Rig[T]">r</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; T">one</a>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math.Jet.apply(6f4ebbf315).a" title="T">a</a>, <a href="#spire.math.Jet.apply(6f4ebbf315).v" title="Array[T]">v</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// Zero real, indicator for k-th partial derivative.</span>
  def <a title="[T](k: Int)(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit r: spire.algebra.Rig[T])spire.math.Jet[T]" id="spire.math.Jet.h">h</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math.Jet.h;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="spire.math.Jet.h.k">k</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[T]" id="spire.math.Jet.h.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.JetDim" id="spire.math.Jet.h.d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a>, <a title="spire.algebra.Rig[T]" id="spire.math.Jet.h.r">r</a>: <a href="../algebra/Rig.scala.html#spire.algebra;Rig" title="spire.algebra.Rig[T]">Rig</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
      <a href="#spire.math.Jet.apply(6f4ebbf315)" title="(a: T, k: Int)(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit r: spire.algebra.Rig[T])spire.math.Jet[T]">Jet</a><a href="#spire.math.Jet.h.c" title="scala.reflect.ClassTag[T]" class="delimiter">(</a><a href="#spire.math.Jet.h.r" title="spire.algebra.Rig[T]">r</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a>, <a href="#spire.math.Jet.h.k" title="Int">k</a><span class="delimiter">)</span>

  def <a title="[T](implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit r: spire.algebra.Rig[T])spire.math.Jet[T]" id="spire.math.Jet.one">one</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math.Jet.one;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[T]" id="spire.math.Jet.one.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.JetDim" id="spire.math.Jet.one.d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a>, <a title="spire.algebra.Rig[T]" id="spire.math.Jet.one.r">r</a>: <a href="../algebra/Rig.scala.html#spire.algebra;Rig" title="spire.algebra.Rig[T]">Rig</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math.Jet.apply(fce0152b15)" title="(real: T)(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit s: spire.algebra.Semiring[T])spire.math.Jet[T]">Jet</a><a href="#spire.math.Jet.one.c" title="scala.reflect.ClassTag[T]" class="delimiter">(</a><a href="#spire.math.Jet.one.r" title="spire.algebra.Rig[T]">r</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; T">one</a><span class="delimiter">)</span>

  def <a title="[T](implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit s: spire.algebra.Semiring[T])spire.math.Jet[T]" id="spire.math.Jet.zero">zero</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math.Jet.zero;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[T]" id="spire.math.Jet.zero.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.JetDim" id="spire.math.Jet.zero.d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a>, <a title="spire.algebra.Semiring[T]" id="spire.math.Jet.zero.s">s</a>: <a href="../algebra/Semiring.scala.html#spire.algebra;Semiring" title="spire.algebra.Semiring[T]">Semiring</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math.Jet.apply(fce0152b15)" title="(real: T)(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit s: spire.algebra.Semiring[T])spire.math.Jet[T]">Jet</a><a href="#spire.math.Jet.zero.c" title="scala.reflect.ClassTag[T]" class="delimiter">(</a><a href="#spire.math.Jet.zero.s" title="spire.algebra.Semiring[T]">s</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span>

  def <a title="[T](n: Int)(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit r: spire.algebra.Ring[T])spire.math.Jet[T]" id="spire.math.Jet.fromInt">fromInt</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math.Jet.fromInt;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="spire.math.Jet.fromInt.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[T]" id="spire.math.Jet.fromInt.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.JetDim" id="spire.math.Jet.fromInt.d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a>, <a title="spire.algebra.Ring[T]" id="spire.math.Jet.fromInt.r">r</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[T]">Ring</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#spire.math.Jet.apply(fce0152b15)" title="(real: T)(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit s: spire.algebra.Semiring[T])spire.math.Jet[T]">Jet</a><a href="#spire.math.Jet.fromInt.c" title="scala.reflect.ClassTag[T]" class="delimiter">(</a><a href="#spire.math.Jet.fromInt.r" title="spire.algebra.Ring[T]">r</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)T">fromInt</a><span class="delimiter">(</span><a href="#spire.math.Jet.fromInt.n" title="Int">n</a><span class="delimiter">)</span><span class="delimiter">)</span>

  implicit def <a title="implicit spire.math.Jet.intToJet : (n: Int)(implicit d: spire.math.JetDim)spire.math.Jet[Double]" id="spire.math.Jet.intToJet">intToJet</a><span class="delimiter">(</span><a title="Int" id="spire.math.Jet.intToJet.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.JetDim" id="spire.math.Jet.intToJet.d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[Double]">Jet</a><span class="delimiter">[</span>Double<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#spire.math.Jet.doubleToJet" title="implicit spire.math.Jet.doubleToJet : (n: Double)(implicit d: spire.math.JetDim)spire.math.Jet[Double]">doubleToJet</a><a href="#spire.math.Jet.intToJet.d" title="spire.math.JetDim" class="delimiter">(</a><a href="#spire.math.Jet.intToJet.n" title="Int">n</a>.<span title="=&gt; Double">toDouble</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  implicit def <a title="implicit spire.math.Jet.longToJet : (n: Long)(implicit d: spire.math.JetDim)spire.math.Jet[Double]" id="spire.math.Jet.longToJet">longToJet</a><span class="delimiter">(</span><a title="Long" id="spire.math.Jet.longToJet.n">n</a>: <span title="Long">Long</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.JetDim" id="spire.math.Jet.longToJet.d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[Double]">Jet</a><span class="delimiter">[</span>Double<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#spire.math.Jet.doubleToJet" title="implicit spire.math.Jet.doubleToJet : (n: Double)(implicit d: spire.math.JetDim)spire.math.Jet[Double]">doubleToJet</a><a href="#spire.math.Jet.longToJet.d" title="spire.math.JetDim" class="delimiter">(</a><a href="#spire.math.Jet.longToJet.n" title="Long">n</a>.<span title="=&gt; Double">toDouble</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  implicit def <a title="implicit spire.math.Jet.floatToJet : (n: Float)(implicit d: spire.math.JetDim)spire.math.Jet[Float]" id="spire.math.Jet.floatToJet">floatToJet</a><span class="delimiter">(</span><a title="Float" id="spire.math.Jet.floatToJet.n">n</a>: <span title="Float">Float</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.JetDim" id="spire.math.Jet.floatToJet.d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[Float]">Jet</a><span class="delimiter">[</span>Float<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[Float]">Jet</a><span class="delimiter">(</span><a href="#spire.math.Jet.floatToJet.n" title="Float">n</a>.<span title="=&gt; Float">toFloat</span>, <span title="Array.type">Array</span>.<span title="[T](n: Int)(elem: =&gt; T)(implicit evidence$9: scala.reflect.ClassTag[T])Array[T]">fill</span><span title="(n: Int)(elem: =&gt; Float)(implicit evidence$9: scala.reflect.ClassTag[Float])Array[Float]" class="delimiter">[</span><span title="Float">Float</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.math.Jet.floatToJet.d" title="spire.math.JetDim">d</a>.<a href="#spire.math;JetDim.dimension" title="=&gt; Int">dimension</a><span class="delimiter">)</span><span title="=&gt; scala.reflect.ClassTag[Float]" class="delimiter">(</span><span title="Float(0.0)" class="float">0.0f</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  implicit def <a title="implicit spire.math.Jet.doubleToJet : (n: Double)(implicit d: spire.math.JetDim)spire.math.Jet[Double]" id="spire.math.Jet.doubleToJet">doubleToJet</a><span class="delimiter">(</span><a title="Double" id="spire.math.Jet.doubleToJet.n">n</a>: <span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.JetDim" id="spire.math.Jet.doubleToJet.d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[Double]">Jet</a><span class="delimiter">[</span>Double<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[Double]">Jet</a><span class="delimiter">(</span><a href="#spire.math.Jet.doubleToJet.n" title="Double">n</a>, <span title="Array.type">Array</span>.<span title="[T](n: Int)(elem: =&gt; T)(implicit evidence$9: scala.reflect.ClassTag[T])Array[T]">fill</span><span title="(n: Int)(elem: =&gt; Double)(implicit evidence$9: scala.reflect.ClassTag[Double])Array[Double]" class="delimiter">[</span><span title="Double">Double</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.math.Jet.doubleToJet.d" title="spire.math.JetDim">d</a>.<a href="#spire.math;JetDim.dimension" title="=&gt; Int">dimension</a><span class="delimiter">)</span><span title="=&gt; scala.reflect.ClassTag[Double]" class="delimiter">(</span><span title="Double(0.0)" class="double">0.0</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  implicit def <a title="implicit spire.math.Jet.bigIntToJet : (n: scala.math.BigInt)(implicit d: spire.math.JetDim)spire.math.Jet[scala.math.BigDecimal]" id="spire.math.Jet.bigIntToJet">bigIntToJet</a><span class="delimiter">(</span><a title="scala.math.BigInt" id="spire.math.Jet.bigIntToJet.n">n</a>: <span title="scala.math.BigInt">BigInt</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.JetDim" id="spire.math.Jet.bigIntToJet.d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[scala.math.BigDecimal]">Jet</a><span class="delimiter">[</span>BigDecimal<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#spire.math.Jet.bigDecimalToJet" title="implicit spire.math.Jet.bigDecimalToJet : (n: scala.math.BigDecimal)(implicit d: spire.math.JetDim)spire.math.Jet[scala.math.BigDecimal]">bigDecimalToJet</a><a href="#spire.math.Jet.bigIntToJet.d" title="spire.math.JetDim" class="delimiter">(</a><span title="(x: scala.math.BigInt)scala.math.BigDecimal">BigDecimal</span><span class="delimiter">(</span><a href="#spire.math.Jet.bigIntToJet.n" title="scala.math.BigInt">n</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  implicit def <a title="implicit spire.math.Jet.bigDecimalToJet : (n: scala.math.BigDecimal)(implicit d: spire.math.JetDim)spire.math.Jet[scala.math.BigDecimal]" id="spire.math.Jet.bigDecimalToJet">bigDecimalToJet</a><span class="delimiter">(</span><a title="scala.math.BigDecimal" id="spire.math.Jet.bigDecimalToJet.n">n</a>: <span title="scala.math.BigDecimal">BigDecimal</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.JetDim" id="spire.math.Jet.bigDecimalToJet.d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[scala.math.BigDecimal]">Jet</a><span class="delimiter">[</span>BigDecimal<span class="delimiter">]</span> = <span class="delimiter">{</span>
    implicit val <a title="java.math.MathContext" id="spire.math.Jet.bigDecimalToJet.mc">mc</a> = <a href="#spire.math.Jet.bigDecimalToJet.n" title="scala.math.BigDecimal">n</a>.<span title="=&gt; java.math.MathContext">mc</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[scala.math.BigDecimal]">Jet</a><span class="delimiter">(</span><a href="#spire.math.Jet.bigDecimalToJet.n" title="scala.math.BigDecimal">n</a>, <span title="Array.type">Array</span>.<span title="[T](n: Int)(elem: =&gt; T)(implicit evidence$9: scala.reflect.ClassTag[T])Array[T]">fill</span><span title="(n: Int)(elem: =&gt; scala.math.BigDecimal)(implicit evidence$9: scala.reflect.ClassTag[scala.math.BigDecimal])Array[scala.math.BigDecimal]" class="delimiter">[</span><span title="scala.math.BigDecimal">BigDecimal</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.math.Jet.bigDecimalToJet.d" title="spire.math.JetDim">d</a>.<a href="#spire.math;JetDim.dimension" title="=&gt; Int">dimension</a><span class="delimiter">)</span><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[scala.math.BigDecimal]" class="delimiter">(</span><span title="implicit scala.math.BigDecimal.double2bigDecimal : (d: Double)scala.math.BigDecimal" class="double">0.0</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
final case class <a href="#spire.math;Jet.copy$default$1" title="[T](real: T, infinitesimal: Array[T])spire.math.Jet[T]" id="spire.math;Jet.canEqual">Jet</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math;Jet.copy$default$2;T">T</a><span class="delimiter">]</span><span title="Product" class="delimiter">(</span><a title="T" id="spire.math;Jet.copy$default$1">real</a>: <a href="#spire.math;Jet.copy$default$2;T" title="T">T</a>, <a title="Array[T]" id="spire.math;Jet.copy$default$2">infinitesimal</a>: <span title="Array[T]">Array</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>
  extends <a href="#spire.math;Jet.canEqual" title="scala.math.ScalaNumber">ScalaNumber</a> with <span title="scala.math.ScalaNumericConversions">ScalaNumericConversions</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span> lhs =&gt;

  import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.order" title="spire.syntax.order.type">order</a>._

  def <a title="=&gt; Int" id="spire.math;Jet.dimension">dimension</a>: <span title="Int">Int</span> = <a href="#spire.math;Jet.copy$default$2" title="(xs: Array[T])scala.collection.mutable.ArrayOps[T]">infinitesimal</a>.<span title="=&gt; Int">size</span>
  implicit def <a title="=&gt; spire.math.JetDim" id="spire.math;Jet.jetDimension">jetDimension</a> = <a href="#spire.math.JetDim.readResolve" title="(dimension: Int)spire.math.JetDim">JetDim</a><span class="delimiter">(</span><a href="#spire.math;Jet.dimension" title="=&gt; Int">dimension</a><span class="delimiter">)</span>

  <span class="comment">/**
   * This is consistent with abs
   */</span>
  def <a title="()(implicit r: spire.algebra.Signed[T])Int" id="spire.math;Jet.signum">signum</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Signed[T]" id="spire.math;Jet.signum.r">r</a>: <a href="../algebra/Signed.scala.html#spire.algebra;Signed" title="spire.algebra.Signed[T]">Signed</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.math;Jet.signum.r" title="spire.algebra.Signed[T]">real</a>.signum<a href="../algebra/Signed.scala.html#spire.algebra;Signed.signum" title="(a: T)Int" class="delimiter">(</a><span class="delimiter">)</span>

  def <a title="=&gt; (T, Array[T])" id="spire.math;Jet.asTuple">asTuple</a> = <span title="(_1: T, _2: Array[T])(T, Array[T])" class="delimiter">(</span><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>

  def <a title="=&gt; Boolean" id="spire.math;Jet.isReal">isReal</a>: <span title="Boolean">Boolean</span> = <a href="#spire.math;Jet.copy$default$2" title="(xs: Array[T])scala.collection.mutable.ArrayOps[T]">infinitesimal</a>.<span title="(p: T =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="package.scala.html#spire.math.package.anyIsZero" title="(n: Any)Boolean">anyIsZero</a><span class="delimiter">)</span>
  def <a title="=&gt; Boolean" id="spire.math;Jet.isZero">isZero</a>: <span title="Boolean">Boolean</span> = <a href="package.scala.html#spire.math.package.anyIsZero" title="(n: Any)Boolean">anyIsZero</a><span class="delimiter">(</span><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Jet.isReal" title="=&gt; Boolean">isReal</a>
  def <a title="(implicit r: spire.algebra.IsReal[T])Boolean" id="spire.math;Jet.isInfinitesimal">isInfinitesimal</a><span class="delimiter">(</span>implicit <a title="spire.algebra.IsReal[T]" id="spire.math;Jet.isInfinitesimal.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="package.scala.html#spire.math.package.anyIsZero" title="(n: Any)Boolean">anyIsZero</a><span class="delimiter">(</span><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#spire.math;Jet.isReal" title="=&gt; Boolean">isReal</a>

  def <a title="(b: spire.math.Jet[T])(implicit o: spire.algebra.Eq[T])Boolean" id="spire.math;Jet.eqv">eqv</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;Jet.eqv.b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Eq[T]" id="spire.math;Jet.eqv.o">o</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[T]">Eq</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <a href="#spire.math;Jet.eqv.o" title="spire.algebra.Eq[T]">real</a> <a href="../algebra/Eq.scala.html#spire.algebra;Eq.eqv" title="(x: T, y: T)Boolean">===</a> <a href="#spire.math;Jet.eqv.b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="../std/array.scala.html#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="../std/array.scala.html#spire.std.ArraySupport.eqv" title="(x: Array[T], y: Array[T])(implicit evidence$1: spire.algebra.Eq[T])Boolean">eqv</a><a href="#spire.math;Jet.eqv.o" title="spire.algebra.Eq[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a>, <a href="#spire.math;Jet.eqv.b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  def <a title="(b: spire.math.Jet[T])(implicit o: spire.algebra.Eq[T])Boolean" id="spire.math;Jet.neqv">neqv</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;Jet.neqv.b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Eq[T]" id="spire.math;Jet.neqv.o">o</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[T]">Eq</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span title="=&gt; Boolean">!</span><span class="delimiter">(</span>this <a href="#spire.math;Jet.eqv" title="(b: spire.math.Jet[T])(implicit o: spire.algebra.Eq[T])Boolean">eqv</a> <a href="#spire.math;Jet.neqv.b" title="spire.math.Jet[T]">b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="()(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.unary_-">unary_-</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.unary_-.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.unary_-.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: T)T">-</a><a href="#spire.math;Jet.unary_-.f" title="spire.algebra.Field[T]">real</a>, <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: Array[T])Array[T]">-</a><a href="#spire.math;Jet.unary_-.v" title="spire.algebra.VectorSpace[Array[T],T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(b: T)(implicit f: spire.algebra.Field[T])spire.math.Jet[T]" id="spire.math;Jet.+(1ce898acce)">+</a><span class="delimiter">(</span><a title="T" id="spire.math;Jet.+(1ce898acce).b">b</a>: <a href="#spire.math;Jet.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.+(1ce898acce).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.+(1ce898acce).f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: T, y: T)T">+</a> <a href="#spire.math;Jet.+(1ce898acce).b" title="T">b</a>, <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  def <a title="(b: T)(implicit f: spire.algebra.Field[T])spire.math.Jet[T]" id="spire.math;Jet.-(1ce898acce)">-</a><span class="delimiter">(</span><a title="T" id="spire.math;Jet.-(1ce898acce).b">b</a>: <a href="#spire.math;Jet.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.-(1ce898acce).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.-(1ce898acce).f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: T, y: T)T">-</a> <a href="#spire.math;Jet.-(1ce898acce).b" title="T">b</a>, <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  def <a title="(b: T)(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.*(c728b4bc4a)">*</a><span class="delimiter">(</span><a title="T" id="spire.math;Jet.*(c728b4bc4a).b">b</a>: <a href="#spire.math;Jet.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.*(c728b4bc4a).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.*(c728b4bc4a).v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.*(c728b4bc4a).f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Jet.*(c728b4bc4a).b" title="T">b</a>, <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesr" title="(v: Array[T], r: T)Array[T]">:*</a> <a href="#spire.math;Jet.*(c728b4bc4a).b" title="T">b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  def <a title="(b: T)(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet./(c728b4bc4a)">/</a><span class="delimiter">(</span><a title="T" id="spire.math;Jet./(c728b4bc4a).b">b</a>: <a href="#spire.math;Jet.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet./(c728b4bc4a).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet./(c728b4bc4a).v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet./(c728b4bc4a).f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <a href="#spire.math;Jet./(c728b4bc4a).b" title="T">b</a>, <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a> <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace.divr" title="(v: Array[T], f: T)Array[T]">:/</a> <a href="#spire.math;Jet./(c728b4bc4a).b" title="T">b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  def <a title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.+(b10a0e21a6)">+</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;Jet.+(b10a0e21a6).b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.+(b10a0e21a6).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.+(b10a0e21a6).v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.+(b10a0e21a6).f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: T, y: T)T">+</a> <a href="#spire.math;Jet.+(b10a0e21a6).b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Jet.+(b10a0e21a6).v" title="spire.algebra.VectorSpace[Array[T],T]">infinitesimal</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: Array[T], y: Array[T])Array[T]">+</a> <a href="#spire.math;Jet.+(b10a0e21a6).b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  def <a title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.-(b10a0e21a6)">-</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;Jet.-(b10a0e21a6).b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.-(b10a0e21a6).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.-(b10a0e21a6).v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.-(b10a0e21a6).f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: T, y: T)T">-</a> <a href="#spire.math;Jet.-(b10a0e21a6).b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Jet.-(b10a0e21a6).v" title="spire.algebra.VectorSpace[Array[T],T]">infinitesimal</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: Array[T], y: Array[T])Array[T]">-</a> <a href="#spire.math;Jet.-(b10a0e21a6).b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">// Multiplication rule for differentials:</span>
  <span class="comment">//</span>
  <span class="comment">//    (a + du)(b + dv) ~= ab + a dv + b du</span>
  <span class="comment">//</span>
  <span class="comment">// because du dv ~= 0</span>
  def <a title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.*(b10a0e21a6)">*</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;Jet.*(b10a0e21a6).b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.*(b10a0e21a6).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.*(b10a0e21a6).v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.*(b10a0e21a6).f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Jet.*(b10a0e21a6).b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Jet.*(b10a0e21a6).b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a> <a href="#spire.math;Jet.*(b10a0e21a6).v" title="spire.algebra.VectorSpace[Array[T],T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: Array[T], y: Array[T])Array[T]">+</a> <a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.*(b10a0e21a6).b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet./(b10a0e21a6)">/</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;Jet./(b10a0e21a6).b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet./(b10a0e21a6).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet./(b10a0e21a6).v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">// Division rule for differentials:</span>
    <span class="comment">//</span>
    <span class="comment">//   a + du   (a + du)(b - dv)    ab - a dv + b du   a    a       1      a   1         a</span>
    <span class="comment">//   ------ = ---------------- ~= ---------------- = - - --- dv + - du = - + - * (du - - dv)</span>
    <span class="comment">//   b + dv   (b + dv)(b - dv)           b^2         b   b^2      b      b   b         b</span>
    <span class="comment">//</span>
    <span class="comment">// which holds because dv dv = du dv = 0.</span>
    val br_inv: <a href="#spire.math;Jet.copy$default$2;T" title="T">T</a> = <a href="#spire.math;Jet./(b10a0e21a6).f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Jet./(b10a0e21a6).f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="T" id="spire.math;Jet./(b10a0e21a6).br_inv">/</a> <a href="#spire.math;Jet./(b10a0e21a6).b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>
    val ar_div_br: <a href="#spire.math;Jet.copy$default$2;T" title="T">T</a> = <a href="#spire.math;Jet./(b10a0e21a6).f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="T" id="spire.math;Jet./(b10a0e21a6).ar_div_br">*</a> <a href="#spire.math;Jet./(b10a0e21a6).br_inv" title="T">br_inv</a>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet./(b10a0e21a6).ar_div_br" title="T">ar_div_br</a>, <a href="#spire.math;Jet./(b10a0e21a6).br_inv" title="T">br_inv</a> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <span class="delimiter">(</span><a href="#spire.math;Jet./(b10a0e21a6).v" title="spire.algebra.VectorSpace[Array[T],T]">infinitesimal</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: Array[T], y: Array[T])Array[T]">-</a> <span class="delimiter">(</span><a href="#spire.math;Jet./(b10a0e21a6).ar_div_br" title="T">ar_div_br</a> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet./(b10a0e21a6).b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(b: spire.math.Jet[T])(implicit c: scala.reflect.ClassTag[T], implicit f: spire.algebra.Field[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet./~">/~</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;Jet./~.b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[T]" id="spire.math;Jet./~.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Field[T]" id="spire.math;Jet./~.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Jet./~.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet./~.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val q = this <a href="#spire.math;Jet./(b10a0e21a6)" title="spire.math.Jet[T]" id="spire.math;Jet./~.q">/</a> <a href="#spire.math;Jet./~.b" title="spire.math.Jet[T]">b</a>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.math;Jet./~.q" title="spire.math.Jet[T]">q</a>.<a href="#spire.math;Jet./~.r" title="spire.algebra.IsReal[T]">real</a>.floor<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.floor" title="(a: T)T" class="delimiter">(</a><span class="delimiter">)</span>, <a href="#spire.math;Jet./~.q" title="spire.math.Jet[T]">q</a>.<a href="#spire.math;Jet.copy$default$2" title="(xs: Array[T])scala.collection.mutable.ArrayOps[T]">infinitesimal</a>.<span title="(f: T =&gt; T)(implicit bf: scala.collection.generic.CanBuildFrom[Array[T],T,Array[T]])Array[T]">map</span><a href="#spire.math;Jet./~.c" title="(implicit t: scala.reflect.ClassTag[T])scala.collection.generic.CanBuildFrom[Array[_],T,Array[T]]" class="delimiter">(</a><a href="#spire.math;Jet./~.r" title="spire.algebra.IsReal[T]">r</a>.<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.floor" title="(a: T)T">floor</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(b: spire.math.Jet[T])(implicit c: scala.reflect.ClassTag[T], implicit f: spire.algebra.Field[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.%">%</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;Jet.%.b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[T]" id="spire.math;Jet.%.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Field[T]" id="spire.math;Jet.%.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Jet.%.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.%.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    this <a href="#spire.math;Jet.-(b10a0e21a6)" title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">-</a> <span class="delimiter">(</span><span class="delimiter">(</span>this <a href="#spire.math;Jet./~" title="(b: spire.math.Jet[T])(implicit c: scala.reflect.ClassTag[T], implicit f: spire.algebra.Field[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">/~</a> <a href="#spire.math;Jet.%.b" title="spire.math.Jet[T]">b</a><span class="delimiter">)</span> <a href="#spire.math;Jet.*(b10a0e21a6)" title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">*</a> <a href="#spire.math;Jet.%.b" title="spire.math.Jet[T]">b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(b: spire.math.Jet[T])(implicit c: scala.reflect.ClassTag[T], implicit f: spire.algebra.Field[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])(spire.math.Jet[T], spire.math.Jet[T])" id="spire.math;Jet./%">/%</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;Jet./%.b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[T]" id="spire.math;Jet./%.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Field[T]" id="spire.math;Jet./%.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Jet./%.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet./%.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(spire.math.Jet[T], spire.math.Jet[T])" class="delimiter">(</span>Jet<span class="delimiter">[</span>T<span class="delimiter">]</span>, Jet<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val q = this <a href="#spire.math;Jet./~" title="spire.math.Jet[T]" id="spire.math;Jet./%.q">/~</a> <a href="#spire.math;Jet./%.b" title="spire.math.Jet[T]">b</a>
    <span title="(_1: spire.math.Jet[T], _2: spire.math.Jet[T])(spire.math.Jet[T], spire.math.Jet[T])" class="delimiter">(</span><a href="#spire.math;Jet./%.q" title="spire.math.Jet[T]">q</a>, this <a href="#spire.math;Jet.-(b10a0e21a6)" title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">-</a> <span class="delimiter">(</span><a href="#spire.math;Jet./%.q" title="spire.math.Jet[T]">q</a> <a href="#spire.math;Jet.*(b10a0e21a6)" title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">*</a> <a href="#spire.math;Jet./%.b" title="spire.math.Jet[T]">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(b: Int)(implicit e: spire.algebra.Eq[T], implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.**(434e89d5d8)">**</a><span class="delimiter">(</span><a title="Int" id="spire.math;Jet.**(434e89d5d8).b">b</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Eq[T]" id="spire.math;Jet.**(434e89d5d8).e">e</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[T]">Eq</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Field[T]" id="spire.math;Jet.**(434e89d5d8).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.**(434e89d5d8).v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;Jet.pow(74c2d09adc)" title="(p: Int)(implicit f: spire.algebra.Field[T], implicit e: spire.algebra.Eq[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">pow</a><a href="#spire.math;Jet.**(434e89d5d8).f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Jet.**(434e89d5d8).b" title="Int">b</a><span class="delimiter">)</span>

  def <a title="(k: Int)(implicit e: spire.algebra.Eq[T], implicit f: spire.algebra.Field[T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.nroot">nroot</a><span class="delimiter">(</span><a title="Int" id="spire.math;Jet.nroot.k">k</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>
      implicit <a title="spire.algebra.Eq[T]" id="spire.math;Jet.nroot.e">e</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[T]">Eq</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Field[T]" id="spire.math;Jet.nroot.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Jet.nroot.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.nroot.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.nroot.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>
      : <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#spire.math;Jet.pow(dcd88456e3)" title="(p: T)(implicit e: spire.algebra.Eq[T], implicit f: spire.algebra.Field[T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">pow</a><a href="#spire.math;Jet.nroot.r" title="spire.algebra.IsReal[T]" class="delimiter">(</a><a href="#spire.math;Jet.nroot.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)T">fromInt</a><a href="#spire.math;Jet.nroot.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Jet.nroot.k" title="Int">k</a><span class="delimiter">)</span>.reciprocal<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.reciprocal" title="(x: T)T" class="delimiter">(</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(b: spire.math.Jet[T])(implicit c: scala.reflect.ClassTag[T], implicit e: spire.algebra.Eq[T], implicit f: spire.algebra.Field[T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.**(71e3031563)">**</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;Jet.**(71e3031563).b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[T]" id="spire.math;Jet.**(71e3031563).c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Eq[T]" id="spire.math;Jet.**(71e3031563).e">e</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[T]">Eq</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Field[T]" id="spire.math;Jet.**(71e3031563).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Jet.**(71e3031563).r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.**(71e3031563).t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>,
        <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.**(71e3031563).v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#spire.math;Jet.pow(0eadd74cfb)" title="(b: spire.math.Jet[T])(implicit c: scala.reflect.ClassTag[T], implicit e: spire.algebra.Eq[T], implicit f: spire.algebra.Field[T], implicit m: spire.algebra.Module[Array[T],T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T])spire.math.Jet[T]">pow</a><a href="#spire.math;Jet.**(71e3031563).c" title="scala.reflect.ClassTag[T]" class="delimiter">(</a><a href="#spire.math;Jet.**(71e3031563).b" title="spire.math.Jet[T]">b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="()(implicit c: scala.reflect.ClassTag[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.floor">floor</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[T]" id="spire.math;Jet.floor.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Jet.floor.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.floor.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.floor.r" title="spire.algebra.IsReal[T]">real</a>.floor<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.floor" title="(a: T)T" class="delimiter">(</a><span class="delimiter">)</span>, <a href="#spire.math;Jet.copy$default$2" title="(xs: Array[T])scala.collection.mutable.ArrayOps[T]">infinitesimal</a>.<span title="(f: T =&gt; T)(implicit bf: scala.collection.generic.CanBuildFrom[Array[T],T,Array[T]])Array[T]">map</span><a href="#spire.math;Jet.floor.c" title="(implicit t: scala.reflect.ClassTag[T])scala.collection.generic.CanBuildFrom[Array[_],T,Array[T]]" class="delimiter">(</a><a href="#spire.math;Jet.floor.r" title="spire.algebra.IsReal[T]">r</a>.<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.floor" title="(a: T)T">floor</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="()(implicit c: scala.reflect.ClassTag[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.ceil">ceil</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[T]" id="spire.math;Jet.ceil.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Jet.ceil.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.ceil.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.ceil.r" title="spire.algebra.IsReal[T]">real</a>.ceil<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.ceil" title="(a: T)T" class="delimiter">(</a><span class="delimiter">)</span>, <a href="#spire.math;Jet.copy$default$2" title="(xs: Array[T])scala.collection.mutable.ArrayOps[T]">infinitesimal</a>.<span title="(f: T =&gt; T)(implicit bf: scala.collection.generic.CanBuildFrom[Array[T],T,Array[T]])Array[T]">map</span><a href="#spire.math;Jet.ceil.c" title="(implicit t: scala.reflect.ClassTag[T])scala.collection.generic.CanBuildFrom[Array[_],T,Array[T]]" class="delimiter">(</a><a href="#spire.math;Jet.ceil.r" title="spire.algebra.IsReal[T]">r</a>.<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.ceil" title="(a: T)T">ceil</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="()(implicit c: scala.reflect.ClassTag[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.round">round</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[T]" id="spire.math;Jet.round.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Jet.round.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.round.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.round.r" title="spire.algebra.IsReal[T]">real</a>.round<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.round" title="(a: T)T" class="delimiter">(</a><span class="delimiter">)</span>, <a href="#spire.math;Jet.copy$default$2" title="(xs: Array[T])scala.collection.mutable.ArrayOps[T]">infinitesimal</a>.<span title="(f: T =&gt; T)(implicit bf: scala.collection.generic.CanBuildFrom[Array[T],T,Array[T]])Array[T]">map</span><a href="#spire.math;Jet.round.c" title="(implicit t: scala.reflect.ClassTag[T])scala.collection.generic.CanBuildFrom[Array[_],T,Array[T]]" class="delimiter">(</a><a href="#spire.math;Jet.round.r" title="spire.algebra.IsReal[T]">r</a>.<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal.round" title="(a: T)T">round</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// Elementary math functions</span>
  <span class="comment">// In general, f(a + du) ~= f(a) + f'(a) du .</span>

  <span class="comment">/**
   * abs(x + du) ~= x + du or -(x + du)
   */</span>
  def <a title="()(implicit f: spire.algebra.Field[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.abs">abs</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.abs.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Jet.abs.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.abs.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.math;Jet.abs.r" title="spire.algebra.IsReal[T]">real</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: T, y: T)Boolean">&lt;</a> <a href="#spire.math;Jet.abs.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span> new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: T)T">-</a><a href="#spire.math;Jet.abs.f" title="spire.algebra.Field[T]">real</a>, <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: Array[T])Array[T]">-</a><a href="#spire.math;Jet.abs.v" title="spire.algebra.VectorSpace[Array[T],T]">infinitesimal</a><span class="delimiter">)</span>
    else this
  <span class="delimiter">}</span>

  <span class="comment">// spire.math. does not define this pow generically, so there it is</span>
  private def <a title="(b: T, e: T)(implicit f: spire.algebra.Field[T], implicit eq: spire.algebra.Eq[T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T])T" id="spire.math;Jet.powScalarToScalar">powScalarToScalar</a><span class="delimiter">(</span><a title="T" id="spire.math;Jet.powScalarToScalar.b">b</a>: <a href="#spire.math;Jet.copy$default$2;T" title="T">T</a>, <a title="T" id="spire.math;Jet.powScalarToScalar.e">e</a>: <a href="#spire.math;Jet.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit
      <a title="spire.algebra.Field[T]" id="spire.math;Jet.powScalarToScalar.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Eq[T]" id="spire.math;Jet.powScalarToScalar.eq">eq</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[T]">Eq</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Jet.powScalarToScalar.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.powScalarToScalar.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.copy$default$2;T" title="T">T</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.math;Jet.powScalarToScalar.r" title="spire.algebra.IsReal[T]">e</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: T, y: T)Boolean">===</a> <a href="#spire.math;Jet.powScalarToScalar.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.math;Jet.powScalarToScalar.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; T">one</a>
    <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.math;Jet.powScalarToScalar.r" title="spire.algebra.IsReal[T]">b</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: T, y: T)Boolean">===</a> <a href="#spire.math;Jet.powScalarToScalar.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#spire.math;Jet.powScalarToScalar.r" title="spire.algebra.IsReal[T]">e</a> <a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: T, y: T)Boolean">&lt;</a> <a href="#spire.math;Jet.powScalarToScalar.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a><span class="delimiter">)</span> throw new <span title="Exception">Exception</span><span class="delimiter">(</span><span title="String(&quot;raising 0 to a negative power&quot;)" class="string">&quot;raising 0 to a negative power&quot;</span><span class="delimiter">)</span>
      else <a href="#spire.math;Jet.powScalarToScalar.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; T">zero</a>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      spire.math.<a href="package.scala.html#spire.math.package.exp(b8a85e94f6)" title="(a: T)(implicit t: spire.algebra.Trig[T])T">exp</a><a href="#spire.math;Jet.powScalarToScalar.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.powScalarToScalar.f" title="spire.algebra.Field[T]">e</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> spire.math.<a href="package.scala.html#spire.math.package.log(b8a85e94f6)" title="(a: T)(implicit t: spire.algebra.Trig[T])T">log</a><a href="#spire.math;Jet.powScalarToScalar.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.powScalarToScalar.b" title="T">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">// pow -- base is a constant, exponent (this) is a differentiable function.</span>
  <span class="comment">// b^(p + du) ~= b^p + b^p * log(b) du</span>
  def <a title="(a: T)(implicit c: scala.reflect.ClassTag[T], implicit e: spire.algebra.Eq[T], implicit f: spire.algebra.Field[T], implicit m: spire.algebra.Module[Array[T],T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T])spire.math.Jet[T]" id="spire.math;Jet.powScalarToJet">powScalarToJet</a><span class="delimiter">(</span><a title="T" id="spire.math;Jet.powScalarToJet.a">a</a>: <a href="#spire.math;Jet.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit
      <a title="scala.reflect.ClassTag[T]" id="spire.math;Jet.powScalarToJet.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Eq[T]" id="spire.math;Jet.powScalarToJet.e">e</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[T]">Eq</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Field[T]" id="spire.math;Jet.powScalarToJet.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Module[Array[T],T]" id="spire.math;Jet.powScalarToJet.m">m</a>: <a href="../algebra/Module.scala.html#spire.algebra;Module" title="spire.algebra.Module[Array[T],T]">Module</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Jet.powScalarToJet.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.powScalarToJet.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.math;Jet.isZero" title="=&gt; Boolean">isZero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.math.Jet.readResolve" title="spire.math.Jet.type">Jet</a>.<a href="#spire.math.Jet.one" title="[T](implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit r: spire.algebra.Rig[T])spire.math.Jet[T]">one</a><a href="#spire.math;Jet.powScalarToJet.c" title="(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit r: spire.algebra.Rig[T])spire.math.Jet[T]" class="delimiter">[</a><a href="#spire.math;Jet.copy$default$2;T" title="T">T</a><span class="delimiter">]</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      val <a title="T" id="spire.math;Jet.powScalarToJet.tmp">tmp</a> = <a href="#spire.math;Jet.powScalarToScalar" title="(b: T, e: T)(implicit f: spire.algebra.Field[T], implicit eq: spire.algebra.Eq[T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T])T">powScalarToScalar</a><a href="#spire.math;Jet.powScalarToJet.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Jet.powScalarToJet.a" title="T">a</a>, <a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>
      new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.powScalarToJet.tmp" title="T">tmp</a>, <span class="delimiter">(</span>spire.math.<a href="package.scala.html#spire.math.package.log(b8a85e94f6)" title="(a: T)(implicit t: spire.algebra.Trig[T])T">log</a><a href="#spire.math;Jet.powScalarToJet.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Jet.powScalarToJet.a" title="T">a</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Jet.powScalarToJet.tmp" title="T">tmp</a><span class="delimiter">)</span> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * pow -- base (this) is a differentiable function, exponent is a constant.
   * pow(a + du, p) ~= pow(a, p) + p * pow(a, p-1) du
   */</span>
  def <a title="(p: T)(implicit e: spire.algebra.Eq[T], implicit f: spire.algebra.Field[T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.pow(dcd88456e3)">pow</a><span class="delimiter">(</span><a title="T" id="spire.math;Jet.pow(dcd88456e3).p">p</a>: <a href="#spire.math;Jet.copy$default$2;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit
      <a title="spire.algebra.Eq[T]" id="spire.math;Jet.pow(dcd88456e3).e">e</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[T]">Eq</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Field[T]" id="spire.math;Jet.pow(dcd88456e3).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Jet.pow(dcd88456e3).r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.pow(dcd88456e3).t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.pow(dcd88456e3).v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val tmp: <a href="#spire.math;Jet.copy$default$2;T" title="T">T</a> = <a href="#spire.math;Jet.pow(dcd88456e3).f" title="spire.algebra.Field[T]">p</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="T" id="spire.math;Jet.pow(dcd88456e3).tmp">*</a> <a href="#spire.math;Jet.powScalarToScalar" title="(b: T, e: T)(implicit f: spire.algebra.Field[T], implicit eq: spire.algebra.Eq[T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T])T">powScalarToScalar</a><a href="#spire.math;Jet.pow(dcd88456e3).f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Jet.pow(dcd88456e3).f" title="spire.algebra.Field[T]">p</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: T, y: T)T">-</a> <a href="#spire.math;Jet.pow(dcd88456e3).f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; T">one</a><span class="delimiter">)</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.powScalarToScalar" title="(b: T, e: T)(implicit f: spire.algebra.Field[T], implicit eq: spire.algebra.Eq[T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T])T">powScalarToScalar</a><a href="#spire.math;Jet.pow(dcd88456e3).f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Jet.pow(dcd88456e3).p" title="T">p</a><span class="delimiter">)</span>, <a href="#spire.math;Jet.pow(dcd88456e3).tmp" title="T">tmp</a> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// As above, integer exponent.</span>
  def <a title="(p: Int)(implicit f: spire.algebra.Field[T], implicit e: spire.algebra.Eq[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.pow(74c2d09adc)">pow</a><span class="delimiter">(</span><a title="Int" id="spire.math;Jet.pow(74c2d09adc).p">p</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.pow(74c2d09adc).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Eq[T]" id="spire.math;Jet.pow(74c2d09adc).e">e</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[T]">Eq</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.pow(74c2d09adc).v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val tmp = <a href="../syntax/Syntax.scala.html#spire.syntax;MultiplicativeSemigroupSyntax.literalIntMultiplicativeSemigroupOps" title="implicit spire.syntax.MultiplicativeSemigroupSyntax.literalIntMultiplicativeSemigroupOps : (lhs: Int)spire.syntax.LiteralIntMultiplicativeSemigroupOps">p</a> <a href="../syntax/Ops.scala.html#spire.syntax;LiteralIntMultiplicativeSemigroupOps.*" title="T" id="spire.math;Jet.pow(74c2d09adc).tmp">*</a> <a href="#spire.math;Jet.pow(74c2d09adc).f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Rig.scala.html#spire.algebra;Rig.pow" title="(a: T, n: Int)T">pow</a><span class="delimiter">(</span><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Jet.pow(74c2d09adc).p" title="Int">p</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.pow(74c2d09adc).f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Rig.scala.html#spire.algebra;Rig.pow" title="(a: T, n: Int)T">pow</a><span class="delimiter">(</span><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Jet.pow(74c2d09adc).p" title="Int">p</a><span class="delimiter">)</span>, <a href="#spire.math;Jet.pow(74c2d09adc).tmp" title="T">tmp</a> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * pow -- both base (this) and exponent are differentiable functions.
   * (a + du)^(b + dv) ~= a^b + b * a^(b-1) du + a^b log(a) dv
   */</span>
  def <a title="(b: spire.math.Jet[T])(implicit c: scala.reflect.ClassTag[T], implicit e: spire.algebra.Eq[T], implicit f: spire.algebra.Field[T], implicit m: spire.algebra.Module[Array[T],T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T])spire.math.Jet[T]" id="spire.math;Jet.pow(0eadd74cfb)">pow</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;Jet.pow(0eadd74cfb).b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[T]" id="spire.math;Jet.pow(0eadd74cfb).c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Eq[T]" id="spire.math;Jet.pow(0eadd74cfb).e">e</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[T]">Eq</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Field[T]" id="spire.math;Jet.pow(0eadd74cfb).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Module[Array[T],T]" id="spire.math;Jet.pow(0eadd74cfb).m">m</a>: <a href="../algebra/Module.scala.html#spire.algebra;Module" title="spire.algebra.Module[Array[T],T]">Module</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;Jet.pow(0eadd74cfb).r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.pow(0eadd74cfb).t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>
      : <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.math;Jet.pow(0eadd74cfb).b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.isZero" title="=&gt; Boolean">isZero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.math.Jet.readResolve" title="spire.math.Jet.type">Jet</a>.<a href="#spire.math.Jet.one" title="[T](implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit r: spire.algebra.Rig[T])spire.math.Jet[T]">one</a><a href="#spire.math;Jet.pow(0eadd74cfb).c" title="(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit r: spire.algebra.Rig[T])spire.math.Jet[T]" class="delimiter">[</a><a href="#spire.math;Jet.copy$default$2;T" title="T">T</a><span class="delimiter">]</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      val <a title="T" id="spire.math;Jet.pow(0eadd74cfb).tmp1">tmp1</a> = <a href="#spire.math;Jet.powScalarToScalar" title="(b: T, e: T)(implicit f: spire.algebra.Field[T], implicit eq: spire.algebra.Eq[T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T])T">powScalarToScalar</a><a href="#spire.math;Jet.pow(0eadd74cfb).f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Jet.pow(0eadd74cfb).b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>
      val tmp2 = <a href="#spire.math;Jet.pow(0eadd74cfb).b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.pow(0eadd74cfb).f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="T" id="spire.math;Jet.pow(0eadd74cfb).tmp2">*</a> <a href="#spire.math;Jet.powScalarToScalar" title="(b: T, e: T)(implicit f: spire.algebra.Field[T], implicit eq: spire.algebra.Eq[T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T])T">powScalarToScalar</a><a href="#spire.math;Jet.pow(0eadd74cfb).f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Jet.pow(0eadd74cfb).b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.pow(0eadd74cfb).f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: T, y: T)T">-</a> <a href="#spire.math;Jet.pow(0eadd74cfb).f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; T">one</a><span class="delimiter">)</span>
      val tmp3 = <a href="#spire.math;Jet.pow(0eadd74cfb).f" title="spire.algebra.Field[T]">tmp1</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="T" id="spire.math;Jet.pow(0eadd74cfb).tmp3">*</a> spire.math.<a href="package.scala.html#spire.math.package.log(b8a85e94f6)" title="(a: T)(implicit t: spire.algebra.Trig[T])T">log</a><a href="#spire.math;Jet.pow(0eadd74cfb).t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>
      new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.pow(0eadd74cfb).tmp1" title="T">tmp1</a>, <span class="delimiter">(</span><a href="#spire.math;Jet.pow(0eadd74cfb).tmp2" title="T">tmp2</a> <a href="#spire.math;Jet.pow(0eadd74cfb).m" title="spire.algebra.Module[Array[T],T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: Array[T], y: Array[T])Array[T]">+</a> <span class="delimiter">(</span><a href="#spire.math;Jet.pow(0eadd74cfb).tmp3" title="T">tmp3</a> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.pow(0eadd74cfb).b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * log(a + du) ~= log(a) + du / a
   */</span>
  def <a title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.log">log</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.log.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.log.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.log.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span>spire.math.<a href="package.scala.html#spire.math.package.log(b8a85e94f6)" title="(a: T)(implicit t: spire.algebra.Trig[T])T">log</a><a href="#spire.math;Jet.log.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>, <span class="delimiter">(</span><a href="#spire.math;Jet.log.f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Jet.log.f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * sqrt(a + du) ~= sqrt(a) + du / (2 sqrt(a))
   */</span>
  def <a title="()(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.sqrt">sqrt</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.sqrt.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Jet.sqrt.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.sqrt.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="T" id="spire.math;Jet.sqrt.sa">sa</a> = <a href="#spire.math;Jet.sqrt.n" title="spire.algebra.NRoot[T]">real</a>.<a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.sqrt" title="(a: T)T">sqrt</a>
    val oneHalf = <a href="#spire.math;Jet.sqrt.f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Jet.sqrt.f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="T" id="spire.math;Jet.sqrt.oneHalf">/</a> <span class="delimiter">(</span><a href="#spire.math;Jet.sqrt.f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Jet.sqrt.f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: T, y: T)T">+</a> <a href="#spire.math;Jet.sqrt.f" title="spire.algebra.Field[T]">f</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; T">one</a><span class="delimiter">)</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.sqrt.sa" title="T">sa</a>, <span class="delimiter">(</span><a href="#spire.math;Jet.sqrt.f" title="spire.algebra.Field[T]">oneHalf</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: T, y: T)T">/</a> <a href="#spire.math;Jet.sqrt.sa" title="T">sa</a><span class="delimiter">)</span> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * acos(a + du) ~= acos(a) - 1 / sqrt(1 - a**2) du
   */</span>
  def <a title="()(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.acos">acos</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.acos.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Jet.acos.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.acos.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.acos.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val tmp = <a href="#spire.math;Jet.acos.f" title="spire.algebra.Field[T]">-</a><a href="#spire.math;Jet.acos.f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Jet.acos.f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="T" id="spire.math;Jet.acos.tmp">/</a> spire.math.<a href="package.scala.html#spire.math.package.sqrt(f6ffd48950)" title="(a: T)(implicit ev: spire.algebra.NRoot[T])T">sqrt</a><a href="#spire.math;Jet.acos.n" title="spire.algebra.NRoot[T]" class="delimiter">(</a><a href="#spire.math;Jet.acos.f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Jet.acos.f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: T, y: T)T">-</a> <a href="#spire.math;Jet.acos.f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span>spire.math.<a href="package.scala.html#spire.math.package.acos" title="(a: T)(implicit ev: spire.algebra.Trig[T])T">acos</a><a href="#spire.math;Jet.acos.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>, <a href="#spire.math;Jet.acos.tmp" title="T">tmp</a> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * asin(a + du) ~= asin(a) - 1 / sqrt(1 - a**2) du
   */</span>
  def <a title="()(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.asin">asin</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.asin.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Jet.asin.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.asin.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.asin.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val tmp = <a href="#spire.math;Jet.asin.f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Jet.asin.f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="T" id="spire.math;Jet.asin.tmp">/</a> spire.math.<a href="package.scala.html#spire.math.package.sqrt(f6ffd48950)" title="(a: T)(implicit ev: spire.algebra.NRoot[T])T">sqrt</a><a href="#spire.math;Jet.asin.n" title="spire.algebra.NRoot[T]" class="delimiter">(</a><a href="#spire.math;Jet.asin.f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Jet.asin.f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: T, y: T)T">-</a> <a href="#spire.math;Jet.asin.f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span>spire.math.<a href="package.scala.html#spire.math.package.asin" title="(a: T)(implicit ev: spire.algebra.Trig[T])T">asin</a><a href="#spire.math;Jet.asin.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>, <a href="#spire.math;Jet.asin.tmp" title="T">tmp</a> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * atan(a + du) ~= atan(a) + 1 / (1 + a**2) du
   */</span>
  def <a title="()(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.atan">atan</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.atan.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;Jet.atan.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.atan.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.atan.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val tmp = <a href="#spire.math;Jet.atan.f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Jet.atan.f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="T" id="spire.math;Jet.atan.tmp">/</a> <span class="delimiter">(</span><a href="#spire.math;Jet.atan.f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Jet.atan.f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: T, y: T)T">+</a> <a href="#spire.math;Jet.atan.f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span>spire.math.<a href="package.scala.html#spire.math.package.atan" title="(a: T)(implicit ev: spire.algebra.Trig[T])T">atan</a><a href="#spire.math;Jet.atan.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>, <a href="#spire.math;Jet.atan.tmp" title="T">tmp</a> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Defined with &quot;this&quot; as the y coordinate: this.atan2(a) == atan2(this, a) == atan(this / a)
   * atan2(b + dv, a + du) ~= atan2(b, a) + (- b du + a dv) / (a^2 + b^2)
   */</span>
  def <a title="(a: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.atan2">atan2</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;Jet.atan2.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.atan2.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.atan2.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.atan2.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val tmp = <a href="#spire.math;Jet.atan2.f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Jet.atan2.f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="T" id="spire.math;Jet.atan2.tmp">/</a> <span class="delimiter">(</span><a href="#spire.math;Jet.atan2.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.atan2.f" title="spire.algebra.Field[T]">real</a> <a href="#spire.math;Jet.atan2.f" title="spire.algebra.Field[T]">*</a> <a href="#spire.math;Jet.atan2.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: T, y: T)T">+</a> <a href="#spire.math;Jet.atan2.f" title="spire.algebra.Field[T]">real</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span>spire.math.<a href="package.scala.html#spire.math.package.atan2" title="(y: T, x: T)(implicit ev: spire.algebra.Trig[T])T">atan2</a><a href="#spire.math;Jet.atan2.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;Jet.atan2.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>,
            <span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math;Jet.atan2.f" title="spire.algebra.Field[T]">tmp</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <span class="delimiter">(</span><a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: T)T">-</a><a href="#spire.math;Jet.atan2.f" title="spire.algebra.Field[T]">real</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#spire.math;Jet.atan2.v" title="spire.algebra.VectorSpace[Array[T],T]">*:</a> <a href="#spire.math;Jet.atan2.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: Array[T], y: Array[T])Array[T]">+</a> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#spire.math;Jet.atan2.f" title="spire.algebra.Field[T]">tmp</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Jet.atan2.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * exp(a + du) ~= exp(a) + exp(a) du
   */</span>
  def <a title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.exp">exp</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.exp.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.exp.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.exp.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="T" id="spire.math;Jet.exp.ea">ea</a> = spire.math.<a href="package.scala.html#spire.math.package.exp(b8a85e94f6)" title="(a: T)(implicit t: spire.algebra.Trig[T])T">exp</a><a href="#spire.math;Jet.exp.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.math;Jet.exp.ea" title="T">ea</a>, <a href="#spire.math;Jet.exp.ea" title="T">ea</a> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * sin(a + du) ~= sin(a) + cos(a) du
   */</span>
  def <a title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.sin">sin</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.sin.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.sin.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.sin.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span>spire.math.<a href="package.scala.html#spire.math.package.sin" title="(a: T)(implicit ev: spire.algebra.Trig[T])T">sin</a><a href="#spire.math;Jet.sin.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>, spire.math.<a href="package.scala.html#spire.math.package.cos" title="(a: T)(implicit ev: spire.algebra.Trig[T])T">cos</a><a href="#spire.math;Jet.sin.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * sinh(a + du) ~= sinh(a) + cosh(a) du
   */</span>
  def <a title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.sinh">sinh</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.sinh.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.sinh.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.sinh.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span>spire.math.<a href="package.scala.html#spire.math.package.sinh" title="(x: T)(implicit ev: spire.algebra.Trig[T])T">sinh</a><a href="#spire.math;Jet.sinh.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>, spire.math.<a href="package.scala.html#spire.math.package.cosh(e07b9397d3)" title="(x: T)(implicit ev: spire.algebra.Trig[T])T">cosh</a><a href="#spire.math;Jet.sinh.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * cos(a + du) ~= cos(a) - sin(a) du
   */</span>
  def <a title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.cos">cos</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.cos.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.cos.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.cos.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span>spire.math.<a href="package.scala.html#spire.math.package.cos" title="(a: T)(implicit ev: spire.algebra.Trig[T])T">cos</a><a href="#spire.math;Jet.cos.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>, <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: T)T">-</a>spire.math.<a href="package.scala.html#spire.math.package.sin" title="(a: T)(implicit ev: spire.algebra.Trig[T])T">sin</a><a href="#spire.math;Jet.cos.f" title="spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * cosh(a + du) ~= cosh(a) + sinh(a) du
   */</span>
  def <a title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.cosh">cosh</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.cosh.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.cosh.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.cosh.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span>spire.math.<a href="package.scala.html#spire.math.package.cosh(e07b9397d3)" title="(x: T)(implicit ev: spire.algebra.Trig[T])T">cosh</a><a href="#spire.math;Jet.cosh.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>, spire.math.<a href="package.scala.html#spire.math.package.sinh" title="(x: T)(implicit ev: spire.algebra.Trig[T])T">sinh</a><a href="#spire.math;Jet.cosh.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * tan(a + du) ~= tan(a) + (1 + tan(a)**2) du
   */</span>
  def <a title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.tan">tan</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.tan.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.tan.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.tan.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="T" id="spire.math;Jet.tan.tan_a">tan_a</a> = spire.math.<a href="package.scala.html#spire.math.package.tan" title="(a: T)(implicit ev: spire.algebra.Trig[T])T">tan</a><a href="#spire.math;Jet.tan.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>
    val tmp = <a href="#spire.math;Jet.tan.f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Jet.tan.f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="T" id="spire.math;Jet.tan.tmp">+</a> <a href="#spire.math;Jet.tan.f" title="spire.algebra.Field[T]">tan_a</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Jet.tan.tan_a" title="T">tan_a</a>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.tan.tan_a" title="T">tan_a</a>, <a href="#spire.math;Jet.tan.tmp" title="T">tmp</a> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * tanh(a + du) ~= tanh(a) + (1 - tanh(a)**2) du
   */</span>
  def <a title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]" id="spire.math;Jet.tanh">tanh</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[T]" id="spire.math;Jet.tanh.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Trig[T]" id="spire.math;Jet.tanh.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;Jet.tanh.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="T" id="spire.math;Jet.tanh.tanh_a">tanh_a</a> = spire.math.<a href="package.scala.html#spire.math.package.tanh" title="(x: T)(implicit ev: spire.algebra.Trig[T])T">tanh</a><a href="#spire.math;Jet.tanh.t" title="spire.algebra.Trig[T]" class="delimiter">(</a><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>
    val tmp = <a href="#spire.math;Jet.tanh.f" title="spire.algebra.Field[T]">f</a>.<a href="#spire.math;Jet.tanh.f" title="spire.algebra.Field[T]">one</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="T" id="spire.math;Jet.tanh.tmp">-</a> <a href="#spire.math;Jet.tanh.f" title="spire.algebra.Field[T]">tanh_a</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">*</a> <a href="#spire.math;Jet.tanh.tanh_a" title="T">tanh_a</a>
    new <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">(</span><a href="#spire.math;Jet.tanh.tanh_a" title="T">tanh_a</a>, <a href="#spire.math;Jet.tanh.tmp" title="T">tmp</a> <a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: T, v: Array[T])Array[T]">*:</a> <a href="#spire.math;Jet.copy$default$2" title="=&gt; Array[T]">infinitesimal</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// Stuff needed by ScalaNumber</span>
  override def <a title="()Float" id="spire.math;Jet.floatValue">floatValue</a>: <span title="Float">Float</span> = <a href="#spire.math;Jet.doubleValue" title="()Double">doubleValue</a>.<span title="=&gt; Float">toFloat</span>
  override def <a title="()Double" id="spire.math;Jet.doubleValue">doubleValue</a>: <span title="Double">Double</span> = <a href="package.scala.html#spire.math.package.anyToDouble" title="(n: Any)Double">anyToDouble</a><span class="delimiter">(</span><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>
  override def <a title="()Byte" id="spire.math;Jet.byteValue">byteValue</a>: <span title="Byte">Byte</span> = <a href="#spire.math;Jet.longValue" title="()Long">longValue</a>.<span title="=&gt; Byte">toByte</span>
  override def <a title="()Short" id="spire.math;Jet.shortValue">shortValue</a>: <span title="Short">Short</span> = <a href="#spire.math;Jet.longValue" title="()Long">longValue</a>.<span title="=&gt; Short">toShort</span>
  override def <a title="()Int" id="spire.math;Jet.intValue">intValue</a>: <span title="Int">Int</span> = <a href="#spire.math;Jet.longValue" title="()Long">longValue</a>.<span title="=&gt; Int">toInt</span>
  override def <a title="()Long" id="spire.math;Jet.longValue">longValue</a>: <span title="Long">Long</span> = <a href="package.scala.html#spire.math.package.anyToLong" title="(n: Any)Long">anyToLong</a><span class="delimiter">(</span><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span>
  override def <a title="()Object" id="spire.math;Jet.underlying">underlying</a>: <span title="Object">Object</span> = this
  override def <a title="()Boolean" id="spire.math;Jet.isWhole">isWhole</a>: <span title="Boolean">Boolean</span> = <a href="package.scala.html#spire.math.package.anyIsWhole" title="(n: Any)Boolean">anyIsWhole</a><span class="delimiter">(</span><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Jet.isReal" title="=&gt; Boolean">isReal</a>
  override def <a title="=&gt; Boolean" id="spire.math;Jet.isValidInt">isValidInt</a>: <span title="Boolean">Boolean</span> = <a href="package.scala.html#spire.math.package.anyIsValidInt" title="(n: Any)Boolean">anyIsValidInt</a><span class="delimiter">(</span><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Jet.isReal" title="=&gt; Boolean">isReal</a>

  <span class="comment">// Object stuff</span>
  override def <a title="()Int" id="spire.math;Jet.hashCode">hashCode</a>: <span title="Int">Int</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.math;Jet.isReal" title="=&gt; Boolean">isReal</a><span class="delimiter">)</span> <a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>.<span title="()Int">##</span>
    else <span title="Int(13)" class="int">13</span> <span title="(x: Int)Int">*</span> <a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>.<span title="()Int">##</span> <span title="(x: Int)Int">+</span> <a href="#spire.math;Jet.copy$default$2" title="(xs: Array[T])scala.collection.mutable.ArrayOps[T]">infinitesimal</a>.<span title="(z: Int)(op: (Int, T) =&gt; Int)Int">foldLeft</span><span class="delimiter">(</span><span title="Int(53)" class="int">53</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Int" id="spire.math;Jet.hashCode.$anonfun.x">x</a>, <a title="T" id="spire.math;Jet.hashCode.$anonfun.y">y</a><span class="delimiter">)</span> =&gt; <a href="#spire.math;Jet.hashCode.$anonfun.x" title="Int">x</a> <span title="(x: Int)Int">+</span> <a href="#spire.math;Jet.hashCode.$anonfun.y" title="T">y</a>.<span title="()Int">##</span> <span title="(x: Int)Int">*</span> <span title="Int(19)" class="int">19</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  override def <a title="(that: Any)Boolean" id="spire.math;Jet.equals">equals</a><span class="delimiter">(</span><span title="Any">that</span>: <span title="Any">Any</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="Any">that</span> match <span class="delimiter">{</span>
    case <span title="spire.math.Jet[_]">that</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[_]">Jet</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt;
      <a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a> <span title="(x$1: Any)Boolean">==</span> <span title="spire.math.Jet[_]">that</span>.<a href="#spire.math;Jet.copy$default$1" title="=&gt; _">real</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Jet.dimension" title="=&gt; Int">dimension</a> <span title="(x: Int)Boolean">==</span> <span title="spire.math.Jet[_]">that</span>.<a href="#spire.math;Jet.dimension" title="=&gt; Int">dimension</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <a href="#spire.math;Jet.copy$default$2" title="(xs: Array[T])scala.collection.mutable.ArrayOps[T]">infinitesimal</a>.<span title="(that: scala.collection.GenIterable[_])(implicit bf: scala.collection.generic.CanBuildFrom[Array[T],(T, _),Array[(T, _)]])Array[(T, _)]">zip</span><span title="(xs: Array[(T, _)])scala.collection.mutable.ArrayOps[(T, _)]" class="delimiter">(</span><span title="spire.math.Jet[_]">that</span>.<a href="#spire.math;Jet.copy$default$2" title="(xs: Array[_])scala.collection.mutable.WrappedArray[_]">infinitesimal</a><span class="delimiter">)</span>.<span title="(p: ((T, _)) =&gt; Boolean)Boolean">forall</span><a href="#spire.math;Jet.equals.$anonfun.x0$1" title="Boolean" class="delimiter">{</a> case <span class="delimiter">(</span><a title="T" id="spire.math;Jet.equals.$anonfun.x">x</a>, <a title="_" id="spire.math;Jet.equals.$anonfun.y">y</a><span class="delimiter">)</span> =&gt; <a href="#spire.math;Jet.equals.$anonfun.x" title="T">x</a> <span title="(x$1: Any)Boolean">==</span> <a href="#spire.math;Jet.equals.$anonfun.y" title="_">y</a> <span class="delimiter">}</span>
    case <span title="Any">that</span> =&gt; <a href="#spire.math;Jet.isReal" title="=&gt; Boolean">isReal</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a> <span title="(x$1: Any)Boolean">==</span> <span title="Any">that</span>
  <span class="delimiter">}</span>

  override def <a title="()String" id="spire.math;Jet.toString">toString</a>: <span title="String">String</span> = <span class="delimiter">{</span>
    <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;(%s + [%s]h)&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>.<span title="()String">toString</span>, <a href="#spire.math;Jet.copy$default$2" title="(xs: Array[T])scala.collection.mutable.ArrayOps[T]">infinitesimal</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

trait <a title="trait JetInstances extends AnyRef" id="spire.math;JetInstances">JetInstances</a> <span title="Unit" class="delimiter">{</span>
  implicit def <a title="[T](implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit eq: spire.algebra.Eq[T], implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit r: spire.algebra.IsReal[T])spire.math.JetAlgebra[T]" id="spire.math;JetInstances.JetAlgebra">JetAlgebra</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math;JetInstances.JetAlgebra;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit
      <a title="scala.reflect.ClassTag[T]" id="spire.math;JetInstances.JetAlgebra.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.JetDim" id="spire.math;JetInstances.JetAlgebra.d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a>, <a title="spire.algebra.Eq[T]" id="spire.math;JetInstances.JetAlgebra.eq">eq</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[T]">Eq</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.Field[T]" id="spire.math;JetInstances.JetAlgebra.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[T]" id="spire.math;JetInstances.JetAlgebra.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>,
      <a title="spire.algebra.Trig[T]" id="spire.math;JetInstances.JetAlgebra.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.algebra.IsReal[T]" id="spire.math;JetInstances.JetAlgebra.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    import spire.std.<a href="../std/package.scala.html#spire.std.package.array" title="spire.std.array.type">array</a>.ArrayVectorSpace
    new <a href="#spire.math;JetAlgebra" title="spire.math.JetAlgebra[T]">JetAlgebra</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  implicit def <a title="[T](implicit evidence$1: spire.algebra.Eq[T])spire.math.JetEq[T]" id="spire.math;JetInstances.JetEq">JetEq</a><span class="delimiter">[</span><a title="" id="spire.math;JetInstances.JetEq;T">T</a> : Eq<span class="delimiter">]</span> = new <a href="#spire.math;JetEq" title="spire.math.JetEq[T]">JetEq</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
<span class="delimiter">}</span>

private<span class="delimiter">[</span>math<span class="delimiter">]</span> trait <a title="trait JetIsRing[T] extends AnyRef with spire.algebra.Ring[spire.math.Jet[T]]" id="spire.math;JetIsRing">JetIsRing</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math;JetIsRing;T">T</a><span class="delimiter">]</span> extends <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[spire.math.Jet[T]]">Ring</a><span class="delimiter">[</span>Jet<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  implicit def <a title="=&gt; scala.reflect.ClassTag[T]" id="spire.math;JetIsRing.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.math.JetDim" id="spire.math;JetIsRing.d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a>
  implicit def <a title="=&gt; spire.algebra.Eq[T]" id="spire.math;JetIsRing.eq(bb2751182d)">eq</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[T]">Eq</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.Field[T]" id="spire.math;JetIsRing.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.IsReal[T]" id="spire.math;JetIsRing.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.Trig[T]" id="spire.math;JetIsRing.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.VectorSpace[Array[T],T]" id="spire.math;JetIsRing.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span>

  override def <a title="(a: spire.math.Jet[T], b: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsRing.minus">minus</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsRing.minus.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.Jet[T]" id="spire.math;JetIsRing.minus.b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsRing.minus.a" title="spire.math.Jet[T]">a</a> <a href="#spire.math;Jet.-(b10a0e21a6)" title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">-</a> <a href="#spire.math;JetIsRing.minus.b" title="spire.math.Jet[T]">b</a>
  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsRing.negate">negate</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsRing.negate.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;Jet.unary_-" title="()(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">-</a><a href="#spire.math;JetIsRing.negate.a" title="spire.math.Jet[T]">a</a>
  def <a title="=&gt; spire.math.Jet[T]" id="spire.math;JetIsRing.one">one</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math.Jet.readResolve" title="spire.math.Jet.type">Jet</a>.<a href="#spire.math.Jet.one" title="[T](implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit r: spire.algebra.Rig[T])spire.math.Jet[T]">one</a><span title="(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit r: spire.algebra.Rig[T])spire.math.Jet[T]" class="delimiter">[</span><a href="#spire.math;JetIsRing;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.math;JetIsRing.c" title="=&gt; scala.reflect.ClassTag[T]">c</a>, <a href="#spire.math;JetIsRing.d" title="=&gt; spire.math.JetDim">d</a>, <a href="#spire.math;JetIsRing.f" title="=&gt; spire.algebra.Field[T]">f</a><span class="delimiter">)</span>
  def <a title="(a: spire.math.Jet[T], b: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsRing.plus">plus</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsRing.plus.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.Jet[T]" id="spire.math;JetIsRing.plus.b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsRing.plus.a" title="spire.math.Jet[T]">a</a> <a href="#spire.math;Jet.+(b10a0e21a6)" title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">+</a> <a href="#spire.math;JetIsRing.plus.b" title="spire.math.Jet[T]">b</a>
  override def <a title="(a: spire.math.Jet[T], b: Int)spire.math.Jet[T]" id="spire.math;JetIsRing.pow">pow</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsRing.pow.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Int" id="spire.math;JetIsRing.pow.b">b</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsRing.pow.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.pow(74c2d09adc)" title="(p: Int)(implicit f: spire.algebra.Field[T], implicit e: spire.algebra.Eq[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">pow</a><a href="#spire.math;JetIsRing.f" title="=&gt; spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;JetIsRing.pow.b" title="Int">b</a><span class="delimiter">)</span>
  override def <a title="(a: spire.math.Jet[T], b: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsRing.times">times</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsRing.times.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.Jet[T]" id="spire.math;JetIsRing.times.b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsRing.times.a" title="spire.math.Jet[T]">a</a> <a href="#spire.math;Jet.*(b10a0e21a6)" title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">*</a> <a href="#spire.math;JetIsRing.times.b" title="spire.math.Jet[T]">b</a>
  def <a title="=&gt; spire.math.Jet[T]" id="spire.math;JetIsRing.zero">zero</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math.Jet.readResolve" title="spire.math.Jet.type">Jet</a>.<a href="#spire.math.Jet.zero" title="(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit s: spire.algebra.Semiring[T])spire.math.Jet[T]">zero</a><span class="delimiter">(</span><a href="#spire.math;JetIsRing.c" title="=&gt; scala.reflect.ClassTag[T]">c</a>, <a href="#spire.math;JetIsRing.d" title="=&gt; spire.math.JetDim">d</a>, <a href="#spire.math;JetIsRing.f" title="=&gt; spire.algebra.Field[T]">f</a><span class="delimiter">)</span>

  override def <a title="(n: Int)spire.math.Jet[T]" id="spire.math;JetIsRing.fromInt">fromInt</a><span class="delimiter">(</span><a title="Int" id="spire.math;JetIsRing.fromInt.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math.Jet.readResolve" title="spire.math.Jet.type">Jet</a>.<a href="#spire.math.Jet.fromInt" title="[T](n: Int)(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit r: spire.algebra.Ring[T])spire.math.Jet[T]">fromInt</a><span title="(n: Int)(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit r: spire.algebra.Ring[T])spire.math.Jet[T]" class="delimiter">[</span><a href="#spire.math;JetIsRing;T" title="T">T</a><span class="delimiter">]</span><a href="#spire.math;JetIsRing.c" title="=&gt; scala.reflect.ClassTag[T]" class="delimiter">(</a><a href="#spire.math;JetIsRing.fromInt.n" title="Int">n</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

private<span class="delimiter">[</span>math<span class="delimiter">]</span> trait <a title="trait JetIsEuclideanRing[T] extends AnyRef with spire.math.JetIsRing[T] with spire.algebra.EuclideanRing[spire.math.Jet[T]]" id="spire.math;JetIsEuclideanRing">JetIsEuclideanRing</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Float,Double<span class="delimiter">)</span> <a title="" id="spire.math;JetIsEuclideanRing;T">T</a><span class="delimiter">]</span>
  extends <a href="#spire.math;JetIsRing" title="spire.math.JetIsRing[T]">JetIsRing</a><span class="delimiter">[</span>T<span class="delimiter">]</span> with <a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing" title="spire.algebra.EuclideanRing[spire.math.Jet[T]]">EuclideanRing</a><span class="delimiter">[</span>Jet<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>

  def <a title="(a: spire.math.Jet[T], b: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsEuclideanRing.quot">quot</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsEuclideanRing.quot.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.Jet[T]" id="spire.math;JetIsEuclideanRing.quot.b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math;JetIsEuclideanRing.quot.a" title="spire.math.Jet[T]">a</a> <a href="#spire.math;Jet./~" title="(b: spire.math.Jet[T])(implicit c: scala.reflect.ClassTag[T], implicit f: spire.algebra.Field[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">/~</a> <a href="#spire.math;JetIsEuclideanRing.quot.b" title="spire.math.Jet[T]">b</a>
  def <a title="(a: spire.math.Jet[T], b: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsEuclideanRing.mod">mod</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsEuclideanRing.mod.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.Jet[T]" id="spire.math;JetIsEuclideanRing.mod.b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math;JetIsEuclideanRing.mod.a" title="spire.math.Jet[T]">a</a> <a href="#spire.math;Jet.%" title="(b: spire.math.Jet[T])(implicit c: scala.reflect.ClassTag[T], implicit f: spire.algebra.Field[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">%</a> <a href="#spire.math;JetIsEuclideanRing.mod.b" title="spire.math.Jet[T]">b</a>
  override def <a title="(a: spire.math.Jet[T], b: spire.math.Jet[T])(spire.math.Jet[T], spire.math.Jet[T])" id="spire.math;JetIsEuclideanRing.quotmod">quotmod</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsEuclideanRing.quotmod.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.Jet[T]" id="spire.math;JetIsEuclideanRing.quotmod.b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math;JetIsEuclideanRing.quotmod.a" title="spire.math.Jet[T]">a</a> <a href="#spire.math;Jet./%" title="(b: spire.math.Jet[T])(implicit c: scala.reflect.ClassTag[T], implicit f: spire.algebra.Field[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])(spire.math.Jet[T], spire.math.Jet[T])">/%</a> <a href="#spire.math;JetIsEuclideanRing.quotmod.b" title="spire.math.Jet[T]">b</a>
  def <a title="(a: spire.math.Jet[T], b: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsEuclideanRing.gcd">gcd</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsEuclideanRing.gcd.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.Jet[T]" id="spire.math;JetIsEuclideanRing.gcd.b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    @tailrec def <a title="(a: spire.math.Jet[T], b: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsEuclideanRing.gcd._gcd">_gcd</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsEuclideanRing.gcd._gcd.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.Jet[T]" id="spire.math;JetIsEuclideanRing.gcd._gcd.b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#spire.math;JetIsEuclideanRing.gcd._gcd.b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.isZero" title="=&gt; Boolean">isZero</a><span class="delimiter">)</span> <a href="#spire.math;JetIsEuclideanRing.gcd._gcd.a" title="spire.math.Jet[T]">a</a> else <a href="#spire.math;JetIsEuclideanRing.gcd._gcd" title="(a: spire.math.Jet[T], b: spire.math.Jet[T])spire.math.Jet[T]">_gcd</a><span class="delimiter">(</span><a href="#spire.math;JetIsEuclideanRing.gcd._gcd.b" title="spire.math.Jet[T]">b</a>, <a href="#spire.math;JetIsEuclideanRing.gcd._gcd.a" title="spire.math.Jet[T]">a</a> <a href="#spire.math;Jet.-(b10a0e21a6)" title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">-</a> <span class="delimiter">(</span><a href="#spire.math;JetIsEuclideanRing.gcd._gcd.a" title="spire.math.Jet[T]">a</a> <a href="#spire.math;Jet./(b10a0e21a6)" title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">/</a> <a href="#spire.math;JetIsEuclideanRing.gcd._gcd.b" title="spire.math.Jet[T]">b</a><span class="delimiter">)</span>.<a href="#spire.math;Jet.round" title="()(implicit c: scala.reflect.ClassTag[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">round</a> <a href="#spire.math;Jet.*(b10a0e21a6)" title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">*</a> <a href="#spire.math;JetIsEuclideanRing.gcd._gcd.b" title="spire.math.Jet[T]">b</a><span class="delimiter">)</span>
    <a href="#spire.math;JetIsEuclideanRing.gcd._gcd" title="(a: spire.math.Jet[T], b: spire.math.Jet[T])spire.math.Jet[T]">_gcd</a><span class="delimiter">(</span><a href="#spire.math;JetIsEuclideanRing.gcd.a" title="spire.math.Jet[T]">a</a>, <a href="#spire.math;JetIsEuclideanRing.gcd.b" title="spire.math.Jet[T]">b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

private<span class="delimiter">[</span>math<span class="delimiter">]</span> trait <a title="trait JetIsField[T] extends AnyRef with spire.math.JetIsEuclideanRing[T] with spire.algebra.Field[spire.math.Jet[T]]" id="spire.math;JetIsField">JetIsField</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Float,Double<span class="delimiter">)</span> <a title="" id="spire.math;JetIsField;T">T</a><span class="delimiter">]</span>
  extends <a href="#spire.math;JetIsEuclideanRing" title="spire.math.JetIsEuclideanRing[T]">JetIsEuclideanRing</a><span class="delimiter">[</span>T<span class="delimiter">]</span> with <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[spire.math.Jet[T]]">Field</a><span class="delimiter">[</span>Jet<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  override def <a title="(n: Double)spire.math.Jet[T]" id="spire.math;JetIsField.fromDouble">fromDouble</a><span class="delimiter">(</span><a title="Double" id="spire.math;JetIsField.fromDouble.n">n</a>: <span title="Double">Double</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math.Jet.apply(fce0152b15)" title="(real: T)(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit s: spire.algebra.Semiring[T])spire.math.Jet[T]">Jet</a><a href="#spire.math;JetIsRing.c" title="=&gt; scala.reflect.ClassTag[T]" class="delimiter">(</a><a href="#spire.math;JetIsRing.f" title="=&gt; spire.algebra.Field[T]">f</a>.<a href="../algebra/Field.scala.html#spire.algebra;Field.fromDouble" title="(a: Double)T">fromDouble</a><span class="delimiter">(</span><a href="#spire.math;JetIsField.fromDouble.n" title="Double">n</a><span class="delimiter">)</span><span class="delimiter">)</span>
  def <a title="(a: spire.math.Jet[T], b: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsField.div">div</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsField.div.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.Jet[T]" id="spire.math;JetIsField.div.b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math;JetIsField.div.a" title="spire.math.Jet[T]">a</a> <a href="#spire.math;Jet./(b10a0e21a6)" title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">/</a> <a href="#spire.math;JetIsField.div.b" title="spire.math.Jet[T]">b</a>
  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsField.ceil">ceil</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsField.ceil.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsField.ceil.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.ceil" title="()(implicit c: scala.reflect.ClassTag[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">ceil</a>
  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsField.floor">floor</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsField.floor.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsField.floor.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.floor" title="()(implicit c: scala.reflect.ClassTag[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">floor</a>
  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsField.round">round</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsField.round.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsField.round.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.round" title="()(implicit c: scala.reflect.ClassTag[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">round</a>
  def <a title="(a: spire.math.Jet[T])Boolean" id="spire.math;JetIsField.isWhole">isWhole</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsField.isWhole.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math;JetIsField.isWhole.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.isWhole" title="()Boolean">isWhole</a>
<span class="delimiter">}</span>

private<span class="delimiter">[</span>math<span class="delimiter">]</span> trait <a title="trait JetIsTrig[T] extends AnyRef with spire.algebra.Trig[spire.math.Jet[T]]" id="spire.math;JetIsTrig">JetIsTrig</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math;JetIsTrig;T">T</a><span class="delimiter">]</span> extends <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[spire.math.Jet[T]]">Trig</a><span class="delimiter">[</span>Jet<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  implicit def <a title="=&gt; scala.reflect.ClassTag[T]" id="spire.math;JetIsTrig.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.math.JetDim" id="spire.math;JetIsTrig.d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a>
  implicit def <a title="=&gt; spire.algebra.Field[T]" id="spire.math;JetIsTrig.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.NRoot[T]" id="spire.math;JetIsTrig.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.IsReal[T]" id="spire.math;JetIsTrig.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.Trig[T]" id="spire.math;JetIsTrig.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.VectorSpace[Array[T],T]" id="spire.math;JetIsTrig.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span>

  def <a title="=&gt; spire.math.Jet[T]" id="spire.math;JetIsTrig.e">e</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math.Jet.apply(fce0152b15)" title="(real: T)(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit s: spire.algebra.Semiring[T])spire.math.Jet[T]">Jet</a><a href="#spire.math;JetIsTrig.c" title="=&gt; scala.reflect.ClassTag[T]" class="delimiter">(</a><a href="#spire.math;JetIsTrig.t" title="=&gt; spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.e" title="=&gt; T">e</a><span class="delimiter">)</span>
  def <a title="=&gt; spire.math.Jet[T]" id="spire.math;JetIsTrig.pi">pi</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math.Jet.apply(fce0152b15)" title="(real: T)(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit s: spire.algebra.Semiring[T])spire.math.Jet[T]">Jet</a><a href="#spire.math;JetIsTrig.c" title="=&gt; scala.reflect.ClassTag[T]" class="delimiter">(</a><a href="#spire.math;JetIsTrig.t" title="=&gt; spire.algebra.Trig[T]">t</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.pi" title="=&gt; T">pi</a><span class="delimiter">)</span>

  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.exp">exp</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.exp.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsTrig.exp.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.exp" title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">exp</a>
  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.expm1">expm1</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.expm1.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsTrig.expm1.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.exp" title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">exp</a> <a href="#spire.math;Jet.-(1ce898acce)" title="(b: T)(implicit f: spire.algebra.Field[T])spire.math.Jet[T]">-</a> <a href="#spire.math;JetIsTrig.f" title="=&gt; spire.algebra.Field[T]">f</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; T">one</a>
  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.log">log</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.log.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsTrig.log.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.log" title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">log</a>
  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.log1p">log1p</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.log1p.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">(</span><a href="#spire.math;JetIsTrig.log1p.a" title="spire.math.Jet[T]">a</a> <a href="#spire.math;Jet.+(1ce898acce)" title="(b: T)(implicit f: spire.algebra.Field[T])spire.math.Jet[T]">+</a> <a href="#spire.math;JetIsTrig.f" title="=&gt; spire.algebra.Field[T]">f</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; T">one</a><span class="delimiter">)</span>.<a href="#spire.math;Jet.log" title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">log</a>

  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.sin">sin</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.sin.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsTrig.sin.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.sin" title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">sin</a>
  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.cos">cos</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.cos.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsTrig.cos.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.cos" title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">cos</a>
  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.tan">tan</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.tan.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsTrig.tan.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.tan" title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">tan</a>

  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.asin">asin</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.asin.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsTrig.asin.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.asin" title="()(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">asin</a>
  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.acos">acos</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.acos.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsTrig.acos.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.acos" title="()(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">acos</a>
  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.atan">atan</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.atan.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsTrig.atan.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.atan" title="()(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">atan</a>
  def <a title="(y: spire.math.Jet[T], x: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.atan2">atan2</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.atan2.y">y</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.atan2.x">x</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsTrig.atan2.y" title="spire.math.Jet[T]">y</a>.<a href="#spire.math;Jet.atan2" title="(a: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">atan2</a><a href="#spire.math;JetIsTrig.f" title="=&gt; spire.algebra.Field[T]" class="delimiter">(</a><a href="#spire.math;JetIsTrig.atan2.x" title="spire.math.Jet[T]">x</a><span class="delimiter">)</span>

  def <a title="(x: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.sinh">sinh</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.sinh.x">x</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsTrig.sinh.x" title="spire.math.Jet[T]">x</a>.<a href="#spire.math;Jet.sinh" title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">sinh</a>
  def <a title="(x: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.cosh">cosh</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.cosh.x">x</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsTrig.cosh.x" title="spire.math.Jet[T]">x</a>.<a href="#spire.math;Jet.cosh" title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">cosh</a>
  def <a title="(x: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.tanh">tanh</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.tanh.x">x</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsTrig.tanh.x" title="spire.math.Jet[T]">x</a>.<a href="#spire.math;Jet.tanh" title="()(implicit f: spire.algebra.Field[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">tanh</a>

  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.toRadians">toRadians</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.toRadians.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsTrig.toRadians.a" title="spire.math.Jet[T]">a</a>
  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsTrig.toDegrees">toDegrees</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsTrig.toDegrees.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsTrig.toDegrees.a" title="spire.math.Jet[T]">a</a>
<span class="delimiter">}</span>

private<span class="delimiter">[</span>math<span class="delimiter">]</span> trait <a title="trait JetIsNRoot[T] extends AnyRef with spire.algebra.NRoot[spire.math.Jet[T]]" id="spire.math;JetIsNRoot">JetIsNRoot</a><span class="delimiter">[</span><a title="" id="spire.math;JetIsNRoot;T">T</a><span class="delimiter">]</span> extends <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[spire.math.Jet[T]]">NRoot</a><span class="delimiter">[</span>Jet<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  implicit def <a title="=&gt; spire.algebra.Field[T]" id="spire.math;JetIsNRoot.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.NRoot[T]" id="spire.math;JetIsNRoot.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.Trig[T]" id="spire.math;JetIsNRoot.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.IsReal[T]" id="spire.math;JetIsNRoot.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; scala.reflect.ClassTag[T]" id="spire.math;JetIsNRoot.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.VectorSpace[Array[T],T]" id="spire.math;JetIsNRoot.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span>

  def <a title="(a: spire.math.Jet[T], k: Int)spire.math.Jet[T]" id="spire.math;JetIsNRoot.nroot">nroot</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsNRoot.nroot.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Int" id="spire.math;JetIsNRoot.nroot.k">k</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsNRoot.nroot.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.nroot" title="(k: Int)(implicit e: spire.algebra.Eq[T], implicit f: spire.algebra.Field[T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">nroot</a><a href="#spire.math;JetIsNRoot.r" title="=&gt; spire.algebra.IsReal[T]" class="delimiter">(</a><a href="#spire.math;JetIsNRoot.nroot.k" title="Int">k</a><span class="delimiter">)</span>
  override def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsNRoot.sqrt">sqrt</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsNRoot.sqrt.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsNRoot.sqrt.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.sqrt" title="()(implicit f: spire.algebra.Field[T], implicit n: spire.algebra.NRoot[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">sqrt</a>
  def <a title="(a: spire.math.Jet[T], b: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsNRoot.fpow(3f60197e31)">fpow</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsNRoot.fpow(3f60197e31).a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.Jet[T]" id="spire.math;JetIsNRoot.fpow(3f60197e31).b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsNRoot.fpow(3f60197e31).a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.pow(0eadd74cfb)" title="(b: spire.math.Jet[T])(implicit c: scala.reflect.ClassTag[T], implicit e: spire.algebra.Eq[T], implicit f: spire.algebra.Field[T], implicit m: spire.algebra.Module[Array[T],T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T])spire.math.Jet[T]">pow</a><a href="#spire.math;JetIsNRoot.c" title="=&gt; scala.reflect.ClassTag[T]" class="delimiter">(</a><a href="#spire.math;JetIsNRoot.fpow(3f60197e31).b" title="spire.math.Jet[T]">b</a><span class="delimiter">)</span>
  def <a title="(a: T, b: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsNRoot.fpow(0cbd96532a)">fpow</a><span class="delimiter">(</span><a title="T" id="spire.math;JetIsNRoot.fpow(0cbd96532a).a">a</a>: <a href="#spire.math;JetIsNRoot;T" title="T">T</a>, <a title="spire.math.Jet[T]" id="spire.math;JetIsNRoot.fpow(0cbd96532a).b">b</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsNRoot.fpow(0cbd96532a).b" title="spire.math.Jet[T]">b</a>.<a href="#spire.math;Jet.powScalarToJet" title="(a: T)(implicit c: scala.reflect.ClassTag[T], implicit e: spire.algebra.Eq[T], implicit f: spire.algebra.Field[T], implicit m: spire.algebra.Module[Array[T],T], implicit r: spire.algebra.IsReal[T], implicit t: spire.algebra.Trig[T])spire.math.Jet[T]">powScalarToJet</a><a href="#spire.math;JetIsNRoot.c" title="=&gt; scala.reflect.ClassTag[T]" class="delimiter">(</a><a href="#spire.math;JetIsNRoot.fpow(0cbd96532a).a" title="T">a</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
private<span class="delimiter">[</span>math<span class="delimiter">]</span> class <a title="class JetEq[T] extends AnyRef with spire.algebra.Eq[spire.math.Jet[T]] with Serializable" id="spire.math;JetEq">JetEq</a><span class="delimiter">[</span><a title="" id="spire.math;JetEq;T">T</a> : Eq<span class="delimiter">]</span> extends <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[spire.math.Jet[T]]">Eq</a><span class="delimiter">[</span>Jet<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="(x: spire.math.Jet[T], y: spire.math.Jet[T])Boolean" id="spire.math;JetEq.eqv">eqv</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetEq.eqv.x">x</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.Jet[T]" id="spire.math;JetEq.eqv.y">y</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math;JetEq.eqv.x" title="spire.math.Jet[T]">x</a> <a href="#spire.math;Jet.eqv" title="(b: spire.math.Jet[T])(implicit o: spire.algebra.Eq[T])Boolean">eqv</a> <a href="#spire.math;JetEq.eqv.y" title="spire.math.Jet[T]">y</a>
  override def <a title="(x: spire.math.Jet[T], y: spire.math.Jet[T])Boolean" id="spire.math;JetEq.neqv">neqv</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetEq.neqv.x">x</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.Jet[T]" id="spire.math;JetEq.neqv.y">y</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.math;JetEq.neqv.x" title="spire.math.Jet[T]">x</a> <a href="#spire.math;Jet.neqv" title="(b: spire.math.Jet[T])(implicit o: spire.algebra.Eq[T])Boolean">neqv</a> <a href="#spire.math;JetEq.neqv.y" title="spire.math.Jet[T]">y</a>
<span class="delimiter">}</span>

private<span class="delimiter">[</span>math<span class="delimiter">]</span> trait <a title="trait JetIsSigned[T] extends AnyRef with spire.algebra.Signed[spire.math.Jet[T]]" id="spire.math;JetIsSigned">JetIsSigned</a><span class="delimiter">[</span><a title="" id="spire.math;JetIsSigned;T">T</a><span class="delimiter">]</span> extends <a href="../algebra/Signed.scala.html#spire.algebra;Signed" title="spire.algebra.Signed[spire.math.Jet[T]]">Signed</a><span class="delimiter">[</span>Jet<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  implicit def <a title="=&gt; spire.algebra.Field[T]" id="spire.math;JetIsSigned.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.IsReal[T]" id="spire.math;JetIsSigned.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.Trig[T]" id="spire.math;JetIsSigned.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  implicit def <a title="=&gt; spire.algebra.VectorSpace[Array[T],T]" id="spire.math;JetIsSigned.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>,T<span class="delimiter">]</span>

  def <a title="(a: spire.math.Jet[T])Int" id="spire.math;JetIsSigned.signum">signum</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsSigned.signum.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.math;JetIsSigned.signum.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.signum" title="()(implicit r: spire.algebra.Signed[T])Int">signum</a>
  def <a title="(a: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetIsSigned.abs">abs</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetIsSigned.abs.a">a</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math;JetIsSigned.abs.a" title="spire.math.Jet[T]">a</a>.<a href="#spire.math;Jet.abs" title="()(implicit f: spire.algebra.Field[T], implicit r: spire.algebra.IsReal[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">abs</a>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
private<span class="delimiter">[</span>math<span class="delimiter">]</span> class <a title="class JetAlgebra[T] extends AnyRef with spire.math.JetIsField[T] with spire.math.JetIsTrig[T] with spire.math.JetIsNRoot[T] with spire.math.JetIsSigned[T] with spire.algebra.VectorSpace[spire.math.Jet[T],T] with spire.algebra.FieldAlgebra[spire.math.Jet[T],T] with Serializable" id="spire.math;JetAlgebra">JetAlgebra</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.math;JetAlgebra;T">T</a><span class="delimiter">]</span><a href="#spire.math;JetAlgebra" title="spire.math.JetAlgebra[T]" class="delimiter">(</a>implicit
    val <a title="scala.reflect.ClassTag[T]" id="spire.math;JetAlgebra.c">c</a>: <span title="scala.reflect.ClassTag[T]">ClassTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, val <a title="spire.math.JetDim" id="spire.math;JetAlgebra.d">d</a>: <a href="#spire.math.JetDim.readResolve" title="spire.math.JetDim">JetDim</a>, val <a title="spire.algebra.Eq[T]" id="spire.math;JetAlgebra.eq">eq</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[T]">Eq</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, val <a title="spire.algebra.Field[T]" id="spire.math;JetAlgebra.f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[T]">Field</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, val <a title="spire.algebra.NRoot[T]" id="spire.math;JetAlgebra.n">n</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[T]">NRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>,
    val <a title="spire.algebra.Trig[T]" id="spire.math;JetAlgebra.t">t</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[T]">Trig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, val <a title="spire.algebra.IsReal[T]" id="spire.math;JetAlgebra.r">r</a>: <a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[T]">IsReal</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, val <a title="spire.algebra.VectorSpace[Array[T],T]" id="spire.math;JetAlgebra.v">v</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[T],T]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>
  extends <a href="#spire.math;JetIsField" title="spire.math.JetIsField[T]">JetIsField</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  with <a href="#spire.math;JetIsTrig" title="spire.math.JetIsTrig[T]">JetIsTrig</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  with <a href="#spire.math;JetIsNRoot" title="spire.math.JetIsNRoot[T]">JetIsNRoot</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  with <a href="#spire.math;JetIsSigned" title="spire.math.JetIsSigned[T]">JetIsSigned</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  with <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[spire.math.Jet[T],T]">VectorSpace</a><span class="delimiter">[</span>Jet<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span>
  with <a href="../algebra/RingAlgebra.scala.html#spire.algebra;FieldAlgebra" title="spire.algebra.FieldAlgebra[spire.math.Jet[T],T]">FieldAlgebra</a><span class="delimiter">[</span>Jet<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span>
  with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="=&gt; spire.algebra.Field[T]" id="spire.math;JetAlgebra.scalar">scalar</a> = <a href="#spire.math;JetAlgebra.f" title="=&gt; spire.algebra.Field[T]">f</a>
  def <a title="=&gt; spire.algebra.Field[T]" id="spire.math;JetAlgebra.nroot(3324ab74fa)">nroot</a> = <a href="#spire.math;JetAlgebra.f" title="=&gt; spire.algebra.Field[T]">f</a>
  def <a title="(a: T, w: spire.math.Jet[T])spire.math.Jet[T]" id="spire.math;JetAlgebra.timesl">timesl</a><span class="delimiter">(</span><a title="T" id="spire.math;JetAlgebra.timesl.a">a</a>: <a href="#spire.math;JetAlgebra;T" title="T">T</a>, <a title="spire.math.Jet[T]" id="spire.math;JetAlgebra.timesl.w">w</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#spire.math.Jet.apply(fce0152b15)" title="(real: T)(implicit c: scala.reflect.ClassTag[T], implicit d: spire.math.JetDim, implicit s: spire.algebra.Semiring[T])spire.math.Jet[T]">Jet</a><a href="#spire.math;JetAlgebra.c" title="=&gt; scala.reflect.ClassTag[T]" class="delimiter">(</a><a href="#spire.math;JetAlgebra.timesl.a" title="T">a</a><span class="delimiter">)</span> <a href="#spire.math;Jet.*(b10a0e21a6)" title="(b: spire.math.Jet[T])(implicit f: spire.algebra.Field[T], implicit v: spire.algebra.VectorSpace[Array[T],T])spire.math.Jet[T]">*</a> <a href="#spire.math;JetAlgebra.timesl.w" title="spire.math.Jet[T]">w</a>
  def <a title="(x: spire.math.Jet[T], y: spire.math.Jet[T])T" id="spire.math;JetAlgebra.dot">dot</a><span class="delimiter">(</span><a title="spire.math.Jet[T]" id="spire.math;JetAlgebra.dot.x">x</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="spire.math.Jet[T]" id="spire.math;JetAlgebra.dot.y">y</a>: <a href="#spire.math;Jet.canEqual" title="spire.math.Jet[T]">Jet</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.math;JetAlgebra;T" title="T">T</a> = <span class="delimiter">{</span>
    <a href="#spire.math;JetAlgebra.dot.x" title="spire.math.Jet[T]">x</a>.<a href="#spire.math;Jet.copy$default$2" title="(xs: Array[T])scala.collection.mutable.ArrayOps[T]">infinitesimal</a>.<span title="(that: scala.collection.GenIterable[T])(implicit bf: scala.collection.generic.CanBuildFrom[Array[T],(T, T),Array[(T, T)]])Array[(T, T)]">zip</span><span title="(xs: Array[(T, T)])scala.collection.mutable.ArrayOps[(T, T)]" class="delimiter">(</span><a href="#spire.math;JetAlgebra.dot.y" title="spire.math.Jet[T]">y</a>.<a href="#spire.math;Jet.copy$default$2" title="(xs: Array[T])scala.collection.mutable.WrappedArray[T]">infinitesimal</a><span class="delimiter">)</span>.<span title="(z: T)(op: (T, (T, T)) =&gt; T)T">foldLeft</span><span class="delimiter">{</span><a href="#spire.math;JetAlgebra.scalar" title="=&gt; spire.algebra.Field[T]">scalar</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">times</a><span class="delimiter">(</span><a href="#spire.math;JetAlgebra.dot.x" title="spire.math.Jet[T]">x</a>.<a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a>, <a href="#spire.math;JetAlgebra.dot.y" title="spire.math.Jet[T]">y</a>.<a href="#spire.math;Jet.copy$default$1" title="=&gt; T">real</a><span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">{</span>
      <span class="delimiter">(</span><a title="T" id="spire.math;JetAlgebra.dot.$anonfun.xx">xx</a>, <a title="(T, T)" id="spire.math;JetAlgebra.dot.$anonfun.yy">yy</a><span class="delimiter">)</span> =&gt; <a href="#spire.math;JetAlgebra.scalar" title="=&gt; spire.algebra.Field[T]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: T, y: T)T">plus</a><span class="delimiter">(</span><a href="#spire.math;JetAlgebra.dot.$anonfun.xx" title="T">xx</a>, <a href="#spire.math;JetAlgebra.scalar" title="=&gt; spire.algebra.Field[T]">scalar</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: T, y: T)T">times</a><span class="delimiter">(</span><a href="#spire.math;JetAlgebra.dot.$anonfun.yy" title="(T, T)">yy</a>.<span title="=&gt; T">_1</span>, <a href="#spire.math;JetAlgebra.dot.$anonfun.yy" title="(T, T)">yy</a>.<span title="=&gt; T">_2</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
