<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>spire/spire/optional/mapIntIntPermutation.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package spire.optional

import scala.<span class="delimiter">{</span>specialized =&gt; sp<span class="delimiter">}</span>

import scala.collection.SeqLike
import scala.collection.generic.CanBuildFrom

import spire.algebra.<span class="delimiter">{</span>Action, Group<span class="delimiter">}</span>
import spire.algebra.partial.PartialAction
import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.cfor" title="spire.syntax.cfor.type">cfor</a>._
import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.group" title="spire.syntax.group.type">group</a>._
import spire.util._

final class <a title="class MapIntIntIntAction extends AnyRef with spire.algebra.Action[Int,Map[Int,Int]]" id="spire.optional;MapIntIntIntAction">MapIntIntIntAction</a> extends <a href="../algebra/Action.scala.html#spire.algebra;Action" title="spire.algebra.Action[Int,Map[Int,Int]]">Action</a><span class="delimiter">[</span>Int, Map<span class="delimiter">[</span>Int, Int<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  def <a title="(k: Int, perm: Map[Int,Int])Int" id="spire.optional;MapIntIntIntAction.actr">actr</a><span class="delimiter">(</span><a title="Int" id="spire.optional;MapIntIntIntAction.actr.k">k</a>: <span title="Int">Int</span>, <a title="Map[Int,Int]" id="spire.optional;MapIntIntIntAction.actr.perm">perm</a>: <span title="Map[Int,Int]">Map</span><span class="delimiter">[</span>Int, Int<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.optional;MapIntIntIntAction.actr.perm" title="Map[Int,Int]">perm</a>.<span title="(key: Int, default: =&gt; Int)Int">getOrElse</span><span class="delimiter">(</span><a href="#spire.optional;MapIntIntIntAction.actr.k" title="Int">k</a>, <a href="#spire.optional;MapIntIntIntAction.actr.k" title="Int">k</a><span class="delimiter">)</span>
  def <a title="(perm: Map[Int,Int], k: Int)Int" id="spire.optional;MapIntIntIntAction.actl">actl</a><span class="delimiter">(</span><a title="Map[Int,Int]" id="spire.optional;MapIntIntIntAction.actl.perm">perm</a>: <span title="Map[Int,Int]">Map</span><span class="delimiter">[</span>Int, Int<span class="delimiter">]</span>, <a title="Int" id="spire.optional;MapIntIntIntAction.actl.k">k</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.optional;MapIntIntIntAction.actl.perm" title="Map[Int,Int]">perm</a>.<span title="(p: ((Int, Int)) =&gt; Boolean)Option[(Int, Int)]">find</span><span class="delimiter">(</span><a href="#spire.optional;MapIntIntIntAction.actl.$anonfun.x$1" title="(Int, Int)">_</a>.<span title="=&gt; Int">_2</span> <span title="(x: Int)Boolean">==</span> <a href="#spire.optional;MapIntIntIntAction.actl.k" title="Int">k</a><span class="delimiter">)</span>.<span title="(ifEmpty: =&gt; Int)(f: ((Int, Int)) =&gt; Int)Int">fold</span><span class="delimiter">(</span><a href="#spire.optional;MapIntIntIntAction.actl.k" title="Int">k</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.optional;MapIntIntIntAction.actl.$anonfun.x$2" title="(Int, Int)">_</a>.<span title="=&gt; Int">_1</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a title="class MapIntIntGroup extends AnyRef with spire.algebra.Group[Map[Int,Int]]" id="spire.optional;MapIntIntGroup">MapIntIntGroup</a> extends <a href="../algebra/Group.scala.html#spire.algebra;Group" title="spire.algebra.Group[Map[Int,Int]]">Group</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>Int, Int<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  def <a title="=&gt; scala.collection.immutable.Map[Int,Int]" id="spire.optional;MapIntIntGroup.id">id</a> = <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[Int,Int]" class="delimiter">[</span><span title="Int">Int</span>, <span title="Int">Int</span><span class="delimiter">]</span>
  def <a title="(x: Map[Int,Int], y: Map[Int,Int])scala.collection.immutable.Map[Int,Int]" id="spire.optional;MapIntIntGroup.op">op</a><span class="delimiter">(</span><a title="Map[Int,Int]" id="spire.optional;MapIntIntGroup.op.x">x</a>: <span title="Map[Int,Int]">Map</span><span class="delimiter">[</span>Int, Int<span class="delimiter">]</span>, <a title="Map[Int,Int]" id="spire.optional;MapIntIntGroup.op.y">y</a>: <span title="Map[Int,Int]">Map</span><span class="delimiter">[</span>Int, Int<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val preimages = <a href="#spire.optional;MapIntIntGroup.op.x" title="Map[Int,Int]">x</a>.<span title="=&gt; Iterable[Int]">keys</span> <a title="Iterable[Int]" id="spire.optional;MapIntIntGroup.op.preimages">++</a> <a href="#spire.optional;MapIntIntGroup.op.y" title="Map[Int,Int]">y</a>.<span title="=&gt; Iterable[Int]">keys</span>

    <span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[Int,Int]" class="delimiter">[</span><span title="Int">Int</span>, <span title="Int">Int</span><span class="delimiter">]</span> <a href="#spire.optional;MapIntIntGroup.op.x$3" title="(z: scala.collection.immutable.Map[Int,Int])(op: (scala.collection.immutable.Map[Int,Int], Int) =&gt; scala.collection.immutable.Map[Int,Int])scala.collection.immutable.Map[Int,Int]">/:</a> <a href="#spire.optional;MapIntIntGroup.op.preimages" title="Iterable[Int]">preimages</a><span class="delimiter">)</span> <a href="#spire.optional;MapIntIntGroup.op.$anonfun.x0$1" title="scala.collection.immutable.Map[Int,Int]" class="delimiter">{</a>
      case <span class="delimiter">(</span><a title="scala.collection.immutable.Map[Int,Int]" id="spire.optional;MapIntIntGroup.op.$anonfun.prevMap">prevMap</a>, <a title="Int" id="spire.optional;MapIntIntGroup.op.$anonfun.preimage">preimage</a><span class="delimiter">)</span> =&gt;
        val <a title="Int" id="spire.optional;MapIntIntGroup.op.$anonfun.imageX">imageX</a> = <a href="#spire.optional;MapIntIntGroup.op.x" title="Map[Int,Int]">x</a>.<span title="(key: Int, default: =&gt; Int)Int">getOrElse</span><span class="delimiter">(</span><a href="#spire.optional;MapIntIntGroup.op.$anonfun.preimage" title="Int">preimage</a>, <a href="#spire.optional;MapIntIntGroup.op.$anonfun.preimage" title="Int">preimage</a><span class="delimiter">)</span>
        val <a title="Int" id="spire.optional;MapIntIntGroup.op.$anonfun.image">image</a> = <a href="#spire.optional;MapIntIntGroup.op.y" title="Map[Int,Int]">y</a>.<span title="(key: Int, default: =&gt; Int)Int">getOrElse</span><span class="delimiter">(</span><a href="#spire.optional;MapIntIntGroup.op.$anonfun.imageX" title="Int">imageX</a>, <a href="#spire.optional;MapIntIntGroup.op.$anonfun.imageX" title="Int">imageX</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#spire.optional;MapIntIntGroup.op.$anonfun.preimage" title="Int">preimage</a> <span title="(x: Int)Boolean">!=</span> <a href="#spire.optional;MapIntIntGroup.op.$anonfun.image" title="Int">image</a><span class="delimiter">)</span> <a href="#spire.optional;MapIntIntGroup.op.$anonfun.prevMap" title="scala.collection.immutable.Map[Int,Int]">prevMap</a> <span title="(kv: (Int, Int))scala.collection.immutable.Map[Int,Int]">+</span> <span class="delimiter">(</span><a href="#spire.optional;MapIntIntGroup.op.$anonfun.preimage" title="(self: Int)ArrowAssoc[Int]">preimage</a> <span title="(y: Int)(Int, Int)">-&gt;</span> <a href="#spire.optional;MapIntIntGroup.op.$anonfun.image" title="Int">image</a><span class="delimiter">)</span> else <a href="#spire.optional;MapIntIntGroup.op.$anonfun.prevMap" title="scala.collection.immutable.Map[Int,Int]">prevMap</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  def <a title="(a: Map[Int,Int])Map[Int,Int]" id="spire.optional;MapIntIntGroup.inverse">inverse</a><span class="delimiter">(</span><a title="Map[Int,Int]" id="spire.optional;MapIntIntGroup.inverse.a">a</a>: <span title="Map[Int,Int]">Map</span><span class="delimiter">[</span>Int, Int<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Map[Int,Int]">Map</span><span class="delimiter">[</span>Int, Int<span class="delimiter">]</span> = <a href="#spire.optional;MapIntIntGroup.inverse.a" title="Map[Int,Int]">a</a>.<span title="(f: ((Int, Int)) =&gt; (Int, Int))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[Int,Int],(Int, Int),scala.collection.immutable.Map[Int,Int]])scala.collection.immutable.Map[Int,Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map.Coll,(Int, Int),scala.collection.immutable.Map[Int,Int]]" class="delimiter">(</span><a href="#spire.optional;MapIntIntGroup.inverse.$anonfun.x$4" title="(Int, Int)">_</a>.<span title="=&gt; (Int, Int)">swap</span><span class="delimiter">)</span>.<span title="(implicit ev: &lt;:&lt;[(Int, Int),(Int, Int)])scala.collection.immutable.Map[Int,Int]">toMap</span>
<span class="delimiter">}</span>

final class <a title="class MapIntIntSeqPartialAction[A, SA &lt;: scala.collection.SeqLike[A,SA]] extends AnyRef with spire.algebra.partial.PartialAction[SA,Map[Int,Int]]" id="spire.optional;MapIntIntSeqPartialAction">MapIntIntSeqPartialAction</a><span class="delimiter">[</span><a title="" id="spire.optional;MapIntIntSeqPartialAction;A">A</a>, <a title=" &lt;: scala.collection.SeqLike[A,SA]" id="spire.optional;MapIntIntSeqPartialAction;SA">SA</a> &lt;: SeqLike<span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">]</span><a href="#spire.optional;MapIntIntSeqPartialAction" title="spire.optional.MapIntIntSeqPartialAction[A,SA]" class="delimiter">(</a>implicit <a title="scala.collection.generic.CanBuildFrom[SA,A,SA]" id="spire.optional;MapIntIntSeqPartialAction.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[SA,A,SA]">CanBuildFrom</span><span class="delimiter">[</span>SA, A, SA<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="../algebra/partial/PartialAction.scala.html#spire.algebra.partial;PartialAction" title="spire.algebra.partial.PartialAction[SA,Map[Int,Int]]">PartialAction</a><span class="delimiter">[</span>SA, Map<span class="delimiter">[</span>Int, Int<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  import <a href="#spire.optional.mapIntIntPermutation" title="spire.optional.mapIntIntPermutation.type">mapIntIntPermutation</a>._
  def <a title="(perm: Map[Int,Int], sa: SA)spire.util.Opt[SA]" id="spire.optional;MapIntIntSeqPartialAction.partialActl">partialActl</a><span class="delimiter">(</span><a title="Map[Int,Int]" id="spire.optional;MapIntIntSeqPartialAction.partialActl.perm">perm</a>: <span title="Map[Int,Int]">Map</span><span class="delimiter">[</span>Int, Int<span class="delimiter">]</span>, <a title="SA" id="spire.optional;MapIntIntSeqPartialAction.partialActl.sa">sa</a>: <a href="#spire.optional;MapIntIntSeqPartialAction;SA" title="SA">SA</a><span class="delimiter">)</span>: <a href="../util/Opt.scala.html#spire.util;Opt" title="spire.util.Opt[SA]">Opt</a><span class="delimiter">[</span>SA<span class="delimiter">]</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.optional;MapIntIntSeqPartialAction.partialActl.perm" title="Map[Int,Int]">perm</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> return <a href="../util/Opt.scala.html#spire.util.Opt.apply" title="(a: SA)spire.util.Opt[SA]">Opt</a><span class="delimiter">(</span><a href="#spire.optional;MapIntIntSeqPartialAction.partialActl.sa" title="SA">sa</a><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#spire.optional;MapIntIntSeqPartialAction.partialActl.perm" title="Map[Int,Int]">perm</a>.<span title="=&gt; Iterable[Int]">keys</span>.<span title="(implicit cmp: Ordering[Int])Int">max</span> <span title="(x: Int)Boolean">&gt;=</span> <a href="#spire.optional;MapIntIntSeqPartialAction.partialActl.sa" title="SA">sa</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> return <a href="../util/Opt.scala.html#spire.util.Opt" title="spire.util.Opt.type">Opt</a>.<a href="../util/Opt.scala.html#spire.util.Opt.empty" title="[A]=&gt; spire.util.Opt[A]">empty</a><span title="spire.util.Opt[SA]" class="delimiter">[</span><a href="#spire.optional;MapIntIntSeqPartialAction;SA" title="SA">SA</a><span class="delimiter">]</span>
    val <a title="scala.collection.mutable.Builder[A,SA]" id="spire.optional;MapIntIntSeqPartialAction.partialActl.builder">builder</a> = <a href="#spire.optional;MapIntIntSeqPartialAction.cbf" title="()scala.collection.mutable.Builder[A,SA]">cbf</a><span class="delimiter">(</span><span class="delimiter">)</span>
    cforRange<span class="delimiter">(</span><span title="Int(0)" class="int">0</span> until <a href="#spire.optional;MapIntIntSeqPartialAction.partialActl.sa" title="SA">sa</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <a title="Int" id="spire.optional;MapIntIntSeqPartialAction.partialActl.limit$macro$409" class="delimiter">{</a> k =&gt;
      <a href="#spire.optional;MapIntIntSeqPartialAction.partialActl.builder" title="scala.collection.mutable.Builder[A,SA]">builder</a> <span title="(elem: A)builder.type">+=</span> <a href="#spire.optional;MapIntIntSeqPartialAction.partialActl.sa" title="(idx: Int)A">sa</a><span class="delimiter">(</span><a href="#spire.optional;MapIntIntSeqPartialAction.partialActl.perm" title="Map[Int,Int]">perm</a>.<span title="(key: Int, default: =&gt; Int)Int">getOrElse</span><span class="delimiter">(</span>k, k<span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="../util/Opt.scala.html#spire.util.Opt.apply" title="(a: SA)spire.util.Opt[SA]">Opt</a><span class="delimiter">(</span><a href="#spire.optional;MapIntIntSeqPartialAction.partialActl.builder" title="scala.collection.mutable.Builder[A,SA]">builder</a>.<span title="()SA">result</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  def <a title="(sa: SA, perm: Map[Int,Int])spire.util.Opt[SA]" id="spire.optional;MapIntIntSeqPartialAction.partialActr">partialActr</a><span class="delimiter">(</span><a title="SA" id="spire.optional;MapIntIntSeqPartialAction.partialActr.sa">sa</a>: <a href="#spire.optional;MapIntIntSeqPartialAction;SA" title="SA">SA</a>, <a title="Map[Int,Int]" id="spire.optional;MapIntIntSeqPartialAction.partialActr.perm">perm</a>: <span title="Map[Int,Int]">Map</span><span class="delimiter">[</span>Int, Int<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#spire.optional;MapIntIntSeqPartialAction.partialActl" title="(perm: Map[Int,Int], sa: SA)spire.util.Opt[SA]">partialActl</a><span class="delimiter">(</span><a href="#spire.optional.mapIntIntPermutation.MapIntIntGroup" title="=&gt; spire.algebra.Group[Map[Int,Int]]">perm</a>.<a href="../algebra/Group.scala.html#spire.algebra;Group.inverse" title="(a: Map[Int,Int])Map[Int,Int]">inverse</a>, <a href="#spire.optional;MapIntIntSeqPartialAction.partialActr.sa" title="SA">sa</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

object <a title="spire.optional.mapIntIntPermutation.type" id="spire.optional.mapIntIntPermutation">mapIntIntPermutation</a> <a href="#spire.optional.mapIntIntPermutation" title="spire.optional.mapIntIntPermutation.type" class="delimiter">{</a>
  implicit val <a title="spire.algebra.Action[Int,Map[Int,Int]]" id="spire.optional.mapIntIntPermutation.MapIntIntIntAction">MapIntIntIntAction</a>: <a href="../algebra/Action.scala.html#spire.algebra;Action" title="spire.algebra.Action[Int,Map[Int,Int]]">Action</a><span class="delimiter">[</span>Int, Map<span class="delimiter">[</span>Int, Int<span class="delimiter">]</span><span class="delimiter">]</span> = new <a href="#spire.optional;MapIntIntIntAction" title="spire.optional.MapIntIntIntAction">MapIntIntIntAction</a>
  implicit val <a title="spire.algebra.Group[Map[Int,Int]]" id="spire.optional.mapIntIntPermutation.MapIntIntGroup">MapIntIntGroup</a>: <a href="../algebra/Group.scala.html#spire.algebra;Group" title="spire.algebra.Group[Map[Int,Int]]">Group</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>Int, Int<span class="delimiter">]</span><span class="delimiter">]</span> = new <a href="#spire.optional;MapIntIntGroup" title="spire.optional.MapIntIntGroup">MapIntIntGroup</a>
  implicit def <a title="[A, CC[A] &lt;: scala.collection.SeqLike[A,CC[A]]](implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])spire.algebra.partial.PartialAction[CC[A],Map[Int,Int]]" id="spire.optional.mapIntIntPermutation.MapIntIntSeqPartialAction">MapIntIntSeqPartialAction</a><span class="delimiter">[</span><a title="" id="spire.optional.mapIntIntPermutation.MapIntIntSeqPartialAction;A">A</a>, <a title="[A] &lt;: scala.collection.SeqLike[A,CC[A]]" id="spire.optional.mapIntIntPermutation.MapIntIntSeqPartialAction;CC">CC</a><span class="delimiter">[</span><a title="" id="spire.optional.mapIntIntPermutation.MapIntIntSeqPartialAction;CC;A">A</a><span class="delimiter">]</span> &lt;: SeqLike<span class="delimiter">[</span>A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" id="spire.optional.mapIntIntPermutation.MapIntIntSeqPartialAction.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../algebra/partial/PartialAction.scala.html#spire.algebra.partial;PartialAction" title="spire.algebra.partial.PartialAction[CC[A],Map[Int,Int]]">PartialAction</a><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, Map<span class="delimiter">[</span>Int, Int<span class="delimiter">]</span><span class="delimiter">]</span> = new <a href="#spire.optional;MapIntIntSeqPartialAction" title="spire.optional.MapIntIntSeqPartialAction[A,CC[A]]">MapIntIntSeqPartialAction</a><span class="delimiter">[</span>A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
