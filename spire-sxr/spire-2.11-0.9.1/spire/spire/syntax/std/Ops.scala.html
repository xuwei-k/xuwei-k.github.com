<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>spire/spire/syntax/std/Ops.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package spire.syntax.std

import scala.collection.SeqLike
import scala.collection.generic.CanBuildFrom
import scala.reflect.ClassTag
import scala.<span class="delimiter">{</span>specialized =&gt; sp<span class="delimiter">}</span>

import spire.algebra.<span class="delimiter">{</span>AdditiveMonoid, Field, MultiplicativeMonoid, NRoot, Order, PartialOrder, Signed<span class="delimiter">}</span>
import spire.math.<span class="delimiter">{</span>Natural, Number, QuickSort, SafeLong, Searching, ULong<span class="delimiter">}</span>
import spire.syntax.<a href="../package.scala.html#spire.syntax.package.cfor" title="spire.syntax.cfor.type">cfor</a>._
import spire.syntax.<a href="../package.scala.html#spire.syntax.package.field" title="spire.syntax.field.type">field</a>._
import spire.syntax.<a href="../package.scala.html#spire.syntax.package.nroot" title="spire.syntax.nroot.type">nroot</a>._
import spire.syntax.<a href="../package.scala.html#spire.syntax.package.order" title="spire.syntax.order.type">order</a>._
import spire.syntax.<a href="../package.scala.html#spire.syntax.package.signed" title="spire.syntax.signed.type">signed</a>._

final class <a href="#spire.syntax.std;LiteralIntOps.lhs" title="class LiteralIntOps extends AnyVal" id="spire.syntax.std.LiteralIntOps">LiteralIntOps</a><a href="#spire.syntax.std.LiteralIntOps" title="spire.syntax.std.LiteralIntOps" class="delimiter">(</a>val <a title="Int" id="spire.syntax.std;LiteralIntOps.lhs">lhs</a>: <span title="Int">Int</span><span class="delimiter">)</span> extends <a href="#spire.syntax.std.LiteralIntOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="(rhs: Int)Int" id="spire.syntax.std;LiteralIntOps./~">/~</a><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;LiteralIntOps./~.rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.syntax.std;LiteralIntOps.lhs" title="=&gt; Int">lhs</a> <span title="(x: Int)Int">/</span> <a href="#spire.syntax.std;LiteralIntOps./~.rhs" title="Int">rhs</a>
  def <a title="(rhs: Int)(Int, Int)" id="spire.syntax.std;LiteralIntOps./%">/%</a><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;LiteralIntOps./%.rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="(Int, Int)" class="delimiter">(</span>Int, Int<span class="delimiter">)</span> = <span title="(_1: Int, _2: Int)(Int, Int)" class="delimiter">(</span><a href="#spire.syntax.std;LiteralIntOps.lhs" title="=&gt; Int">lhs</a> <span title="(x: Int)Int">/</span> <a href="#spire.syntax.std;LiteralIntOps./%.rhs" title="Int">rhs</a>, <a href="#spire.syntax.std;LiteralIntOps.lhs" title="=&gt; Int">lhs</a> <span title="(x: Int)Int">%</span> <a href="#spire.syntax.std;LiteralIntOps./%.rhs" title="Int">rhs</a><span class="delimiter">)</span>
  def <a title="(rhs: Int)Int" id="spire.syntax.std;LiteralIntOps.pow">pow</a><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;LiteralIntOps.pow.rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span title="Math.type">Math</span>.<span title="(x$1: Double, x$2: Double)Double">pow</span><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralIntOps.lhs" title="=&gt; Double">lhs</a>, <a href="#spire.syntax.std;LiteralIntOps.pow.rhs" title="=&gt; Double">rhs</a><span class="delimiter">)</span>.<span title="=&gt; Int">toInt</span>
  def <a title="(rhs: Int)Int" id="spire.syntax.std;LiteralIntOps.**">**</a><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;LiteralIntOps.**.rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span title="Math.type">Math</span>.<span title="(x$1: Double, x$2: Double)Double">pow</span><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralIntOps.lhs" title="=&gt; Double">lhs</a>, <a href="#spire.syntax.std;LiteralIntOps.**.rhs" title="=&gt; Double">rhs</a><span class="delimiter">)</span>.<span title="=&gt; Int">toInt</span>
  def <a title="()BigInt" id="spire.syntax.std;LiteralIntOps.!">!</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = spire.math.<a href="../../math/package.scala.html#spire.math.package.fact" title="(n: Long)BigInt">fact</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralIntOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>
  def <a title="(rhs: Int)BigInt" id="spire.syntax.std;LiteralIntOps.choose">choose</a><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;LiteralIntOps.choose.rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = spire.math.<a href="../../math/package.scala.html#spire.math.package.choose" title="(n: Long, k: Long)BigInt">choose</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralIntOps.lhs" title="=&gt; Long">lhs</a>, <a href="#spire.syntax.std;LiteralIntOps.choose.rhs" title="=&gt; Long">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax.std;LiteralLongOps.lhs" title="class LiteralLongOps extends AnyVal" id="spire.syntax.std.LiteralLongOps">LiteralLongOps</a><a href="#spire.syntax.std.LiteralLongOps" title="spire.syntax.std.LiteralLongOps" class="delimiter">(</a>val <a title="Long" id="spire.syntax.std;LiteralLongOps.lhs">lhs</a>: <span title="Long">Long</span><span class="delimiter">)</span> extends <a href="#spire.syntax.std.LiteralLongOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="(rhs: Long)Long" id="spire.syntax.std;LiteralLongOps./~">/~</a><span class="delimiter">(</span><a title="Long" id="spire.syntax.std;LiteralLongOps./~.rhs">rhs</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Long">Long</span> = <a href="#spire.syntax.std;LiteralLongOps.lhs" title="=&gt; Long">lhs</a> <span title="(x: Long)Long">/</span> <a href="#spire.syntax.std;LiteralLongOps./~.rhs" title="Long">rhs</a>
  def <a title="(rhs: Long)(Long, Long)" id="spire.syntax.std;LiteralLongOps./%">/%</a><span class="delimiter">(</span><a title="Long" id="spire.syntax.std;LiteralLongOps./%.rhs">rhs</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="(Long, Long)" class="delimiter">(</span>Long, Long<span class="delimiter">)</span> = <span title="(_1: Long, _2: Long)(Long, Long)" class="delimiter">(</span><a href="#spire.syntax.std;LiteralLongOps.lhs" title="=&gt; Long">lhs</a> <span title="(x: Long)Long">/</span> <a href="#spire.syntax.std;LiteralLongOps./%.rhs" title="Long">rhs</a>, <a href="#spire.syntax.std;LiteralLongOps.lhs" title="=&gt; Long">lhs</a> <span title="(x: Long)Long">%</span> <a href="#spire.syntax.std;LiteralLongOps./%.rhs" title="Long">rhs</a><span class="delimiter">)</span>
  def <a title="(rhs: Long)Long" id="spire.syntax.std;LiteralLongOps.pow">pow</a><span class="delimiter">(</span><a title="Long" id="spire.syntax.std;LiteralLongOps.pow.rhs">rhs</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Long">Long</span> = spire.math.<a href="../../math/package.scala.html#spire.math.package.pow(3c710e3f90)" title="(base: Long, exponent: Long)Long">pow</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralLongOps.lhs" title="=&gt; Long">lhs</a>, <a href="#spire.syntax.std;LiteralLongOps.pow.rhs" title="Long">rhs</a><span class="delimiter">)</span>
  def <a title="(rhs: Long)Long" id="spire.syntax.std;LiteralLongOps.**">**</a><span class="delimiter">(</span><a title="Long" id="spire.syntax.std;LiteralLongOps.**.rhs">rhs</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Long">Long</span> = spire.math.<a href="../../math/package.scala.html#spire.math.package.pow(3c710e3f90)" title="(base: Long, exponent: Long)Long">pow</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralLongOps.lhs" title="=&gt; Long">lhs</a>, <a href="#spire.syntax.std;LiteralLongOps.**.rhs" title="Long">rhs</a><span class="delimiter">)</span>
  def <a title="()BigInt" id="spire.syntax.std;LiteralLongOps.!">!</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = spire.math.<a href="../../math/package.scala.html#spire.math.package.fact" title="(n: Long)BigInt">fact</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralLongOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>
  def <a title="(rhs: Long)BigInt" id="spire.syntax.std;LiteralLongOps.choose">choose</a><span class="delimiter">(</span><a title="Long" id="spire.syntax.std;LiteralLongOps.choose.rhs">rhs</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = spire.math.<a href="../../math/package.scala.html#spire.math.package.choose" title="(n: Long, k: Long)BigInt">choose</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralLongOps.lhs" title="=&gt; Long">lhs</a>, <a href="#spire.syntax.std;LiteralLongOps.choose.rhs" title="Long">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax.std;LiteralDoubleOps.lhs" title="class LiteralDoubleOps extends AnyVal" id="spire.syntax.std.LiteralDoubleOps">LiteralDoubleOps</a><a href="#spire.syntax.std.LiteralDoubleOps" title="spire.syntax.std.LiteralDoubleOps" class="delimiter">(</a>val <a title="Double" id="spire.syntax.std;LiteralDoubleOps.lhs">lhs</a>: <span title="Double">Double</span><span class="delimiter">)</span> extends <a href="#spire.syntax.std.LiteralDoubleOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="(rhs: Double)Double" id="spire.syntax.std;LiteralDoubleOps.pow">pow</a><span class="delimiter">(</span><a title="Double" id="spire.syntax.std;LiteralDoubleOps.pow.rhs">rhs</a>: <span title="Double">Double</span><span class="delimiter">)</span>: <span title="Double">Double</span> = spire.math.<a href="../../math/package.scala.html#spire.math.package.pow(cf8359b3f7)" title="(base: Double, exponent: Double)Double">pow</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralDoubleOps.lhs" title="=&gt; Double">lhs</a>, <a href="#spire.syntax.std;LiteralDoubleOps.pow.rhs" title="Double">rhs</a><span class="delimiter">)</span>
  def <a title="(rhs: Double)Double" id="spire.syntax.std;LiteralDoubleOps.**">**</a><span class="delimiter">(</span><a title="Double" id="spire.syntax.std;LiteralDoubleOps.**.rhs">rhs</a>: <span title="Double">Double</span><span class="delimiter">)</span>: <span title="Double">Double</span> = spire.math.<a href="../../math/package.scala.html#spire.math.package.pow(cf8359b3f7)" title="(base: Double, exponent: Double)Double">pow</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralDoubleOps.lhs" title="=&gt; Double">lhs</a>, <a href="#spire.syntax.std;LiteralDoubleOps.**.rhs" title="Double">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

class <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="class LiteralBigIntOps extends AnyVal" id="spire.syntax.std.LiteralBigIntOps">LiteralBigIntOps</a><a href="#spire.syntax.std.LiteralBigIntOps" title="spire.syntax.std.LiteralBigIntOps" class="delimiter">(</a>val <a title="BigInt" id="spire.syntax.std;LiteralBigIntOps.lhs">lhs</a>: <span title="BigInt">BigInt</span><span class="delimiter">)</span> extends <a href="#spire.syntax.std.LiteralBigIntOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="(rhs: BigInt)BigInt" id="spire.syntax.std;LiteralBigIntOps./~(7234e90845)">/~</a><span class="delimiter">(</span><a title="BigInt" id="spire.syntax.std;LiteralBigIntOps./~(7234e90845).rhs">rhs</a>: <span title="BigInt">BigInt</span><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a> <span title="(that: scala.math.BigInt)scala.math.BigInt">/</span> <a href="#spire.syntax.std;LiteralBigIntOps./~(7234e90845).rhs" title="BigInt">rhs</a>
  def <a title="(rhs: BigInt)BigInt" id="spire.syntax.std;LiteralBigIntOps.pow">pow</a><span class="delimiter">(</span><a title="BigInt" id="spire.syntax.std;LiteralBigIntOps.pow.rhs">rhs</a>: <span title="BigInt">BigInt</span><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = spire.math.<a href="../../math/package.scala.html#spire.math.package.pow(83b8c5e536)" title="(base: BigInt, ex: BigInt)BigInt">pow</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a>, <a href="#spire.syntax.std;LiteralBigIntOps.pow.rhs" title="BigInt">rhs</a><span class="delimiter">)</span>
  def <a title="(rhs: BigInt)BigInt" id="spire.syntax.std;LiteralBigIntOps.**">**</a><span class="delimiter">(</span><a title="BigInt" id="spire.syntax.std;LiteralBigIntOps.**.rhs">rhs</a>: <span title="BigInt">BigInt</span><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = spire.math.<a href="../../math/package.scala.html#spire.math.package.pow(83b8c5e536)" title="(base: BigInt, ex: BigInt)BigInt">pow</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a>, <a href="#spire.syntax.std;LiteralBigIntOps.**.rhs" title="BigInt">rhs</a><span class="delimiter">)</span>

  def <a title="(rhs: spire.math.SafeLong)spire.math.SafeLong" id="spire.syntax.std;LiteralBigIntOps.+(a361d50555)">+</a><span class="delimiter">(</span><a title="spire.math.SafeLong" id="spire.syntax.std;LiteralBigIntOps.+(a361d50555).rhs">rhs</a>: <a href="../../math/SafeLong.scala.html#spire.math;SafeLong" title="spire.math.SafeLong">SafeLong</a><span class="delimiter">)</span>: <a href="../../math/SafeLong.scala.html#spire.math;SafeLong" title="spire.math.SafeLong">SafeLong</a> = <a href="../../math/SafeLong.scala.html#spire.math.SafeLong.apply(d3aa3b28f0)" title="implicit spire.math.SafeLong.apply : (x: BigInt)spire.math.SafeLong">SafeLong</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a><span class="delimiter">)</span> <a href="../../math/SafeLong.scala.html#spire.math;SafeLong.+(a361d50555)" title="(rhs: spire.math.SafeLong)spire.math.SafeLong">+</a> <a href="#spire.syntax.std;LiteralBigIntOps.+(a361d50555).rhs" title="spire.math.SafeLong">rhs</a>
  def <a title="(rhs: spire.math.SafeLong)spire.math.SafeLong" id="spire.syntax.std;LiteralBigIntOps.*(a361d50555)">*</a><span class="delimiter">(</span><a title="spire.math.SafeLong" id="spire.syntax.std;LiteralBigIntOps.*(a361d50555).rhs">rhs</a>: <a href="../../math/SafeLong.scala.html#spire.math;SafeLong" title="spire.math.SafeLong">SafeLong</a><span class="delimiter">)</span>: <a href="../../math/SafeLong.scala.html#spire.math;SafeLong" title="spire.math.SafeLong">SafeLong</a> = <a href="../../math/SafeLong.scala.html#spire.math.SafeLong.apply(d3aa3b28f0)" title="implicit spire.math.SafeLong.apply : (x: BigInt)spire.math.SafeLong">SafeLong</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a><span class="delimiter">)</span> <a href="../../math/SafeLong.scala.html#spire.math;SafeLong.*(a361d50555)" title="(rhs: spire.math.SafeLong)spire.math.SafeLong">*</a> <a href="#spire.syntax.std;LiteralBigIntOps.*(a361d50555).rhs" title="spire.math.SafeLong">rhs</a>
  def <a title="(rhs: spire.math.SafeLong)spire.math.SafeLong" id="spire.syntax.std;LiteralBigIntOps.-(a361d50555)">-</a><span class="delimiter">(</span><a title="spire.math.SafeLong" id="spire.syntax.std;LiteralBigIntOps.-(a361d50555).rhs">rhs</a>: <a href="../../math/SafeLong.scala.html#spire.math;SafeLong" title="spire.math.SafeLong">SafeLong</a><span class="delimiter">)</span>: <a href="../../math/SafeLong.scala.html#spire.math;SafeLong" title="spire.math.SafeLong">SafeLong</a> = <a href="../../math/SafeLong.scala.html#spire.math.SafeLong.apply(d3aa3b28f0)" title="implicit spire.math.SafeLong.apply : (x: BigInt)spire.math.SafeLong">SafeLong</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a><span class="delimiter">)</span> <a href="../../math/SafeLong.scala.html#spire.math;SafeLong.-(a361d50555)" title="(rhs: spire.math.SafeLong)spire.math.SafeLong">-</a> <a href="#spire.syntax.std;LiteralBigIntOps.-(a361d50555).rhs" title="spire.math.SafeLong">rhs</a>
  def <a title="(rhs: spire.math.SafeLong)spire.math.SafeLong" id="spire.syntax.std;LiteralBigIntOps./(a361d50555)">/</a><span class="delimiter">(</span><a title="spire.math.SafeLong" id="spire.syntax.std;LiteralBigIntOps./(a361d50555).rhs">rhs</a>: <a href="../../math/SafeLong.scala.html#spire.math;SafeLong" title="spire.math.SafeLong">SafeLong</a><span class="delimiter">)</span>: <a href="../../math/SafeLong.scala.html#spire.math;SafeLong" title="spire.math.SafeLong">SafeLong</a> = <a href="../../math/SafeLong.scala.html#spire.math.SafeLong.apply(d3aa3b28f0)" title="implicit spire.math.SafeLong.apply : (x: BigInt)spire.math.SafeLong">SafeLong</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a><span class="delimiter">)</span> <a href="../../math/SafeLong.scala.html#spire.math;SafeLong./(a361d50555)" title="(rhs: spire.math.SafeLong)spire.math.SafeLong">/</a> <a href="#spire.syntax.std;LiteralBigIntOps./(a361d50555).rhs" title="spire.math.SafeLong">rhs</a>
  def <a title="(rhs: spire.math.SafeLong)spire.math.SafeLong" id="spire.syntax.std;LiteralBigIntOps./~(a361d50555)">/~</a><span class="delimiter">(</span><a title="spire.math.SafeLong" id="spire.syntax.std;LiteralBigIntOps./~(a361d50555).rhs">rhs</a>: <a href="../../math/SafeLong.scala.html#spire.math;SafeLong" title="spire.math.SafeLong">SafeLong</a><span class="delimiter">)</span>: <a href="../../math/SafeLong.scala.html#spire.math;SafeLong" title="spire.math.SafeLong">SafeLong</a> = <a href="../../math/SafeLong.scala.html#spire.math.SafeLong.apply(d3aa3b28f0)" title="implicit spire.math.SafeLong.apply : (x: BigInt)spire.math.SafeLong">SafeLong</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a><span class="delimiter">)</span> <a href="../../math/SafeLong.scala.html#spire.math;SafeLong./~" title="(rhs: spire.math.SafeLong)spire.math.SafeLong">/~</a> <a href="#spire.syntax.std;LiteralBigIntOps./~(a361d50555).rhs" title="spire.math.SafeLong">rhs</a>
  def <a title="(rhs: spire.math.SafeLong)spire.math.SafeLong" id="spire.syntax.std;LiteralBigIntOps.%(a361d50555)">%</a><span class="delimiter">(</span><a title="spire.math.SafeLong" id="spire.syntax.std;LiteralBigIntOps.%(a361d50555).rhs">rhs</a>: <a href="../../math/SafeLong.scala.html#spire.math;SafeLong" title="spire.math.SafeLong">SafeLong</a><span class="delimiter">)</span>: <a href="../../math/SafeLong.scala.html#spire.math;SafeLong" title="spire.math.SafeLong">SafeLong</a> = <a href="../../math/SafeLong.scala.html#spire.math.SafeLong.apply(d3aa3b28f0)" title="implicit spire.math.SafeLong.apply : (x: BigInt)spire.math.SafeLong">SafeLong</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a><span class="delimiter">)</span> <a href="../../math/SafeLong.scala.html#spire.math;SafeLong.%(a361d50555)" title="(rhs: spire.math.SafeLong)spire.math.SafeLong">%</a> <a href="#spire.syntax.std;LiteralBigIntOps.%(a361d50555).rhs" title="spire.math.SafeLong">rhs</a>
  def <a title="(rhs: spire.math.SafeLong)(spire.math.SafeLong, spire.math.SafeLong)" id="spire.syntax.std;LiteralBigIntOps./%(7e6a3a570b)">/%</a><span class="delimiter">(</span><a title="spire.math.SafeLong" id="spire.syntax.std;LiteralBigIntOps./%(7e6a3a570b).rhs">rhs</a>: <a href="../../math/SafeLong.scala.html#spire.math;SafeLong" title="spire.math.SafeLong">SafeLong</a><span class="delimiter">)</span>: <span title="(spire.math.SafeLong, spire.math.SafeLong)" class="delimiter">(</span>SafeLong, SafeLong<span class="delimiter">)</span> = <a href="../../math/SafeLong.scala.html#spire.math.SafeLong.apply(d3aa3b28f0)" title="implicit spire.math.SafeLong.apply : (x: BigInt)spire.math.SafeLong">SafeLong</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a><span class="delimiter">)</span> <a href="../../math/SafeLong.scala.html#spire.math;SafeLong./%(7e6a3a570b)" title="(rhs: spire.math.SafeLong)(spire.math.SafeLong, spire.math.SafeLong)">/%</a> <a href="#spire.syntax.std;LiteralBigIntOps./%(7e6a3a570b).rhs" title="spire.math.SafeLong">rhs</a>

  def <a title="(rhs: spire.math.Natural)BigInt" id="spire.syntax.std;LiteralBigIntOps.+(4ea8620ed0)">+</a><span class="delimiter">(</span><a title="spire.math.Natural" id="spire.syntax.std;LiteralBigIntOps.+(4ea8620ed0).rhs">rhs</a>: <a href="../../math/Natural.scala.html#spire.math;Natural" title="spire.math.Natural">Natural</a><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a> <span title="(that: scala.math.BigInt)scala.math.BigInt">+</span> <a href="#spire.syntax.std;LiteralBigIntOps.+(4ea8620ed0).rhs" title="spire.math.Natural">rhs</a>.<a href="../../math/Natural.scala.html#spire.math;Natural.toBigInt" title="=&gt; BigInt">toBigInt</a>
  def <a title="(rhs: spire.math.Natural)BigInt" id="spire.syntax.std;LiteralBigIntOps.*(4ea8620ed0)">*</a><span class="delimiter">(</span><a title="spire.math.Natural" id="spire.syntax.std;LiteralBigIntOps.*(4ea8620ed0).rhs">rhs</a>: <a href="../../math/Natural.scala.html#spire.math;Natural" title="spire.math.Natural">Natural</a><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a> <span title="(that: scala.math.BigInt)scala.math.BigInt">*</span> <a href="#spire.syntax.std;LiteralBigIntOps.*(4ea8620ed0).rhs" title="spire.math.Natural">rhs</a>.<a href="../../math/Natural.scala.html#spire.math;Natural.toBigInt" title="=&gt; BigInt">toBigInt</a>
  def <a title="(rhs: spire.math.Natural)BigInt" id="spire.syntax.std;LiteralBigIntOps.-(4ea8620ed0)">-</a><span class="delimiter">(</span><a title="spire.math.Natural" id="spire.syntax.std;LiteralBigIntOps.-(4ea8620ed0).rhs">rhs</a>: <a href="../../math/Natural.scala.html#spire.math;Natural" title="spire.math.Natural">Natural</a><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a> <span title="(that: scala.math.BigInt)scala.math.BigInt">-</span> <a href="#spire.syntax.std;LiteralBigIntOps.-(4ea8620ed0).rhs" title="spire.math.Natural">rhs</a>.<a href="../../math/Natural.scala.html#spire.math;Natural.toBigInt" title="=&gt; BigInt">toBigInt</a>
  def <a title="(rhs: spire.math.Natural)BigInt" id="spire.syntax.std;LiteralBigIntOps./(4ea8620ed0)">/</a><span class="delimiter">(</span><a title="spire.math.Natural" id="spire.syntax.std;LiteralBigIntOps./(4ea8620ed0).rhs">rhs</a>: <a href="../../math/Natural.scala.html#spire.math;Natural" title="spire.math.Natural">Natural</a><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a> <span title="(that: scala.math.BigInt)scala.math.BigInt">/</span> <a href="#spire.syntax.std;LiteralBigIntOps./(4ea8620ed0).rhs" title="spire.math.Natural">rhs</a>.<a href="../../math/Natural.scala.html#spire.math;Natural.toBigInt" title="=&gt; BigInt">toBigInt</a>
  def <a title="(rhs: spire.math.Natural)BigInt" id="spire.syntax.std;LiteralBigIntOps./~(4ea8620ed0)">/~</a><span class="delimiter">(</span><a title="spire.math.Natural" id="spire.syntax.std;LiteralBigIntOps./~(4ea8620ed0).rhs">rhs</a>: <a href="../../math/Natural.scala.html#spire.math;Natural" title="spire.math.Natural">Natural</a><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a> <span title="(that: scala.math.BigInt)scala.math.BigInt">/</span> <a href="#spire.syntax.std;LiteralBigIntOps./~(4ea8620ed0).rhs" title="spire.math.Natural">rhs</a>.<a href="../../math/Natural.scala.html#spire.math;Natural.toBigInt" title="=&gt; BigInt">toBigInt</a>
  def <a title="(rhs: spire.math.Natural)BigInt" id="spire.syntax.std;LiteralBigIntOps.%(4ea8620ed0)">%</a><span class="delimiter">(</span><a title="spire.math.Natural" id="spire.syntax.std;LiteralBigIntOps.%(4ea8620ed0).rhs">rhs</a>: <a href="../../math/Natural.scala.html#spire.math;Natural" title="spire.math.Natural">Natural</a><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a> <span title="(that: scala.math.BigInt)scala.math.BigInt">%</span> <a href="#spire.syntax.std;LiteralBigIntOps.%(4ea8620ed0).rhs" title="spire.math.Natural">rhs</a>.<a href="../../math/Natural.scala.html#spire.math;Natural.toBigInt" title="=&gt; BigInt">toBigInt</a>
  def <a title="(rhs: spire.math.Natural)(BigInt, BigInt)" id="spire.syntax.std;LiteralBigIntOps./%(b5ad240896)">/%</a><span class="delimiter">(</span><a title="spire.math.Natural" id="spire.syntax.std;LiteralBigIntOps./%(b5ad240896).rhs">rhs</a>: <a href="../../math/Natural.scala.html#spire.math;Natural" title="spire.math.Natural">Natural</a><span class="delimiter">)</span>: <span title="(BigInt, BigInt)" class="delimiter">(</span>BigInt, BigInt<span class="delimiter">)</span> = <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a> <span title="(that: scala.math.BigInt)(scala.math.BigInt, scala.math.BigInt)">/%</span> <a href="#spire.syntax.std;LiteralBigIntOps./%(b5ad240896).rhs" title="spire.math.Natural">rhs</a>.<a href="../../math/Natural.scala.html#spire.math;Natural.toBigInt" title="=&gt; BigInt">toBigInt</a>

  def <a title="(rhs: spire.math.ULong)BigInt" id="spire.syntax.std;LiteralBigIntOps.+(9895457f69)">+</a><span class="delimiter">(</span><a title="spire.math.ULong" id="spire.syntax.std;LiteralBigIntOps.+(9895457f69).rhs">rhs</a>: <a href="../../math/ULong.scala.html#spire.math;ULong" title="spire.math.ULong">ULong</a><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a> <span title="(that: scala.math.BigInt)scala.math.BigInt">+</span> <a href="#spire.syntax.std;LiteralBigIntOps.+(9895457f69).rhs" title="spire.math.ULong">rhs</a>.<a href="../../math/ULong.scala.html#spire.math;ULong.toBigInt" title="=&gt; BigInt">toBigInt</a>
  def <a title="(rhs: spire.math.ULong)BigInt" id="spire.syntax.std;LiteralBigIntOps.*(9895457f69)">*</a><span class="delimiter">(</span><a title="spire.math.ULong" id="spire.syntax.std;LiteralBigIntOps.*(9895457f69).rhs">rhs</a>: <a href="../../math/ULong.scala.html#spire.math;ULong" title="spire.math.ULong">ULong</a><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a> <span title="(that: scala.math.BigInt)scala.math.BigInt">*</span> <a href="#spire.syntax.std;LiteralBigIntOps.*(9895457f69).rhs" title="spire.math.ULong">rhs</a>.<a href="../../math/ULong.scala.html#spire.math;ULong.toBigInt" title="=&gt; BigInt">toBigInt</a>
  def <a title="(rhs: spire.math.ULong)BigInt" id="spire.syntax.std;LiteralBigIntOps.-(9895457f69)">-</a><span class="delimiter">(</span><a title="spire.math.ULong" id="spire.syntax.std;LiteralBigIntOps.-(9895457f69).rhs">rhs</a>: <a href="../../math/ULong.scala.html#spire.math;ULong" title="spire.math.ULong">ULong</a><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a> <span title="(that: scala.math.BigInt)scala.math.BigInt">-</span> <a href="#spire.syntax.std;LiteralBigIntOps.-(9895457f69).rhs" title="spire.math.ULong">rhs</a>.<a href="../../math/ULong.scala.html#spire.math;ULong.toBigInt" title="=&gt; BigInt">toBigInt</a>
  def <a title="(rhs: spire.math.ULong)BigInt" id="spire.syntax.std;LiteralBigIntOps./(9895457f69)">/</a><span class="delimiter">(</span><a title="spire.math.ULong" id="spire.syntax.std;LiteralBigIntOps./(9895457f69).rhs">rhs</a>: <a href="../../math/ULong.scala.html#spire.math;ULong" title="spire.math.ULong">ULong</a><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a> <span title="(that: scala.math.BigInt)scala.math.BigInt">/</span> <a href="#spire.syntax.std;LiteralBigIntOps./(9895457f69).rhs" title="spire.math.ULong">rhs</a>.<a href="../../math/ULong.scala.html#spire.math;ULong.toBigInt" title="=&gt; BigInt">toBigInt</a>
  def <a title="(rhs: spire.math.ULong)BigInt" id="spire.syntax.std;LiteralBigIntOps./~(9895457f69)">/~</a><span class="delimiter">(</span><a title="spire.math.ULong" id="spire.syntax.std;LiteralBigIntOps./~(9895457f69).rhs">rhs</a>: <a href="../../math/ULong.scala.html#spire.math;ULong" title="spire.math.ULong">ULong</a><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a> <span title="(that: scala.math.BigInt)scala.math.BigInt">/</span> <a href="#spire.syntax.std;LiteralBigIntOps./~(9895457f69).rhs" title="spire.math.ULong">rhs</a>.<a href="../../math/ULong.scala.html#spire.math;ULong.toBigInt" title="=&gt; BigInt">toBigInt</a>
  def <a title="(rhs: spire.math.ULong)BigInt" id="spire.syntax.std;LiteralBigIntOps.%(9895457f69)">%</a><span class="delimiter">(</span><a title="spire.math.ULong" id="spire.syntax.std;LiteralBigIntOps.%(9895457f69).rhs">rhs</a>: <a href="../../math/ULong.scala.html#spire.math;ULong" title="spire.math.ULong">ULong</a><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a> <span title="(that: scala.math.BigInt)scala.math.BigInt">%</span> <a href="#spire.syntax.std;LiteralBigIntOps.%(9895457f69).rhs" title="spire.math.ULong">rhs</a>.<a href="../../math/ULong.scala.html#spire.math;ULong.toBigInt" title="=&gt; BigInt">toBigInt</a>
  def <a title="(rhs: spire.math.ULong)(BigInt, BigInt)" id="spire.syntax.std;LiteralBigIntOps./%(2ee2baf5cc)">/%</a><span class="delimiter">(</span><a title="spire.math.ULong" id="spire.syntax.std;LiteralBigIntOps./%(2ee2baf5cc).rhs">rhs</a>: <a href="../../math/ULong.scala.html#spire.math;ULong" title="spire.math.ULong">ULong</a><span class="delimiter">)</span>: <span title="(BigInt, BigInt)" class="delimiter">(</span>BigInt, BigInt<span class="delimiter">)</span> = <a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a> <span title="(that: scala.math.BigInt)(scala.math.BigInt, scala.math.BigInt)">/%</span> <a href="#spire.syntax.std;LiteralBigIntOps./%(2ee2baf5cc).rhs" title="spire.math.ULong">rhs</a>.<a href="../../math/ULong.scala.html#spire.math;ULong.toBigInt" title="=&gt; BigInt">toBigInt</a>

  def <a title="(rhs: spire.math.Number)spire.math.Number" id="spire.syntax.std;LiteralBigIntOps.+(b5eb6b3b88)">+</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax.std;LiteralBigIntOps.+(b5eb6b3b88).rhs">rhs</a>: <a href="../../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span>: <a href="../../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="../../math/Number.scala.html#spire.math.Number.apply(e6b90038b3)" title="implicit spire.math.Number.apply : (n: BigInt)spire.math.Number">Number</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a><span class="delimiter">)</span> <a href="../../math/Number.scala.html#spire.math;Number.+" title="(rhs: spire.math.Number)spire.math.Number">+</a> <a href="#spire.syntax.std;LiteralBigIntOps.+(b5eb6b3b88).rhs" title="spire.math.Number">rhs</a>
  def <a title="(rhs: spire.math.Number)spire.math.Number" id="spire.syntax.std;LiteralBigIntOps.*(b5eb6b3b88)">*</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax.std;LiteralBigIntOps.*(b5eb6b3b88).rhs">rhs</a>: <a href="../../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span>: <a href="../../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="../../math/Number.scala.html#spire.math.Number.apply(e6b90038b3)" title="implicit spire.math.Number.apply : (n: BigInt)spire.math.Number">Number</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a><span class="delimiter">)</span> <a href="../../math/Number.scala.html#spire.math;Number.*" title="(rhs: spire.math.Number)spire.math.Number">*</a> <a href="#spire.syntax.std;LiteralBigIntOps.*(b5eb6b3b88).rhs" title="spire.math.Number">rhs</a>
  def <a title="(rhs: spire.math.Number)spire.math.Number" id="spire.syntax.std;LiteralBigIntOps.-(b5eb6b3b88)">-</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax.std;LiteralBigIntOps.-(b5eb6b3b88).rhs">rhs</a>: <a href="../../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span>: <a href="../../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="../../math/Number.scala.html#spire.math.Number.apply(e6b90038b3)" title="implicit spire.math.Number.apply : (n: BigInt)spire.math.Number">Number</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a><span class="delimiter">)</span> <a href="../../math/Number.scala.html#spire.math;Number.-" title="(rhs: spire.math.Number)spire.math.Number">-</a> <a href="#spire.syntax.std;LiteralBigIntOps.-(b5eb6b3b88).rhs" title="spire.math.Number">rhs</a>
  def <a title="(rhs: spire.math.Number)spire.math.Number" id="spire.syntax.std;LiteralBigIntOps./(b5eb6b3b88)">/</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax.std;LiteralBigIntOps./(b5eb6b3b88).rhs">rhs</a>: <a href="../../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span>: <a href="../../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="../../math/Number.scala.html#spire.math.Number.apply(e6b90038b3)" title="implicit spire.math.Number.apply : (n: BigInt)spire.math.Number">Number</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a><span class="delimiter">)</span> <a href="../../math/Number.scala.html#spire.math;Number./" title="(rhs: spire.math.Number)spire.math.Number">/</a> <a href="#spire.syntax.std;LiteralBigIntOps./(b5eb6b3b88).rhs" title="spire.math.Number">rhs</a>
  def <a title="(rhs: spire.math.Number)spire.math.Number" id="spire.syntax.std;LiteralBigIntOps./~(b5eb6b3b88)">/~</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax.std;LiteralBigIntOps./~(b5eb6b3b88).rhs">rhs</a>: <a href="../../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span>: <a href="../../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="../../math/Number.scala.html#spire.math.Number.apply(e6b90038b3)" title="implicit spire.math.Number.apply : (n: BigInt)spire.math.Number">Number</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a><span class="delimiter">)</span> <a href="../../math/Number.scala.html#spire.math;Number./" title="(rhs: spire.math.Number)spire.math.Number">/</a> <a href="#spire.syntax.std;LiteralBigIntOps./~(b5eb6b3b88).rhs" title="spire.math.Number">rhs</a>
  def <a title="(rhs: spire.math.Number)spire.math.Number" id="spire.syntax.std;LiteralBigIntOps.%(b5eb6b3b88)">%</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax.std;LiteralBigIntOps.%(b5eb6b3b88).rhs">rhs</a>: <a href="../../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span>: <a href="../../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="../../math/Number.scala.html#spire.math.Number.apply(e6b90038b3)" title="implicit spire.math.Number.apply : (n: BigInt)spire.math.Number">Number</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a><span class="delimiter">)</span> <a href="../../math/Number.scala.html#spire.math;Number.%" title="(rhs: spire.math.Number)spire.math.Number">%</a> <a href="#spire.syntax.std;LiteralBigIntOps.%(b5eb6b3b88).rhs" title="spire.math.Number">rhs</a>
  def <a title="(rhs: spire.math.Number)(spire.math.Number, spire.math.Number)" id="spire.syntax.std;LiteralBigIntOps./%(0ded7149ae)">/%</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax.std;LiteralBigIntOps./%(0ded7149ae).rhs">rhs</a>: <a href="../../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span>: <span title="(spire.math.Number, spire.math.Number)" class="delimiter">(</span>Number, Number<span class="delimiter">)</span> = <a href="../../math/Number.scala.html#spire.math.Number.apply(e6b90038b3)" title="implicit spire.math.Number.apply : (n: BigInt)spire.math.Number">Number</a><span class="delimiter">(</span><a href="#spire.syntax.std;LiteralBigIntOps.lhs" title="=&gt; BigInt">lhs</a><span class="delimiter">)</span> <a href="../../math/Number.scala.html#spire.math;Number./%" title="(rhs: spire.math.Number)(spire.math.Number, spire.math.Number)">/%</a> <a href="#spire.syntax.std;LiteralBigIntOps./%(0ded7149ae).rhs" title="spire.math.Number">rhs</a>
<span class="delimiter">}</span>

final class <a title="class ArrayOps[A] extends AnyRef" id="spire.syntax.std;ArrayOps">ArrayOps</a><span class="delimiter">[</span>@sp <a title="" id="spire.syntax.std;ArrayOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax.std;ArrayOps" title="spire.syntax.std.ArrayOps[A]" class="delimiter">(</a><a title="Array[A]" id="spire.syntax.std;ArrayOps.arr">arr</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(implicit ev: spire.algebra.AdditiveMonoid[A])A" id="spire.syntax.std;ArrayOps.qsum">qsum</a><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveMonoid[A]" id="spire.syntax.std;ArrayOps.qsum.ev">ev</a>: <a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;ArrayOps;A" title="A">A</a> = <span class="delimiter">{</span>
    var <a title="A" id="spire.syntax.std;ArrayOps.qsum.result">result</a> = <a href="#spire.syntax.std;ArrayOps.qsum.ev" title="spire.algebra.AdditiveMonoid[A]">ev</a>.<a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a>
    cfor<span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">(</span>_ <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span>, _ <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a title="Int" id="spire.syntax.std;ArrayOps.qsum.index$macro$432" class="delimiter">{</a> i =&gt; <a href="#spire.syntax.std;ArrayOps.qsum.result" title="A">result</a> <a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+=</a> <a href="#spire.syntax.std;ArrayOps.arr" title="(i: Int)A">arr</a><span class="delimiter">(</span>i<span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#spire.syntax.std;ArrayOps.qsum.result" title="A">result</a>
  <span class="delimiter">}</span>

  def <a title="(implicit ev: spire.algebra.MultiplicativeMonoid[A])A" id="spire.syntax.std;ArrayOps.qproduct">qproduct</a><span class="delimiter">(</span>implicit <a title="spire.algebra.MultiplicativeMonoid[A]" id="spire.syntax.std;ArrayOps.qproduct.ev">ev</a>: <a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid" title="spire.algebra.MultiplicativeMonoid[A]">MultiplicativeMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;ArrayOps;A" title="A">A</a> = <span class="delimiter">{</span>
    var <a title="A" id="spire.syntax.std;ArrayOps.qproduct.result">result</a> = <a href="#spire.syntax.std;ArrayOps.qproduct.ev" title="spire.algebra.MultiplicativeMonoid[A]">ev</a>.<a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; A">one</a>
    cfor<span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">(</span>_ <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span>, _ <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a title="Int" id="spire.syntax.std;ArrayOps.qproduct.index$macro$433" class="delimiter">{</a> i =&gt; <a href="#spire.syntax.std;ArrayOps.qproduct.result" title="A">result</a> <a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*=</a> <a href="#spire.syntax.std;ArrayOps.arr" title="(i: Int)A">arr</a><span class="delimiter">(</span>i<span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#spire.syntax.std;ArrayOps.qproduct.result" title="A">result</a>
  <span class="delimiter">}</span>

  def <a title="(p: Int)(implicit ev: spire.algebra.Field[A], implicit s: spire.algebra.Signed[A], implicit nr: spire.algebra.NRoot[A])A" id="spire.syntax.std;ArrayOps.qnorm">qnorm</a><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;ArrayOps.qnorm.p">p</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax.std;ArrayOps.qnorm.ev">ev</a>: <a href="../../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.algebra.Signed[A]" id="spire.syntax.std;ArrayOps.qnorm.s">s</a>: <a href="../../algebra/Signed.scala.html#spire.algebra;Signed" title="spire.algebra.Signed[A]">Signed</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[A]" id="spire.syntax.std;ArrayOps.qnorm.nr">nr</a>: <a href="../../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[A]">NRoot</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;ArrayOps;A" title="A">A</a> = <span class="delimiter">{</span>
    var <a title="A" id="spire.syntax.std;ArrayOps.qnorm.result">result</a> = <a href="#spire.syntax.std;ArrayOps.qnorm.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; A">one</a>
    cfor<span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">(</span>_ <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span>, _ <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a title="Int" id="spire.syntax.std;ArrayOps.qnorm.index$macro$434" class="delimiter">{</a> i =&gt; <a href="#spire.syntax.std;ArrayOps.qnorm.result" title="A">result</a> <a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+=</a> <a href="#spire.syntax.std;ArrayOps.arr" title="(i: Int)A">arr</a><a href="#spire.syntax.std;ArrayOps.qnorm.s" title="spire.algebra.Signed[A]" class="delimiter">(</a>i<span class="delimiter">)</span>.<a href="#spire.syntax.std;ArrayOps.qnorm.ev" title="spire.algebra.Field[A]">abs</a>.pow<a href="../../algebra/Rig.scala.html#spire.algebra;Rig.pow" title="(a: A, n: Int)A" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.qnorm.p" title="Int">p</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#spire.syntax.std;ArrayOps.qnorm.nr" title="spire.algebra.NRoot[A]">result</a>.nroot<a href="../../algebra/NRoot.scala.html#spire.algebra;NRoot.nroot" title="(a: A, n: Int)A" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.qnorm.p" title="Int">p</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="[R](p: Int)(f: A =&gt; R)(implicit ev: spire.algebra.Field[R], implicit s: spire.algebra.Signed[R], implicit nr: spire.algebra.NRoot[R])R" id="spire.syntax.std;ArrayOps.qnormWith">qnormWith</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Double<span class="delimiter">)</span> <a title="" id="spire.syntax.std;ArrayOps.qnormWith;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;ArrayOps.qnormWith.p">p</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; R" id="spire.syntax.std;ArrayOps.qnormWith.f">f</a>: A =&gt; R<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[R]" id="spire.syntax.std;ArrayOps.qnormWith.ev">ev</a>: <a href="../../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[R]">Field</a><span class="delimiter">[</span>R<span class="delimiter">]</span>, <a title="spire.algebra.Signed[R]" id="spire.syntax.std;ArrayOps.qnormWith.s">s</a>: <a href="../../algebra/Signed.scala.html#spire.algebra;Signed" title="spire.algebra.Signed[R]">Signed</a><span class="delimiter">[</span>R<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[R]" id="spire.syntax.std;ArrayOps.qnormWith.nr">nr</a>: <a href="../../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[R]">NRoot</a><span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;ArrayOps.qnormWith;R" title="R">R</a> = <span class="delimiter">{</span>
    var <a title="R" id="spire.syntax.std;ArrayOps.qnormWith.result">result</a>: <a href="#spire.syntax.std;ArrayOps.qnormWith;R" title="R">R</a> = <a href="#spire.syntax.std;ArrayOps.qnormWith.ev" title="spire.algebra.Field[R]">ev</a>.<a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; R">one</a>
    cfor<span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">(</span>_ <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span>, _ <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a title="Int" id="spire.syntax.std;ArrayOps.qnormWith.index$macro$435" class="delimiter">{</a> i =&gt; <a href="#spire.syntax.std;ArrayOps.qnormWith.result" title="R">result</a> <a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: R, y: R)R">+=</a> <a href="#spire.syntax.std;ArrayOps.qnormWith.f" title="(v1: A)R">f</a><a href="#spire.syntax.std;ArrayOps.qnormWith.s" title="spire.algebra.Signed[R]" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.arr" title="(i: Int)A">arr</a><span class="delimiter">(</span>i<span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#spire.syntax.std;ArrayOps.qnormWith.ev" title="spire.algebra.Field[R]">abs</a>.pow<a href="../../algebra/Rig.scala.html#spire.algebra;Rig.pow" title="(a: R, n: Int)R" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.qnormWith.p" title="Int">p</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#spire.syntax.std;ArrayOps.qnormWith.nr" title="spire.algebra.NRoot[R]">result</a>.nroot<a href="../../algebra/NRoot.scala.html#spire.algebra;NRoot.nroot" title="(a: R, n: Int)R" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.qnormWith.p" title="Int">p</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(implicit ev: spire.algebra.Order[A])A" id="spire.syntax.std;ArrayOps.qmin">qmin</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax.std;ArrayOps.qmin.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;ArrayOps;A" title="A">A</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> throw new <span title="UnsupportedOperationException">UnsupportedOperationException</span><span class="delimiter">(</span><span title="String(&quot;empty array&quot;)" class="string">&quot;empty array&quot;</span><span class="delimiter">)</span>
    var <a title="A" id="spire.syntax.std;ArrayOps.qmin.result">result</a> = <a href="#spire.syntax.std;ArrayOps.arr" title="(i: Int)A">arr</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
    cfor<span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">(</span>_ <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span>, _ <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a title="Int" id="spire.syntax.std;ArrayOps.qmin.index$macro$436" class="delimiter">{</a> i =&gt;
      <a href="#spire.syntax.std;ArrayOps.qmin.result" title="A">result</a> = <a href="#spire.syntax.std;ArrayOps.qmin.ev" title="spire.algebra.Order[A]">result</a> <a href="../../algebra/Order.scala.html#spire.algebra;Order.min" title="(x: A, y: A)A">min</a> <a href="#spire.syntax.std;ArrayOps.arr" title="(i: Int)A">arr</a><span class="delimiter">(</span>i<span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#spire.syntax.std;ArrayOps.qmin.result" title="A">result</a>
  <span class="delimiter">}</span>

  def <a title="(implicit ev: spire.algebra.Order[A])A" id="spire.syntax.std;ArrayOps.qmax">qmax</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax.std;ArrayOps.qmax.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;ArrayOps;A" title="A">A</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> throw new <span title="UnsupportedOperationException">UnsupportedOperationException</span><span class="delimiter">(</span><span title="String(&quot;empty array&quot;)" class="string">&quot;empty array&quot;</span><span class="delimiter">)</span>
    var <a title="A" id="spire.syntax.std;ArrayOps.qmax.result">result</a> = <a href="#spire.syntax.std;ArrayOps.arr" title="(i: Int)A">arr</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
    cfor<span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">(</span>_ <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span>, _ <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a title="Int" id="spire.syntax.std;ArrayOps.qmax.index$macro$437" class="delimiter">{</a> i =&gt;
      <a href="#spire.syntax.std;ArrayOps.qmax.result" title="A">result</a> = <a href="#spire.syntax.std;ArrayOps.qmax.ev" title="spire.algebra.Order[A]">result</a> <a href="../../algebra/Order.scala.html#spire.algebra;Order.max" title="(x: A, y: A)A">max</a> <a href="#spire.syntax.std;ArrayOps.arr" title="(i: Int)A">arr</a><span class="delimiter">(</span>i<span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#spire.syntax.std;ArrayOps.qmax.result" title="A">result</a>
  <span class="delimiter">}</span>

  def <a title="(implicit ev: spire.algebra.Field[A])A" id="spire.syntax.std;ArrayOps.qmean">qmean</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax.std;ArrayOps.qmean.ev">ev</a>: <a href="../../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;ArrayOps;A" title="A">A</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> throw new <span title="UnsupportedOperationException">UnsupportedOperationException</span><span class="delimiter">(</span><span title="String(&quot;empty array&quot;)" class="string">&quot;empty array&quot;</span><span class="delimiter">)</span>
    var <a title="A" id="spire.syntax.std;ArrayOps.qmean.result">result</a> = <a href="#spire.syntax.std;ArrayOps.qmean.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a>
    cfor<span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">(</span>_ <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span>, _ <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a title="Int" id="spire.syntax.std;ArrayOps.qmean.index$macro$438" class="delimiter">{</a> i =&gt;
      <a href="#spire.syntax.std;ArrayOps.qmean.result" title="A">result</a> = <span class="delimiter">(</span><a href="#spire.syntax.std;ArrayOps.qmean.ev" title="spire.algebra.Field[A]">result</a> <a href="#spire.syntax.std;ArrayOps.qmean.ev" title="spire.algebra.Field[A]">*</a> i <a href="#spire.syntax.std;ArrayOps.qmean.ev" title="spire.algebra.Field[A]">/</a> <span class="delimiter">(</span>i <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+</a> <span class="delimiter">(</span><a href="#spire.syntax.std;ArrayOps.arr" title="(i: Int)A">arr</a><a href="#spire.syntax.std;ArrayOps.qmean.ev" title="spire.algebra.Field[A]" class="delimiter">(</a>i<span class="delimiter">)</span> <a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: A, y: A)A">/</a> <span class="delimiter">(</span>i <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#spire.syntax.std;ArrayOps.qmean.result" title="A">result</a>
  <span class="delimiter">}</span>

  def <a title="[R](f: A =&gt; R)(implicit ev: spire.algebra.Field[R])R" id="spire.syntax.std;ArrayOps.qmeanWith">qmeanWith</a><span class="delimiter">[</span>@sp<span class="delimiter">(</span>Double<span class="delimiter">)</span> <a title="" id="spire.syntax.std;ArrayOps.qmeanWith;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; R" id="spire.syntax.std;ArrayOps.qmeanWith.f">f</a>: A =&gt; R<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[R]" id="spire.syntax.std;ArrayOps.qmeanWith.ev">ev</a>: <a href="../../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[R]">Field</a><span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;ArrayOps.qmeanWith;R" title="R">R</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> throw new <span title="UnsupportedOperationException">UnsupportedOperationException</span><span class="delimiter">(</span><span title="String(&quot;empty array&quot;)" class="string">&quot;empty array&quot;</span><span class="delimiter">)</span>
    var <a title="R" id="spire.syntax.std;ArrayOps.qmeanWith.result">result</a>: <a href="#spire.syntax.std;ArrayOps.qmeanWith;R" title="R">R</a> = <a href="#spire.syntax.std;ArrayOps.qmeanWith.ev" title="spire.algebra.Field[R]">ev</a>.<a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; R">zero</a>
    cfor<span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">(</span>_ <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span>, _ <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a title="Int" id="spire.syntax.std;ArrayOps.qmeanWith.index$macro$439" class="delimiter">{</a> i =&gt;
      <a href="#spire.syntax.std;ArrayOps.qmeanWith.result" title="R">result</a> = <span class="delimiter">(</span><a href="#spire.syntax.std;ArrayOps.qmeanWith.ev" title="spire.algebra.Field[R]">result</a> <a href="#spire.syntax.std;ArrayOps.qmeanWith.ev" title="spire.algebra.Field[R]">*</a> i <a href="#spire.syntax.std;ArrayOps.qmeanWith.ev" title="spire.algebra.Field[R]">/</a> <span class="delimiter">(</span>i <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: R, y: R)R">+</a> <span class="delimiter">(</span><a href="#spire.syntax.std;ArrayOps.qmeanWith.f" title="(v1: A)R">f</a><a href="#spire.syntax.std;ArrayOps.qmeanWith.ev" title="spire.algebra.Field[R]" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.arr" title="(i: Int)A">arr</a><span class="delimiter">(</span>i<span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: R, y: R)R">/</a> <span class="delimiter">(</span>i <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#spire.syntax.std;ArrayOps.qmeanWith.result" title="R">result</a>
  <span class="delimiter">}</span>

  import spire.math.<span class="delimiter">{</span>Sorting, Selection, Searching<span class="delimiter">}</span>

  def <a title="(a: A)(implicit ev: spire.algebra.Order[A])Int" id="spire.syntax.std;ArrayOps.qsearch">qsearch</a><span class="delimiter">(</span><a title="A" id="spire.syntax.std;ArrayOps.qsearch.a">a</a>: <a href="#spire.syntax.std;ArrayOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax.std;ArrayOps.qsearch.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
    <a href="../../math/Searching.scala.html#spire.math.Searching" title="spire.math.Searching.type">Searching</a>.<a href="../../math/Searching.scala.html#spire.math.Searching.search(003cd0969b)" title="(as: Array[A], item: A)(implicit evidence$1: spire.algebra.Order[A])Int">search</a><a href="#spire.syntax.std;ArrayOps.qsearch.ev" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>, <a href="#spire.syntax.std;ArrayOps.qsearch.a" title="A">a</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(implicit ev: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Unit" id="spire.syntax.std;ArrayOps.qsort">qsort</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax.std;ArrayOps.qsort.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;ArrayOps.qsort.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <a href="../../math/Sorting.scala.html#spire.math.Sorting" title="spire.math.Sorting.type">Sorting</a>.<a href="../../math/Sorting.scala.html#spire.math.Sorting.sort" title="(data: Array[A])(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.syntax.std;ArrayOps.qsort.ev" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="[B](f: A =&gt; B)(implicit ev: spire.algebra.Order[B], implicit ct: scala.reflect.ClassTag[A])Unit" id="spire.syntax.std;ArrayOps.qsortBy">qsortBy</a><span class="delimiter">[</span>@sp <a title="" id="spire.syntax.std;ArrayOps.qsortBy;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="spire.syntax.std;ArrayOps.qsortBy.f">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[B]" id="spire.syntax.std;ArrayOps.qsortBy.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[B]">Order</a><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;ArrayOps.qsortBy.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    implicit val <a title="spire.algebra.Order[A]" id="spire.syntax.std;ArrayOps.qsortBy.ord">ord</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.syntax.std;ArrayOps.qsortBy.ev" title="spire.algebra.Order[B]">ev</a>.<a href="../../algebra/Order.scala.html#spire.algebra;Order.on" title="(f: A =&gt; B)spire.algebra.Order[A]">on</a><span class="delimiter">(</span><a href="#spire.syntax.std;ArrayOps.qsortBy.f" title="A =&gt; B">f</a><span class="delimiter">)</span>
    <a href="../../math/Sorting.scala.html#spire.math.Sorting" title="spire.math.Sorting.type">Sorting</a>.<a href="../../math/Sorting.scala.html#spire.math.Sorting.sort" title="(data: Array[A])(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.syntax.std;ArrayOps.qsortBy.ord" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(f: (A, A) =&gt; Int)(implicit ct: scala.reflect.ClassTag[A])Unit" id="spire.syntax.std;ArrayOps.qsortWith">qsortWith</a><span class="delimiter">(</span><a title="(A, A) =&gt; Int" id="spire.syntax.std;ArrayOps.qsortWith.f">f</a>: <span class="delimiter">(</span>A, A<span class="delimiter">)</span> =&gt; Int<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;ArrayOps.qsortWith.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    implicit val <a title="spire.algebra.Order[A]" id="spire.syntax.std;ArrayOps.qsortWith.ord">ord</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="../../algebra/Order.scala.html#spire.algebra.Order" title="spire.algebra.Order.type">Order</a>.<a href="../../algebra/Order.scala.html#spire.algebra.Order.from" title="(f: (A, A) =&gt; Int)spire.algebra.Order[A]">from</a><span class="delimiter">(</span><a href="#spire.syntax.std;ArrayOps.qsortWith.f" title="(A, A) =&gt; Int">f</a><span class="delimiter">)</span>
    <a href="../../math/Sorting.scala.html#spire.math.Sorting" title="spire.math.Sorting.type">Sorting</a>.<a href="../../math/Sorting.scala.html#spire.math.Sorting.sort" title="(data: Array[A])(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.syntax.std;ArrayOps.qsortWith.ord" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(implicit ev: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Array[A]" id="spire.syntax.std;ArrayOps.qsorted">qsorted</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax.std;ArrayOps.qsorted.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;ArrayOps.qsorted.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[A]" id="spire.syntax.std;ArrayOps.qsorted.arr2">arr2</a> = <a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="()Array[A]">clone</span>
    <a href="../../math/Sorting.scala.html#spire.math.Sorting" title="spire.math.Sorting.type">Sorting</a>.<a href="../../math/Sorting.scala.html#spire.math.Sorting.sort" title="(data: Array[A])(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.syntax.std;ArrayOps.qsorted.ev" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.qsorted.arr2" title="Array[A]">arr2</a><span class="delimiter">)</span>
    <a href="#spire.syntax.std;ArrayOps.qsorted.arr2" title="Array[A]">arr2</a>
  <span class="delimiter">}</span>

  def <a title="[B](f: A =&gt; B)(implicit ev: spire.algebra.Order[B], implicit ct: scala.reflect.ClassTag[A])Array[A]" id="spire.syntax.std;ArrayOps.qsortedBy">qsortedBy</a><span class="delimiter">[</span>@sp <a title="" id="spire.syntax.std;ArrayOps.qsortedBy;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="spire.syntax.std;ArrayOps.qsortedBy.f">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[B]" id="spire.syntax.std;ArrayOps.qsortedBy.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[B]">Order</a><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;ArrayOps.qsortedBy.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    implicit val <a title="spire.algebra.Order[A]" id="spire.syntax.std;ArrayOps.qsortedBy.ord">ord</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.syntax.std;ArrayOps.qsortedBy.ev" title="spire.algebra.Order[B]">ev</a>.<a href="../../algebra/Order.scala.html#spire.algebra;Order.on" title="(f: A =&gt; B)spire.algebra.Order[A]">on</a><span class="delimiter">(</span><a href="#spire.syntax.std;ArrayOps.qsortedBy.f" title="A =&gt; B">f</a><span class="delimiter">)</span>
    val <a title="Array[A]" id="spire.syntax.std;ArrayOps.qsortedBy.arr2">arr2</a> = <a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="()Array[A]">clone</span>
    <a href="../../math/Sorting.scala.html#spire.math.Sorting" title="spire.math.Sorting.type">Sorting</a>.<a href="../../math/Sorting.scala.html#spire.math.Sorting.sort" title="(data: Array[A])(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.syntax.std;ArrayOps.qsortedBy.ord" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.qsortedBy.arr2" title="Array[A]">arr2</a><span class="delimiter">)</span>
    <a href="#spire.syntax.std;ArrayOps.qsortedBy.arr2" title="Array[A]">arr2</a>
  <span class="delimiter">}</span>

  def <a title="(f: (A, A) =&gt; Int)(implicit ct: scala.reflect.ClassTag[A])Array[A]" id="spire.syntax.std;ArrayOps.qsortedWith">qsortedWith</a><span class="delimiter">(</span><a title="(A, A) =&gt; Int" id="spire.syntax.std;ArrayOps.qsortedWith.f">f</a>: <span class="delimiter">(</span>A, A<span class="delimiter">)</span> =&gt; Int<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;ArrayOps.qsortedWith.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    implicit val <a title="spire.algebra.Order[A]" id="spire.syntax.std;ArrayOps.qsortedWith.ord">ord</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="../../algebra/Order.scala.html#spire.algebra.Order" title="spire.algebra.Order.type">Order</a>.<a href="../../algebra/Order.scala.html#spire.algebra.Order.from" title="(f: (A, A) =&gt; Int)spire.algebra.Order[A]">from</a><span class="delimiter">(</span><a href="#spire.syntax.std;ArrayOps.qsortedWith.f" title="(A, A) =&gt; Int">f</a><span class="delimiter">)</span>
    val <a title="Array[A]" id="spire.syntax.std;ArrayOps.qsortedWith.arr2">arr2</a> = <a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="()Array[A]">clone</span>
    <a href="../../math/Sorting.scala.html#spire.math.Sorting" title="spire.math.Sorting.type">Sorting</a>.<a href="../../math/Sorting.scala.html#spire.math.Sorting.sort" title="(data: Array[A])(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.syntax.std;ArrayOps.qsortedWith.ord" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.qsortedWith.arr2" title="Array[A]">arr2</a><span class="delimiter">)</span>
    <a href="#spire.syntax.std;ArrayOps.qsortedWith.arr2" title="Array[A]">arr2</a>
  <span class="delimiter">}</span>

  def <a title="(k: Int)(implicit ev: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Unit" id="spire.syntax.std;ArrayOps.qselect">qselect</a><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;ArrayOps.qselect.k">k</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax.std;ArrayOps.qselect.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;ArrayOps.qselect.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <a href="../../math/Selection.scala.html#spire.math.Selection" title="spire.math.Selection.type">Selection</a>.<a href="../../math/Selection.scala.html#spire.math.Selection.select" title="(data: Array[A], k: Int)(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit">select</a><a href="#spire.syntax.std;ArrayOps.qselect.ev" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>, <a href="#spire.syntax.std;ArrayOps.qselect.k" title="Int">k</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(k: Int)(implicit ev: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Array[A]" id="spire.syntax.std;ArrayOps.qselected">qselected</a><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;ArrayOps.qselected.k">k</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax.std;ArrayOps.qselected.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;ArrayOps.qselected.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[A]" id="spire.syntax.std;ArrayOps.qselected.arr2">arr2</a> = <a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="()Array[A]">clone</span>
    <a href="../../math/Selection.scala.html#spire.math.Selection" title="spire.math.Selection.type">Selection</a>.<a href="../../math/Selection.scala.html#spire.math.Selection.select" title="(data: Array[A], k: Int)(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit">select</a><a href="#spire.syntax.std;ArrayOps.qselected.ev" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.qselected.arr2" title="Array[A]">arr2</a>, <a href="#spire.syntax.std;ArrayOps.qselected.k" title="Int">k</a><span class="delimiter">)</span>
    <a href="#spire.syntax.std;ArrayOps.qselected.arr2" title="Array[A]">arr2</a>
  <span class="delimiter">}</span>

  import spire.random.Generator

  def <a title="()(implicit gen: spire.random.Generator)Unit" id="spire.syntax.std;ArrayOps.qshuffle">qshuffle</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.random.Generator" id="spire.syntax.std;ArrayOps.qshuffle.gen">gen</a>: <a href="../../random/Generator.scala.html#spire.random;Generator" title="spire.random.Generator">Generator</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#spire.syntax.std;ArrayOps.qshuffle.gen" title="spire.random.Generator">gen</a>.<a href="../../random/Generator.scala.html#spire.random;Generator.shuffle" title="(as: Array[A])(implicit gen: spire.random.Generator)Unit">shuffle</a><a href="#spire.syntax.std;ArrayOps.qshuffle.gen" title="spire.random.Generator" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a><span class="delimiter">)</span>

  def <a title="(implicit gen: spire.random.Generator)Array[A]" id="spire.syntax.std;ArrayOps.qshuffled">qshuffled</a><span class="delimiter">(</span>implicit <a title="spire.random.Generator" id="spire.syntax.std;ArrayOps.qshuffled.gen">gen</a>: <a href="../../random/Generator.scala.html#spire.random;Generator" title="spire.random.Generator">Generator</a><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[A]" id="spire.syntax.std;ArrayOps.qshuffled.arr2">arr2</a> = <a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>.<span title="()Array[A]">clone</span>
    <a href="#spire.syntax.std;ArrayOps.qshuffled.gen" title="spire.random.Generator">gen</a>.<a href="../../random/Generator.scala.html#spire.random;Generator.shuffle" title="(as: Array[A])(implicit gen: spire.random.Generator)Unit">shuffle</a><a href="#spire.syntax.std;ArrayOps.qshuffled.gen" title="spire.random.Generator" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.qshuffled.arr2" title="Array[A]">arr2</a><span class="delimiter">)</span>
    <a href="#spire.syntax.std;ArrayOps.qshuffled.arr2" title="Array[A]">arr2</a>
  <span class="delimiter">}</span>

  def <a title="(n: Int)(implicit gen: spire.random.Generator, implicit ct: scala.reflect.ClassTag[A])Array[A]" id="spire.syntax.std;ArrayOps.qsampled">qsampled</a><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;ArrayOps.qsampled.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.random.Generator" id="spire.syntax.std;ArrayOps.qsampled.gen">gen</a>: <a href="../../random/Generator.scala.html#spire.random;Generator" title="spire.random.Generator">Generator</a>, <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;ArrayOps.qsampled.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#spire.syntax.std;ArrayOps.qsampled.gen" title="spire.random.Generator">gen</a>.<a href="../../random/Generator.scala.html#spire.random;Generator.sampleFromArray" title="(as: Array[A], size: Int)(implicit evidence$4: scala.reflect.ClassTag[A], implicit gen: spire.random.Generator)Array[A]">sampleFromArray</a><a href="#spire.syntax.std;ArrayOps.qsampled.ct" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.syntax.std;ArrayOps.arr" title="Array[A]">arr</a>, <a href="#spire.syntax.std;ArrayOps.qsampled.n" title="Int">n</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a title="class IndexedSeqOps[A, CC[A] &lt;: IndexedSeq[A]] extends AnyRef" id="spire.syntax.std;IndexedSeqOps">IndexedSeqOps</a><span class="delimiter">[</span>@sp <a title="" id="spire.syntax.std;IndexedSeqOps;A">A</a>, <a title="[A] &lt;: IndexedSeq[A]" id="spire.syntax.std;IndexedSeqOps;CC">CC</a><span class="delimiter">[</span><a title="" id="spire.syntax.std;IndexedSeqOps;CC;A">A</a><span class="delimiter">]</span> &lt;: IndexedSeq<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><a href="#spire.syntax.std;IndexedSeqOps" title="spire.syntax.std.IndexedSeqOps[A,CC]" class="delimiter">(</a><a title="CC[A]" id="spire.syntax.std;IndexedSeqOps.as">as</a>: <a href="#spire.syntax.std;IndexedSeqOps;CC" title="CC[A]">CC</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(a: A)(implicit ev: spire.algebra.Order[A])Int" id="spire.syntax.std;IndexedSeqOps.qsearch">qsearch</a><span class="delimiter">(</span><a title="A" id="spire.syntax.std;IndexedSeqOps.qsearch.a">a</a>: <a href="#spire.syntax.std;IndexedSeqOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax.std;IndexedSeqOps.qsearch.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> =
    <a href="../../math/Searching.scala.html#spire.math.Searching" title="spire.math.Searching.type">Searching</a>.<a href="../../math/Searching.scala.html#spire.math.Searching.search(c1beaf1a66)" title="(as: IndexedSeq[A], item: A)(implicit evidence$3: spire.algebra.Order[A])Int">search</a><a href="#spire.syntax.std;IndexedSeqOps.qsearch.ev" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;IndexedSeqOps.as" title="CC[A]">as</a>, <a href="#spire.syntax.std;IndexedSeqOps.qsearch.a" title="A">a</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a title="class SeqOps[A, CC[A] &lt;: Iterable[A]] extends AnyRef" id="spire.syntax.std;SeqOps">SeqOps</a><span class="delimiter">[</span>@sp <a title="" id="spire.syntax.std;SeqOps;A">A</a>, <a title="[A] &lt;: Iterable[A]" id="spire.syntax.std;SeqOps;CC">CC</a><span class="delimiter">[</span><a title="" id="spire.syntax.std;SeqOps;CC;A">A</a><span class="delimiter">]</span> &lt;: Iterable<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><a href="#spire.syntax.std;SeqOps" title="spire.syntax.std.SeqOps[A,CC]" class="delimiter">(</a><a title="CC[A]" id="spire.syntax.std;SeqOps.as">as</a>: <a href="#spire.syntax.std;SeqOps;CC" title="CC[A]">CC</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">//fixme</span>
  def <a title="(implicit ev: spire.algebra.AdditiveMonoid[A])A" id="spire.syntax.std;SeqOps.qsum">qsum</a><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveMonoid[A]" id="spire.syntax.std;SeqOps.qsum.ev">ev</a>: <a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;A" title="A">A</a> =
    <a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<span title="(z: =&gt; A)(seqop: (A, A) =&gt; A, combop: (A, A) =&gt; A)A">aggregate</span><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qsum.ev" title="spire.algebra.AdditiveMonoid[A]">ev</a>.<a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qsum.ev" title="spire.algebra.AdditiveMonoid[A]">ev</a>.<a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">plus</a>, <a href="#spire.syntax.std;SeqOps.qsum.ev" title="spire.algebra.AdditiveMonoid[A]">ev</a>.<a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">plus</a><span class="delimiter">)</span>

  def <a title="(implicit ev: spire.algebra.MultiplicativeMonoid[A])A" id="spire.syntax.std;SeqOps.qproduct">qproduct</a><span class="delimiter">(</span>implicit <a title="spire.algebra.MultiplicativeMonoid[A]" id="spire.syntax.std;SeqOps.qproduct.ev">ev</a>: <a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid" title="spire.algebra.MultiplicativeMonoid[A]">MultiplicativeMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;A" title="A">A</a> =
    <a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<span title="(z: =&gt; A)(seqop: (A, A) =&gt; A, combop: (A, A) =&gt; A)A">aggregate</span><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qproduct.ev" title="spire.algebra.MultiplicativeMonoid[A]">ev</a>.<a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; A">one</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qproduct.ev" title="spire.algebra.MultiplicativeMonoid[A]">ev</a>.<a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">times</a>, <a href="#spire.syntax.std;SeqOps.qproduct.ev" title="spire.algebra.MultiplicativeMonoid[A]">ev</a>.<a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">times</a><span class="delimiter">)</span>

  def <a title="(p: Int)(implicit ev: spire.algebra.Field[A], implicit s: spire.algebra.Signed[A], implicit nr: spire.algebra.NRoot[A])A" id="spire.syntax.std;SeqOps.qnorm">qnorm</a><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;SeqOps.qnorm.p">p</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax.std;SeqOps.qnorm.ev">ev</a>: <a href="../../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.algebra.Signed[A]" id="spire.syntax.std;SeqOps.qnorm.s">s</a>: <a href="../../algebra/Signed.scala.html#spire.algebra;Signed" title="spire.algebra.Signed[A]">Signed</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[A]" id="spire.syntax.std;SeqOps.qnorm.nr">nr</a>: <a href="../../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[A]">NRoot</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;A" title="A">A</a> =
    <a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<span title="(z: =&gt; A)(seqop: (A, A) =&gt; A, combop: (A, A) =&gt; A)A">aggregate</span><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qnorm.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; A">one</a><span class="delimiter">)</span><a href="#spire.syntax.std;SeqOps.qnorm.nr" title="spire.algebra.NRoot[A]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qnorm.ev" title="spire.algebra.Field[A]">_</a> <a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+</a> <a href="#spire.syntax.std;SeqOps.qnorm.s" title="spire.algebra.Signed[A]">_</a>.<a href="#spire.syntax.std;SeqOps.qnorm.ev" title="spire.algebra.Field[A]">abs</a>.pow<a href="../../algebra/Rig.scala.html#spire.algebra;Rig.pow" title="(a: A, n: Int)A" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qnorm.p" title="Int">p</a><span class="delimiter">)</span>, <a href="#spire.syntax.std;SeqOps.qnorm.ev" title="spire.algebra.Field[A]">_</a> <a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+</a> <a href="#spire.syntax.std;SeqOps.qnorm.$anonfun.x$20" title="A">_</a><span class="delimiter">)</span>.nroot<a href="../../algebra/NRoot.scala.html#spire.algebra;NRoot.nroot" title="(a: A, n: Int)A" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qnorm.p" title="Int">p</a><span class="delimiter">)</span>

  def <a title="[R](p: Int)(f: A =&gt; R)(implicit ev: spire.algebra.Field[R], implicit s: spire.algebra.Signed[R], implicit nr: spire.algebra.NRoot[R])R" id="spire.syntax.std;SeqOps.qnormWith">qnormWith</a><span class="delimiter">[</span><a title="" id="spire.syntax.std;SeqOps.qnormWith;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;SeqOps.qnormWith.p">p</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; R" id="spire.syntax.std;SeqOps.qnormWith.f">f</a>: A =&gt; R<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[R]" id="spire.syntax.std;SeqOps.qnormWith.ev">ev</a>: <a href="../../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[R]">Field</a><span class="delimiter">[</span>R<span class="delimiter">]</span>, <a title="spire.algebra.Signed[R]" id="spire.syntax.std;SeqOps.qnormWith.s">s</a>: <a href="../../algebra/Signed.scala.html#spire.algebra;Signed" title="spire.algebra.Signed[R]">Signed</a><span class="delimiter">[</span>R<span class="delimiter">]</span>, <a title="spire.algebra.NRoot[R]" id="spire.syntax.std;SeqOps.qnormWith.nr">nr</a>: <a href="../../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[R]">NRoot</a><span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps.qnormWith;R" title="R">R</a> =
    <a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<span title="(z: =&gt; R)(seqop: (R, A) =&gt; R, combop: (R, R) =&gt; R)R">aggregate</span><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qnormWith.ev" title="spire.algebra.Field[R]">ev</a>.<a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; R">one</a><span class="delimiter">)</span><a href="#spire.syntax.std;SeqOps.qnormWith.nr" title="spire.algebra.NRoot[R]" class="delimiter">(</a><span class="delimiter">(</span><a title="R" id="spire.syntax.std;SeqOps.qnormWith.$anonfun.t">t</a>, <a title="A" id="spire.syntax.std;SeqOps.qnormWith.$anonfun.a">a</a><span class="delimiter">)</span> =&gt; <a href="#spire.syntax.std;SeqOps.qnormWith.ev" title="spire.algebra.Field[R]">t</a> <a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: R, y: R)R">+</a> <a href="#spire.syntax.std;SeqOps.qnormWith.f" title="(v1: A)R">f</a><a href="#spire.syntax.std;SeqOps.qnormWith.s" title="spire.algebra.Signed[R]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qnormWith.$anonfun.a" title="A">a</a><span class="delimiter">)</span>.<a href="#spire.syntax.std;SeqOps.qnormWith.ev" title="spire.algebra.Field[R]">abs</a>.pow<a href="../../algebra/Rig.scala.html#spire.algebra;Rig.pow" title="(a: R, n: Int)R" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qnormWith.p" title="Int">p</a><span class="delimiter">)</span>, <a href="#spire.syntax.std;SeqOps.qnormWith.ev" title="spire.algebra.Field[R]">_</a> <a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: R, y: R)R">+</a> <a href="#spire.syntax.std;SeqOps.qnormWith.$anonfun.x$22" title="R">_</a><span class="delimiter">)</span>.nroot<a href="../../algebra/NRoot.scala.html#spire.algebra;NRoot.nroot" title="(a: R, n: Int)R" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qnormWith.p" title="Int">p</a><span class="delimiter">)</span>

  <span class="comment">/** Computes the minimal elements of a partially ordered set.
   * If the poset contains multiple copies of a minimal element, the function
   * will only return a single copy of it.
   */</span>
  def <a title="(implicit ev: spire.algebra.PartialOrder[A])Seq[A]" id="spire.syntax.std;SeqOps.pmin">pmin</a><span class="delimiter">(</span>implicit <a title="spire.algebra.PartialOrder[A]" id="spire.syntax.std;SeqOps.pmin.ev">ev</a>: <a href="../../algebra/PartialOrder.scala.html#spire.algebra;PartialOrder" title="spire.algebra.PartialOrder[A]">PartialOrder</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[A]">Seq</span><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="../../math/Searching.scala.html#spire.math.Searching" title="spire.math.Searching.type">Searching</a>.<a href="../../math/Searching.scala.html#spire.math.Searching.minimalElements" title="(as: Iterable[A])(implicit ev: spire.algebra.PartialOrder[A])Seq[A]">minimalElements</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.pmin.ev" title="spire.algebra.PartialOrder[A]">ev</a><span class="delimiter">)</span>

  <span class="comment">/** Computes the maximal elements of a partially ordered set.
   * If the posset contains multiple copies of a maximal element, the function
   * will only return a single copy of it.
   */</span>
  def <a title="(implicit ev: spire.algebra.PartialOrder[A])Seq[A]" id="spire.syntax.std;SeqOps.pmax">pmax</a><span class="delimiter">(</span>implicit <a title="spire.algebra.PartialOrder[A]" id="spire.syntax.std;SeqOps.pmax.ev">ev</a>: <a href="../../algebra/PartialOrder.scala.html#spire.algebra;PartialOrder" title="spire.algebra.PartialOrder[A]">PartialOrder</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[A]">Seq</span><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="../../math/Searching.scala.html#spire.math.Searching" title="spire.math.Searching.type">Searching</a>.<a href="../../math/Searching.scala.html#spire.math.Searching.minimalElements" title="(as: Iterable[A])(implicit ev: spire.algebra.PartialOrder[A])Seq[A]">minimalElements</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.pmax.ev" title="spire.algebra.PartialOrder[A]">ev</a>.<a href="../../algebra/PartialOrder.scala.html#spire.algebra;PartialOrder.reverse" title="=&gt; spire.algebra.PartialOrder[A]">reverse</a><span class="delimiter">)</span>

  def <a title="(implicit ev: spire.algebra.Order[A])A" id="spire.syntax.std;SeqOps.qmin">qmin</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax.std;SeqOps.qmin.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;A" title="A">A</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> throw new <span title="UnsupportedOperationException">UnsupportedOperationException</span><span class="delimiter">(</span><span title="String(&quot;empty seq&quot;)" class="string">&quot;empty seq&quot;</span><span class="delimiter">)</span>
    <a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<span title="(z: =&gt; A)(seqop: (A, A) =&gt; A, combop: (A, A) =&gt; A)A">aggregate</span><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<span title="=&gt; A">head</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmin.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../../algebra/Order.scala.html#spire.algebra;Order.min" title="(x: A, y: A)A">min</a>, <a href="#spire.syntax.std;SeqOps.qmin.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../../algebra/Order.scala.html#spire.algebra;Order.min" title="(x: A, y: A)A">min</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(implicit ev: spire.algebra.Order[A])A" id="spire.syntax.std;SeqOps.qmax">qmax</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax.std;SeqOps.qmax.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;A" title="A">A</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> throw new <span title="UnsupportedOperationException">UnsupportedOperationException</span><span class="delimiter">(</span><span title="String(&quot;empty seq&quot;)" class="string">&quot;empty seq&quot;</span><span class="delimiter">)</span>
    <a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<span title="(z: =&gt; A)(seqop: (A, A) =&gt; A, combop: (A, A) =&gt; A)A">aggregate</span><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<span title="=&gt; A">head</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmax.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../../algebra/Order.scala.html#spire.algebra;Order.max" title="(x: A, y: A)A">max</a>, <a href="#spire.syntax.std;SeqOps.qmax.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../../algebra/Order.scala.html#spire.algebra;Order.max" title="(x: A, y: A)A">max</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(implicit ev: spire.algebra.Field[A])A" id="spire.syntax.std;SeqOps.qmean">qmean</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax.std;SeqOps.qmean.ev">ev</a>: <a href="../../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;A" title="A">A</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> throw new <span title="UnsupportedOperationException">UnsupportedOperationException</span><span class="delimiter">(</span><span title="String(&quot;empty seq&quot;)" class="string">&quot;empty seq&quot;</span><span class="delimiter">)</span>
    var <a title="A" id="spire.syntax.std;SeqOps.qmean.mean">mean</a> = <a href="#spire.syntax.std;SeqOps.qmean.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a>
    var <a title="Int" id="spire.syntax.std;SeqOps.qmean.i">i</a> = <span title="Int(0)" class="int">0</span>
    var <a title="Int" id="spire.syntax.std;SeqOps.qmean.j">j</a> = <span title="Int(1)" class="int">1</span>
    <a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<span title="(f: A =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="A" id="spire.syntax.std;SeqOps.qmean.$anonfun.a">a</a> =&gt;
      val <a title="A" id="spire.syntax.std;SeqOps.qmean.$anonfun.t">t</a> = <a href="#spire.syntax.std;SeqOps.qmean.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: A, y: A)A">div</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmean.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">times</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmean.mean" title="A">mean</a>, <a href="#spire.syntax.std;SeqOps.qmean.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmean.i" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#spire.syntax.std;SeqOps.qmean.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmean.j" title="Int">j</a><span class="delimiter">)</span><span class="delimiter">)</span>
      val <a title="A" id="spire.syntax.std;SeqOps.qmean.$anonfun.z">z</a> = <a href="#spire.syntax.std;SeqOps.qmean.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: A, y: A)A">div</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmean.$anonfun.a" title="A">a</a>, <a href="#spire.syntax.std;SeqOps.qmean.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmean.j" title="Int">j</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#spire.syntax.std;SeqOps.qmean.mean" title="A">mean</a> = <a href="#spire.syntax.std;SeqOps.qmean.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">plus</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmean.$anonfun.t" title="A">t</a>, <a href="#spire.syntax.std;SeqOps.qmean.$anonfun.z" title="A">z</a><span class="delimiter">)</span>
      <a href="#spire.syntax.std;SeqOps.qmean.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
      <a href="#spire.syntax.std;SeqOps.qmean.j" title="Int">j</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <span class="delimiter">}</span>
    <a href="#spire.syntax.std;SeqOps.qmean.mean" title="A">mean</a>
  <span class="delimiter">}</span>

  def <a title="[R](f: A =&gt; R)(implicit ev: spire.algebra.Field[R])R" id="spire.syntax.std;SeqOps.qmeanWith">qmeanWith</a><span class="delimiter">[</span><a title="" id="spire.syntax.std;SeqOps.qmeanWith;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; R" id="spire.syntax.std;SeqOps.qmeanWith.f">f</a>: A =&gt; R<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[R]" id="spire.syntax.std;SeqOps.qmeanWith.ev">ev</a>: <a href="../../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[R]">Field</a><span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps.qmeanWith;R" title="R">R</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> throw new <span title="UnsupportedOperationException">UnsupportedOperationException</span><span class="delimiter">(</span><span title="String(&quot;empty seq&quot;)" class="string">&quot;empty seq&quot;</span><span class="delimiter">)</span>
    var <a title="R" id="spire.syntax.std;SeqOps.qmeanWith.mean">mean</a> = <a href="#spire.syntax.std;SeqOps.qmeanWith.ev" title="spire.algebra.Field[R]">ev</a>.<a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; R">zero</a>
    var <a title="Int" id="spire.syntax.std;SeqOps.qmeanWith.i">i</a> = <span title="Int(0)" class="int">0</span>
    var <a title="Int" id="spire.syntax.std;SeqOps.qmeanWith.j">j</a> = <span title="Int(1)" class="int">1</span>
    <a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<span title="(f: A =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="A" id="spire.syntax.std;SeqOps.qmeanWith.$anonfun.a">a</a> =&gt;
      val <a title="R" id="spire.syntax.std;SeqOps.qmeanWith.$anonfun.t">t</a> = <a href="#spire.syntax.std;SeqOps.qmeanWith.ev" title="spire.algebra.Field[R]">ev</a>.<a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: R, y: R)R">div</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmeanWith.ev" title="spire.algebra.Field[R]">ev</a>.<a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: R, y: R)R">times</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmeanWith.mean" title="R">mean</a>, <a href="#spire.syntax.std;SeqOps.qmeanWith.ev" title="spire.algebra.Field[R]">ev</a>.<a href="../../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)R">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmeanWith.i" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#spire.syntax.std;SeqOps.qmeanWith.ev" title="spire.algebra.Field[R]">ev</a>.<a href="../../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)R">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmeanWith.j" title="Int">j</a><span class="delimiter">)</span><span class="delimiter">)</span>
      val <a title="R" id="spire.syntax.std;SeqOps.qmeanWith.$anonfun.z">z</a> = <a href="#spire.syntax.std;SeqOps.qmeanWith.ev" title="spire.algebra.Field[R]">ev</a>.<a href="../../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: R, y: R)R">div</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmeanWith.f" title="(v1: A)R">f</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmeanWith.$anonfun.a" title="A">a</a><span class="delimiter">)</span>, <a href="#spire.syntax.std;SeqOps.qmeanWith.ev" title="spire.algebra.Field[R]">ev</a>.<a href="../../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)R">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmeanWith.j" title="Int">j</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#spire.syntax.std;SeqOps.qmeanWith.mean" title="R">mean</a> = <a href="#spire.syntax.std;SeqOps.qmeanWith.ev" title="spire.algebra.Field[R]">ev</a>.<a href="../../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: R, y: R)R">plus</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qmeanWith.$anonfun.t" title="R">t</a>, <a href="#spire.syntax.std;SeqOps.qmeanWith.$anonfun.z" title="R">z</a><span class="delimiter">)</span>
      <a href="#spire.syntax.std;SeqOps.qmeanWith.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
      <a href="#spire.syntax.std;SeqOps.qmeanWith.j" title="Int">j</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <span class="delimiter">}</span>
    <a href="#spire.syntax.std;SeqOps.qmeanWith.mean" title="R">mean</a>
  <span class="delimiter">}</span>

  import spire.math.<span class="delimiter">{</span>Sorting, Selection<span class="delimiter">}</span>

  protected<span class="delimiter">[</span>this<span class="delimiter">]</span> def <a title="(arr: Array[A])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]" id="spire.syntax.std;SeqOps.fromArray">fromArray</a><span class="delimiter">(</span><a title="Array[A]" id="spire.syntax.std;SeqOps.fromArray.arr">arr</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" id="spire.syntax.std;SeqOps.fromArray.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;CC" title="CC[A]">CC</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scala.collection.mutable.Builder[A,CC[A]]" id="spire.syntax.std;SeqOps.fromArray.b">b</a> = <a href="#spire.syntax.std;SeqOps.fromArray.cbf" title="(from: CC[A])scala.collection.mutable.Builder[A,CC[A]]">cbf</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a><span class="delimiter">)</span>
    <a href="#spire.syntax.std;SeqOps.fromArray.b" title="scala.collection.mutable.Builder[A,CC[A]]">b</a>.<span title="(size: Int)Unit">sizeHint</span><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.fromArray.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span>
    cfor<span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">(</span>_ <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.syntax.std;SeqOps.fromArray.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span>, _ <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a title="Int" id="spire.syntax.std;SeqOps.fromArray.index$macro$440" class="delimiter">{</a> i =&gt; <a href="#spire.syntax.std;SeqOps.fromArray.b" title="scala.collection.mutable.Builder[A,CC[A]]">b</a> <span title="(elem: A)b.type">+=</span> <a href="#spire.syntax.std;SeqOps.fromArray.arr" title="(i: Int)A">arr</a><span class="delimiter">(</span>i<span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#spire.syntax.std;SeqOps.fromArray.b" title="scala.collection.mutable.Builder[A,CC[A]]">b</a>.<span title="()CC[A]">result</span>
  <span class="delimiter">}</span>

  protected<span class="delimiter">[</span>this<span class="delimiter">]</span> def <a title="(size: Int, arr: Array[A])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]" id="spire.syntax.std;SeqOps.fromSizeAndArray">fromSizeAndArray</a><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;SeqOps.fromSizeAndArray.size">size</a>: <span title="Int">Int</span>, <a title="Array[A]" id="spire.syntax.std;SeqOps.fromSizeAndArray.arr">arr</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" id="spire.syntax.std;SeqOps.fromSizeAndArray.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;CC" title="CC[A]">CC</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scala.collection.mutable.Builder[A,CC[A]]" id="spire.syntax.std;SeqOps.fromSizeAndArray.b">b</a> = <a href="#spire.syntax.std;SeqOps.fromSizeAndArray.cbf" title="(from: CC[A])scala.collection.mutable.Builder[A,CC[A]]">cbf</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a><span class="delimiter">)</span>
    <a href="#spire.syntax.std;SeqOps.fromSizeAndArray.b" title="scala.collection.mutable.Builder[A,CC[A]]">b</a>.<span title="(size: Int)Unit">sizeHint</span><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.fromSizeAndArray.size" title="Int">size</a><span class="delimiter">)</span>
    cfor<span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">(</span>_ <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.syntax.std;SeqOps.fromSizeAndArray.size" title="Int">size</a>, _ <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a title="Int" id="spire.syntax.std;SeqOps.fromSizeAndArray.index$macro$441" class="delimiter">{</a> i =&gt; <a href="#spire.syntax.std;SeqOps.fromSizeAndArray.b" title="scala.collection.mutable.Builder[A,CC[A]]">b</a> <span title="(elem: A)b.type">+=</span> <a href="#spire.syntax.std;SeqOps.fromSizeAndArray.arr" title="(i: Int)A">arr</a><span class="delimiter">(</span>i<span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#spire.syntax.std;SeqOps.fromSizeAndArray.b" title="scala.collection.mutable.Builder[A,CC[A]]">b</a>.<span title="()CC[A]">result</span>
  <span class="delimiter">}</span>

  def <a title="(implicit ev: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A], implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]" id="spire.syntax.std;SeqOps.qsorted">qsorted</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax.std;SeqOps.qsorted.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;SeqOps.qsorted.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" id="spire.syntax.std;SeqOps.qsorted.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;CC" title="CC[A]">CC</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[A]" id="spire.syntax.std;SeqOps.qsorted.arr">arr</a> = <a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<a href="#spire.syntax.std;SeqOps.qsorted.ct" title="(implicit evidence$1: scala.reflect.ClassTag[A])Array[A]">toArray</a>
    <a href="../../math/Sorting.scala.html#spire.math.Sorting" title="spire.math.Sorting.type">Sorting</a>.<a href="../../math/Sorting.scala.html#spire.math.Sorting.sort" title="(data: Array[A])(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.syntax.std;SeqOps.qsorted.ev" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qsorted.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
    <a href="#spire.syntax.std;SeqOps.fromArray" title="(arr: Array[A])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]">fromArray</a><a href="#spire.syntax.std;SeqOps.qsorted.cbf" title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qsorted.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  def <a title="[B](f: A =&gt; B)(implicit ev: spire.algebra.Order[B], implicit ct: scala.reflect.ClassTag[A], implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]" id="spire.syntax.std;SeqOps.qsortedBy">qsortedBy</a><span class="delimiter">[</span>@sp <a title="" id="spire.syntax.std;SeqOps.qsortedBy;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="spire.syntax.std;SeqOps.qsortedBy.f">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[B]" id="spire.syntax.std;SeqOps.qsortedBy.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[B]">Order</a><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;SeqOps.qsortedBy.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" id="spire.syntax.std;SeqOps.qsortedBy.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;CC" title="CC[A]">CC</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    implicit val <a title="spire.algebra.Order[A]" id="spire.syntax.std;SeqOps.qsortedBy.ord">ord</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.syntax.std;SeqOps.qsortedBy.ev" title="spire.algebra.Order[B]">ev</a>.<a href="../../algebra/Order.scala.html#spire.algebra;Order.on" title="(f: A =&gt; B)spire.algebra.Order[A]">on</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qsortedBy.f" title="A =&gt; B">f</a><span class="delimiter">)</span>
    val <a title="Array[A]" id="spire.syntax.std;SeqOps.qsortedBy.arr">arr</a> = <a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<a href="#spire.syntax.std;SeqOps.qsortedBy.ct" title="(implicit evidence$1: scala.reflect.ClassTag[A])Array[A]">toArray</a>
    <a href="../../math/Sorting.scala.html#spire.math.Sorting" title="spire.math.Sorting.type">Sorting</a>.<a href="../../math/Sorting.scala.html#spire.math.Sorting.sort" title="(data: Array[A])(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.syntax.std;SeqOps.qsortedBy.ord" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qsortedBy.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
    <a href="#spire.syntax.std;SeqOps.fromArray" title="(arr: Array[A])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]">fromArray</a><a href="#spire.syntax.std;SeqOps.qsortedBy.cbf" title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qsortedBy.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  def <a title="(f: (A, A) =&gt; Int)(implicit ct: scala.reflect.ClassTag[A], implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]" id="spire.syntax.std;SeqOps.qsortedWith">qsortedWith</a><span class="delimiter">(</span><a title="(A, A) =&gt; Int" id="spire.syntax.std;SeqOps.qsortedWith.f">f</a>: <span class="delimiter">(</span>A, A<span class="delimiter">)</span> =&gt; Int<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;SeqOps.qsortedWith.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" id="spire.syntax.std;SeqOps.qsortedWith.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;CC" title="CC[A]">CC</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    implicit val <a title="spire.algebra.Order[A]" id="spire.syntax.std;SeqOps.qsortedWith.ord">ord</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="../../algebra/Order.scala.html#spire.algebra.Order" title="spire.algebra.Order.type">Order</a>.<a href="../../algebra/Order.scala.html#spire.algebra.Order.from" title="(f: (A, A) =&gt; Int)spire.algebra.Order[A]">from</a><span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qsortedWith.f" title="(A, A) =&gt; Int">f</a><span class="delimiter">)</span>
    val <a title="Array[A]" id="spire.syntax.std;SeqOps.qsortedWith.arr">arr</a> = <a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<a href="#spire.syntax.std;SeqOps.qsortedWith.ct" title="(implicit evidence$1: scala.reflect.ClassTag[A])Array[A]">toArray</a>
    <a href="../../math/Sorting.scala.html#spire.math.Sorting" title="spire.math.Sorting.type">Sorting</a>.<a href="../../math/Sorting.scala.html#spire.math.Sorting.sort" title="(data: Array[A])(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.syntax.std;SeqOps.qsortedWith.ord" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qsortedWith.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
    <a href="#spire.syntax.std;SeqOps.fromArray" title="(arr: Array[A])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]">fromArray</a><a href="#spire.syntax.std;SeqOps.qsortedWith.cbf" title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qsortedWith.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  def <a title="(k: Int)(implicit ev: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A], implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]" id="spire.syntax.std;SeqOps.qselected">qselected</a><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;SeqOps.qselected.k">k</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax.std;SeqOps.qselected.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;SeqOps.qselected.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" id="spire.syntax.std;SeqOps.qselected.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;CC" title="CC[A]">CC</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[A]" id="spire.syntax.std;SeqOps.qselected.arr">arr</a> = <a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<a href="#spire.syntax.std;SeqOps.qselected.ct" title="(implicit evidence$1: scala.reflect.ClassTag[A])Array[A]">toArray</a>
    <a href="../../math/Selection.scala.html#spire.math.Selection" title="spire.math.Selection.type">Selection</a>.<a href="../../math/Selection.scala.html#spire.math.Selection.select" title="(data: Array[A], k: Int)(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit">select</a><a href="#spire.syntax.std;SeqOps.qselected.ev" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qselected.arr" title="Array[A]">arr</a>, <a href="#spire.syntax.std;SeqOps.qselected.k" title="Int">k</a><span class="delimiter">)</span>
    <a href="#spire.syntax.std;SeqOps.fromArray" title="(arr: Array[A])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]">fromArray</a><a href="#spire.syntax.std;SeqOps.qselected.cbf" title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qselected.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(k: Int)(implicit ev: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A], implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]" id="spire.syntax.std;SeqOps.qselectk">qselectk</a><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;SeqOps.qselectk.k">k</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax.std;SeqOps.qselectk.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;SeqOps.qselectk.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" id="spire.syntax.std;SeqOps.qselectk.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;CC" title="CC[A]">CC</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[A]" id="spire.syntax.std;SeqOps.qselectk.arr">arr</a> = <a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<a href="#spire.syntax.std;SeqOps.qselectk.ct" title="(implicit evidence$1: scala.reflect.ClassTag[A])Array[A]">toArray</a>
    if <span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qselectk.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">&lt;=</span> <a href="#spire.syntax.std;SeqOps.qselectk.k" title="Int">k</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.syntax.std;SeqOps.fromArray" title="(arr: Array[A])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]">fromArray</a><a href="#spire.syntax.std;SeqOps.qselectk.cbf" title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qselectk.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <a href="../../math/Selection.scala.html#spire.math.Selection" title="spire.math.Selection.type">Selection</a>.<a href="../../math/Selection.scala.html#spire.math.Selection.select" title="(data: Array[A], k: Int)(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit">select</a><a href="#spire.syntax.std;SeqOps.qselectk.ev" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qselectk.arr" title="Array[A]">arr</a>, <a href="#spire.syntax.std;SeqOps.qselectk.k" title="Int">k</a><span class="delimiter">)</span>
      <a href="#spire.syntax.std;SeqOps.fromSizeAndArray" title="(size: Int, arr: Array[A])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]">fromSizeAndArray</a><a href="#spire.syntax.std;SeqOps.qselectk.cbf" title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qselectk.k" title="Int">k</a>, <a href="#spire.syntax.std;SeqOps.qselectk.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(k: Int)(implicit ev: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A], implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]" id="spire.syntax.std;SeqOps.qtopk">qtopk</a><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;SeqOps.qtopk.k">k</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax.std;SeqOps.qtopk.ev">ev</a>: <a href="../../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;SeqOps.qtopk.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" id="spire.syntax.std;SeqOps.qtopk.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;CC" title="CC[A]">CC</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[A]" id="spire.syntax.std;SeqOps.qtopk.arr">arr</a> = <a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<a href="#spire.syntax.std;SeqOps.qtopk.ct" title="(implicit evidence$1: scala.reflect.ClassTag[A])Array[A]">toArray</a>
    if <span class="delimiter">(</span><a href="#spire.syntax.std;SeqOps.qtopk.arr" title="Array[A]">arr</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">&lt;=</span> <a href="#spire.syntax.std;SeqOps.qtopk.k" title="Int">k</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../math/Sorting.scala.html#spire.math.Sorting" title="spire.math.Sorting.type">Sorting</a>.<a href="../../math/Sorting.scala.html#spire.math.Sorting.sort" title="(data: Array[A])(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit">sort</a><a href="#spire.syntax.std;SeqOps.qtopk.ev" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qtopk.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
      <a href="#spire.syntax.std;SeqOps.fromArray" title="(arr: Array[A])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]">fromArray</a><a href="#spire.syntax.std;SeqOps.qtopk.cbf" title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qtopk.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <a href="../../math/Selection.scala.html#spire.math.Selection" title="spire.math.Selection.type">Selection</a>.<a href="../../math/Selection.scala.html#spire.math.Selection.select" title="(data: Array[A], k: Int)(implicit evidence$9: spire.algebra.Order[A], implicit evidence$10: scala.reflect.ClassTag[A])Unit">select</a><a href="#spire.syntax.std;SeqOps.qtopk.ev" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qtopk.arr" title="Array[A]">arr</a>, <a href="#spire.syntax.std;SeqOps.qtopk.k" title="Int">k</a><span class="delimiter">)</span>
      <a href="../../math/Sorting.scala.html#spire.math.QuickSort" title="spire.math.QuickSort.type">QuickSort</a>.<a href="../../math/Sorting.scala.html#spire.math.QuickSort.qsort" title="(data: Array[A], left: Int, right: Int)(implicit o: spire.algebra.Order[A], implicit ct: scala.reflect.ClassTag[A])Unit">qsort</a><a href="#spire.syntax.std;SeqOps.qtopk.ev" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qtopk.arr" title="Array[A]">arr</a>, <span title="Int(0)" class="int">0</span>, <a href="#spire.syntax.std;SeqOps.qtopk.k" title="Int">k</a><span class="delimiter">)</span>
      <a href="#spire.syntax.std;SeqOps.fromSizeAndArray" title="(size: Int, arr: Array[A])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]">fromSizeAndArray</a><a href="#spire.syntax.std;SeqOps.qtopk.cbf" title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qtopk.k" title="Int">k</a>, <a href="#spire.syntax.std;SeqOps.qtopk.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  import spire.random.Generator

  def <a title="(implicit gen: spire.random.Generator, implicit ct: scala.reflect.ClassTag[A], implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]" id="spire.syntax.std;SeqOps.qshuffled">qshuffled</a><span class="delimiter">(</span>implicit <a title="spire.random.Generator" id="spire.syntax.std;SeqOps.qshuffled.gen">gen</a>: <a href="../../random/Generator.scala.html#spire.random;Generator" title="spire.random.Generator">Generator</a>, <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;SeqOps.qshuffled.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" id="spire.syntax.std;SeqOps.qshuffled.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;CC" title="CC[A]">CC</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[A]" id="spire.syntax.std;SeqOps.qshuffled.arr">arr</a> = <a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>.<a href="#spire.syntax.std;SeqOps.qshuffled.ct" title="(implicit evidence$1: scala.reflect.ClassTag[A])Array[A]">toArray</a>
    <a href="#spire.syntax.std;SeqOps.qshuffled.gen" title="spire.random.Generator">gen</a>.<a href="../../random/Generator.scala.html#spire.random;Generator.shuffle" title="(as: Array[A])(implicit gen: spire.random.Generator)Unit">shuffle</a><a href="#spire.syntax.std;SeqOps.qshuffled.gen" title="spire.random.Generator" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qshuffled.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
    <a href="#spire.syntax.std;SeqOps.fromArray" title="(arr: Array[A])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]">fromArray</a><a href="#spire.syntax.std;SeqOps.qshuffled.cbf" title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qshuffled.arr" title="Array[A]">arr</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(n: Int)(implicit gen: spire.random.Generator, implicit ct: scala.reflect.ClassTag[A], implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]" id="spire.syntax.std;SeqOps.qsampled">qsampled</a><span class="delimiter">(</span><a title="Int" id="spire.syntax.std;SeqOps.qsampled.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.random.Generator" id="spire.syntax.std;SeqOps.qsampled.gen">gen</a>: <a href="../../random/Generator.scala.html#spire.random;Generator" title="spire.random.Generator">Generator</a>, <a title="scala.reflect.ClassTag[A]" id="spire.syntax.std;SeqOps.qsampled.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" id="spire.syntax.std;SeqOps.qsampled.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;CC" title="CC[A]">CC</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#spire.syntax.std;SeqOps.fromArray" title="(arr: Array[A])(implicit cbf: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])CC[A]">fromArray</a><a href="#spire.syntax.std;SeqOps.qsampled.cbf" title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.qsampled.gen" title="spire.random.Generator">gen</a>.<a href="../../random/Generator.scala.html#spire.random;Generator.sampleFromTraversable" title="(as: Traversable[A], size: Int)(implicit evidence$5: scala.reflect.ClassTag[A], implicit gen: spire.random.Generator)Array[A]">sampleFromTraversable</a><a href="#spire.syntax.std;SeqOps.qsampled.ct" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a>, <a href="#spire.syntax.std;SeqOps.qsampled.n" title="Int">n</a><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="(implicit gen: spire.random.Generator)A" id="spire.syntax.std;SeqOps.qchoose">qchoose</a><span class="delimiter">(</span>implicit <a title="spire.random.Generator" id="spire.syntax.std;SeqOps.qchoose.gen">gen</a>: <a href="../../random/Generator.scala.html#spire.random;Generator" title="spire.random.Generator">Generator</a><span class="delimiter">)</span>: <a href="#spire.syntax.std;SeqOps;A" title="A">A</a> =
    <a href="#spire.syntax.std;SeqOps.qchoose.gen" title="spire.random.Generator">gen</a>.<a href="../../random/Generator.scala.html#spire.random;Generator.chooseFromIterable" title="(as: Iterable[A])(implicit gen: spire.random.Generator)A">chooseFromIterable</a><a href="#spire.syntax.std;SeqOps.qchoose.gen" title="spire.random.Generator" class="delimiter">(</a><a href="#spire.syntax.std;SeqOps.as" title="CC[A]">as</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
