<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>spire/spire/syntax/Ops.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package spire.syntax

import spire.algebra._
import spire.algebra.lattice._
import spire.algebra.partial._
import spire.macros.Ops
import spire.math.<span class="delimiter">{</span>BitString, ConvertableTo, ConvertableFrom, Interval, Rational, Number<span class="delimiter">}</span>
import spire.util.Opt

final class <a title="class EqOps[A] extends AnyRef" id="spire.syntax;EqOps">EqOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;EqOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;EqOps" title="spire.syntax.EqOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;EqOps.lhs">lhs</a>:<a href="#spire.syntax;EqOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Eq[A]" id="spire.syntax;EqOps.ev">ev</a>:<a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[A]">Eq</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: A)Boolean" id="spire.syntax;EqOps.===">===</a><span class="delimiter">(</span><a title="A" id="spire.syntax;EqOps.===.rhs">rhs</a>:<a href="#spire.syntax;EqOps;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[Boolean]" class="delimiter">[</span><a href="#spire.syntax;EqOps;A" title="A">A</a>, <span title="Boolean">Boolean</span><span class="delimiter">]</span>
  def <a title="(rhs: A)Boolean" id="spire.syntax;EqOps.=!=">=!=</a><span class="delimiter">(</span><a title="A" id="spire.syntax;EqOps.=!=.rhs">rhs</a>:<a href="#spire.syntax;EqOps;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[Boolean]" class="delimiter">[</span><a href="#spire.syntax;EqOps;A" title="A">A</a>, <span title="Boolean">Boolean</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class PartialOrderOps[A] extends AnyRef" id="spire.syntax;PartialOrderOps">PartialOrderOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;PartialOrderOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;PartialOrderOps" title="spire.syntax.PartialOrderOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;PartialOrderOps.lhs">lhs</a>: <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.PartialOrder[A]" id="spire.syntax;PartialOrderOps.ev">ev</a>: <a href="../algebra/PartialOrder.scala.html#spire.algebra;PartialOrder" title="spire.algebra.PartialOrder[A]">PartialOrder</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: A)Boolean" id="spire.syntax;PartialOrderOps.>(ad117a4409)">&gt;</a><span class="delimiter">(</span><a title="A" id="spire.syntax;PartialOrderOps.>(ad117a4409).rhs">rhs</a>: <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[Boolean]" class="delimiter">[</span><a href="#spire.syntax;PartialOrderOps;A" title="A">A</a>, <span title="Boolean">Boolean</span><span class="delimiter">]</span>
  def <a title="(rhs: A)Boolean" id="spire.syntax;PartialOrderOps.>=(ad117a4409)">&gt;=</a><span class="delimiter">(</span><a title="A" id="spire.syntax;PartialOrderOps.>=(ad117a4409).rhs">rhs</a>: <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[Boolean]" class="delimiter">[</span><a href="#spire.syntax;PartialOrderOps;A" title="A">A</a>, <span title="Boolean">Boolean</span><span class="delimiter">]</span>
  def <a title="(rhs: A)Boolean" id="spire.syntax;PartialOrderOps.<(ad117a4409)">&lt;</a><span class="delimiter">(</span><a title="A" id="spire.syntax;PartialOrderOps.<(ad117a4409).rhs">rhs</a>: <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[Boolean]" class="delimiter">[</span><a href="#spire.syntax;PartialOrderOps;A" title="A">A</a>, <span title="Boolean">Boolean</span><span class="delimiter">]</span>
  def <a title="(rhs: A)Boolean" id="spire.syntax;PartialOrderOps.<=(ad117a4409)">&lt;=</a><span class="delimiter">(</span><a title="A" id="spire.syntax;PartialOrderOps.<=(ad117a4409).rhs">rhs</a>: <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[Boolean]" class="delimiter">[</span><a href="#spire.syntax;PartialOrderOps;A" title="A">A</a>, <span title="Boolean">Boolean</span><span class="delimiter">]</span>

  def <a title="(rhs: A)Double" id="spire.syntax;PartialOrderOps.partialCompare">partialCompare</a><span class="delimiter">(</span><a title="A" id="spire.syntax;PartialOrderOps.partialCompare.rhs">rhs</a>: <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">)</span>: <span title="Double">Double</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[Double]" class="delimiter">[</span><a href="#spire.syntax;PartialOrderOps;A" title="A">A</a>, <span title="Double">Double</span><span class="delimiter">]</span>
  def <a title="(rhs: A)Option[Int]" id="spire.syntax;PartialOrderOps.tryCompare">tryCompare</a><span class="delimiter">(</span><a title="A" id="spire.syntax;PartialOrderOps.tryCompare.rhs">rhs</a>: <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">)</span>: <span title="Option[Int]">Option</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[Option[Int]]" class="delimiter">[</span><a href="#spire.syntax;PartialOrderOps;A" title="A">A</a>, <span title="Option[Int]">Option</span><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">]</span>
  def <a title="(rhs: A)Option[A]" id="spire.syntax;PartialOrderOps.pmin">pmin</a><span class="delimiter">(</span><a title="A" id="spire.syntax;PartialOrderOps.pmin.rhs">rhs</a>: <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">)</span>: <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;PartialOrderOps;A" title="A">A</a>, <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)Option[A]" id="spire.syntax;PartialOrderOps.pmax">pmax</a><span class="delimiter">(</span><a title="A" id="spire.syntax;PartialOrderOps.pmax.rhs">rhs</a>: <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">)</span>: <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;PartialOrderOps;A" title="A">A</a>, <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])Boolean" id="spire.syntax;PartialOrderOps.>(ba1d3f3c6f)">&gt;</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;PartialOrderOps.>(ba1d3f3c6f).rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;PartialOrderOps.>(ba1d3f3c6f).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])Boolean" id="spire.syntax;PartialOrderOps.>=(ba1d3f3c6f)">&gt;=</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;PartialOrderOps.>=(ba1d3f3c6f).rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;PartialOrderOps.>=(ba1d3f3c6f).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])Boolean" id="spire.syntax;PartialOrderOps.<(ba1d3f3c6f)">&lt;</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;PartialOrderOps.<(ba1d3f3c6f).rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;PartialOrderOps.<(ba1d3f3c6f).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])Boolean" id="spire.syntax;PartialOrderOps.<=(ba1d3f3c6f)">&lt;=</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;PartialOrderOps.<=(ba1d3f3c6f).rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;PartialOrderOps.<=(ba1d3f3c6f).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="(rhs: Double)(implicit ev1: spire.algebra.Field[A])Boolean" id="spire.syntax;PartialOrderOps.>(a57a576713)">&gt;</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;PartialOrderOps.>(a57a576713).rhs">rhs</a>: <span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;PartialOrderOps.>(a57a576713).ev1">ev1</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Field[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Double)(implicit ev1: spire.algebra.Field[A])Boolean" id="spire.syntax;PartialOrderOps.>=(a57a576713)">&gt;=</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;PartialOrderOps.>=(a57a576713).rhs">rhs</a>: <span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;PartialOrderOps.>=(a57a576713).ev1">ev1</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Field[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Double)(implicit ev1: spire.algebra.Field[A])Boolean" id="spire.syntax;PartialOrderOps.<(a57a576713)">&lt;</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;PartialOrderOps.<(a57a576713).rhs">rhs</a>: <span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;PartialOrderOps.<(a57a576713).ev1">ev1</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Field[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Double)(implicit ev1: spire.algebra.Field[A])Boolean" id="spire.syntax;PartialOrderOps.<=(a57a576713)">&lt;=</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;PartialOrderOps.<=(a57a576713).rhs">rhs</a>: <span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;PartialOrderOps.<=(a57a576713).ev1">ev1</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Field[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;PartialOrderOps;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])Boolean" id="spire.syntax;PartialOrderOps.>(6a5ed69336)">&gt;</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;PartialOrderOps.>(6a5ed69336).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;PartialOrderOps.>(6a5ed69336).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;PartialOrderOps.>(6a5ed69336).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;PartialOrderOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number.>" title="(rhs: spire.math.Number)Boolean">&gt;</a> <a href="#spire.syntax;PartialOrderOps.>(6a5ed69336).rhs" title="spire.math.Number">rhs</a>
  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])Boolean" id="spire.syntax;PartialOrderOps.>=(6a5ed69336)">&gt;=</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;PartialOrderOps.>=(6a5ed69336).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;PartialOrderOps.>=(6a5ed69336).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;PartialOrderOps.>=(6a5ed69336).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;PartialOrderOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number.>=" title="(rhs: spire.math.Number)Boolean">&gt;=</a> <a href="#spire.syntax;PartialOrderOps.>=(6a5ed69336).rhs" title="spire.math.Number">rhs</a>
  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])Boolean" id="spire.syntax;PartialOrderOps.<(6a5ed69336)">&lt;</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;PartialOrderOps.<(6a5ed69336).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;PartialOrderOps.<(6a5ed69336).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;PartialOrderOps.<(6a5ed69336).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;PartialOrderOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number.<" title="(rhs: spire.math.Number)Boolean">&lt;</a> <a href="#spire.syntax;PartialOrderOps.<(6a5ed69336).rhs" title="spire.math.Number">rhs</a>
  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])Boolean" id="spire.syntax;PartialOrderOps.<=(6a5ed69336)">&lt;=</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;PartialOrderOps.<=(6a5ed69336).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;PartialOrderOps.<=(6a5ed69336).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;PartialOrderOps.<=(6a5ed69336).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;PartialOrderOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number.<=" title="(rhs: spire.math.Number)Boolean">&lt;=</a> <a href="#spire.syntax;PartialOrderOps.<=(6a5ed69336).rhs" title="spire.math.Number">rhs</a>
<span class="delimiter">}</span>

final class <a title="class OrderOps[A] extends AnyRef" id="spire.syntax;OrderOps">OrderOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;OrderOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;OrderOps" title="spire.syntax.OrderOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;OrderOps.lhs">lhs</a>: <a href="#spire.syntax;OrderOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;OrderOps.ev">ev</a>: <a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: A)Int" id="spire.syntax;OrderOps.compare(eb5e8aec9b)">compare</a><span class="delimiter">(</span><a title="A" id="spire.syntax;OrderOps.compare(eb5e8aec9b).rhs">rhs</a>: <a href="#spire.syntax;OrderOps;A" title="A">A</a><span class="delimiter">)</span>: <span title="Int">Int</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[Int]" class="delimiter">[</span><a href="#spire.syntax;OrderOps;A" title="A">A</a>, <span title="Int">Int</span><span class="delimiter">]</span>
  def <a title="(rhs: A)A" id="spire.syntax;OrderOps.min(867292a5eb)">min</a><span class="delimiter">(</span><a title="A" id="spire.syntax;OrderOps.min(867292a5eb).rhs">rhs</a>: <a href="#spire.syntax;OrderOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;OrderOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;OrderOps;A" title="A">A</a>, <a href="#spire.syntax;OrderOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)A" id="spire.syntax;OrderOps.max(867292a5eb)">max</a><span class="delimiter">(</span><a title="A" id="spire.syntax;OrderOps.max(867292a5eb).rhs">rhs</a>: <a href="#spire.syntax;OrderOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;OrderOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;OrderOps;A" title="A">A</a>, <a href="#spire.syntax;OrderOps;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])Int" id="spire.syntax;OrderOps.compare(a519130607)">compare</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;OrderOps.compare(a519130607).rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;OrderOps.compare(a519130607).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;OrderOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])A" id="spire.syntax;OrderOps.min(5faa3d8872)">min</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;OrderOps.min(5faa3d8872).rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;OrderOps.min(5faa3d8872).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;OrderOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;OrderOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])A" id="spire.syntax;OrderOps.max(5faa3d8872)">max</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;OrderOps.max(5faa3d8872).rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;OrderOps.max(5faa3d8872).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;OrderOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;OrderOps;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="(rhs: Double)(implicit ev1: spire.algebra.Field[A])Int" id="spire.syntax;OrderOps.compare(e4897ded84)">compare</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;OrderOps.compare(e4897ded84).rhs">rhs</a>: <span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;OrderOps.compare(e4897ded84).ev1">ev1</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Field[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;OrderOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Double)(implicit ev1: spire.algebra.Field[A])A" id="spire.syntax;OrderOps.min(a7265c38be)">min</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;OrderOps.min(a7265c38be).rhs">rhs</a>: <span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;OrderOps.min(a7265c38be).ev1">ev1</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;OrderOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Field[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;OrderOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Double)(implicit ev1: spire.algebra.Field[A])A" id="spire.syntax;OrderOps.max(a7265c38be)">max</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;OrderOps.max(a7265c38be).rhs">rhs</a>: <span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;OrderOps.max(a7265c38be).ev1">ev1</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;OrderOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Field[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;OrderOps;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])Int" id="spire.syntax;OrderOps.compare(f5ce4d2778)">compare</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;OrderOps.compare(f5ce4d2778).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;OrderOps.compare(f5ce4d2778).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.syntax;OrderOps.compare(f5ce4d2778).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;OrderOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number.compare" title="(rhs: spire.math.Number)Int">compare</a> <a href="#spire.syntax;OrderOps.compare(f5ce4d2778).rhs" title="spire.math.Number">rhs</a>
  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])spire.math.Number" id="spire.syntax;OrderOps.min(8885950850)">min</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;OrderOps.min(8885950850).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;OrderOps.min(8885950850).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="#spire.syntax;OrderOps.min(8885950850).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;OrderOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number.min" title="(rhs: spire.math.Number)spire.math.Number">min</a> <a href="#spire.syntax;OrderOps.min(8885950850).rhs" title="spire.math.Number">rhs</a>
  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])spire.math.Number" id="spire.syntax;OrderOps.max(8885950850)">max</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;OrderOps.max(8885950850).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;OrderOps.max(8885950850).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="#spire.syntax;OrderOps.max(8885950850).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;OrderOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number.max" title="(rhs: spire.math.Number)spire.math.Number">max</a> <a href="#spire.syntax;OrderOps.max(8885950850).rhs" title="spire.math.Number">rhs</a>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralIntOrderOps.lhs" title="class LiteralIntOrderOps extends AnyVal" id="spire.syntax.LiteralIntOrderOps">LiteralIntOrderOps</a><a href="#spire.syntax.LiteralIntOrderOps" title="spire.syntax.LiteralIntOrderOps" class="delimiter">(</a>val <a title="Int" id="spire.syntax;LiteralIntOrderOps.lhs">lhs</a>: <span title="Int">Int</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralIntOrderOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])Boolean" id="spire.syntax;LiteralIntOrderOps.<">&lt;</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralIntOrderOps.<;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralIntOrderOps.<.rhs">rhs</a>:<a href="#spire.syntax;LiteralIntOrderOps.<;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralIntOrderOps.<.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralIntOrderOps.<.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;LiteralIntOrderOps.<.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">lt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntOrderOps.<.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntOrderOps.lhs" title="=&gt; Int">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralIntOrderOps.<.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])Boolean" id="spire.syntax;LiteralIntOrderOps.<=">&lt;=</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralIntOrderOps.<=;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralIntOrderOps.<=.rhs">rhs</a>:<a href="#spire.syntax;LiteralIntOrderOps.<=;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralIntOrderOps.<=.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralIntOrderOps.<=.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;LiteralIntOrderOps.<=.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.lteqv" title="(x: A, y: A)Boolean">lteqv</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntOrderOps.<=.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntOrderOps.lhs" title="=&gt; Int">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralIntOrderOps.<=.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])Boolean" id="spire.syntax;LiteralIntOrderOps.>">&gt;</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralIntOrderOps.>;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralIntOrderOps.>.rhs">rhs</a>:<a href="#spire.syntax;LiteralIntOrderOps.>;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralIntOrderOps.>.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralIntOrderOps.>.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;LiteralIntOrderOps.>.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">gt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntOrderOps.>.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntOrderOps.lhs" title="=&gt; Int">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralIntOrderOps.>.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])Boolean" id="spire.syntax;LiteralIntOrderOps.>=">&gt;=</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralIntOrderOps.>=;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralIntOrderOps.>=.rhs">rhs</a>:<a href="#spire.syntax;LiteralIntOrderOps.>=;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralIntOrderOps.>=.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralIntOrderOps.>=.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;LiteralIntOrderOps.>=.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.gteqv" title="(x: A, y: A)Boolean">gteqv</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntOrderOps.>=.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntOrderOps.lhs" title="=&gt; Int">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralIntOrderOps.>=.rhs" title="A">rhs</a><span class="delimiter">)</span>

  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])Int" id="spire.syntax;LiteralIntOrderOps.cmp">cmp</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralIntOrderOps.cmp;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralIntOrderOps.cmp.rhs">rhs</a>:<a href="#spire.syntax;LiteralIntOrderOps.cmp;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralIntOrderOps.cmp.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralIntOrderOps.cmp.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.syntax;LiteralIntOrderOps.cmp.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.compare" title="(x: A, y: A)Int">compare</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntOrderOps.cmp.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntOrderOps.lhs" title="=&gt; Int">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralIntOrderOps.cmp.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])A" id="spire.syntax;LiteralIntOrderOps.min">min</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralIntOrderOps.min;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralIntOrderOps.min.rhs">rhs</a>:<a href="#spire.syntax;LiteralIntOrderOps.min;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralIntOrderOps.min.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralIntOrderOps.min.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralIntOrderOps.min;A" title="A">A</a> = <a href="#spire.syntax;LiteralIntOrderOps.min.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.min" title="(x: A, y: A)A">min</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntOrderOps.min.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntOrderOps.lhs" title="=&gt; Int">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralIntOrderOps.min.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])A" id="spire.syntax;LiteralIntOrderOps.max">max</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralIntOrderOps.max;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralIntOrderOps.max.rhs">rhs</a>:<a href="#spire.syntax;LiteralIntOrderOps.max;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralIntOrderOps.max.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralIntOrderOps.max.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralIntOrderOps.max;A" title="A">A</a> = <a href="#spire.syntax;LiteralIntOrderOps.max.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.max" title="(x: A, y: A)A">max</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntOrderOps.max.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntOrderOps.lhs" title="=&gt; Int">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralIntOrderOps.max.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralLongOrderOps.lhs" title="class LiteralLongOrderOps extends AnyVal" id="spire.syntax.LiteralLongOrderOps">LiteralLongOrderOps</a><a href="#spire.syntax.LiteralLongOrderOps" title="spire.syntax.LiteralLongOrderOps" class="delimiter">(</a>val <a title="Long" id="spire.syntax;LiteralLongOrderOps.lhs">lhs</a>: <span title="Long">Long</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralLongOrderOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])Boolean" id="spire.syntax;LiteralLongOrderOps.<">&lt;</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralLongOrderOps.<;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralLongOrderOps.<.rhs">rhs</a>:<a href="#spire.syntax;LiteralLongOrderOps.<;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralLongOrderOps.<.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralLongOrderOps.<.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;LiteralLongOrderOps.<.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">lt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongOrderOps.<.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongOrderOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralLongOrderOps.<.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])Boolean" id="spire.syntax;LiteralLongOrderOps.<=">&lt;=</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralLongOrderOps.<=;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralLongOrderOps.<=.rhs">rhs</a>:<a href="#spire.syntax;LiteralLongOrderOps.<=;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralLongOrderOps.<=.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralLongOrderOps.<=.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;LiteralLongOrderOps.<=.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.lteqv" title="(x: A, y: A)Boolean">lteqv</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongOrderOps.<=.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongOrderOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralLongOrderOps.<=.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])Boolean" id="spire.syntax;LiteralLongOrderOps.>">&gt;</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralLongOrderOps.>;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralLongOrderOps.>.rhs">rhs</a>:<a href="#spire.syntax;LiteralLongOrderOps.>;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralLongOrderOps.>.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralLongOrderOps.>.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;LiteralLongOrderOps.>.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">gt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongOrderOps.>.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongOrderOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralLongOrderOps.>.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])Boolean" id="spire.syntax;LiteralLongOrderOps.>=">&gt;=</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralLongOrderOps.>=;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralLongOrderOps.>=.rhs">rhs</a>:<a href="#spire.syntax;LiteralLongOrderOps.>=;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralLongOrderOps.>=.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralLongOrderOps.>=.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;LiteralLongOrderOps.>=.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.gteqv" title="(x: A, y: A)Boolean">gteqv</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongOrderOps.>=.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongOrderOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralLongOrderOps.>=.rhs" title="A">rhs</a><span class="delimiter">)</span>

  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])Int" id="spire.syntax;LiteralLongOrderOps.cmp">cmp</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralLongOrderOps.cmp;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralLongOrderOps.cmp.rhs">rhs</a>:<a href="#spire.syntax;LiteralLongOrderOps.cmp;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralLongOrderOps.cmp.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralLongOrderOps.cmp.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.syntax;LiteralLongOrderOps.cmp.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.compare" title="(x: A, y: A)Int">compare</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongOrderOps.cmp.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongOrderOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralLongOrderOps.cmp.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])A" id="spire.syntax;LiteralLongOrderOps.min">min</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralLongOrderOps.min;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralLongOrderOps.min.rhs">rhs</a>:<a href="#spire.syntax;LiteralLongOrderOps.min;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralLongOrderOps.min.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralLongOrderOps.min.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralLongOrderOps.min;A" title="A">A</a> = <a href="#spire.syntax;LiteralLongOrderOps.min.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.min" title="(x: A, y: A)A">min</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongOrderOps.min.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongOrderOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralLongOrderOps.min.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])A" id="spire.syntax;LiteralLongOrderOps.max">max</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralLongOrderOps.max;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralLongOrderOps.max.rhs">rhs</a>:<a href="#spire.syntax;LiteralLongOrderOps.max;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralLongOrderOps.max.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralLongOrderOps.max.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralLongOrderOps.max;A" title="A">A</a> = <a href="#spire.syntax;LiteralLongOrderOps.max.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.max" title="(x: A, y: A)A">max</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongOrderOps.max.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongOrderOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralLongOrderOps.max.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralDoubleOrderOps.lhs" title="class LiteralDoubleOrderOps extends AnyVal" id="spire.syntax.LiteralDoubleOrderOps">LiteralDoubleOrderOps</a><a href="#spire.syntax.LiteralDoubleOrderOps" title="spire.syntax.LiteralDoubleOrderOps" class="delimiter">(</a>val <a title="Double" id="spire.syntax;LiteralDoubleOrderOps.lhs">lhs</a>: <span title="Double">Double</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralDoubleOrderOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])Boolean" id="spire.syntax;LiteralDoubleOrderOps.<">&lt;</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralDoubleOrderOps.<;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralDoubleOrderOps.<.rhs">rhs</a>:<a href="#spire.syntax;LiteralDoubleOrderOps.<;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralDoubleOrderOps.<.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralDoubleOrderOps.<.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;LiteralDoubleOrderOps.<.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.lt" title="(x: A, y: A)Boolean">lt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleOrderOps.<.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromDouble" title="(n: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleOrderOps.lhs" title="=&gt; Double">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralDoubleOrderOps.<.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])Boolean" id="spire.syntax;LiteralDoubleOrderOps.<=">&lt;=</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralDoubleOrderOps.<=;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralDoubleOrderOps.<=.rhs">rhs</a>:<a href="#spire.syntax;LiteralDoubleOrderOps.<=;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralDoubleOrderOps.<=.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralDoubleOrderOps.<=.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;LiteralDoubleOrderOps.<=.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.lteqv" title="(x: A, y: A)Boolean">lteqv</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleOrderOps.<=.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromDouble" title="(n: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleOrderOps.lhs" title="=&gt; Double">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralDoubleOrderOps.<=.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])Boolean" id="spire.syntax;LiteralDoubleOrderOps.>">&gt;</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralDoubleOrderOps.>;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralDoubleOrderOps.>.rhs">rhs</a>:<a href="#spire.syntax;LiteralDoubleOrderOps.>;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralDoubleOrderOps.>.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralDoubleOrderOps.>.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;LiteralDoubleOrderOps.>.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">gt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleOrderOps.>.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromDouble" title="(n: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleOrderOps.lhs" title="=&gt; Double">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralDoubleOrderOps.>.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])Boolean" id="spire.syntax;LiteralDoubleOrderOps.>=">&gt;=</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralDoubleOrderOps.>=;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralDoubleOrderOps.>=.rhs">rhs</a>:<a href="#spire.syntax;LiteralDoubleOrderOps.>=;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralDoubleOrderOps.>=.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralDoubleOrderOps.>=.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;LiteralDoubleOrderOps.>=.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.gteqv" title="(x: A, y: A)Boolean">gteqv</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleOrderOps.>=.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromDouble" title="(n: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleOrderOps.lhs" title="=&gt; Double">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralDoubleOrderOps.>=.rhs" title="A">rhs</a><span class="delimiter">)</span>

  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])Int" id="spire.syntax;LiteralDoubleOrderOps.cmp">cmp</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralDoubleOrderOps.cmp;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralDoubleOrderOps.cmp.rhs">rhs</a>:<a href="#spire.syntax;LiteralDoubleOrderOps.cmp;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralDoubleOrderOps.cmp.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralDoubleOrderOps.cmp.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.syntax;LiteralDoubleOrderOps.cmp.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.compare" title="(x: A, y: A)Int">compare</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleOrderOps.cmp.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromDouble" title="(n: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleOrderOps.lhs" title="=&gt; Double">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralDoubleOrderOps.cmp.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])A" id="spire.syntax;LiteralDoubleOrderOps.min">min</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralDoubleOrderOps.min;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralDoubleOrderOps.min.rhs">rhs</a>:<a href="#spire.syntax;LiteralDoubleOrderOps.min;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralDoubleOrderOps.min.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralDoubleOrderOps.min.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralDoubleOrderOps.min;A" title="A">A</a> = <a href="#spire.syntax;LiteralDoubleOrderOps.min.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.min" title="(x: A, y: A)A">min</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleOrderOps.min.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromDouble" title="(n: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleOrderOps.lhs" title="=&gt; Double">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralDoubleOrderOps.min.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Order[A], implicit c: spire.math.ConvertableTo[A])A" id="spire.syntax;LiteralDoubleOrderOps.max">max</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralDoubleOrderOps.max;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralDoubleOrderOps.max.rhs">rhs</a>:<a href="#spire.syntax;LiteralDoubleOrderOps.max;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;LiteralDoubleOrderOps.max.ev">ev</a>:<a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralDoubleOrderOps.max.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralDoubleOrderOps.max;A" title="A">A</a> = <a href="#spire.syntax;LiteralDoubleOrderOps.max.ev" title="spire.algebra.Order[A]">ev</a>.<a href="../algebra/Order.scala.html#spire.algebra;Order.max" title="(x: A, y: A)A">max</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleOrderOps.max.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromDouble" title="(n: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleOrderOps.lhs" title="=&gt; Double">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralDoubleOrderOps.max.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a title="class SignedOps[A] extends AnyRef" id="spire.syntax;SignedOps">SignedOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;SignedOps;A">A</a>:Signed<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;SignedOps.lhs">lhs</a>: <a href="#spire.syntax;SignedOps;A" title="A">A</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="()A" id="spire.syntax;SignedOps.abs">abs</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;SignedOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;SignedOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="()spire.algebra.Sign" id="spire.syntax;SignedOps.sign">sign</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../algebra/Sign.scala.html#spire.algebra;Sign" title="spire.algebra.Sign">Sign</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[spire.algebra.Sign]" class="delimiter">[</span><a href="../algebra/Sign.scala.html#spire.algebra;Sign" title="spire.algebra.Sign">Sign</a><span class="delimiter">]</span>
  def <a title="()Int" id="spire.syntax;SignedOps.signum">signum</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Int">Int</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Int]" class="delimiter">[</span><span title="Int">Int</span><span class="delimiter">]</span>

  def <a title="()Boolean" id="spire.syntax;SignedOps.isSignZero">isSignZero</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Boolean]" class="delimiter">[</span><span title="Boolean">Boolean</span><span class="delimiter">]</span>
  def <a title="()Boolean" id="spire.syntax;SignedOps.isSignPositive">isSignPositive</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Boolean]" class="delimiter">[</span><span title="Boolean">Boolean</span><span class="delimiter">]</span>
  def <a title="()Boolean" id="spire.syntax;SignedOps.isSignNegative">isSignNegative</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Boolean]" class="delimiter">[</span><span title="Boolean">Boolean</span><span class="delimiter">]</span>

  def <a title="()Boolean" id="spire.syntax;SignedOps.isSignNonZero">isSignNonZero</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Boolean]" class="delimiter">[</span><span title="Boolean">Boolean</span><span class="delimiter">]</span>
  def <a title="()Boolean" id="spire.syntax;SignedOps.isSignNonPositive">isSignNonPositive</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Boolean]" class="delimiter">[</span><span title="Boolean">Boolean</span><span class="delimiter">]</span>
  def <a title="()Boolean" id="spire.syntax;SignedOps.isSignNonNegative">isSignNonNegative</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Boolean]" class="delimiter">[</span><span title="Boolean">Boolean</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class SemigroupoidOps[A] extends AnyRef" id="spire.syntax;SemigroupoidOps">SemigroupoidOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;SemigroupoidOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;SemigroupoidOps" title="spire.syntax.SemigroupoidOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;SemigroupoidOps.lhs">lhs</a>:<a href="#spire.syntax;SemigroupoidOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.partial.Semigroupoid[A]" id="spire.syntax;SemigroupoidOps.ev">ev</a>:<a href="../algebra/partial/Semigroupoid.scala.html#spire.algebra.partial;Semigroupoid" title="spire.algebra.partial.Semigroupoid[A]">Semigroupoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: A)spire.util.Opt[A]" id="spire.syntax;SemigroupoidOps.|+|?">|+|?</a> <span class="delimiter">(</span><a title="A" id="spire.syntax;SemigroupoidOps.|+|?.rhs">rhs</a>: <a href="#spire.syntax;SemigroupoidOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="../util/Opt.scala.html#spire.util;Opt" title="spire.util.Opt[A]">Opt</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[spire.util.Opt[A]]" class="delimiter">[</span><a href="#spire.syntax;SemigroupoidOps;A" title="A">A</a>, <a href="../util/Opt.scala.html#spire.util;Opt" title="spire.util.Opt[A]">Opt</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>
  def <a title="(rhs: A)Boolean" id="spire.syntax;SemigroupoidOps.|+|??">|+|??</a> <span class="delimiter">(</span><a title="A" id="spire.syntax;SemigroupoidOps.|+|??.rhs">rhs</a>: <a href="#spire.syntax;SemigroupoidOps;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[Boolean]" class="delimiter">[</span><a href="#spire.syntax;SemigroupoidOps;A" title="A">A</a>, <span title="Boolean">Boolean</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class GroupoidCommonOps[A] extends AnyRef" id="spire.syntax;GroupoidCommonOps">GroupoidCommonOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;GroupoidCommonOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;GroupoidCommonOps" title="spire.syntax.GroupoidCommonOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;GroupoidCommonOps.lhs">lhs</a>:<a href="#spire.syntax;GroupoidCommonOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.partial.Groupoid[A]" id="spire.syntax;GroupoidCommonOps.ev">ev</a>:<a href="../algebra/partial/Groupoid.scala.html#spire.algebra.partial;Groupoid" title="spire.algebra.partial.Groupoid[A]">Groupoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="()A" id="spire.syntax;GroupoidCommonOps.inverse">inverse</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;GroupoidCommonOps;A" title="A">A</a> = <a href="#spire.syntax;GroupoidCommonOps.ev" title="spire.algebra.partial.Groupoid[A]">ev</a>.<a href="../algebra/partial/Groupoid.scala.html#spire.algebra.partial;Groupoid.inverse" title="(a: A)A">inverse</a><span class="delimiter">(</span><a href="#spire.syntax;GroupoidCommonOps.lhs" title="A">lhs</a><span class="delimiter">)</span>
  def <a title="(implicit ev1: spire.algebra.Eq[A])Boolean" id="spire.syntax;GroupoidCommonOps.isId">isId</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Eq[A]" id="spire.syntax;GroupoidCommonOps.isId.ev1">ev1</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[A]">Eq</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.syntax;GroupoidCommonOps.ev" title="spire.algebra.partial.Groupoid[A]">ev</a>.<a href="../algebra/partial/Groupoid.scala.html#spire.algebra.partial;Groupoid.isId" title="(a: A)(implicit ev: spire.algebra.Eq[A])Boolean">isId</a><span class="delimiter">(</span><a href="#spire.syntax;GroupoidCommonOps.lhs" title="A">lhs</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.syntax;GroupoidCommonOps.isId.ev1" title="spire.algebra.Eq[A]">ev1</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a title="class GroupoidOps[A] extends AnyRef" id="spire.syntax;GroupoidOps">GroupoidOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;GroupoidOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;GroupoidOps" title="spire.syntax.GroupoidOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;GroupoidOps.lhs">lhs</a>:<a href="#spire.syntax;GroupoidOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.partial.Groupoid[A]" id="spire.syntax;GroupoidOps.ev">ev</a>:<a href="../algebra/partial/Groupoid.scala.html#spire.algebra.partial;Groupoid" title="spire.algebra.partial.Groupoid[A]">Groupoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="()A" id="spire.syntax;GroupoidOps.leftId">leftId</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;GroupoidOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;GroupoidOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="()A" id="spire.syntax;GroupoidOps.rightId">rightId</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;GroupoidOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;GroupoidOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)spire.util.Opt[A]" id="spire.syntax;GroupoidOps.|-|?">|-|?</a> <span class="delimiter">(</span><a title="A" id="spire.syntax;GroupoidOps.|-|?.rhs">rhs</a>: <a href="#spire.syntax;GroupoidOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="../util/Opt.scala.html#spire.util;Opt" title="spire.util.Opt[A]">Opt</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[Option[A]]" class="delimiter">[</span><a href="#spire.syntax;GroupoidOps;A" title="A">A</a>, <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>
  def <a title="(rhs: A)Boolean" id="spire.syntax;GroupoidOps.|-|??">|-|??</a> <span class="delimiter">(</span><a title="A" id="spire.syntax;GroupoidOps.|-|??.rhs">rhs</a>: <a href="#spire.syntax;GroupoidOps;A" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[Boolean]" class="delimiter">[</span><a href="#spire.syntax;GroupoidOps;A" title="A">A</a>, <span title="Boolean">Boolean</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class SemigroupOps[A] extends AnyRef" id="spire.syntax;SemigroupOps">SemigroupOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;SemigroupOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;SemigroupOps" title="spire.syntax.SemigroupOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;SemigroupOps.lhs">lhs</a>:<a href="#spire.syntax;SemigroupOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Semigroup[A]" id="spire.syntax;SemigroupOps.ev">ev</a>:<a href="../algebra/Semigroup.scala.html#spire.algebra;Semigroup" title="spire.algebra.Semigroup[A]">Semigroup</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: A)A" id="spire.syntax;SemigroupOps.|+|">|+|</a><span class="delimiter">(</span><a title="A" id="spire.syntax;SemigroupOps.|+|.rhs">rhs</a>:<a href="#spire.syntax;SemigroupOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;SemigroupOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;SemigroupOps;A" title="A">A</a>, <a href="#spire.syntax;SemigroupOps;A" title="A">A</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class MonoidOps[A] extends AnyRef" id="spire.syntax;MonoidOps">MonoidOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;MonoidOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;MonoidOps" title="spire.syntax.MonoidOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;MonoidOps.lhs">lhs</a>:<a href="#spire.syntax;MonoidOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Monoid[A]" id="spire.syntax;MonoidOps.ev">ev</a>: <a href="../algebra/Monoid.scala.html#spire.algebra;Monoid" title="spire.algebra.Monoid[A]">Monoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(implicit ev1: spire.algebra.Eq[A])Boolean" id="spire.syntax;MonoidOps.isId">isId</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Eq[A]" id="spire.syntax;MonoidOps.isId.ev1">ev1</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[A]">Eq</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops.unopWithEv2" title="[Ev1, R](c: spire.macros.compat.Context)(ev1: c.Expr[Ev1])c.Expr[R]">unopWithEv2</a><span title="(c: spire.macros.compat.Context)(ev1: c.Expr[spire.algebra.Eq[A]])c.Expr[Boolean]" class="delimiter">[</span><a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[A]">Eq</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <span title="Boolean">Boolean</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class GroupOps[A] extends AnyRef" id="spire.syntax;GroupOps">GroupOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;GroupOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;GroupOps" title="spire.syntax.GroupOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;GroupOps.lhs">lhs</a>:<a href="#spire.syntax;GroupOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Group[A]" id="spire.syntax;GroupOps.ev">ev</a>:<a href="../algebra/Group.scala.html#spire.algebra;Group" title="spire.algebra.Group[A]">Group</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="()A" id="spire.syntax;GroupOps.inverse">inverse</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;GroupOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;GroupOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)A" id="spire.syntax;GroupOps.|-|">|-|</a><span class="delimiter">(</span><a title="A" id="spire.syntax;GroupOps.|-|.rhs">rhs</a>:<a href="#spire.syntax;GroupOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;GroupOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;GroupOps;A" title="A">A</a>, <a href="#spire.syntax;GroupOps;A" title="A">A</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class AdditiveSemigroupOps[A] extends AnyRef" id="spire.syntax;AdditiveSemigroupOps">AdditiveSemigroupOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;AdditiveSemigroupOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;AdditiveSemigroupOps" title="spire.syntax.AdditiveSemigroupOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;AdditiveSemigroupOps.lhs">lhs</a>:<a href="#spire.syntax;AdditiveSemigroupOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveSemigroup[A]" id="spire.syntax;AdditiveSemigroupOps.ev">ev</a>:<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup" title="spire.algebra.AdditiveSemigroup[A]">AdditiveSemigroup</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: A)A" id="spire.syntax;AdditiveSemigroupOps.+(867292a5eb)">+</a><span class="delimiter">(</span><a title="A" id="spire.syntax;AdditiveSemigroupOps.+(867292a5eb).rhs">rhs</a>:<a href="#spire.syntax;AdditiveSemigroupOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;AdditiveSemigroupOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;AdditiveSemigroupOps;A" title="A">A</a>, <a href="#spire.syntax;AdditiveSemigroupOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])A" id="spire.syntax;AdditiveSemigroupOps.+(5faa3d8872)">+</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;AdditiveSemigroupOps.+(5faa3d8872).rhs">rhs</a>:<span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;AdditiveSemigroupOps.+(5faa3d8872).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;AdditiveSemigroupOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;AdditiveSemigroupOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Double)(implicit ev1: spire.algebra.Field[A])A" id="spire.syntax;AdditiveSemigroupOps.+(a7265c38be)">+</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;AdditiveSemigroupOps.+(a7265c38be).rhs">rhs</a>:<span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;AdditiveSemigroupOps.+(a7265c38be).ev1">ev1</a>:<a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;AdditiveSemigroupOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Double])(ev1: c.Expr[spire.algebra.Field[A]])(implicit evidence$1: c.WeakTypeTag[Double])c.Expr[A]" class="delimiter">[</span><span title="Double">Double</span>, <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;AdditiveSemigroupOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])spire.math.Number" id="spire.syntax;AdditiveSemigroupOps.+(8885950850)">+</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;AdditiveSemigroupOps.+(8885950850).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;AdditiveSemigroupOps.+(8885950850).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="#spire.syntax;AdditiveSemigroupOps.+(8885950850).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;AdditiveSemigroupOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number.+" title="(rhs: spire.math.Number)spire.math.Number">+</a> <a href="#spire.syntax;AdditiveSemigroupOps.+(8885950850).rhs" title="spire.math.Number">rhs</a>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralIntAdditiveSemigroupOps.lhs" title="class LiteralIntAdditiveSemigroupOps extends AnyVal" id="spire.syntax.LiteralIntAdditiveSemigroupOps">LiteralIntAdditiveSemigroupOps</a><a href="#spire.syntax.LiteralIntAdditiveSemigroupOps" title="spire.syntax.LiteralIntAdditiveSemigroupOps" class="delimiter">(</a>val <a title="Int" id="spire.syntax;LiteralIntAdditiveSemigroupOps.lhs">lhs</a>: <span title="Int">Int</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralIntAdditiveSemigroupOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Ring[A])A" id="spire.syntax;LiteralIntAdditiveSemigroupOps.+">+</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralIntAdditiveSemigroupOps.+;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralIntAdditiveSemigroupOps.+.rhs">rhs</a>:<a href="#spire.syntax;LiteralIntAdditiveSemigroupOps.+;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;LiteralIntAdditiveSemigroupOps.+.ev">ev</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralIntAdditiveSemigroupOps.+;A" title="A">A</a> = <a href="#spire.syntax;LiteralIntAdditiveSemigroupOps.+.ev" title="spire.algebra.Ring[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">plus</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntAdditiveSemigroupOps.+.ev" title="spire.algebra.Ring[A]">ev</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntAdditiveSemigroupOps.lhs" title="=&gt; Int">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralIntAdditiveSemigroupOps.+.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralLongAdditiveSemigroupOps.lhs" title="class LiteralLongAdditiveSemigroupOps extends AnyVal" id="spire.syntax.LiteralLongAdditiveSemigroupOps">LiteralLongAdditiveSemigroupOps</a><a href="#spire.syntax.LiteralLongAdditiveSemigroupOps" title="spire.syntax.LiteralLongAdditiveSemigroupOps" class="delimiter">(</a>val <a title="Long" id="spire.syntax;LiteralLongAdditiveSemigroupOps.lhs">lhs</a>: <span title="Long">Long</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralLongAdditiveSemigroupOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Ring[A], implicit c: spire.math.ConvertableTo[A])A" id="spire.syntax;LiteralLongAdditiveSemigroupOps.+">+</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralLongAdditiveSemigroupOps.+;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralLongAdditiveSemigroupOps.+.rhs">rhs</a>:<a href="#spire.syntax;LiteralLongAdditiveSemigroupOps.+;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;LiteralLongAdditiveSemigroupOps.+.ev">ev</a>:<a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralLongAdditiveSemigroupOps.+.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralLongAdditiveSemigroupOps.+;A" title="A">A</a> = <a href="#spire.syntax;LiteralLongAdditiveSemigroupOps.+.ev" title="spire.algebra.Ring[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">plus</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongAdditiveSemigroupOps.+.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongAdditiveSemigroupOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralLongAdditiveSemigroupOps.+.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralDoubleAdditiveSemigroupOps.lhs" title="class LiteralDoubleAdditiveSemigroupOps extends AnyVal" id="spire.syntax.LiteralDoubleAdditiveSemigroupOps">LiteralDoubleAdditiveSemigroupOps</a><a href="#spire.syntax.LiteralDoubleAdditiveSemigroupOps" title="spire.syntax.LiteralDoubleAdditiveSemigroupOps" class="delimiter">(</a>val <a title="Double" id="spire.syntax;LiteralDoubleAdditiveSemigroupOps.lhs">lhs</a>: <span title="Double">Double</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralDoubleAdditiveSemigroupOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Field[A])A" id="spire.syntax;LiteralDoubleAdditiveSemigroupOps.+">+</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralDoubleAdditiveSemigroupOps.+;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralDoubleAdditiveSemigroupOps.+.rhs">rhs</a>:<a href="#spire.syntax;LiteralDoubleAdditiveSemigroupOps.+;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;LiteralDoubleAdditiveSemigroupOps.+.ev">ev</a>:<a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralDoubleAdditiveSemigroupOps.+;A" title="A">A</a> = <a href="#spire.syntax;LiteralDoubleAdditiveSemigroupOps.+.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">plus</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleAdditiveSemigroupOps.+.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/Field.scala.html#spire.algebra;Field.fromDouble" title="(a: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleAdditiveSemigroupOps.lhs" title="=&gt; Double">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralDoubleAdditiveSemigroupOps.+.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a title="class AdditiveMonoidOps[A] extends AnyRef" id="spire.syntax;AdditiveMonoidOps">AdditiveMonoidOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;AdditiveMonoidOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;AdditiveMonoidOps" title="spire.syntax.AdditiveMonoidOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;AdditiveMonoidOps.lhs">lhs</a>: <a href="#spire.syntax;AdditiveMonoidOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveMonoid[A]" id="spire.syntax;AdditiveMonoidOps.ev">ev</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(implicit ev1: spire.algebra.Eq[A])Boolean" id="spire.syntax;AdditiveMonoidOps.isZero">isZero</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Eq[A]" id="spire.syntax;AdditiveMonoidOps.isZero.ev1">ev1</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[A]">Eq</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops.unopWithEv2" title="[Ev1, R](c: spire.macros.compat.Context)(ev1: c.Expr[Ev1])c.Expr[R]">unopWithEv2</a><span title="(c: spire.macros.compat.Context)(ev1: c.Expr[spire.algebra.Eq[A]])c.Expr[Boolean]" class="delimiter">[</span><a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[A]">Eq</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <span title="Boolean">Boolean</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class AdditiveGroupOps[A] extends AnyRef" id="spire.syntax;AdditiveGroupOps">AdditiveGroupOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;AdditiveGroupOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;AdditiveGroupOps" title="spire.syntax.AdditiveGroupOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;AdditiveGroupOps.lhs">lhs</a>:<a href="#spire.syntax;AdditiveGroupOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveGroup[A]" id="spire.syntax;AdditiveGroupOps.ev">ev</a>:<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup" title="spire.algebra.AdditiveGroup[A]">AdditiveGroup</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="()A" id="spire.syntax;AdditiveGroupOps.unary_-">unary_-</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;AdditiveGroupOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;AdditiveGroupOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)A" id="spire.syntax;AdditiveGroupOps.-(867292a5eb)">-</a><span class="delimiter">(</span><a title="A" id="spire.syntax;AdditiveGroupOps.-(867292a5eb).rhs">rhs</a>:<a href="#spire.syntax;AdditiveGroupOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;AdditiveGroupOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;AdditiveGroupOps;A" title="A">A</a>, <a href="#spire.syntax;AdditiveGroupOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])A" id="spire.syntax;AdditiveGroupOps.-(5faa3d8872)">-</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;AdditiveGroupOps.-(5faa3d8872).rhs">rhs</a>:<span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;AdditiveGroupOps.-(5faa3d8872).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;AdditiveGroupOps;A" title="A">A</a> =  macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;AdditiveGroupOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Double)(implicit ev1: spire.algebra.Field[A])A" id="spire.syntax;AdditiveGroupOps.-(a7265c38be)">-</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;AdditiveGroupOps.-(a7265c38be).rhs">rhs</a>:<span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;AdditiveGroupOps.-(a7265c38be).ev1">ev1</a>:<a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;AdditiveGroupOps;A" title="A">A</a> =  macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Double])(ev1: c.Expr[spire.algebra.Field[A]])(implicit evidence$1: c.WeakTypeTag[Double])c.Expr[A]" class="delimiter">[</span><span title="Double">Double</span>, <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;AdditiveGroupOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])spire.math.Number" id="spire.syntax;AdditiveGroupOps.-(8885950850)">-</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;AdditiveGroupOps.-(8885950850).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;AdditiveGroupOps.-(8885950850).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="#spire.syntax;AdditiveGroupOps.-(8885950850).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;AdditiveGroupOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number.-" title="(rhs: spire.math.Number)spire.math.Number">-</a> <a href="#spire.syntax;AdditiveGroupOps.-(8885950850).rhs" title="spire.math.Number">rhs</a>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralIntAdditiveGroupOps.lhs" title="class LiteralIntAdditiveGroupOps extends AnyVal" id="spire.syntax.LiteralIntAdditiveGroupOps">LiteralIntAdditiveGroupOps</a><a href="#spire.syntax.LiteralIntAdditiveGroupOps" title="spire.syntax.LiteralIntAdditiveGroupOps" class="delimiter">(</a>val <a title="Int" id="spire.syntax;LiteralIntAdditiveGroupOps.lhs">lhs</a>: <span title="Int">Int</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralIntAdditiveGroupOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Ring[A])A" id="spire.syntax;LiteralIntAdditiveGroupOps.-">-</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralIntAdditiveGroupOps.-;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralIntAdditiveGroupOps.-.rhs">rhs</a>:<a href="#spire.syntax;LiteralIntAdditiveGroupOps.-;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;LiteralIntAdditiveGroupOps.-.ev">ev</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralIntAdditiveGroupOps.-;A" title="A">A</a> = <a href="#spire.syntax;LiteralIntAdditiveGroupOps.-.ev" title="spire.algebra.Ring[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: A, y: A)A">minus</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntAdditiveGroupOps.-.ev" title="spire.algebra.Ring[A]">ev</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntAdditiveGroupOps.lhs" title="=&gt; Int">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralIntAdditiveGroupOps.-.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralLongAdditiveGroupOps.lhs" title="class LiteralLongAdditiveGroupOps extends AnyVal" id="spire.syntax.LiteralLongAdditiveGroupOps">LiteralLongAdditiveGroupOps</a><a href="#spire.syntax.LiteralLongAdditiveGroupOps" title="spire.syntax.LiteralLongAdditiveGroupOps" class="delimiter">(</a>val <a title="Long" id="spire.syntax;LiteralLongAdditiveGroupOps.lhs">lhs</a>: <span title="Long">Long</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralLongAdditiveGroupOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Ring[A], implicit c: spire.math.ConvertableTo[A])A" id="spire.syntax;LiteralLongAdditiveGroupOps.-">-</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralLongAdditiveGroupOps.-;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralLongAdditiveGroupOps.-.rhs">rhs</a>:<a href="#spire.syntax;LiteralLongAdditiveGroupOps.-;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;LiteralLongAdditiveGroupOps.-.ev">ev</a>:<a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralLongAdditiveGroupOps.-.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralLongAdditiveGroupOps.-;A" title="A">A</a> = <a href="#spire.syntax;LiteralLongAdditiveGroupOps.-.ev" title="spire.algebra.Ring[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: A, y: A)A">minus</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongAdditiveGroupOps.-.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongAdditiveGroupOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralLongAdditiveGroupOps.-.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralDoubleAdditiveGroupOps.lhs" title="class LiteralDoubleAdditiveGroupOps extends AnyVal" id="spire.syntax.LiteralDoubleAdditiveGroupOps">LiteralDoubleAdditiveGroupOps</a><a href="#spire.syntax.LiteralDoubleAdditiveGroupOps" title="spire.syntax.LiteralDoubleAdditiveGroupOps" class="delimiter">(</a>val <a title="Double" id="spire.syntax;LiteralDoubleAdditiveGroupOps.lhs">lhs</a>: <span title="Double">Double</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralDoubleAdditiveGroupOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Field[A])A" id="spire.syntax;LiteralDoubleAdditiveGroupOps.-">-</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralDoubleAdditiveGroupOps.-;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralDoubleAdditiveGroupOps.-.rhs">rhs</a>:<a href="#spire.syntax;LiteralDoubleAdditiveGroupOps.-;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;LiteralDoubleAdditiveGroupOps.-.ev">ev</a>:<a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralDoubleAdditiveGroupOps.-;A" title="A">A</a> = <a href="#spire.syntax;LiteralDoubleAdditiveGroupOps.-.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: A, y: A)A">minus</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleAdditiveGroupOps.-.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/Field.scala.html#spire.algebra;Field.fromDouble" title="(a: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleAdditiveGroupOps.lhs" title="=&gt; Double">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralDoubleAdditiveGroupOps.-.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a title="class MultiplicativeSemigroupOps[A] extends AnyRef" id="spire.syntax;MultiplicativeSemigroupOps">MultiplicativeSemigroupOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;MultiplicativeSemigroupOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;MultiplicativeSemigroupOps" title="spire.syntax.MultiplicativeSemigroupOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;MultiplicativeSemigroupOps.lhs">lhs</a>:<a href="#spire.syntax;MultiplicativeSemigroupOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.MultiplicativeSemigroup[A]" id="spire.syntax;MultiplicativeSemigroupOps.ev">ev</a>:<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup" title="spire.algebra.MultiplicativeSemigroup[A]">MultiplicativeSemigroup</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: A)A" id="spire.syntax;MultiplicativeSemigroupOps.*(867292a5eb)">*</a><span class="delimiter">(</span><a title="A" id="spire.syntax;MultiplicativeSemigroupOps.*(867292a5eb).rhs">rhs</a>:<a href="#spire.syntax;MultiplicativeSemigroupOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;MultiplicativeSemigroupOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;MultiplicativeSemigroupOps;A" title="A">A</a>, <a href="#spire.syntax;MultiplicativeSemigroupOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])A" id="spire.syntax;MultiplicativeSemigroupOps.*(5faa3d8872)">*</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;MultiplicativeSemigroupOps.*(5faa3d8872).rhs">rhs</a>:<span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;MultiplicativeSemigroupOps.*(5faa3d8872).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;MultiplicativeSemigroupOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;MultiplicativeSemigroupOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Double)(implicit ev1: spire.algebra.Field[A])A" id="spire.syntax;MultiplicativeSemigroupOps.*(a7265c38be)">*</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;MultiplicativeSemigroupOps.*(a7265c38be).rhs">rhs</a>:<span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;MultiplicativeSemigroupOps.*(a7265c38be).ev1">ev1</a>:<a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;MultiplicativeSemigroupOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Double])(ev1: c.Expr[spire.algebra.Field[A]])(implicit evidence$1: c.WeakTypeTag[Double])c.Expr[A]" class="delimiter">[</span><span title="Double">Double</span>, <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;MultiplicativeSemigroupOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])spire.math.Number" id="spire.syntax;MultiplicativeSemigroupOps.*(8885950850)">*</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;MultiplicativeSemigroupOps.*(8885950850).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;MultiplicativeSemigroupOps.*(8885950850).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="#spire.syntax;MultiplicativeSemigroupOps.*(8885950850).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;MultiplicativeSemigroupOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number.*" title="(rhs: spire.math.Number)spire.math.Number">*</a> <a href="#spire.syntax;MultiplicativeSemigroupOps.*(8885950850).rhs" title="spire.math.Number">rhs</a>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralIntMultiplicativeSemigroupOps.lhs" title="class LiteralIntMultiplicativeSemigroupOps extends AnyVal" id="spire.syntax.LiteralIntMultiplicativeSemigroupOps">LiteralIntMultiplicativeSemigroupOps</a><a href="#spire.syntax.LiteralIntMultiplicativeSemigroupOps" title="spire.syntax.LiteralIntMultiplicativeSemigroupOps" class="delimiter">(</a>val <a title="Int" id="spire.syntax;LiteralIntMultiplicativeSemigroupOps.lhs">lhs</a>: <span title="Int">Int</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralIntMultiplicativeSemigroupOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Ring[A])A" id="spire.syntax;LiteralIntMultiplicativeSemigroupOps.*">*</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralIntMultiplicativeSemigroupOps.*;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralIntMultiplicativeSemigroupOps.*.rhs">rhs</a>:<a href="#spire.syntax;LiteralIntMultiplicativeSemigroupOps.*;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;LiteralIntMultiplicativeSemigroupOps.*.ev">ev</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralIntMultiplicativeSemigroupOps.*;A" title="A">A</a> = <a href="#spire.syntax;LiteralIntMultiplicativeSemigroupOps.*.ev" title="spire.algebra.Ring[A]">ev</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">times</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntMultiplicativeSemigroupOps.*.ev" title="spire.algebra.Ring[A]">ev</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntMultiplicativeSemigroupOps.lhs" title="=&gt; Int">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralIntMultiplicativeSemigroupOps.*.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralLongMultiplicativeSemigroupOps.lhs" title="class LiteralLongMultiplicativeSemigroupOps extends AnyVal" id="spire.syntax.LiteralLongMultiplicativeSemigroupOps">LiteralLongMultiplicativeSemigroupOps</a><a href="#spire.syntax.LiteralLongMultiplicativeSemigroupOps" title="spire.syntax.LiteralLongMultiplicativeSemigroupOps" class="delimiter">(</a>val <a title="Long" id="spire.syntax;LiteralLongMultiplicativeSemigroupOps.lhs">lhs</a>: <span title="Long">Long</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralLongMultiplicativeSemigroupOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Ring[A], implicit c: spire.math.ConvertableTo[A])A" id="spire.syntax;LiteralLongMultiplicativeSemigroupOps.*">*</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralLongMultiplicativeSemigroupOps.*;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralLongMultiplicativeSemigroupOps.*.rhs">rhs</a>:<a href="#spire.syntax;LiteralLongMultiplicativeSemigroupOps.*;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;LiteralLongMultiplicativeSemigroupOps.*.ev">ev</a>:<a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralLongMultiplicativeSemigroupOps.*.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralLongMultiplicativeSemigroupOps.*;A" title="A">A</a> = <a href="#spire.syntax;LiteralLongMultiplicativeSemigroupOps.*.ev" title="spire.algebra.Ring[A]">ev</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">times</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongMultiplicativeSemigroupOps.*.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongMultiplicativeSemigroupOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralLongMultiplicativeSemigroupOps.*.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralDoubleMultiplicativeSemigroupOps.lhs" title="class LiteralDoubleMultiplicativeSemigroupOps extends AnyVal" id="spire.syntax.LiteralDoubleMultiplicativeSemigroupOps">LiteralDoubleMultiplicativeSemigroupOps</a><a href="#spire.syntax.LiteralDoubleMultiplicativeSemigroupOps" title="spire.syntax.LiteralDoubleMultiplicativeSemigroupOps" class="delimiter">(</a>val <a title="Double" id="spire.syntax;LiteralDoubleMultiplicativeSemigroupOps.lhs">lhs</a>: <span title="Double">Double</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralDoubleMultiplicativeSemigroupOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Field[A])A" id="spire.syntax;LiteralDoubleMultiplicativeSemigroupOps.*">*</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralDoubleMultiplicativeSemigroupOps.*;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralDoubleMultiplicativeSemigroupOps.*.rhs">rhs</a>:<a href="#spire.syntax;LiteralDoubleMultiplicativeSemigroupOps.*;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;LiteralDoubleMultiplicativeSemigroupOps.*.ev">ev</a>:<a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralDoubleMultiplicativeSemigroupOps.*;A" title="A">A</a> = <a href="#spire.syntax;LiteralDoubleMultiplicativeSemigroupOps.*.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">times</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleMultiplicativeSemigroupOps.*.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/Field.scala.html#spire.algebra;Field.fromDouble" title="(a: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleMultiplicativeSemigroupOps.lhs" title="=&gt; Double">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralDoubleMultiplicativeSemigroupOps.*.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a title="class MultiplicativeMonoidOps[A] extends AnyRef" id="spire.syntax;MultiplicativeMonoidOps">MultiplicativeMonoidOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;MultiplicativeMonoidOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;MultiplicativeMonoidOps" title="spire.syntax.MultiplicativeMonoidOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;MultiplicativeMonoidOps.lhs">lhs</a>: <a href="#spire.syntax;MultiplicativeMonoidOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.MultiplicativeMonoid[A]" id="spire.syntax;MultiplicativeMonoidOps.ev">ev</a>: <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid" title="spire.algebra.MultiplicativeMonoid[A]">MultiplicativeMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(implicit ev1: spire.algebra.Eq[A])Boolean" id="spire.syntax;MultiplicativeMonoidOps.isOne">isOne</a><span class="delimiter">(</span>implicit <a title="spire.algebra.Eq[A]" id="spire.syntax;MultiplicativeMonoidOps.isOne.ev1">ev1</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[A]">Eq</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops.unopWithEv2" title="[Ev1, R](c: spire.macros.compat.Context)(ev1: c.Expr[Ev1])c.Expr[R]">unopWithEv2</a><span title="(c: spire.macros.compat.Context)(ev1: c.Expr[spire.algebra.Eq[A]])c.Expr[Boolean]" class="delimiter">[</span><a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[A]">Eq</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <span title="Boolean">Boolean</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class MultiplicativeGroupOps[A] extends AnyRef" id="spire.syntax;MultiplicativeGroupOps">MultiplicativeGroupOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;MultiplicativeGroupOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;MultiplicativeGroupOps" title="spire.syntax.MultiplicativeGroupOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;MultiplicativeGroupOps.lhs">lhs</a>:<a href="#spire.syntax;MultiplicativeGroupOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.MultiplicativeGroup[A]" id="spire.syntax;MultiplicativeGroupOps.ev">ev</a>:<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup" title="spire.algebra.MultiplicativeGroup[A]">MultiplicativeGroup</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="()A" id="spire.syntax;MultiplicativeGroupOps.reciprocal">reciprocal</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;MultiplicativeGroupOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;MultiplicativeGroupOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)A" id="spire.syntax;MultiplicativeGroupOps./(867292a5eb)">/</a><span class="delimiter">(</span><a title="A" id="spire.syntax;MultiplicativeGroupOps./(867292a5eb).rhs">rhs</a>:<a href="#spire.syntax;MultiplicativeGroupOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;MultiplicativeGroupOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;MultiplicativeGroupOps;A" title="A">A</a>, <a href="#spire.syntax;MultiplicativeGroupOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])A" id="spire.syntax;MultiplicativeGroupOps./(5faa3d8872)">/</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;MultiplicativeGroupOps./(5faa3d8872).rhs">rhs</a>:<span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;MultiplicativeGroupOps./(5faa3d8872).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;MultiplicativeGroupOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;MultiplicativeGroupOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Double)(implicit ev1: spire.algebra.Field[A])A" id="spire.syntax;MultiplicativeGroupOps./(a7265c38be)">/</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;MultiplicativeGroupOps./(a7265c38be).rhs">rhs</a>:<span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;MultiplicativeGroupOps./(a7265c38be).ev1">ev1</a>:<a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;MultiplicativeGroupOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Double])(ev1: c.Expr[spire.algebra.Field[A]])(implicit evidence$1: c.WeakTypeTag[Double])c.Expr[A]" class="delimiter">[</span><span title="Double">Double</span>, <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;MultiplicativeGroupOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])spire.math.Number" id="spire.syntax;MultiplicativeGroupOps./(8885950850)">/</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;MultiplicativeGroupOps./(8885950850).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;MultiplicativeGroupOps./(8885950850).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="#spire.syntax;MultiplicativeGroupOps./(8885950850).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;MultiplicativeGroupOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number./" title="(rhs: spire.math.Number)spire.math.Number">/</a> <a href="#spire.syntax;MultiplicativeGroupOps./(8885950850).rhs" title="spire.math.Number">rhs</a>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralIntMultiplicativeGroupOps.lhs" title="class LiteralIntMultiplicativeGroupOps extends AnyVal" id="spire.syntax.LiteralIntMultiplicativeGroupOps">LiteralIntMultiplicativeGroupOps</a><a href="#spire.syntax.LiteralIntMultiplicativeGroupOps" title="spire.syntax.LiteralIntMultiplicativeGroupOps" class="delimiter">(</a>val <a title="Int" id="spire.syntax;LiteralIntMultiplicativeGroupOps.lhs">lhs</a>: <span title="Int">Int</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralIntMultiplicativeGroupOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Field[A])A" id="spire.syntax;LiteralIntMultiplicativeGroupOps./">/</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralIntMultiplicativeGroupOps./;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralIntMultiplicativeGroupOps./.rhs">rhs</a>:<a href="#spire.syntax;LiteralIntMultiplicativeGroupOps./;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;LiteralIntMultiplicativeGroupOps./.ev">ev</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralIntMultiplicativeGroupOps./;A" title="A">A</a> = <a href="#spire.syntax;LiteralIntMultiplicativeGroupOps./.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: A, y: A)A">div</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntMultiplicativeGroupOps./.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntMultiplicativeGroupOps.lhs" title="=&gt; Int">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralIntMultiplicativeGroupOps./.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralLongMultiplicativeGroupOps.lhs" title="class LiteralLongMultiplicativeGroupOps extends AnyVal" id="spire.syntax.LiteralLongMultiplicativeGroupOps">LiteralLongMultiplicativeGroupOps</a><a href="#spire.syntax.LiteralLongMultiplicativeGroupOps" title="spire.syntax.LiteralLongMultiplicativeGroupOps" class="delimiter">(</a>val <a title="Long" id="spire.syntax;LiteralLongMultiplicativeGroupOps.lhs">lhs</a>: <span title="Long">Long</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralLongMultiplicativeGroupOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Field[A], implicit c: spire.math.ConvertableTo[A])A" id="spire.syntax;LiteralLongMultiplicativeGroupOps./">/</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralLongMultiplicativeGroupOps./;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralLongMultiplicativeGroupOps./.rhs">rhs</a>:<a href="#spire.syntax;LiteralLongMultiplicativeGroupOps./;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;LiteralLongMultiplicativeGroupOps./.ev">ev</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralLongMultiplicativeGroupOps./.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralLongMultiplicativeGroupOps./;A" title="A">A</a> = <a href="#spire.syntax;LiteralLongMultiplicativeGroupOps./.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: A, y: A)A">div</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongMultiplicativeGroupOps./.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongMultiplicativeGroupOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralLongMultiplicativeGroupOps./.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralDoubleMultiplicativeGroupOps.lhs" title="class LiteralDoubleMultiplicativeGroupOps extends AnyVal" id="spire.syntax.LiteralDoubleMultiplicativeGroupOps">LiteralDoubleMultiplicativeGroupOps</a><a href="#spire.syntax.LiteralDoubleMultiplicativeGroupOps" title="spire.syntax.LiteralDoubleMultiplicativeGroupOps" class="delimiter">(</a>val <a title="Double" id="spire.syntax;LiteralDoubleMultiplicativeGroupOps.lhs">lhs</a>: <span title="Double">Double</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralDoubleMultiplicativeGroupOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Field[A])A" id="spire.syntax;LiteralDoubleMultiplicativeGroupOps./">/</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralDoubleMultiplicativeGroupOps./;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralDoubleMultiplicativeGroupOps./.rhs">rhs</a>:<a href="#spire.syntax;LiteralDoubleMultiplicativeGroupOps./;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;LiteralDoubleMultiplicativeGroupOps./.ev">ev</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralDoubleMultiplicativeGroupOps./;A" title="A">A</a> = <a href="#spire.syntax;LiteralDoubleMultiplicativeGroupOps./.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: A, y: A)A">div</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleMultiplicativeGroupOps./.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/Field.scala.html#spire.algebra;Field.fromDouble" title="(a: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleMultiplicativeGroupOps.lhs" title="=&gt; Double">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralDoubleMultiplicativeGroupOps./.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a title="class SemiringOps[A] extends AnyRef" id="spire.syntax;SemiringOps">SemiringOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;SemiringOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;SemiringOps" title="spire.syntax.SemiringOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;SemiringOps.lhs">lhs</a>:<a href="#spire.syntax;SemiringOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Semiring[A]" id="spire.syntax;SemiringOps.ev">ev</a>:<a href="../algebra/Semiring.scala.html#spire.algebra;Semiring" title="spire.algebra.Semiring[A]">Semiring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: Int)A" id="spire.syntax;SemiringOps.pow">pow</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;SemiringOps.pow.rhs">rhs</a>:<span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.syntax;SemiringOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="#spire.syntax;SemiringOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)A" id="spire.syntax;SemiringOps.**">**</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;SemiringOps.**.rhs">rhs</a>:<span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.syntax;SemiringOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="#spire.syntax;SemiringOps;A" title="A">A</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class EuclideanRingOps[A] extends AnyRef" id="spire.syntax;EuclideanRingOps">EuclideanRingOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;EuclideanRingOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;EuclideanRingOps" title="spire.syntax.EuclideanRingOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;EuclideanRingOps.lhs">lhs</a>:<a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.EuclideanRing[A]" id="spire.syntax;EuclideanRingOps.ev">ev</a>:<a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing" title="spire.algebra.EuclideanRing[A]">EuclideanRing</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: A)A" id="spire.syntax;EuclideanRingOps./~(867292a5eb)">/~</a><span class="delimiter">(</span><a title="A" id="spire.syntax;EuclideanRingOps./~(867292a5eb).rhs">rhs</a>:<a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a>, <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)A" id="spire.syntax;EuclideanRingOps.%(867292a5eb)">%</a><span class="delimiter">(</span><a title="A" id="spire.syntax;EuclideanRingOps.%(867292a5eb).rhs">rhs</a>:<a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a>, <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)(A, A)" id="spire.syntax;EuclideanRingOps./%(f06e15eb7b)">/%</a><span class="delimiter">(</span><a title="A" id="spire.syntax;EuclideanRingOps./%(f06e15eb7b).rhs">rhs</a>:<a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a><span class="delimiter">)</span>: <span title="(A, A)" class="delimiter">(</span>A, A<span class="delimiter">)</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[(A, A)]" class="delimiter">[</span><a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a>, <span title="(A, A)" class="delimiter">(</span>A, A<span class="delimiter">)</span><span class="delimiter">]</span>

  def <a title="(rhs: A)A" id="spire.syntax;EuclideanRingOps.gcd">gcd</a><span class="delimiter">(</span><a title="A" id="spire.syntax;EuclideanRingOps.gcd.rhs">rhs</a>:<a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a>, <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)A" id="spire.syntax;EuclideanRingOps.lcm">lcm</a><span class="delimiter">(</span><a title="A" id="spire.syntax;EuclideanRingOps.lcm.rhs">rhs</a>:<a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a>, <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a><span class="delimiter">]</span>

  <span class="comment">// TODO: This is a bit</span>
  def <a title="(rhs: Int)A" id="spire.syntax;EuclideanRingOps./~(3151d0aa9d)">/~</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;EuclideanRingOps./~(3151d0aa9d).rhs">rhs</a>:<span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(implicit evidence$2: c.WeakTypeTag[A])c.Expr[R]">binopWithSelfLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(implicit evidence$2: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)A" id="spire.syntax;EuclideanRingOps.%(3151d0aa9d)">%</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;EuclideanRingOps.%(3151d0aa9d).rhs">rhs</a>:<span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(implicit evidence$2: c.WeakTypeTag[A])c.Expr[R]">binopWithSelfLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(implicit evidence$2: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)(A, A)" id="spire.syntax;EuclideanRingOps./%(d99811684f)">/%</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;EuclideanRingOps./%(d99811684f).rhs">rhs</a>:<span title="Int">Int</span><span class="delimiter">)</span>: <span title="(A, A)" class="delimiter">(</span>A, A<span class="delimiter">)</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(implicit evidence$2: c.WeakTypeTag[A])c.Expr[R]">binopWithSelfLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(implicit evidence$2: c.WeakTypeTag[Int])c.Expr[(A, A)]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <span title="(A, A)" class="delimiter">(</span>A, A<span class="delimiter">)</span><span class="delimiter">]</span>

  def <a title="(rhs: Double)(implicit ev1: spire.algebra.Field[A])A" id="spire.syntax;EuclideanRingOps./~(a7265c38be)">/~</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;EuclideanRingOps./~(a7265c38be).rhs">rhs</a>:<span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;EuclideanRingOps./~(a7265c38be).ev1">ev1</a>:<a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Double])(ev1: c.Expr[spire.algebra.Field[A]])(implicit evidence$1: c.WeakTypeTag[Double])c.Expr[A]" class="delimiter">[</span><span title="Double">Double</span>, <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Double)(implicit ev1: spire.algebra.Field[A])A" id="spire.syntax;EuclideanRingOps.%(a7265c38be)">%</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;EuclideanRingOps.%(a7265c38be).rhs">rhs</a>:<span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;EuclideanRingOps.%(a7265c38be).ev1">ev1</a>:<a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Double])(ev1: c.Expr[spire.algebra.Field[A]])(implicit evidence$1: c.WeakTypeTag[Double])c.Expr[A]" class="delimiter">[</span><span title="Double">Double</span>, <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;EuclideanRingOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Double)(implicit ev1: spire.algebra.Field[A])(A, A)" id="spire.syntax;EuclideanRingOps./%(fafb5db7c4)">/%</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;EuclideanRingOps./%(fafb5db7c4).rhs">rhs</a>:<span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;EuclideanRingOps./%(fafb5db7c4).ev1">ev1</a>:<a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(A, A)" class="delimiter">(</span>A, A<span class="delimiter">)</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Double])(ev1: c.Expr[spire.algebra.Field[A]])(implicit evidence$1: c.WeakTypeTag[Double])c.Expr[(A, A)]" class="delimiter">[</span><span title="Double">Double</span>, <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <span title="(A, A)" class="delimiter">(</span>A, A<span class="delimiter">)</span><span class="delimiter">]</span>

  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])spire.math.Number" id="spire.syntax;EuclideanRingOps./~(8885950850)">/~</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;EuclideanRingOps./~(8885950850).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;EuclideanRingOps./~(8885950850).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="#spire.syntax;EuclideanRingOps./~(8885950850).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;EuclideanRingOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number./~" title="(rhs: spire.math.Number)spire.math.Number">/~</a> <a href="#spire.syntax;EuclideanRingOps./~(8885950850).rhs" title="spire.math.Number">rhs</a>
  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])spire.math.Number" id="spire.syntax;EuclideanRingOps.%(8885950850)">%</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;EuclideanRingOps.%(8885950850).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;EuclideanRingOps.%(8885950850).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="#spire.syntax;EuclideanRingOps.%(8885950850).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;EuclideanRingOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number.%" title="(rhs: spire.math.Number)spire.math.Number">%</a> <a href="#spire.syntax;EuclideanRingOps.%(8885950850).rhs" title="spire.math.Number">rhs</a>
  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])(spire.math.Number, spire.math.Number)" id="spire.syntax;EuclideanRingOps./%(c15b8661a4)">/%</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;EuclideanRingOps./%(c15b8661a4).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;EuclideanRingOps./%(c15b8661a4).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(spire.math.Number, spire.math.Number)" class="delimiter">(</span>Number, Number<span class="delimiter">)</span> = <a href="#spire.syntax;EuclideanRingOps./%(c15b8661a4).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;EuclideanRingOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number./%" title="(rhs: spire.math.Number)(spire.math.Number, spire.math.Number)">/%</a> <a href="#spire.syntax;EuclideanRingOps./%(c15b8661a4).rhs" title="spire.math.Number">rhs</a>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralIntEuclideanRingOps.lhs" title="class LiteralIntEuclideanRingOps extends AnyVal" id="spire.syntax.LiteralIntEuclideanRingOps">LiteralIntEuclideanRingOps</a><a href="#spire.syntax.LiteralIntEuclideanRingOps" title="spire.syntax.LiteralIntEuclideanRingOps" class="delimiter">(</a>val <a title="Int" id="spire.syntax;LiteralIntEuclideanRingOps.lhs">lhs</a>: <span title="Int">Int</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralIntEuclideanRingOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.EuclideanRing[A])A" id="spire.syntax;LiteralIntEuclideanRingOps./~">/~</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralIntEuclideanRingOps./~;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralIntEuclideanRingOps./~.rhs">rhs</a>:<a href="#spire.syntax;LiteralIntEuclideanRingOps./~;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.EuclideanRing[A]" id="spire.syntax;LiteralIntEuclideanRingOps./~.ev">ev</a>: <a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing" title="spire.algebra.EuclideanRing[A]">EuclideanRing</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralIntEuclideanRingOps./~;A" title="A">A</a> = <a href="#spire.syntax;LiteralIntEuclideanRingOps./~.ev" title="spire.algebra.EuclideanRing[A]">ev</a>.<a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing.quot" title="(a: A, b: A)A">quot</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntEuclideanRingOps./~.ev" title="spire.algebra.EuclideanRing[A]">ev</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntEuclideanRingOps.lhs" title="=&gt; Int">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralIntEuclideanRingOps./~.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.EuclideanRing[A])A" id="spire.syntax;LiteralIntEuclideanRingOps.%">%</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralIntEuclideanRingOps.%;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralIntEuclideanRingOps.%.rhs">rhs</a>:<a href="#spire.syntax;LiteralIntEuclideanRingOps.%;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.EuclideanRing[A]" id="spire.syntax;LiteralIntEuclideanRingOps.%.ev">ev</a>: <a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing" title="spire.algebra.EuclideanRing[A]">EuclideanRing</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralIntEuclideanRingOps.%;A" title="A">A</a> = <a href="#spire.syntax;LiteralIntEuclideanRingOps.%.ev" title="spire.algebra.EuclideanRing[A]">ev</a>.<a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing.mod" title="(a: A, b: A)A">mod</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntEuclideanRingOps.%.ev" title="spire.algebra.EuclideanRing[A]">ev</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntEuclideanRingOps.lhs" title="=&gt; Int">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralIntEuclideanRingOps.%.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.EuclideanRing[A])(A, A)" id="spire.syntax;LiteralIntEuclideanRingOps./%">/%</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralIntEuclideanRingOps./%;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralIntEuclideanRingOps./%.rhs">rhs</a>:<a href="#spire.syntax;LiteralIntEuclideanRingOps./%;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.EuclideanRing[A]" id="spire.syntax;LiteralIntEuclideanRingOps./%.ev">ev</a>: <a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing" title="spire.algebra.EuclideanRing[A]">EuclideanRing</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(A, A)" class="delimiter">(</span>A, A<span class="delimiter">)</span> = <a href="#spire.syntax;LiteralIntEuclideanRingOps./%.ev" title="spire.algebra.EuclideanRing[A]">ev</a>.<a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing.quotmod" title="(a: A, b: A)(A, A)">quotmod</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntEuclideanRingOps./%.ev" title="spire.algebra.EuclideanRing[A]">ev</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntEuclideanRingOps.lhs" title="=&gt; Int">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralIntEuclideanRingOps./%.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralLongEuclideanRingOps.lhs" title="class LiteralLongEuclideanRingOps extends AnyVal" id="spire.syntax.LiteralLongEuclideanRingOps">LiteralLongEuclideanRingOps</a><a href="#spire.syntax.LiteralLongEuclideanRingOps" title="spire.syntax.LiteralLongEuclideanRingOps" class="delimiter">(</a>val <a title="Long" id="spire.syntax;LiteralLongEuclideanRingOps.lhs">lhs</a>: <span title="Long">Long</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralLongEuclideanRingOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.EuclideanRing[A], implicit c: spire.math.ConvertableTo[A])A" id="spire.syntax;LiteralLongEuclideanRingOps./~">/~</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralLongEuclideanRingOps./~;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralLongEuclideanRingOps./~.rhs">rhs</a>:<a href="#spire.syntax;LiteralLongEuclideanRingOps./~;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.EuclideanRing[A]" id="spire.syntax;LiteralLongEuclideanRingOps./~.ev">ev</a>: <a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing" title="spire.algebra.EuclideanRing[A]">EuclideanRing</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralLongEuclideanRingOps./~.c">c</a>: <a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralLongEuclideanRingOps./~;A" title="A">A</a> = <a href="#spire.syntax;LiteralLongEuclideanRingOps./~.ev" title="spire.algebra.EuclideanRing[A]">ev</a>.<a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing.quot" title="(a: A, b: A)A">quot</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongEuclideanRingOps./~.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongEuclideanRingOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralLongEuclideanRingOps./~.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.EuclideanRing[A], implicit c: spire.math.ConvertableTo[A])A" id="spire.syntax;LiteralLongEuclideanRingOps.%">%</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralLongEuclideanRingOps.%;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralLongEuclideanRingOps.%.rhs">rhs</a>:<a href="#spire.syntax;LiteralLongEuclideanRingOps.%;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.EuclideanRing[A]" id="spire.syntax;LiteralLongEuclideanRingOps.%.ev">ev</a>: <a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing" title="spire.algebra.EuclideanRing[A]">EuclideanRing</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralLongEuclideanRingOps.%.c">c</a>: <a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralLongEuclideanRingOps.%;A" title="A">A</a> = <a href="#spire.syntax;LiteralLongEuclideanRingOps.%.ev" title="spire.algebra.EuclideanRing[A]">ev</a>.<a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing.mod" title="(a: A, b: A)A">mod</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongEuclideanRingOps.%.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongEuclideanRingOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralLongEuclideanRingOps.%.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.EuclideanRing[A], implicit c: spire.math.ConvertableTo[A])(A, A)" id="spire.syntax;LiteralLongEuclideanRingOps./%">/%</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralLongEuclideanRingOps./%;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralLongEuclideanRingOps./%.rhs">rhs</a>:<a href="#spire.syntax;LiteralLongEuclideanRingOps./%;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.EuclideanRing[A]" id="spire.syntax;LiteralLongEuclideanRingOps./%.ev">ev</a>: <a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing" title="spire.algebra.EuclideanRing[A]">EuclideanRing</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralLongEuclideanRingOps./%.c">c</a>: <a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(A, A)" class="delimiter">(</span>A, A<span class="delimiter">)</span> = <a href="#spire.syntax;LiteralLongEuclideanRingOps./%.ev" title="spire.algebra.EuclideanRing[A]">ev</a>.<a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing.quotmod" title="(a: A, b: A)(A, A)">quotmod</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongEuclideanRingOps./%.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongEuclideanRingOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralLongEuclideanRingOps./%.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralDoubleEuclideanRingOps.lhs" title="class LiteralDoubleEuclideanRingOps extends AnyVal" id="spire.syntax.LiteralDoubleEuclideanRingOps">LiteralDoubleEuclideanRingOps</a><a href="#spire.syntax.LiteralDoubleEuclideanRingOps" title="spire.syntax.LiteralDoubleEuclideanRingOps" class="delimiter">(</a>val <a title="Double" id="spire.syntax;LiteralDoubleEuclideanRingOps.lhs">lhs</a>: <span title="Double">Double</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralDoubleEuclideanRingOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Field[A])A" id="spire.syntax;LiteralDoubleEuclideanRingOps./~">/~</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralDoubleEuclideanRingOps./~;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralDoubleEuclideanRingOps./~.rhs">rhs</a>:<a href="#spire.syntax;LiteralDoubleEuclideanRingOps./~;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;LiteralDoubleEuclideanRingOps./~.ev">ev</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralDoubleEuclideanRingOps./~;A" title="A">A</a> = <a href="#spire.syntax;LiteralDoubleEuclideanRingOps./~.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing.quot" title="(a: A, b: A)A">quot</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleEuclideanRingOps./~.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/Field.scala.html#spire.algebra;Field.fromDouble" title="(a: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleEuclideanRingOps.lhs" title="=&gt; Double">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralDoubleEuclideanRingOps./~.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Field[A])A" id="spire.syntax;LiteralDoubleEuclideanRingOps.%">%</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralDoubleEuclideanRingOps.%;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralDoubleEuclideanRingOps.%.rhs">rhs</a>:<a href="#spire.syntax;LiteralDoubleEuclideanRingOps.%;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;LiteralDoubleEuclideanRingOps.%.ev">ev</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralDoubleEuclideanRingOps.%;A" title="A">A</a> = <a href="#spire.syntax;LiteralDoubleEuclideanRingOps.%.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing.mod" title="(a: A, b: A)A">mod</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleEuclideanRingOps.%.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/Field.scala.html#spire.algebra;Field.fromDouble" title="(a: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleEuclideanRingOps.lhs" title="=&gt; Double">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralDoubleEuclideanRingOps.%.rhs" title="A">rhs</a><span class="delimiter">)</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.Field[A])(A, A)" id="spire.syntax;LiteralDoubleEuclideanRingOps./%">/%</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralDoubleEuclideanRingOps./%;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralDoubleEuclideanRingOps./%.rhs">rhs</a>:<a href="#spire.syntax;LiteralDoubleEuclideanRingOps./%;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;LiteralDoubleEuclideanRingOps./%.ev">ev</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(A, A)" class="delimiter">(</span>A, A<span class="delimiter">)</span> = <a href="#spire.syntax;LiteralDoubleEuclideanRingOps./%.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/EuclideanRing.scala.html#spire.algebra;EuclideanRing.quotmod" title="(a: A, b: A)(A, A)">quotmod</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleEuclideanRingOps./%.ev" title="spire.algebra.Field[A]">ev</a>.<a href="../algebra/Field.scala.html#spire.algebra;Field.fromDouble" title="(a: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleEuclideanRingOps.lhs" title="=&gt; Double">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralDoubleEuclideanRingOps./%.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a title="class IsRealOps[A] extends AnyRef" id="spire.syntax;IsRealOps">IsRealOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;IsRealOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;IsRealOps" title="spire.syntax.IsRealOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;IsRealOps.lhs">lhs</a>:<a href="#spire.syntax;IsRealOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.IsReal[A]" id="spire.syntax;IsRealOps.ev">ev</a>:<a href="../algebra/IsReal.scala.html#spire.algebra;IsReal" title="spire.algebra.IsReal[A]">IsReal</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="()Boolean" id="spire.syntax;IsRealOps.isWhole">isWhole</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Boolean]" class="delimiter">[</span><span title="Boolean">Boolean</span><span class="delimiter">]</span>
  def <a title="()A" id="spire.syntax;IsRealOps.ceil">ceil</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;IsRealOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;IsRealOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="()A" id="spire.syntax;IsRealOps.floor">floor</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;IsRealOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;IsRealOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="()A" id="spire.syntax;IsRealOps.round">round</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;IsRealOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;IsRealOps;A" title="A">A</a><span class="delimiter">]</span>
  <span class="comment">//def toDouble(): Double = macro Ops.unop[Double]</span>
<span class="delimiter">}</span>

final class <a title="class NRootOps[A] extends AnyRef" id="spire.syntax;NRootOps">NRootOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;NRootOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;NRootOps" title="spire.syntax.NRootOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;NRootOps.lhs">lhs</a>: <a href="#spire.syntax;NRootOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.NRoot[A]" id="spire.syntax;NRootOps.ev">ev</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[A]">NRoot</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: Int)A" id="spire.syntax;NRootOps.nroot">nroot</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;NRootOps.nroot.rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.syntax;NRootOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="#spire.syntax;NRootOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="()A" id="spire.syntax;NRootOps.sqrt">sqrt</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;NRootOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;NRootOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)A" id="spire.syntax;NRootOps.fpow">fpow</a><span class="delimiter">(</span><a title="A" id="spire.syntax;NRootOps.fpow.rhs">rhs</a>: <a href="#spire.syntax;NRootOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;NRootOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;NRootOps;A" title="A">A</a>, <a href="#spire.syntax;NRootOps;A" title="A">A</a><span class="delimiter">]</span>

  <span class="comment">// TODO: should be macros</span>
  def <a title="(rhs: Double)(implicit c: spire.algebra.Field[A])A" id="spire.syntax;NRootOps.pow(806610ccac)">pow</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;NRootOps.pow(806610ccac).rhs">rhs</a>: <span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;NRootOps.pow(806610ccac).c">c</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;NRootOps;A" title="A">A</a> = <a href="#spire.syntax;NRootOps.ev" title="spire.algebra.NRoot[A]">ev</a>.<a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.fpow" title="(a: A, b: A)A">fpow</a><span class="delimiter">(</span><a href="#spire.syntax;NRootOps.lhs" title="A">lhs</a>, <a href="#spire.syntax;NRootOps.pow(806610ccac).c" title="spire.algebra.Field[A]">c</a>.<a href="../algebra/Field.scala.html#spire.algebra;Field.fromDouble" title="(a: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;NRootOps.pow(806610ccac).rhs" title="Double">rhs</a><span class="delimiter">)</span><span class="delimiter">)</span>
  def <a title="(rhs: Double)(implicit c: spire.algebra.Field[A])A" id="spire.syntax;NRootOps.**(806610ccac)">**</a><span class="delimiter">(</span><a title="Double" id="spire.syntax;NRootOps.**(806610ccac).rhs">rhs</a>: <span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;NRootOps.**(806610ccac).c">c</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;NRootOps;A" title="A">A</a> = <a href="#spire.syntax;NRootOps.ev" title="spire.algebra.NRoot[A]">ev</a>.<a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.fpow" title="(a: A, b: A)A">fpow</a><span class="delimiter">(</span><a href="#spire.syntax;NRootOps.lhs" title="A">lhs</a>, <a href="#spire.syntax;NRootOps.**(806610ccac).c" title="spire.algebra.Field[A]">c</a>.<a href="../algebra/Field.scala.html#spire.algebra;Field.fromDouble" title="(a: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;NRootOps.**(806610ccac).rhs" title="Double">rhs</a><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])spire.math.Number" id="spire.syntax;NRootOps.pow(8885950850)">pow</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;NRootOps.pow(8885950850).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;NRootOps.pow(8885950850).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="#spire.syntax;NRootOps.pow(8885950850).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;NRootOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number.pow" title="(rhs: spire.math.Number)spire.math.Number">pow</a> <a href="#spire.syntax;NRootOps.pow(8885950850).rhs" title="spire.math.Number">rhs</a>
  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])spire.math.Number" id="spire.syntax;NRootOps.**(8885950850)">**</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;NRootOps.**(8885950850).rhs">rhs</a>:<a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;NRootOps.**(8885950850).c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="#spire.syntax;NRootOps.**(8885950850).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;NRootOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number.**" title="(rhs: spire.math.Number)spire.math.Number">**</a> <a href="#spire.syntax;NRootOps.**(8885950850).rhs" title="spire.math.Number">rhs</a>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralIntNRootOps.lhs" title="class LiteralIntNRootOps extends AnyVal" id="spire.syntax.LiteralIntNRootOps">LiteralIntNRootOps</a><a href="#spire.syntax.LiteralIntNRootOps" title="spire.syntax.LiteralIntNRootOps" class="delimiter">(</a>val <a title="Int" id="spire.syntax;LiteralIntNRootOps.lhs">lhs</a>: <span title="Int">Int</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralIntNRootOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.NRoot[A], implicit c: spire.math.ConvertableTo[A])A" id="spire.syntax;LiteralIntNRootOps.**">**</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralIntNRootOps.**;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralIntNRootOps.**.rhs">rhs</a>:<a href="#spire.syntax;LiteralIntNRootOps.**;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.NRoot[A]" id="spire.syntax;LiteralIntNRootOps.**.ev">ev</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[A]">NRoot</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralIntNRootOps.**.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralIntNRootOps.**;A" title="A">A</a> = <a href="#spire.syntax;LiteralIntNRootOps.**.ev" title="spire.algebra.NRoot[A]">ev</a>.<a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.fpow" title="(a: A, b: A)A">fpow</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntNRootOps.**.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralIntNRootOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralIntNRootOps.**.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralLongNRootOps.lhs" title="class LiteralLongNRootOps extends AnyVal" id="spire.syntax.LiteralLongNRootOps">LiteralLongNRootOps</a><a href="#spire.syntax.LiteralLongNRootOps" title="spire.syntax.LiteralLongNRootOps" class="delimiter">(</a>val <a title="Long" id="spire.syntax;LiteralLongNRootOps.lhs">lhs</a>: <span title="Long">Long</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralLongNRootOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.NRoot[A], implicit c: spire.math.ConvertableTo[A])A" id="spire.syntax;LiteralLongNRootOps.**">**</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralLongNRootOps.**;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralLongNRootOps.**.rhs">rhs</a>:<a href="#spire.syntax;LiteralLongNRootOps.**;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.NRoot[A]" id="spire.syntax;LiteralLongNRootOps.**.ev">ev</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[A]">NRoot</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralLongNRootOps.**.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralLongNRootOps.**;A" title="A">A</a> = <a href="#spire.syntax;LiteralLongNRootOps.**.ev" title="spire.algebra.NRoot[A]">ev</a>.<a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.fpow" title="(a: A, b: A)A">fpow</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongNRootOps.**.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromLong" title="(n: Long)A">fromLong</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralLongNRootOps.lhs" title="=&gt; Long">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralLongNRootOps.**.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a href="#spire.syntax;LiteralDoubleNRootOps.lhs" title="class LiteralDoubleNRootOps extends AnyVal" id="spire.syntax.LiteralDoubleNRootOps">LiteralDoubleNRootOps</a><a href="#spire.syntax.LiteralDoubleNRootOps" title="spire.syntax.LiteralDoubleNRootOps" class="delimiter">(</a>val <a title="Double" id="spire.syntax;LiteralDoubleNRootOps.lhs">lhs</a>: <span title="Double">Double</span><span class="delimiter">)</span> extends <a href="#spire.syntax.LiteralDoubleNRootOps" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
  def <a title="[A](rhs: A)(implicit ev: spire.algebra.NRoot[A], implicit c: spire.math.ConvertableTo[A])A" id="spire.syntax;LiteralDoubleNRootOps.**">**</a><span class="delimiter">[</span><a title="" id="spire.syntax;LiteralDoubleNRootOps.**;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;LiteralDoubleNRootOps.**.rhs">rhs</a>:<a href="#spire.syntax;LiteralDoubleNRootOps.**;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.NRoot[A]" id="spire.syntax;LiteralDoubleNRootOps.**.ev">ev</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[A]">NRoot</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.math.ConvertableTo[A]" id="spire.syntax;LiteralDoubleNRootOps.**.c">c</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableTo" title="spire.math.ConvertableTo[A]">ConvertableTo</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LiteralDoubleNRootOps.**;A" title="A">A</a> = <a href="#spire.syntax;LiteralDoubleNRootOps.**.ev" title="spire.algebra.NRoot[A]">ev</a>.<a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.fpow" title="(a: A, b: A)A">fpow</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleNRootOps.**.c" title="spire.math.ConvertableTo[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableTo.fromDouble" title="(n: Double)A">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;LiteralDoubleNRootOps.lhs" title="=&gt; Double">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;LiteralDoubleNRootOps.**.rhs" title="A">rhs</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a title="class TrigOps[A] extends AnyRef" id="spire.syntax;TrigOps">TrigOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;TrigOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;TrigOps" title="spire.syntax.TrigOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;TrigOps.lhs">lhs</a>: <a href="#spire.syntax;TrigOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Trig[A]" id="spire.syntax;TrigOps.ev">ev</a>: <a href="../algebra/Trig.scala.html#spire.algebra;Trig" title="spire.algebra.Trig[A]">Trig</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="()A" id="spire.syntax;TrigOps.exp">exp</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;TrigOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;TrigOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="()A" id="spire.syntax;TrigOps.log(8f065de60a)">log</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;TrigOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;TrigOps;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="(base: Int)(implicit f: spire.algebra.Field[A])A" id="spire.syntax;TrigOps.log(e414c6c4c0)">log</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;TrigOps.log(e414c6c4c0).base">base</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.syntax;TrigOps.log(e414c6c4c0).f">f</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;TrigOps;A" title="A">A</a> =
    <a href="#spire.syntax;TrigOps.log(e414c6c4c0).f" title="spire.algebra.Field[A]">f</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeGroup.div" title="(x: A, y: A)A">div</a><span class="delimiter">(</span><a href="#spire.syntax;TrigOps.ev" title="spire.algebra.Trig[A]">ev</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.log" title="(a: A)A">log</a><span class="delimiter">(</span><a href="#spire.syntax;TrigOps.lhs" title="A">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;TrigOps.ev" title="spire.algebra.Trig[A]">ev</a>.<a href="../algebra/Trig.scala.html#spire.algebra;Trig.log" title="(a: A)A">log</a><span class="delimiter">(</span><a href="#spire.syntax;TrigOps.log(e414c6c4c0).f" title="spire.algebra.Field[A]">f</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)A">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;TrigOps.log(e414c6c4c0).base" title="Int">base</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a title="class MeetOps[A] extends AnyRef" id="spire.syntax;MeetOps">MeetOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;MeetOps;A">A</a>: MeetSemilattice<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;MeetOps.lhs">lhs</a>: <a href="#spire.syntax;MeetOps;A" title="A">A</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: A)A" id="spire.syntax;MeetOps.meet(867292a5eb)">meet</a><span class="delimiter">(</span><a title="A" id="spire.syntax;MeetOps.meet(867292a5eb).rhs">rhs</a>: <a href="#spire.syntax;MeetOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;MeetOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;MeetOps;A" title="A">A</a>, <a href="#spire.syntax;MeetOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)A" id="spire.syntax;MeetOps.(867292a5eb)"></a><span class="delimiter">(</span><a title="A" id="spire.syntax;MeetOps.(867292a5eb).rhs">rhs</a>: <a href="#spire.syntax;MeetOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;MeetOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;MeetOps;A" title="A">A</a>, <a href="#spire.syntax;MeetOps;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])A" id="spire.syntax;MeetOps.meet(5faa3d8872)">meet</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;MeetOps.meet(5faa3d8872).rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;MeetOps.meet(5faa3d8872).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;MeetOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;MeetOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])A" id="spire.syntax;MeetOps.(5faa3d8872)"></a><span class="delimiter">(</span><a title="Int" id="spire.syntax;MeetOps.(5faa3d8872).rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;MeetOps.(5faa3d8872).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;MeetOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;MeetOps;A" title="A">A</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class JoinOps[A] extends AnyRef" id="spire.syntax;JoinOps">JoinOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;JoinOps;A">A</a>: JoinSemilattice<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;JoinOps.lhs">lhs</a>: <a href="#spire.syntax;JoinOps;A" title="A">A</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: A)A" id="spire.syntax;JoinOps.join(867292a5eb)">join</a><span class="delimiter">(</span><a title="A" id="spire.syntax;JoinOps.join(867292a5eb).rhs">rhs</a>: <a href="#spire.syntax;JoinOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;JoinOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;JoinOps;A" title="A">A</a>, <a href="#spire.syntax;JoinOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)A" id="spire.syntax;JoinOps.(867292a5eb)"></a><span class="delimiter">(</span><a title="A" id="spire.syntax;JoinOps.(867292a5eb).rhs">rhs</a>: <a href="#spire.syntax;JoinOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;JoinOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;JoinOps;A" title="A">A</a>, <a href="#spire.syntax;JoinOps;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])A" id="spire.syntax;JoinOps.join(5faa3d8872)">join</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;JoinOps.join(5faa3d8872).rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;JoinOps.join(5faa3d8872).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;JoinOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;JoinOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])A" id="spire.syntax;JoinOps.(5faa3d8872)"></a><span class="delimiter">(</span><a title="Int" id="spire.syntax;JoinOps.(5faa3d8872).rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;JoinOps.(5faa3d8872).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;JoinOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;JoinOps;A" title="A">A</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class HeytingOps[A] extends AnyRef" id="spire.syntax;HeytingOps">HeytingOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;HeytingOps;A">A</a>: Heyting<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;HeytingOps.lhs">lhs</a>:<a href="#spire.syntax;HeytingOps;A" title="A">A</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="()A" id="spire.syntax;HeytingOps.unary_~">unary_~</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;HeytingOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;HeytingOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)A" id="spire.syntax;HeytingOps.imp">imp</a><span class="delimiter">(</span><a title="A" id="spire.syntax;HeytingOps.imp.rhs">rhs</a>: <a href="#spire.syntax;HeytingOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;HeytingOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;HeytingOps;A" title="A">A</a>, <a href="#spire.syntax;HeytingOps;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="(rhs: A)A" id="spire.syntax;HeytingOps.&(867292a5eb)">&amp;</a><span class="delimiter">(</span><a title="A" id="spire.syntax;HeytingOps.&(867292a5eb).rhs">rhs</a>: <a href="#spire.syntax;HeytingOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;HeytingOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;HeytingOps;A" title="A">A</a>, <a href="#spire.syntax;HeytingOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)A" id="spire.syntax;HeytingOps.|(867292a5eb)">|</a><span class="delimiter">(</span><a title="A" id="spire.syntax;HeytingOps.|(867292a5eb).rhs">rhs</a>: <a href="#spire.syntax;HeytingOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;HeytingOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;HeytingOps;A" title="A">A</a>, <a href="#spire.syntax;HeytingOps;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])A" id="spire.syntax;HeytingOps.&(5faa3d8872)">&amp;</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;HeytingOps.&(5faa3d8872).rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;HeytingOps.&(5faa3d8872).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;HeytingOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;HeytingOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])A" id="spire.syntax;HeytingOps.|(5faa3d8872)">|</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;HeytingOps.|(5faa3d8872).rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;HeytingOps.|(5faa3d8872).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;HeytingOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;HeytingOps;A" title="A">A</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class BoolOps[A] extends AnyRef" id="spire.syntax;BoolOps">BoolOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;BoolOps;A">A</a>: Bool<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.syntax;BoolOps.lhs">lhs</a>:<a href="#spire.syntax;BoolOps;A" title="A">A</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: A)A" id="spire.syntax;BoolOps.^(867292a5eb)">^</a><span class="delimiter">(</span><a title="A" id="spire.syntax;BoolOps.^(867292a5eb).rhs">rhs</a>: <a href="#spire.syntax;BoolOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;BoolOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;BoolOps;A" title="A">A</a>, <a href="#spire.syntax;BoolOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)A" id="spire.syntax;BoolOps.nand">nand</a><span class="delimiter">(</span><a title="A" id="spire.syntax;BoolOps.nand.rhs">rhs</a>: <a href="#spire.syntax;BoolOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;BoolOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;BoolOps;A" title="A">A</a>, <a href="#spire.syntax;BoolOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)A" id="spire.syntax;BoolOps.nor">nor</a><span class="delimiter">(</span><a title="A" id="spire.syntax;BoolOps.nor.rhs">rhs</a>: <a href="#spire.syntax;BoolOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;BoolOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;BoolOps;A" title="A">A</a>, <a href="#spire.syntax;BoolOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: A)A" id="spire.syntax;BoolOps.nxor">nxor</a><span class="delimiter">(</span><a title="A" id="spire.syntax;BoolOps.nxor.rhs">rhs</a>: <a href="#spire.syntax;BoolOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.syntax;BoolOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;BoolOps;A" title="A">A</a>, <a href="#spire.syntax;BoolOps;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="(rhs: Int)(implicit ev1: spire.algebra.Ring[A])A" id="spire.syntax;BoolOps.^(5faa3d8872)">^</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;BoolOps.^(5faa3d8872).rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Ring[A]" id="spire.syntax;BoolOps.^(5faa3d8872).ev1">ev1</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;BoolOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev1: c.Expr[Ev])(implicit evidence$1: c.WeakTypeTag[A])c.Expr[R]">binopWithLift</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev1: c.Expr[spire.algebra.Ring[A]])(implicit evidence$1: c.WeakTypeTag[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#spire.syntax;BoolOps;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="(rhs: spire.math.Number)(implicit c: spire.math.ConvertableFrom[A])spire.math.Number" id="spire.syntax;BoolOps.^(8885950850)">^</a><span class="delimiter">(</span><a title="spire.math.Number" id="spire.syntax;BoolOps.^(8885950850).rhs">rhs</a>: <a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;BoolOps.^(8885950850).c">c</a>: <a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../math/Number.scala.html#spire.math;Number" title="spire.math.Number">Number</a> = <a href="#spire.syntax;BoolOps.^(8885950850).c" title="spire.math.ConvertableFrom[A]">c</a>.<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom.toNumber" title="(a: A)spire.math.Number">toNumber</a><span class="delimiter">(</span><a href="#spire.syntax;BoolOps.lhs" title="A">lhs</a><span class="delimiter">)</span> <a href="../math/Number.scala.html#spire.math;Number.^" title="(rhs: spire.math.Number)spire.math.Number">^</a> <a href="#spire.syntax;BoolOps.^(8885950850).rhs" title="spire.math.Number">rhs</a>
<span class="delimiter">}</span>

final class <a title="class ModuleOps[V] extends AnyRef" id="spire.syntax;ModuleOps">ModuleOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;ModuleOps;V">V</a><span class="delimiter">]</span><a href="#spire.syntax;ModuleOps" title="spire.syntax.ModuleOps[V]" class="delimiter">(</a><a title="V" id="spire.syntax;ModuleOps.x">x</a>: <a href="#spire.syntax;ModuleOps;V" title="V">V</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[F](lhs: F)(implicit ev: spire.algebra.Module[V,F])V" id="spire.syntax;ModuleOps.*:(f901e9c143)">*:</a><span class="delimiter">[</span><a title="" id="spire.syntax;ModuleOps.*:(f901e9c143);F">F</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F" id="spire.syntax;ModuleOps.*:(f901e9c143).lhs">lhs</a>:<a href="#spire.syntax;ModuleOps.*:(f901e9c143);F" title="F">F</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Module[V,F]" id="spire.syntax;ModuleOps.*:(f901e9c143).ev">ev</a>: <a href="../algebra/Module.scala.html#spire.algebra;Module" title="spire.algebra.Module[V,F]">Module</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;ModuleOps;V" title="V">V</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(lhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">rbinopWithEv</span><span title="(c: reflect.macros.Context)(lhs: c.Expr[F])(ev: c.Expr[spire.algebra.Module[V,F]])c.Expr[V]" class="delimiter">[</span><a href="#spire.syntax;ModuleOps.*:(f901e9c143);F" title="F">F</a>, <a href="../algebra/Module.scala.html#spire.algebra;Module" title="spire.algebra.Module[V,F]">Module</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span>, <a href="#spire.syntax;ModuleOps;V" title="V">V</a><span class="delimiter">]</span>
  def <a title="[F](rhs: F)(implicit ev: spire.algebra.Module[V,F])V" id="spire.syntax;ModuleOps.:*(419eb62fcc)">:*</a><span class="delimiter">[</span><a title="" id="spire.syntax;ModuleOps.:*(419eb62fcc);F">F</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F" id="spire.syntax;ModuleOps.:*(419eb62fcc).rhs">rhs</a>:<a href="#spire.syntax;ModuleOps.:*(419eb62fcc);F" title="F">F</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Module[V,F]" id="spire.syntax;ModuleOps.:*(419eb62fcc).ev">ev</a>: <a href="../algebra/Module.scala.html#spire.algebra;Module" title="spire.algebra.Module[V,F]">Module</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;ModuleOps;V" title="V">V</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[F])(ev: c.Expr[spire.algebra.Module[V,F]])c.Expr[V]" class="delimiter">[</span><a href="#spire.syntax;ModuleOps.:*(419eb62fcc);F" title="F">F</a>, <a href="../algebra/Module.scala.html#spire.algebra;Module" title="spire.algebra.Module[V,F]">Module</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span>, <a href="#spire.syntax;ModuleOps;V" title="V">V</a><span class="delimiter">]</span>

  <span class="comment">// TODO: Are macros worth it here?</span>
  def <a title="[F](lhs: Int)(implicit ev: spire.algebra.Module[V,F], implicit F: spire.algebra.Ring[F])V" id="spire.syntax;ModuleOps.*:(69e5ca235a)">*:</a><span class="delimiter">[</span><a title="" id="spire.syntax;ModuleOps.*:(69e5ca235a);F">F</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="spire.syntax;ModuleOps.*:(69e5ca235a).lhs">lhs</a>:<span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Module[V,F]" id="spire.syntax;ModuleOps.*:(69e5ca235a).ev">ev</a>: <a href="../algebra/Module.scala.html#spire.algebra;Module" title="spire.algebra.Module[V,F]">Module</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span>, <a title="spire.algebra.Ring[F]" id="spire.syntax;ModuleOps.*:(69e5ca235a).F">F</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[F]">Ring</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;ModuleOps;V" title="V">V</a> = <a href="#spire.syntax;ModuleOps.*:(69e5ca235a).ev" title="spire.algebra.Module[V,F]">ev</a>.<a href="../algebra/Module.scala.html#spire.algebra;Module.timesl" title="(r: F, v: V)V">timesl</a><span class="delimiter">(</span><a href="#spire.syntax;ModuleOps.*:(69e5ca235a).F" title="spire.algebra.Ring[F]">F</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)F">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;ModuleOps.*:(69e5ca235a).lhs" title="Int">lhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;ModuleOps.x" title="V">x</a><span class="delimiter">)</span>
  def <a title="[F](rhs: Int)(implicit ev: spire.algebra.Module[V,F], implicit F: spire.algebra.Ring[F])V" id="spire.syntax;ModuleOps.:*(4636a56e5f)">:*</a><span class="delimiter">[</span><a title="" id="spire.syntax;ModuleOps.:*(4636a56e5f);F">F</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="spire.syntax;ModuleOps.:*(4636a56e5f).rhs">rhs</a>:<span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Module[V,F]" id="spire.syntax;ModuleOps.:*(4636a56e5f).ev">ev</a>: <a href="../algebra/Module.scala.html#spire.algebra;Module" title="spire.algebra.Module[V,F]">Module</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span>, <a title="spire.algebra.Ring[F]" id="spire.syntax;ModuleOps.:*(4636a56e5f).F">F</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[F]">Ring</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;ModuleOps;V" title="V">V</a> = <a href="#spire.syntax;ModuleOps.:*(4636a56e5f).ev" title="spire.algebra.Module[V,F]">ev</a>.<a href="../algebra/Module.scala.html#spire.algebra;Module.timesr" title="(v: V, r: F)V">timesr</a><span class="delimiter">(</span><a href="#spire.syntax;ModuleOps.x" title="V">x</a>, <a href="#spire.syntax;ModuleOps.:*(4636a56e5f).F" title="spire.algebra.Ring[F]">F</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)F">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;ModuleOps.:*(4636a56e5f).rhs" title="Int">rhs</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a title="class ModuleUnboundOps[F] extends AnyRef" id="spire.syntax;ModuleUnboundOps">ModuleUnboundOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;ModuleUnboundOps;F">F</a><span class="delimiter">]</span><a href="#spire.syntax;ModuleUnboundOps" title="spire.syntax.ModuleUnboundOps[F]" class="delimiter">(</a><a title="F" id="spire.syntax;ModuleUnboundOps.lhs">lhs</a>: <a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Module[_, F]" id="spire.syntax;ModuleUnboundOps.ev">ev</a>: <a href="../algebra/Module.scala.html#spire.algebra;Module" title="spire.algebra.Module[_, F]">Module</a><span class="delimiter">[</span>_, F<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: F)F" id="spire.syntax;ModuleUnboundOps.+">+</a><span class="delimiter">(</span><a title="F" id="spire.syntax;ModuleUnboundOps.+.rhs">rhs</a>: <a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a><span class="delimiter">)</span>: <a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binopWithScalar</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[F])c.Expr[F]" class="delimiter">[</span><a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a>, <a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a><span class="delimiter">]</span>
  def <a title="(rhs: F)F" id="spire.syntax;ModuleUnboundOps.-">-</a><span class="delimiter">(</span><a title="F" id="spire.syntax;ModuleUnboundOps.-.rhs">rhs</a>: <a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a><span class="delimiter">)</span>: <a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binopWithScalar</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[F])c.Expr[F]" class="delimiter">[</span><a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a>, <a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a><span class="delimiter">]</span>
  def <a title="()F" id="spire.syntax;ModuleUnboundOps.unary_-">unary_-</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unopWithScalar</span><span title="(c: reflect.macros.Context)()c.Expr[F]" class="delimiter">[</span><a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a><span class="delimiter">]</span>
  
  def <a title="(rhs: F)F" id="spire.syntax;ModuleUnboundOps.*">*</a><span class="delimiter">(</span><a title="F" id="spire.syntax;ModuleUnboundOps.*.rhs">rhs</a>: <a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a><span class="delimiter">)</span>: <a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binopWithScalar</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[F])c.Expr[F]" class="delimiter">[</span><a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a>, <a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a><span class="delimiter">]</span>
  
  def <a title="(rhs: Int)F" id="spire.syntax;ModuleUnboundOps.pow">pow</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;ModuleUnboundOps.pow.rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binopWithScalar</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])c.Expr[F]" class="delimiter">[</span><span title="Int">Int</span>, <a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)F" id="spire.syntax;ModuleUnboundOps.**">**</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;ModuleUnboundOps.**.rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binopWithScalar</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])c.Expr[F]" class="delimiter">[</span><span title="Int">Int</span>, <a href="#spire.syntax;ModuleUnboundOps;F" title="F">F</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class VectorSpaceOps[V] extends AnyRef" id="spire.syntax;VectorSpaceOps">VectorSpaceOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;VectorSpaceOps;V">V</a><span class="delimiter">]</span><a href="#spire.syntax;VectorSpaceOps" title="spire.syntax.VectorSpaceOps[V]" class="delimiter">(</a><a title="V" id="spire.syntax;VectorSpaceOps.x">x</a>: <a href="#spire.syntax;VectorSpaceOps;V" title="V">V</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[F](rhs: F)(implicit ev: spire.algebra.VectorSpace[V,F])V" id="spire.syntax;VectorSpaceOps.:/(7eb59b9dbf)">:/</a><span class="delimiter">[</span><a title="" id="spire.syntax;VectorSpaceOps.:/(7eb59b9dbf);F">F</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F" id="spire.syntax;VectorSpaceOps.:/(7eb59b9dbf).rhs">rhs</a>:<a href="#spire.syntax;VectorSpaceOps.:/(7eb59b9dbf);F" title="F">F</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.VectorSpace[V,F]" id="spire.syntax;VectorSpaceOps.:/(7eb59b9dbf).ev">ev</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[V,F]">VectorSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;VectorSpaceOps;V" title="V">V</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[F])(ev: c.Expr[spire.algebra.VectorSpace[V,F]])c.Expr[V]" class="delimiter">[</span><a href="#spire.syntax;VectorSpaceOps.:/(7eb59b9dbf);F" title="F">F</a>, <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[V,F]">VectorSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span>, <a href="#spire.syntax;VectorSpaceOps;V" title="V">V</a><span class="delimiter">]</span>

  <span class="comment">//def *:[F](lhs:Double)(implicit ev: VectorSpace[V, F]): V = ev.timesl(ev.scalar.fromDouble(lhs), x)</span>
  <span class="comment">//def :*[F](rhs:Double)(implicit ev: VectorSpace[V, F]): V = ev.timesr(x, ev.scalar.fromDouble(rhs))</span>

  def <a title="[F](rhs: Int)(implicit ev: spire.algebra.VectorSpace[V,F])V" id="spire.syntax;VectorSpaceOps.:/(e04fb71e78)">:/</a><span class="delimiter">[</span><a title="" id="spire.syntax;VectorSpaceOps.:/(e04fb71e78);F">F</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="spire.syntax;VectorSpaceOps.:/(e04fb71e78).rhs">rhs</a>:<span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.VectorSpace[V,F]" id="spire.syntax;VectorSpaceOps.:/(e04fb71e78).ev">ev</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[V,F]">VectorSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;VectorSpaceOps;V" title="V">V</a> = <a href="#spire.syntax;VectorSpaceOps.:/(e04fb71e78).ev" title="spire.algebra.VectorSpace[V,F]">ev</a>.<a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace.divr" title="(v: V, f: F)V">divr</a><span class="delimiter">(</span><a href="#spire.syntax;VectorSpaceOps.x" title="V">x</a>, <a href="#spire.syntax;VectorSpaceOps.:/(e04fb71e78).ev" title="spire.algebra.VectorSpace[V,F]">ev</a>.<a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace.scalar" title="=&gt; spire.algebra.Field[F]">scalar</a>.<a href="../algebra/Ring.scala.html#spire.algebra;Ring.fromInt" title="(n: Int)F">fromInt</a><span class="delimiter">(</span><a href="#spire.syntax;VectorSpaceOps.:/(e04fb71e78).rhs" title="Int">rhs</a><span class="delimiter">)</span><span class="delimiter">)</span>
  def <a title="[F](rhs: Double)(implicit ev: spire.algebra.VectorSpace[V,F])V" id="spire.syntax;VectorSpaceOps.:/(95f74897fe)">:/</a><span class="delimiter">[</span><a title="" id="spire.syntax;VectorSpaceOps.:/(95f74897fe);F">F</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Double" id="spire.syntax;VectorSpaceOps.:/(95f74897fe).rhs">rhs</a>:<span title="Double">Double</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.VectorSpace[V,F]" id="spire.syntax;VectorSpaceOps.:/(95f74897fe).ev">ev</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[V,F]">VectorSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;VectorSpaceOps;V" title="V">V</a> = <a href="#spire.syntax;VectorSpaceOps.:/(95f74897fe).ev" title="spire.algebra.VectorSpace[V,F]">ev</a>.<a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace.divr" title="(v: V, f: F)V">divr</a><span class="delimiter">(</span><a href="#spire.syntax;VectorSpaceOps.x" title="V">x</a>, <a href="#spire.syntax;VectorSpaceOps.:/(95f74897fe).ev" title="spire.algebra.VectorSpace[V,F]">ev</a>.<a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace.scalar" title="=&gt; spire.algebra.Field[F]">scalar</a>.<a href="../algebra/Field.scala.html#spire.algebra;Field.fromDouble" title="(a: Double)F">fromDouble</a><span class="delimiter">(</span><a href="#spire.syntax;VectorSpaceOps.:/(95f74897fe).rhs" title="Double">rhs</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

final class <a title="class VectorSpaceUnboundOps[F] extends AnyRef" id="spire.syntax;VectorSpaceUnboundOps">VectorSpaceUnboundOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;VectorSpaceUnboundOps;F">F</a><span class="delimiter">]</span><a href="#spire.syntax;VectorSpaceUnboundOps" title="spire.syntax.VectorSpaceUnboundOps[F]" class="delimiter">(</a><a title="F" id="spire.syntax;VectorSpaceUnboundOps.lhs">lhs</a>: <a href="#spire.syntax;VectorSpaceUnboundOps;F" title="F">F</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.VectorSpace[_, F]" id="spire.syntax;VectorSpaceUnboundOps.ev">ev</a>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[_, F]">VectorSpace</a><span class="delimiter">[</span>_, F<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: F)F" id="spire.syntax;VectorSpaceUnboundOps./">/</a><span class="delimiter">(</span><a title="F" id="spire.syntax;VectorSpaceUnboundOps./.rhs">rhs</a>: <a href="#spire.syntax;VectorSpaceUnboundOps;F" title="F">F</a><span class="delimiter">)</span>: <a href="#spire.syntax;VectorSpaceUnboundOps;F" title="F">F</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binopWithScalar</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[F])c.Expr[F]" class="delimiter">[</span><a href="#spire.syntax;VectorSpaceUnboundOps;F" title="F">F</a>, <a href="#spire.syntax;VectorSpaceUnboundOps;F" title="F">F</a><span class="delimiter">]</span>
  def <a title="()F" id="spire.syntax;VectorSpaceUnboundOps.reciprocal">reciprocal</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;VectorSpaceUnboundOps;F" title="F">F</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unopWithScalar</span><span title="(c: reflect.macros.Context)()c.Expr[F]" class="delimiter">[</span><a href="#spire.syntax;VectorSpaceUnboundOps;F" title="F">F</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class InnerProductSpaceOps[V] extends AnyRef" id="spire.syntax;InnerProductSpaceOps">InnerProductSpaceOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;InnerProductSpaceOps;V">V</a><span class="delimiter">]</span><a href="#spire.syntax;InnerProductSpaceOps" title="spire.syntax.InnerProductSpaceOps[V]" class="delimiter">(</a><a title="V" id="spire.syntax;InnerProductSpaceOps.lhs">lhs</a>: <a href="#spire.syntax;InnerProductSpaceOps;V" title="V">V</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[F](rhs: V)(implicit ev: spire.algebra.InnerProductSpace[V,F])F" id="spire.syntax;InnerProductSpaceOps.dot">dot</a><span class="delimiter">[</span><a title="" id="spire.syntax;InnerProductSpaceOps.dot;F">F</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="V" id="spire.syntax;InnerProductSpaceOps.dot.rhs">rhs</a>: <a href="#spire.syntax;InnerProductSpaceOps;V" title="V">V</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.InnerProductSpace[V,F]" id="spire.syntax;InnerProductSpaceOps.dot.ev">ev</a>: <a href="../algebra/InnerProductSpace.scala.html#spire.algebra;InnerProductSpace" title="spire.algebra.InnerProductSpace[V,F]">InnerProductSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;InnerProductSpaceOps.dot;F" title="F">F</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[V])(ev: c.Expr[spire.algebra.InnerProductSpace[V,F]])c.Expr[F]" class="delimiter">[</span><a href="#spire.syntax;InnerProductSpaceOps;V" title="V">V</a>, <a href="../algebra/InnerProductSpace.scala.html#spire.algebra;InnerProductSpace" title="spire.algebra.InnerProductSpace[V,F]">InnerProductSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span>, <a href="#spire.syntax;InnerProductSpaceOps.dot;F" title="F">F</a><span class="delimiter">]</span>
  def <a title="[F](rhs: V)(implicit ev: spire.algebra.InnerProductSpace[V,F])F" id="spire.syntax;InnerProductSpaceOps."></a><span class="delimiter">[</span><a title="" id="spire.syntax;InnerProductSpaceOps.;F">F</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="V" id="spire.syntax;InnerProductSpaceOps..rhs">rhs</a>: <a href="#spire.syntax;InnerProductSpaceOps;V" title="V">V</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.InnerProductSpace[V,F]" id="spire.syntax;InnerProductSpaceOps..ev">ev</a>: <a href="../algebra/InnerProductSpace.scala.html#spire.algebra;InnerProductSpace" title="spire.algebra.InnerProductSpace[V,F]">InnerProductSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;InnerProductSpaceOps.;F" title="F">F</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[V])(ev: c.Expr[spire.algebra.InnerProductSpace[V,F]])c.Expr[F]" class="delimiter">[</span><a href="#spire.syntax;InnerProductSpaceOps;V" title="V">V</a>, <a href="../algebra/InnerProductSpace.scala.html#spire.algebra;InnerProductSpace" title="spire.algebra.InnerProductSpace[V,F]">InnerProductSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span>, <a href="#spire.syntax;InnerProductSpaceOps.;F" title="F">F</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class CoordinateSpaceOps[V] extends AnyRef" id="spire.syntax;CoordinateSpaceOps">CoordinateSpaceOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;CoordinateSpaceOps;V">V</a><span class="delimiter">]</span><a href="#spire.syntax;CoordinateSpaceOps" title="spire.syntax.CoordinateSpaceOps[V]" class="delimiter">(</a><a title="V" id="spire.syntax;CoordinateSpaceOps.v">v</a>: <a href="#spire.syntax;CoordinateSpaceOps;V" title="V">V</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[F](implicit ev: spire.algebra.CoordinateSpace[V,F])F" id="spire.syntax;CoordinateSpaceOps._x">_x</a><span class="delimiter">[</span><a title="" id="spire.syntax;CoordinateSpaceOps._x;F">F</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.CoordinateSpace[V,F]" id="spire.syntax;CoordinateSpaceOps._x.ev">ev</a>: <a href="../algebra/CoordinateSpace.scala.html#spire.algebra;CoordinateSpace" title="spire.algebra.CoordinateSpace[V,F]">CoordinateSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;CoordinateSpaceOps._x;F" title="F">F</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[Ev, R](c: reflect.macros.Context)(ev: c.Expr[Ev])c.Expr[R]">unopWithEv</span><span title="(c: reflect.macros.Context)(ev: c.Expr[spire.algebra.CoordinateSpace[V,F]])c.Expr[F]" class="delimiter">[</span><a href="../algebra/CoordinateSpace.scala.html#spire.algebra;CoordinateSpace" title="spire.algebra.CoordinateSpace[V,F]">CoordinateSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span>, <a href="#spire.syntax;CoordinateSpaceOps._x;F" title="F">F</a><span class="delimiter">]</span>

  def <a title="[F](implicit ev: spire.algebra.CoordinateSpace[V,F])F" id="spire.syntax;CoordinateSpaceOps._y">_y</a><span class="delimiter">[</span><a title="" id="spire.syntax;CoordinateSpaceOps._y;F">F</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.CoordinateSpace[V,F]" id="spire.syntax;CoordinateSpaceOps._y.ev">ev</a>: <a href="../algebra/CoordinateSpace.scala.html#spire.algebra;CoordinateSpace" title="spire.algebra.CoordinateSpace[V,F]">CoordinateSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;CoordinateSpaceOps._y;F" title="F">F</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[Ev, R](c: reflect.macros.Context)(ev: c.Expr[Ev])c.Expr[R]">unopWithEv</span><span title="(c: reflect.macros.Context)(ev: c.Expr[spire.algebra.CoordinateSpace[V,F]])c.Expr[F]" class="delimiter">[</span><a href="../algebra/CoordinateSpace.scala.html#spire.algebra;CoordinateSpace" title="spire.algebra.CoordinateSpace[V,F]">CoordinateSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span>, <a href="#spire.syntax;CoordinateSpaceOps._y;F" title="F">F</a><span class="delimiter">]</span>

  def <a title="[F](implicit ev: spire.algebra.CoordinateSpace[V,F])F" id="spire.syntax;CoordinateSpaceOps._z">_z</a><span class="delimiter">[</span><a title="" id="spire.syntax;CoordinateSpaceOps._z;F">F</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.CoordinateSpace[V,F]" id="spire.syntax;CoordinateSpaceOps._z.ev">ev</a>: <a href="../algebra/CoordinateSpace.scala.html#spire.algebra;CoordinateSpace" title="spire.algebra.CoordinateSpace[V,F]">CoordinateSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;CoordinateSpaceOps._z;F" title="F">F</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[Ev, R](c: reflect.macros.Context)(ev: c.Expr[Ev])c.Expr[R]">unopWithEv</span><span title="(c: reflect.macros.Context)(ev: c.Expr[spire.algebra.CoordinateSpace[V,F]])c.Expr[F]" class="delimiter">[</span><a href="../algebra/CoordinateSpace.scala.html#spire.algebra;CoordinateSpace" title="spire.algebra.CoordinateSpace[V,F]">CoordinateSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span>, <a href="#spire.syntax;CoordinateSpaceOps._z;F" title="F">F</a><span class="delimiter">]</span>

  def <a title="[F](rhs: Int)(implicit ev: spire.algebra.CoordinateSpace[V,F])F" id="spire.syntax;CoordinateSpaceOps.coord">coord</a><span class="delimiter">[</span><a title="" id="spire.syntax;CoordinateSpaceOps.coord;F">F</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="spire.syntax;CoordinateSpaceOps.coord.rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.CoordinateSpace[V,F]" id="spire.syntax;CoordinateSpaceOps.coord.ev">ev</a>: <a href="../algebra/CoordinateSpace.scala.html#spire.algebra;CoordinateSpace" title="spire.algebra.CoordinateSpace[V,F]">CoordinateSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;CoordinateSpaceOps.coord;F" title="F">F</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])(ev: c.Expr[spire.algebra.CoordinateSpace[V,F]])c.Expr[F]" class="delimiter">[</span><span title="Int">Int</span>, <a href="../algebra/CoordinateSpace.scala.html#spire.algebra;CoordinateSpace" title="spire.algebra.CoordinateSpace[V,F]">CoordinateSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span>, <a href="#spire.syntax;CoordinateSpaceOps.coord;F" title="F">F</a><span class="delimiter">]</span>

  def <a title="[F](implicit ev: spire.algebra.CoordinateSpace[V,F])Int" id="spire.syntax;CoordinateSpaceOps.dimensions">dimensions</a><span class="delimiter">[</span><a title="" id="spire.syntax;CoordinateSpaceOps.dimensions;F">F</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.CoordinateSpace[V,F]" id="spire.syntax;CoordinateSpaceOps.dimensions.ev">ev</a>: <a href="../algebra/CoordinateSpace.scala.html#spire.algebra;CoordinateSpace" title="spire.algebra.CoordinateSpace[V,F]">CoordinateSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[Ev, R](c: reflect.macros.Context)(ev: c.Expr[Ev])c.Expr[R]">unopWithEv</span><span title="(c: reflect.macros.Context)(ev: c.Expr[spire.algebra.CoordinateSpace[V,F]])c.Expr[Int]" class="delimiter">[</span><a href="../algebra/CoordinateSpace.scala.html#spire.algebra;CoordinateSpace" title="spire.algebra.CoordinateSpace[V,F]">CoordinateSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span>, <span title="Int">Int</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class MetricSpaceOps[V] extends AnyRef" id="spire.syntax;MetricSpaceOps">MetricSpaceOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;MetricSpaceOps;V">V</a><span class="delimiter">]</span><a href="#spire.syntax;MetricSpaceOps" title="spire.syntax.MetricSpaceOps[V]" class="delimiter">(</a><a title="V" id="spire.syntax;MetricSpaceOps.lhs">lhs</a>: <a href="#spire.syntax;MetricSpaceOps;V" title="V">V</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[F](rhs: V)(implicit ev: spire.algebra.MetricSpace[V,F])F" id="spire.syntax;MetricSpaceOps.distance">distance</a><span class="delimiter">[</span><a title="" id="spire.syntax;MetricSpaceOps.distance;F">F</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="V" id="spire.syntax;MetricSpaceOps.distance.rhs">rhs</a>: <a href="#spire.syntax;MetricSpaceOps;V" title="V">V</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.MetricSpace[V,F]" id="spire.syntax;MetricSpaceOps.distance.ev">ev</a>: <a href="../algebra/MetricSpace.scala.html#spire.algebra;MetricSpace" title="spire.algebra.MetricSpace[V,F]">MetricSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;MetricSpaceOps.distance;F" title="F">F</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[V])(ev: c.Expr[spire.algebra.MetricSpace[V,F]])c.Expr[F]" class="delimiter">[</span><a href="#spire.syntax;MetricSpaceOps;V" title="V">V</a>, <a href="../algebra/MetricSpace.scala.html#spire.algebra;MetricSpace" title="spire.algebra.MetricSpace[V,F]">MetricSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span>, <a href="#spire.syntax;MetricSpaceOps.distance;F" title="F">F</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class NormedVectorSpaceOps[V] extends AnyRef" id="spire.syntax;NormedVectorSpaceOps">NormedVectorSpaceOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;NormedVectorSpaceOps;V">V</a><span class="delimiter">]</span><a href="#spire.syntax;NormedVectorSpaceOps" title="spire.syntax.NormedVectorSpaceOps[V]" class="delimiter">(</a><a title="V" id="spire.syntax;NormedVectorSpaceOps.lhs">lhs</a>: <a href="#spire.syntax;NormedVectorSpaceOps;V" title="V">V</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[F](implicit ev: spire.algebra.NormedVectorSpace[V,F])F" id="spire.syntax;NormedVectorSpaceOps.norm">norm</a><span class="delimiter">[</span><a title="" id="spire.syntax;NormedVectorSpaceOps.norm;F">F</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.NormedVectorSpace[V,F]" id="spire.syntax;NormedVectorSpaceOps.norm.ev">ev</a>: <a href="../algebra/NormedVectorSpace.scala.html#spire.algebra;NormedVectorSpace" title="spire.algebra.NormedVectorSpace[V,F]">NormedVectorSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;NormedVectorSpaceOps.norm;F" title="F">F</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[Ev, R](c: reflect.macros.Context)(ev: c.Expr[Ev])c.Expr[R]">unopWithEv</span><span title="(c: reflect.macros.Context)(ev: c.Expr[spire.algebra.NormedVectorSpace[V,F]])c.Expr[F]" class="delimiter">[</span><a href="../algebra/NormedVectorSpace.scala.html#spire.algebra;NormedVectorSpace" title="spire.algebra.NormedVectorSpace[V,F]">NormedVectorSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span>, <a href="#spire.syntax;NormedVectorSpaceOps.norm;F" title="F">F</a><span class="delimiter">]</span>

  def <a title="[F](implicit ev: spire.algebra.NormedVectorSpace[V,F])V" id="spire.syntax;NormedVectorSpaceOps.normalize">normalize</a><span class="delimiter">[</span><a title="" id="spire.syntax;NormedVectorSpaceOps.normalize;F">F</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.NormedVectorSpace[V,F]" id="spire.syntax;NormedVectorSpaceOps.normalize.ev">ev</a>: <a href="../algebra/NormedVectorSpace.scala.html#spire.algebra;NormedVectorSpace" title="spire.algebra.NormedVectorSpace[V,F]">NormedVectorSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;NormedVectorSpaceOps;V" title="V">V</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[Ev, R](c: reflect.macros.Context)(ev: c.Expr[Ev])c.Expr[R]">unopWithEv</span><span title="(c: reflect.macros.Context)(ev: c.Expr[spire.algebra.NormedVectorSpace[V,F]])c.Expr[V]" class="delimiter">[</span><a href="../algebra/NormedVectorSpace.scala.html#spire.algebra;NormedVectorSpace" title="spire.algebra.NormedVectorSpace[V,F]">NormedVectorSpace</a><span class="delimiter">[</span>V, F<span class="delimiter">]</span>, <a href="#spire.syntax;NormedVectorSpaceOps;V" title="V">V</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class ConvertableFromOps[A] extends AnyRef" id="spire.syntax;ConvertableFromOps">ConvertableFromOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;ConvertableFromOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;ConvertableFromOps" title="spire.syntax.ConvertableFromOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;ConvertableFromOps.lhs">lhs</a>:<a href="#spire.syntax;ConvertableFromOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.ConvertableFrom[A]" id="spire.syntax;ConvertableFromOps.ev">ev</a>:<a href="../math/Convertable.scala.html#spire.math;ConvertableFrom" title="spire.math.ConvertableFrom[A]">ConvertableFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  override def <a title="()String" id="spire.syntax;ConvertableFromOps.toString">toString</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="String">String</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[String]" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span>
  def <a title="()Byte" id="spire.syntax;ConvertableFromOps.toByte">toByte</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Byte">Byte</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Byte]" class="delimiter">[</span><span title="Byte">Byte</span><span class="delimiter">]</span>
  def <a title="()Short" id="spire.syntax;ConvertableFromOps.toShort">toShort</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Short">Short</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Short]" class="delimiter">[</span><span title="Short">Short</span><span class="delimiter">]</span>
  def <a title="()Int" id="spire.syntax;ConvertableFromOps.toInt">toInt</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Int">Int</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Int]" class="delimiter">[</span><span title="Int">Int</span><span class="delimiter">]</span>
  def <a title="()Long" id="spire.syntax;ConvertableFromOps.toLong">toLong</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Long">Long</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Long]" class="delimiter">[</span><span title="Long">Long</span><span class="delimiter">]</span>
  def <a title="()Float" id="spire.syntax;ConvertableFromOps.toFloat">toFloat</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Float">Float</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Float]" class="delimiter">[</span><span title="Float">Float</span><span class="delimiter">]</span>
  def <a title="()Double" id="spire.syntax;ConvertableFromOps.toDouble">toDouble</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Double">Double</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Double]" class="delimiter">[</span><span title="Double">Double</span><span class="delimiter">]</span>
  def <a title="()BigInt" id="spire.syntax;ConvertableFromOps.toBigInt">toBigInt</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="BigInt">BigInt</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[BigInt]" class="delimiter">[</span><span title="BigInt">BigInt</span><span class="delimiter">]</span>
  def <a title="()BigDecimal" id="spire.syntax;ConvertableFromOps.toBigDecimal">toBigDecimal</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="BigDecimal">BigDecimal</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[BigDecimal]" class="delimiter">[</span><span title="BigDecimal">BigDecimal</span><span class="delimiter">]</span>
  def <a title="()spire.math.Rational" id="spire.syntax;ConvertableFromOps.toRational">toRational</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../math/Rational.scala.html#spire.math;Rational" title="spire.math.Rational">Rational</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[spire.math.Rational]" class="delimiter">[</span><a href="../math/Rational.scala.html#spire.math;Rational" title="spire.math.Rational">Rational</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class BitStringOps[A] extends AnyRef" id="spire.syntax;BitStringOps">BitStringOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;BitStringOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;BitStringOps" title="spire.syntax.BitStringOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;BitStringOps.lhs">lhs</a>: <a href="#spire.syntax;BitStringOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.math.BitString[A]" id="spire.syntax;BitStringOps.ev">ev</a>: <a href="../math/BitString.scala.html#spire.math;BitString" title="spire.math.BitString[A]">BitString</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: Int)A" id="spire.syntax;BitStringOps.<<">&lt;&lt;</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;BitStringOps.<<.rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.syntax;BitStringOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="#spire.syntax;BitStringOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)A" id="spire.syntax;BitStringOps.>>">&gt;&gt;</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;BitStringOps.>>.rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.syntax;BitStringOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="#spire.syntax;BitStringOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)A" id="spire.syntax;BitStringOps.>>>">&gt;&gt;&gt;</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;BitStringOps.>>>.rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.syntax;BitStringOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="#spire.syntax;BitStringOps;A" title="A">A</a><span class="delimiter">]</span>

  def <a title="()Int" id="spire.syntax;BitStringOps.bitCount">bitCount</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Int">Int</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Int]" class="delimiter">[</span><span title="Int">Int</span><span class="delimiter">]</span>
  def <a title="()A" id="spire.syntax;BitStringOps.highestOneBit">highestOneBit</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;BitStringOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;BitStringOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="()A" id="spire.syntax;BitStringOps.lowestOneBit">lowestOneBit</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;BitStringOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[A]" class="delimiter">[</span><a href="#spire.syntax;BitStringOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="()Int" id="spire.syntax;BitStringOps.numberOfLeadingZeros">numberOfLeadingZeros</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Int">Int</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Int]" class="delimiter">[</span><span title="Int">Int</span><span class="delimiter">]</span>
  def <a title="()Int" id="spire.syntax;BitStringOps.numberOfTrailingZeros">numberOfTrailingZeros</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Int">Int</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[Int]" class="delimiter">[</span><span title="Int">Int</span><span class="delimiter">]</span>

  def <a title="()String" id="spire.syntax;BitStringOps.toHexString">toHexString</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="String">String</span> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unop</span><span title="(c: reflect.macros.Context)()c.Expr[String]" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span>

  def <a title="(rhs: Int)A" id="spire.syntax;BitStringOps.rotateLeft">rotateLeft</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;BitStringOps.rotateLeft.rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.syntax;BitStringOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="#spire.syntax;BitStringOps;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="(rhs: Int)A" id="spire.syntax;BitStringOps.rotateRight">rotateRight</a><span class="delimiter">(</span><a title="Int" id="spire.syntax;BitStringOps.rotateRight.rhs">rhs</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.syntax;BitStringOps;A" title="A">A</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binop</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[Int])c.Expr[A]" class="delimiter">[</span><span title="Int">Int</span>, <a href="#spire.syntax;BitStringOps;A" title="A">A</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class LeftPartialActionOps[G] extends AnyRef" id="spire.syntax;LeftPartialActionOps">LeftPartialActionOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;LeftPartialActionOps;G">G</a><span class="delimiter">]</span><a href="#spire.syntax;LeftPartialActionOps" title="spire.syntax.LeftPartialActionOps[G]" class="delimiter">(</a><a title="G" id="spire.syntax;LeftPartialActionOps.lhs">lhs</a>: <a href="#spire.syntax;LeftPartialActionOps;G" title="G">G</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[P](rhs: P)(implicit ev: spire.algebra.partial.LeftPartialAction[P,G])spire.util.Opt[P]" id="spire.syntax;LeftPartialActionOps.?|+|>">?|+|&gt;</a> <span class="delimiter">[</span><a title="" id="spire.syntax;LeftPartialActionOps.?|+|>;P">P</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="P" id="spire.syntax;LeftPartialActionOps.?|+|>.rhs">rhs</a>: <a href="#spire.syntax;LeftPartialActionOps.?|+|>;P" title="P">P</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.partial.LeftPartialAction[P,G]" id="spire.syntax;LeftPartialActionOps.?|+|>.ev">ev</a>: <a href="../algebra/partial/PartialAction.scala.html#spire.algebra.partial;LeftPartialAction" title="spire.algebra.partial.LeftPartialAction[P,G]">LeftPartialAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../util/Opt.scala.html#spire.util;Opt" title="spire.util.Opt[P]">Opt</a><span class="delimiter">[</span>P<span class="delimiter">]</span> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[P])(ev: c.Expr[spire.algebra.partial.LeftPartialAction[P,G]])c.Expr[spire.util.Opt[P]]" class="delimiter">[</span><a href="#spire.syntax;LeftPartialActionOps.?|+|>;P" title="P">P</a>, <a href="../algebra/partial/PartialAction.scala.html#spire.algebra.partial;LeftPartialAction" title="spire.algebra.partial.LeftPartialAction[P,G]">LeftPartialAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span>, <a href="../util/Opt.scala.html#spire.util;Opt" title="spire.util.Opt[P]">Opt</a><span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span>
  def <a title="[P](rhs: P)(implicit ev: spire.algebra.partial.LeftPartialAction[P,G])Boolean" id="spire.syntax;LeftPartialActionOps.??|+|>">??|+|&gt;</a> <span class="delimiter">[</span><a title="" id="spire.syntax;LeftPartialActionOps.??|+|>;P">P</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="P" id="spire.syntax;LeftPartialActionOps.??|+|>.rhs">rhs</a>: <a href="#spire.syntax;LeftPartialActionOps.??|+|>;P" title="P">P</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.partial.LeftPartialAction[P,G]" id="spire.syntax;LeftPartialActionOps.??|+|>.ev">ev</a>: <a href="../algebra/partial/PartialAction.scala.html#spire.algebra.partial;LeftPartialAction" title="spire.algebra.partial.LeftPartialAction[P,G]">LeftPartialAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[P])(ev: c.Expr[spire.algebra.partial.LeftPartialAction[P,G]])c.Expr[Boolean]" class="delimiter">[</span><a href="#spire.syntax;LeftPartialActionOps.??|+|>;P" title="P">P</a>, <a href="../algebra/partial/PartialAction.scala.html#spire.algebra.partial;LeftPartialAction" title="spire.algebra.partial.LeftPartialAction[P,G]">LeftPartialAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span>, <span title="Boolean">Boolean</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class RightPartialActionOps[P] extends AnyRef" id="spire.syntax;RightPartialActionOps">RightPartialActionOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;RightPartialActionOps;P">P</a><span class="delimiter">]</span><a href="#spire.syntax;RightPartialActionOps" title="spire.syntax.RightPartialActionOps[P]" class="delimiter">(</a><a title="P" id="spire.syntax;RightPartialActionOps.lhs">lhs</a>: <a href="#spire.syntax;RightPartialActionOps;P" title="P">P</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[G](rhs: G)(implicit ev: spire.algebra.partial.RightPartialAction[P,G])spire.util.Opt[P]" id="spire.syntax;RightPartialActionOps.<|+|?">&lt;|+|?</a> <span class="delimiter">[</span><a title="" id="spire.syntax;RightPartialActionOps.<|+|?;G">G</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="G" id="spire.syntax;RightPartialActionOps.<|+|?.rhs">rhs</a>: <a href="#spire.syntax;RightPartialActionOps.<|+|?;G" title="G">G</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.partial.RightPartialAction[P,G]" id="spire.syntax;RightPartialActionOps.<|+|?.ev">ev</a>: <a href="../algebra/partial/PartialAction.scala.html#spire.algebra.partial;RightPartialAction" title="spire.algebra.partial.RightPartialAction[P,G]">RightPartialAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../util/Opt.scala.html#spire.util;Opt" title="spire.util.Opt[P]">Opt</a><span class="delimiter">[</span>P<span class="delimiter">]</span> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[G])(ev: c.Expr[spire.algebra.partial.RightPartialAction[P,G]])c.Expr[spire.util.Opt[P]]" class="delimiter">[</span><a href="#spire.syntax;RightPartialActionOps.<|+|?;G" title="G">G</a>, <a href="../algebra/partial/PartialAction.scala.html#spire.algebra.partial;RightPartialAction" title="spire.algebra.partial.RightPartialAction[P,G]">RightPartialAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span>, <a href="../util/Opt.scala.html#spire.util;Opt" title="spire.util.Opt[P]">Opt</a><span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span>
  def <a title="[G](rhs: G)(implicit ev: spire.algebra.partial.RightPartialAction[P,G])Boolean" id="spire.syntax;RightPartialActionOps.<|+|??">&lt;|+|??</a> <span class="delimiter">[</span><a title="" id="spire.syntax;RightPartialActionOps.<|+|??;G">G</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="G" id="spire.syntax;RightPartialActionOps.<|+|??.rhs">rhs</a>: <a href="#spire.syntax;RightPartialActionOps.<|+|??;G" title="G">G</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.partial.RightPartialAction[P,G]" id="spire.syntax;RightPartialActionOps.<|+|??.ev">ev</a>: <a href="../algebra/partial/PartialAction.scala.html#spire.algebra.partial;RightPartialAction" title="spire.algebra.partial.RightPartialAction[P,G]">RightPartialAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[G])(ev: c.Expr[spire.algebra.partial.RightPartialAction[P,G]])c.Expr[Boolean]" class="delimiter">[</span><a href="#spire.syntax;RightPartialActionOps.<|+|??;G" title="G">G</a>, <a href="../algebra/partial/PartialAction.scala.html#spire.algebra.partial;RightPartialAction" title="spire.algebra.partial.RightPartialAction[P,G]">RightPartialAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span>, <span title="Boolean">Boolean</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class LeftActionOps[G] extends AnyRef" id="spire.syntax;LeftActionOps">LeftActionOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;LeftActionOps;G">G</a><span class="delimiter">]</span><a href="#spire.syntax;LeftActionOps" title="spire.syntax.LeftActionOps[G]" class="delimiter">(</a><a title="G" id="spire.syntax;LeftActionOps.lhs">lhs</a>: <a href="#spire.syntax;LeftActionOps;G" title="G">G</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[P](rhs: P)(implicit ev: spire.algebra.LeftAction[P,G])P" id="spire.syntax;LeftActionOps.|+|>">|+|&gt;</a> <span class="delimiter">[</span><a title="" id="spire.syntax;LeftActionOps.|+|>;P">P</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="P" id="spire.syntax;LeftActionOps.|+|>.rhs">rhs</a>: <a href="#spire.syntax;LeftActionOps.|+|>;P" title="P">P</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.LeftAction[P,G]" id="spire.syntax;LeftActionOps.|+|>.ev">ev</a>: <a href="../algebra/Action.scala.html#spire.algebra;LeftAction" title="spire.algebra.LeftAction[P,G]">LeftAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LeftActionOps.|+|>;P" title="P">P</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[P])(ev: c.Expr[spire.algebra.Action[P,G]])c.Expr[P]" class="delimiter">[</span><a href="#spire.syntax;LeftActionOps.|+|>;P" title="P">P</a>, <a href="../algebra/Action.scala.html#spire.algebra;Action" title="spire.algebra.Action[P,G]">Action</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span>, <a href="#spire.syntax;LeftActionOps.|+|>;P" title="P">P</a><span class="delimiter">]</span>
  def <a title="[P](rhs: P)(implicit ev: spire.algebra.AdditiveAction[P,G])P" id="spire.syntax;LeftActionOps.+>">+&gt;</a> <span class="delimiter">[</span><a title="" id="spire.syntax;LeftActionOps.+>;P">P</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="P" id="spire.syntax;LeftActionOps.+>.rhs">rhs</a>: <a href="#spire.syntax;LeftActionOps.+>;P" title="P">P</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveAction[P,G]" id="spire.syntax;LeftActionOps.+>.ev">ev</a>: <a href="../algebra/Action.scala.html#spire.algebra;AdditiveAction" title="spire.algebra.AdditiveAction[P,G]">AdditiveAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LeftActionOps.+>;P" title="P">P</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[P])(ev: c.Expr[spire.algebra.AdditiveAction[P,G]])c.Expr[P]" class="delimiter">[</span><a href="#spire.syntax;LeftActionOps.+>;P" title="P">P</a>, <a href="../algebra/Action.scala.html#spire.algebra;AdditiveAction" title="spire.algebra.AdditiveAction[P,G]">AdditiveAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span>, <a href="#spire.syntax;LeftActionOps.+>;P" title="P">P</a><span class="delimiter">]</span>
  def <a title="[P](rhs: P)(implicit ev: spire.algebra.MultiplicativeAction[P,G])P" id="spire.syntax;LeftActionOps.*>">*&gt;</a> <span class="delimiter">[</span><a title="" id="spire.syntax;LeftActionOps.*>;P">P</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="P" id="spire.syntax;LeftActionOps.*>.rhs">rhs</a>: <a href="#spire.syntax;LeftActionOps.*>;P" title="P">P</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.MultiplicativeAction[P,G]" id="spire.syntax;LeftActionOps.*>.ev">ev</a>: <a href="../algebra/Action.scala.html#spire.algebra;MultiplicativeAction" title="spire.algebra.MultiplicativeAction[P,G]">MultiplicativeAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;LeftActionOps.*>;P" title="P">P</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[P])(ev: c.Expr[spire.algebra.MultiplicativeAction[P,G]])c.Expr[P]" class="delimiter">[</span><a href="#spire.syntax;LeftActionOps.*>;P" title="P">P</a>, <a href="../algebra/Action.scala.html#spire.algebra;MultiplicativeAction" title="spire.algebra.MultiplicativeAction[P,G]">MultiplicativeAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span>, <a href="#spire.syntax;LeftActionOps.*>;P" title="P">P</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class RightActionOps[P] extends AnyRef" id="spire.syntax;RightActionOps">RightActionOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;RightActionOps;P">P</a><span class="delimiter">]</span><a href="#spire.syntax;RightActionOps" title="spire.syntax.RightActionOps[P]" class="delimiter">(</a><a title="P" id="spire.syntax;RightActionOps.lhs">lhs</a>: <a href="#spire.syntax;RightActionOps;P" title="P">P</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[G](rhs: G)(implicit ev: spire.algebra.RightAction[P,G])P" id="spire.syntax;RightActionOps.<|+|">&lt;|+|</a> <span class="delimiter">[</span><a title="" id="spire.syntax;RightActionOps.<|+|;G">G</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="G" id="spire.syntax;RightActionOps.<|+|.rhs">rhs</a>: <a href="#spire.syntax;RightActionOps.<|+|;G" title="G">G</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.RightAction[P,G]" id="spire.syntax;RightActionOps.<|+|.ev">ev</a>: <a href="../algebra/Action.scala.html#spire.algebra;RightAction" title="spire.algebra.RightAction[P,G]">RightAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;RightActionOps;P" title="P">P</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[G])(ev: c.Expr[spire.algebra.Action[P,G]])c.Expr[P]" class="delimiter">[</span><a href="#spire.syntax;RightActionOps.<|+|;G" title="G">G</a>, <a href="../algebra/Action.scala.html#spire.algebra;Action" title="spire.algebra.Action[P,G]">Action</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span>, <a href="#spire.syntax;RightActionOps;P" title="P">P</a><span class="delimiter">]</span>
  def <a title="[G](rhs: G)(implicit ev: spire.algebra.AdditiveAction[P,G])P" id="spire.syntax;RightActionOps.<+">&lt;+</a> <span class="delimiter">[</span><a title="" id="spire.syntax;RightActionOps.<+;G">G</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="G" id="spire.syntax;RightActionOps.<+.rhs">rhs</a>: <a href="#spire.syntax;RightActionOps.<+;G" title="G">G</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveAction[P,G]" id="spire.syntax;RightActionOps.<+.ev">ev</a>: <a href="../algebra/Action.scala.html#spire.algebra;AdditiveAction" title="spire.algebra.AdditiveAction[P,G]">AdditiveAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;RightActionOps;P" title="P">P</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[G])(ev: c.Expr[spire.algebra.AdditiveAction[P,G]])c.Expr[P]" class="delimiter">[</span><a href="#spire.syntax;RightActionOps.<+;G" title="G">G</a>, <a href="../algebra/Action.scala.html#spire.algebra;AdditiveAction" title="spire.algebra.AdditiveAction[P,G]">AdditiveAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span>, <a href="#spire.syntax;RightActionOps;P" title="P">P</a><span class="delimiter">]</span>
  def <a title="[G](rhs: G)(implicit ev: spire.algebra.MultiplicativeAction[P,G])P" id="spire.syntax;RightActionOps.<*">&lt;*</a> <span class="delimiter">[</span><a title="" id="spire.syntax;RightActionOps.<*;G">G</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="G" id="spire.syntax;RightActionOps.<*.rhs">rhs</a>: <a href="#spire.syntax;RightActionOps.<*;G" title="G">G</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.MultiplicativeAction[P,G]" id="spire.syntax;RightActionOps.<*.ev">ev</a>: <a href="../algebra/Action.scala.html#spire.algebra;MultiplicativeAction" title="spire.algebra.MultiplicativeAction[P,G]">MultiplicativeAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;RightActionOps;P" title="P">P</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[G])(ev: c.Expr[spire.algebra.MultiplicativeAction[P,G]])c.Expr[P]" class="delimiter">[</span><a href="#spire.syntax;RightActionOps.<*;G" title="G">G</a>, <a href="../algebra/Action.scala.html#spire.algebra;MultiplicativeAction" title="spire.algebra.MultiplicativeAction[P,G]">MultiplicativeAction</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span>, <a href="#spire.syntax;RightActionOps;P" title="P">P</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class ActionUnboundOps[G] extends AnyRef" id="spire.syntax;ActionUnboundOps">ActionUnboundOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;ActionUnboundOps;G">G</a><span class="delimiter">]</span><a href="#spire.syntax;ActionUnboundOps" title="spire.syntax.ActionUnboundOps[G]" class="delimiter">(</a><a title="G" id="spire.syntax;ActionUnboundOps.lhs">lhs</a>: <a href="#spire.syntax;ActionUnboundOps;G" title="G">G</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Action[_, G]" id="spire.syntax;ActionUnboundOps.ev">ev</a>: <a href="../algebra/Action.scala.html#spire.algebra;Action" title="spire.algebra.Action[_, G]">Action</a><span class="delimiter">[</span>_, G<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: G)G" id="spire.syntax;ActionUnboundOps.|+|">|+|</a><span class="delimiter">(</span><a title="G" id="spire.syntax;ActionUnboundOps.|+|.rhs">rhs</a>: <a href="#spire.syntax;ActionUnboundOps;G" title="G">G</a><span class="delimiter">)</span>: <a href="#spire.syntax;ActionUnboundOps;G" title="G">G</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binopWithScalar</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[G])c.Expr[G]" class="delimiter">[</span><a href="#spire.syntax;ActionUnboundOps;G" title="G">G</a>, <a href="#spire.syntax;ActionUnboundOps;G" title="G">G</a><span class="delimiter">]</span>
  def <a title="(rhs: G)G" id="spire.syntax;ActionUnboundOps.|-|">|-|</a><span class="delimiter">(</span><a title="G" id="spire.syntax;ActionUnboundOps.|-|.rhs">rhs</a>: <a href="#spire.syntax;ActionUnboundOps;G" title="G">G</a><span class="delimiter">)</span>: <a href="#spire.syntax;ActionUnboundOps;G" title="G">G</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binopWithScalar</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[G])c.Expr[G]" class="delimiter">[</span><a href="#spire.syntax;ActionUnboundOps;G" title="G">G</a>, <a href="#spire.syntax;ActionUnboundOps;G" title="G">G</a><span class="delimiter">]</span>
  def <a title="()G" id="spire.syntax;ActionUnboundOps.inverse">inverse</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;ActionUnboundOps;G" title="G">G</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unopWithScalar</span><span title="(c: reflect.macros.Context)()c.Expr[G]" class="delimiter">[</span><a href="#spire.syntax;ActionUnboundOps;G" title="G">G</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class AdditiveActionUnboundOps[G] extends AnyRef" id="spire.syntax;AdditiveActionUnboundOps">AdditiveActionUnboundOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;AdditiveActionUnboundOps;G">G</a><span class="delimiter">]</span><a href="#spire.syntax;AdditiveActionUnboundOps" title="spire.syntax.AdditiveActionUnboundOps[G]" class="delimiter">(</a><a title="G" id="spire.syntax;AdditiveActionUnboundOps.lhs">lhs</a>: <a href="#spire.syntax;AdditiveActionUnboundOps;G" title="G">G</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveAction[_, G]" id="spire.syntax;AdditiveActionUnboundOps.ev">ev</a>: <a href="../algebra/Action.scala.html#spire.algebra;AdditiveAction" title="spire.algebra.AdditiveAction[_, G]">AdditiveAction</a><span class="delimiter">[</span>_, G<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: G)G" id="spire.syntax;AdditiveActionUnboundOps.+">+</a><span class="delimiter">(</span><a title="G" id="spire.syntax;AdditiveActionUnboundOps.+.rhs">rhs</a>: <a href="#spire.syntax;AdditiveActionUnboundOps;G" title="G">G</a><span class="delimiter">)</span>: <a href="#spire.syntax;AdditiveActionUnboundOps;G" title="G">G</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binopWithScalar</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[G])c.Expr[G]" class="delimiter">[</span><a href="#spire.syntax;AdditiveActionUnboundOps;G" title="G">G</a>, <a href="#spire.syntax;AdditiveActionUnboundOps;G" title="G">G</a><span class="delimiter">]</span>
  def <a title="(rhs: G)G" id="spire.syntax;AdditiveActionUnboundOps.-">-</a><span class="delimiter">(</span><a title="G" id="spire.syntax;AdditiveActionUnboundOps.-.rhs">rhs</a>: <a href="#spire.syntax;AdditiveActionUnboundOps;G" title="G">G</a><span class="delimiter">)</span>: <a href="#spire.syntax;AdditiveActionUnboundOps;G" title="G">G</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binopWithScalar</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[G])c.Expr[G]" class="delimiter">[</span><a href="#spire.syntax;AdditiveActionUnboundOps;G" title="G">G</a>, <a href="#spire.syntax;AdditiveActionUnboundOps;G" title="G">G</a><span class="delimiter">]</span>
  def <a title="()G" id="spire.syntax;AdditiveActionUnboundOps.unary_-">unary_-</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;AdditiveActionUnboundOps;G" title="G">G</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unopWithScalar</span><span title="(c: reflect.macros.Context)()c.Expr[G]" class="delimiter">[</span><a href="#spire.syntax;AdditiveActionUnboundOps;G" title="G">G</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class MultiplicativeActionUnboundOps[G] extends AnyRef" id="spire.syntax;MultiplicativeActionUnboundOps">MultiplicativeActionUnboundOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;MultiplicativeActionUnboundOps;G">G</a><span class="delimiter">]</span><a href="#spire.syntax;MultiplicativeActionUnboundOps" title="spire.syntax.MultiplicativeActionUnboundOps[G]" class="delimiter">(</a><a title="G" id="spire.syntax;MultiplicativeActionUnboundOps.lhs">lhs</a>: <a href="#spire.syntax;MultiplicativeActionUnboundOps;G" title="G">G</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.MultiplicativeAction[_, G]" id="spire.syntax;MultiplicativeActionUnboundOps.ev">ev</a>: <a href="../algebra/Action.scala.html#spire.algebra;MultiplicativeAction" title="spire.algebra.MultiplicativeAction[_, G]">MultiplicativeAction</a><span class="delimiter">[</span>_, G<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: G)G" id="spire.syntax;MultiplicativeActionUnboundOps.*">*</a><span class="delimiter">(</span><a title="G" id="spire.syntax;MultiplicativeActionUnboundOps.*.rhs">rhs</a>: <a href="#spire.syntax;MultiplicativeActionUnboundOps;G" title="G">G</a><span class="delimiter">)</span>: <a href="#spire.syntax;MultiplicativeActionUnboundOps;G" title="G">G</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binopWithScalar</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[G])c.Expr[G]" class="delimiter">[</span><a href="#spire.syntax;MultiplicativeActionUnboundOps;G" title="G">G</a>, <a href="#spire.syntax;MultiplicativeActionUnboundOps;G" title="G">G</a><span class="delimiter">]</span>
  def <a title="(rhs: G)G" id="spire.syntax;MultiplicativeActionUnboundOps./">/</a><span class="delimiter">(</span><a title="G" id="spire.syntax;MultiplicativeActionUnboundOps./.rhs">rhs</a>: <a href="#spire.syntax;MultiplicativeActionUnboundOps;G" title="G">G</a><span class="delimiter">)</span>: <a href="#spire.syntax;MultiplicativeActionUnboundOps;G" title="G">G</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, R](c: reflect.macros.Context)(rhs: c.Expr[A])c.Expr[R]">binopWithScalar</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[G])c.Expr[G]" class="delimiter">[</span><a href="#spire.syntax;MultiplicativeActionUnboundOps;G" title="G">G</a>, <a href="#spire.syntax;MultiplicativeActionUnboundOps;G" title="G">G</a><span class="delimiter">]</span>
  def <a title="()G" id="spire.syntax;MultiplicativeActionUnboundOps.reciprocal">reciprocal</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#spire.syntax;MultiplicativeActionUnboundOps;G" title="G">G</a> = macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[R](c: reflect.macros.Context)()c.Expr[R]">unopWithScalar</span><span title="(c: reflect.macros.Context)()c.Expr[G]" class="delimiter">[</span><a href="#spire.syntax;MultiplicativeActionUnboundOps;G" title="G">G</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class TorsorPointOps[P] extends AnyRef" id="spire.syntax;TorsorPointOps">TorsorPointOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;TorsorPointOps;P">P</a><span class="delimiter">]</span><a href="#spire.syntax;TorsorPointOps" title="spire.syntax.TorsorPointOps[P]" class="delimiter">(</a><a title="P" id="spire.syntax;TorsorPointOps.lhs">lhs</a>: <a href="#spire.syntax;TorsorPointOps;P" title="P">P</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[G](rhs: P)(implicit ev: spire.algebra.AdditiveTorsor[P,G])G" id="spire.syntax;TorsorPointOps.<->">&lt;-&gt;</a> <span class="delimiter">[</span><a title="" id="spire.syntax;TorsorPointOps.<->;G">G</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="P" id="spire.syntax;TorsorPointOps.<->.rhs">rhs</a>: <a href="#spire.syntax;TorsorPointOps;P" title="P">P</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveTorsor[P,G]" id="spire.syntax;TorsorPointOps.<->.ev">ev</a>: <a href="../algebra/Torsor.scala.html#spire.algebra;AdditiveTorsor" title="spire.algebra.AdditiveTorsor[P,G]">AdditiveTorsor</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;TorsorPointOps.<->;G" title="G">G</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[P])(ev: c.Expr[spire.algebra.AdditiveTorsor[P,G]])c.Expr[G]" class="delimiter">[</span><a href="#spire.syntax;TorsorPointOps;P" title="P">P</a>, <a href="../algebra/Torsor.scala.html#spire.algebra;AdditiveTorsor" title="spire.algebra.AdditiveTorsor[P,G]">AdditiveTorsor</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span>, <a href="#spire.syntax;TorsorPointOps.<->;G" title="G">G</a><span class="delimiter">]</span>
  def <a title="[G](rhs: P)(implicit ev: spire.algebra.MultiplicativeTorsor[P,G])G" id="spire.syntax;TorsorPointOps.</>">&lt;/&gt;</a> <span class="delimiter">[</span><a title="" id="spire.syntax;TorsorPointOps.</>;G">G</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="P" id="spire.syntax;TorsorPointOps.</>.rhs">rhs</a>: <a href="#spire.syntax;TorsorPointOps;P" title="P">P</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.MultiplicativeTorsor[P,G]" id="spire.syntax;TorsorPointOps.</>.ev">ev</a>: <a href="../algebra/Torsor.scala.html#spire.algebra;MultiplicativeTorsor" title="spire.algebra.MultiplicativeTorsor[P,G]">MultiplicativeTorsor</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.syntax;TorsorPointOps.</>;G" title="G">G</a> =
    macro <a href="../../../spire-macros/spire/macros/Syntax.scala.html#spire.macros.Ops" title="spire.macros.Ops.type">Ops</a>.<span title="[A, Ev, R](c: reflect.macros.Context)(rhs: c.Expr[A])(ev: c.Expr[Ev])c.Expr[R]">binopWithEv</span><span title="(c: reflect.macros.Context)(rhs: c.Expr[P])(ev: c.Expr[spire.algebra.MultiplicativeTorsor[P,G]])c.Expr[G]" class="delimiter">[</span><a href="#spire.syntax;TorsorPointOps;P" title="P">P</a>, <a href="../algebra/Torsor.scala.html#spire.algebra;MultiplicativeTorsor" title="spire.algebra.MultiplicativeTorsor[P,G]">MultiplicativeTorsor</a><span class="delimiter">[</span>P, G<span class="delimiter">]</span>, <a href="#spire.syntax;TorsorPointOps.</>;G" title="G">G</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

final class <a title="class IntervalPointOps[A] extends AnyRef" id="spire.syntax;IntervalPointOps">IntervalPointOps</a><span class="delimiter">[</span><a title="" id="spire.syntax;IntervalPointOps;A">A</a><span class="delimiter">]</span><a href="#spire.syntax;IntervalPointOps" title="spire.syntax.IntervalPointOps[A]" class="delimiter">(</a><a title="A" id="spire.syntax;IntervalPointOps.lhs">lhs</a>: <a href="#spire.syntax;IntervalPointOps;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.syntax;IntervalPointOps.o">o</a>: <a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.algebra.AdditiveGroup[A]" id="spire.syntax;IntervalPointOps.ev">ev</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup" title="spire.algebra.AdditiveGroup[A]">AdditiveGroup</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="(rhs: A)spire.math.Interval[A]" id="spire.syntax;IntervalPointOps."></a><span class="delimiter">(</span><a title="A" id="spire.syntax;IntervalPointOps..rhs">rhs</a>: <a href="#spire.syntax;IntervalPointOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="../math/Interval.scala.html#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="../math/Interval.scala.html#spire.math.Interval.apply(22f0cda0c5)" title="(lower: A, upper: A)(implicit evidence$11: spire.algebra.Order[A])spire.math.Interval[A]">Interval</a><a href="#spire.syntax;IntervalPointOps.o" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax;IntervalPointOps.ev" title="spire.algebra.AdditiveGroup[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: A, y: A)A">minus</a><span class="delimiter">(</span><a href="#spire.syntax;IntervalPointOps.lhs" title="A">lhs</a>, <a href="#spire.syntax;IntervalPointOps..rhs" title="A">rhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;IntervalPointOps.ev" title="spire.algebra.AdditiveGroup[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">plus</a><span class="delimiter">(</span><a href="#spire.syntax;IntervalPointOps.lhs" title="A">lhs</a>, <a href="#spire.syntax;IntervalPointOps..rhs" title="A">rhs</a><span class="delimiter">)</span><span class="delimiter">)</span>
  def <a title="(rhs: A)spire.math.Interval[A]" id="spire.syntax;IntervalPointOps.+/-">+/-</a><span class="delimiter">(</span><a title="A" id="spire.syntax;IntervalPointOps.+/-.rhs">rhs</a>: <a href="#spire.syntax;IntervalPointOps;A" title="A">A</a><span class="delimiter">)</span>: <a href="../math/Interval.scala.html#spire.math;Interval" title="spire.math.Interval[A]">Interval</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="../math/Interval.scala.html#spire.math.Interval.apply(22f0cda0c5)" title="(lower: A, upper: A)(implicit evidence$11: spire.algebra.Order[A])spire.math.Interval[A]">Interval</a><a href="#spire.syntax;IntervalPointOps.o" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.syntax;IntervalPointOps.ev" title="spire.algebra.AdditiveGroup[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: A, y: A)A">minus</a><span class="delimiter">(</span><a href="#spire.syntax;IntervalPointOps.lhs" title="A">lhs</a>, <a href="#spire.syntax;IntervalPointOps.+/-.rhs" title="A">rhs</a><span class="delimiter">)</span>, <a href="#spire.syntax;IntervalPointOps.ev" title="spire.algebra.AdditiveGroup[A]">ev</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">plus</a><span class="delimiter">(</span><a href="#spire.syntax;IntervalPointOps.lhs" title="A">lhs</a>, <a href="#spire.syntax;IntervalPointOps.+/-.rhs" title="A">rhs</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
