<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>spire/spire/std/map.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package spire.std

import spire.algebra._

import scala.<span class="delimiter">{</span> specialized =&gt; spec <span class="delimiter">}</span>
import scala.annotation.tailrec

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class MapMonoid[K, V] extends AnyRef with spire.algebra.Monoid[Map[K,V]] with Serializable" id="spire.std;MapMonoid">MapMonoid</a><span class="delimiter">[</span><a title="" id="spire.std;MapMonoid;K">K</a>, <a title="" id="spire.std;MapMonoid;V">V</a><span class="delimiter">]</span><a href="#spire.std;MapMonoid" title="spire.std.MapMonoid[K,V]" class="delimiter">(</a>implicit val <a title="spire.algebra.Semigroup[V]" id="spire.std;MapMonoid.scalar">scalar</a>: <a href="../algebra/Semigroup.scala.html#spire.algebra;Semigroup" title="spire.algebra.Semigroup[V]">Semigroup</a><span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="../algebra/Monoid.scala.html#spire.algebra;Monoid" title="spire.algebra.Monoid[Map[K,V]]">Monoid</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> 
with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="=&gt; Map[K,V]" id="spire.std;MapMonoid.id">id</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="scala.collection.immutable.Map[K,Nothing]">empty</span>

  def <a title="(x: Map[K,V], y: Map[K,V])Map[K,V]" id="spire.std;MapMonoid.op">op</a><span class="delimiter">(</span><a title="Map[K,V]" id="spire.std;MapMonoid.op.x">x</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="Map[K,V]" id="spire.std;MapMonoid.op.y">y</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span class="delimiter">{</span>
    var <a title="Map[K,V]" id="spire.std;MapMonoid.op.xx">xx</a> = <a href="#spire.std;MapMonoid.op.x" title="Map[K,V]">x</a>
    var <a title="Map[K,V]" id="spire.std;MapMonoid.op.yy">yy</a> = <a href="#spire.std;MapMonoid.op.y" title="Map[K,V]">y</a>
    var <a title="(V, V) =&gt; V" id="spire.std;MapMonoid.op.f">f</a> = <a href="#spire.std;MapMonoid.scalar" title="=&gt; spire.algebra.Semigroup[V]">scalar</a>.<a href="../algebra/Semigroup.scala.html#spire.algebra;Semigroup.op" title="(x: V, y: V)V">op</a> _
    if <span class="delimiter">(</span><a href="#spire.std;MapMonoid.op.x" title="Map[K,V]">x</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std;MapMonoid.op.y" title="Map[K,V]">y</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#spire.std;MapMonoid.op.xx" title="Map[K,V]">xx</a> = <a href="#spire.std;MapMonoid.op.y" title="Map[K,V]">y</a>; <a href="#spire.std;MapMonoid.op.yy" title="Map[K,V]">yy</a> = <a href="#spire.std;MapMonoid.op.x" title="Map[K,V]">x</a>; <a href="#spire.std;MapMonoid.op.f" title="(V, V) =&gt; V">f</a> = <span class="delimiter">(</span>x: <a href="#spire.std;MapMonoid;V" title="V">V</a>, y: <a href="#spire.std;MapMonoid;V" title="V">V</a><span class="delimiter">)</span> =&gt; <a href="#spire.std;MapMonoid.scalar" title="=&gt; spire.algebra.Semigroup[V]">scalar</a>.<a href="../algebra/Semigroup.scala.html#spire.algebra;Semigroup.op" title="(x: V, y: V)V">op</a><span class="delimiter">(</span><a href="#spire.std;MapMonoid.op.$anonfun.y" title="V">y</a>, <a href="#spire.std;MapMonoid.op.$anonfun.x" title="V">x</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#spire.std;MapMonoid.op.yy" title="Map[K,V]">yy</a>.<span title="(z: Map[K,V])(op: (Map[K,V], (K, V)) =&gt; Map[K,V])Map[K,V]">foldLeft</span><span class="delimiter">(</span><a href="#spire.std;MapMonoid.op.xx" title="Map[K,V]">xx</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Map[K,V]" id="spire.std;MapMonoid.op.$anonfun.z">z</a>, <a title="(K, V)" id="spire.std;MapMonoid.op.$anonfun.kv">kv</a><span class="delimiter">)</span> =&gt;
      <a href="#spire.std;MapMonoid.op.$anonfun.z" title="Map[K,V]">z</a>.<span title="(key: K, value: V)scala.collection.immutable.Map[K,V]">updated</span><span class="delimiter">(</span><a href="#spire.std;MapMonoid.op.$anonfun.kv" title="(K, V)">kv</a>.<span title="=&gt; K">_1</span>, <span class="delimiter">(</span><a href="#spire.std;MapMonoid.op.xx" title="Map[K,V]">xx</a> <span title="(key: K)Option[V]">get</span> <a href="#spire.std;MapMonoid.op.$anonfun.kv" title="(K, V)">kv</a>.<span title="=&gt; K">_1</span><span class="delimiter">)</span>.<span title="(f: V =&gt; V)Option[V]">map</span><span class="delimiter">(</span><a title="V" id="spire.std;MapMonoid.op.$anonfun.$anonfun.u">u</a> =&gt; <a href="#spire.std;MapMonoid.op.f" title="(v1: V, v2: V)V">f</a><span class="delimiter">(</span><a href="#spire.std;MapMonoid.op.$anonfun.$anonfun.u" title="V">u</a>, <a href="#spire.std;MapMonoid.op.$anonfun.kv" title="(K, V)">kv</a>.<span title="=&gt; V">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(default: =&gt; V)V">getOrElse</span><span class="delimiter">(</span><a href="#spire.std;MapMonoid.op.$anonfun.kv" title="(K, V)">kv</a>.<span title="=&gt; V">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class MapGroup[K, V] extends spire.std.MapMonoid[K,V] with spire.algebra.Group[Map[K,V]] with Serializable" id="spire.std;MapGroup">MapGroup</a><span class="delimiter">[</span><a title="" id="spire.std;MapGroup;K">K</a>, <a title="" id="spire.std;MapGroup;V">V</a><span class="delimiter">]</span><a href="#spire.std;MapGroup" title="spire.std.MapGroup[K,V]" class="delimiter">(</a>implicit override val <a title="spire.algebra.Group[V]" id="spire.std;MapGroup.scalar">scalar</a>: <a href="../algebra/Group.scala.html#spire.algebra;Group" title="spire.algebra.Group[V]">Group</a><span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#spire.std;MapMonoid" title="spire.std.MapMonoid[K,V]">MapMonoid</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span>
with <a href="../algebra/Group.scala.html#spire.algebra;Group" title="spire.algebra.Group[Map[K,V]]">Group</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="(x: Map[K,V])Map[K,V]" id="spire.std;MapGroup.inverse">inverse</a><span class="delimiter">(</span><a title="Map[K,V]" id="spire.std;MapGroup.inverse.x">x</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <a href="#spire.std;MapGroup.inverse.x" title="Map[K,V]">x</a>.<span title="(f: V =&gt; V)scala.collection.immutable.Map[K,V]">mapValues</span><span class="delimiter">(</span><a href="#spire.std;MapGroup.scalar" title="=&gt; spire.algebra.Group[V]">scalar</a>.<a href="../algebra/Group.scala.html#spire.algebra;Group.inverse" title="(a: V)V">inverse</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class MapSemiring[K, V] extends AnyRef with spire.algebra.Semiring[Map[K,V]] with Serializable" id="spire.std;MapSemiring">MapSemiring</a><span class="delimiter">[</span><a title="" id="spire.std;MapSemiring;K">K</a>, <a title="" id="spire.std;MapSemiring;V">V</a><span class="delimiter">]</span><a href="#spire.std;MapSemiring" title="spire.std.MapSemiring[K,V]" class="delimiter">(</a>implicit val <a title="spire.algebra.Semiring[V]" id="spire.std;MapSemiring.scalar">scalar</a>: <a href="../algebra/Semiring.scala.html#spire.algebra;Semiring" title="spire.algebra.Semiring[V]">Semiring</a><span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="../algebra/Semiring.scala.html#spire.algebra;Semiring" title="spire.algebra.Semiring[Map[K,V]]">Semiring</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>

  def <a title="=&gt; Map[K,V]" id="spire.std;MapSemiring.zero">zero</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="scala.collection.immutable.Map[K,Nothing]">empty</span>

  def <a title="(x: Map[K,V], y: Map[K,V])Map[K,V]" id="spire.std;MapSemiring.plus">plus</a><span class="delimiter">(</span><a title="Map[K,V]" id="spire.std;MapSemiring.plus.x">x</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="Map[K,V]" id="spire.std;MapSemiring.plus.y">y</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span class="delimiter">{</span>
    var <a title="Map[K,V]" id="spire.std;MapSemiring.plus.xx">xx</a> = <a href="#spire.std;MapSemiring.plus.x" title="Map[K,V]">x</a>
    var <a title="Map[K,V]" id="spire.std;MapSemiring.plus.yy">yy</a> = <a href="#spire.std;MapSemiring.plus.y" title="Map[K,V]">y</a>
    if <span class="delimiter">(</span><a href="#spire.std;MapSemiring.plus.x" title="Map[K,V]">x</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std;MapSemiring.plus.y" title="Map[K,V]">y</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#spire.std;MapSemiring.plus.xx" title="Map[K,V]">xx</a> = <a href="#spire.std;MapSemiring.plus.y" title="Map[K,V]">y</a>; <a href="#spire.std;MapSemiring.plus.yy" title="Map[K,V]">yy</a> = <a href="#spire.std;MapSemiring.plus.x" title="Map[K,V]">x</a> <span class="delimiter">}</span>
    <a href="#spire.std;MapSemiring.plus.yy" title="Map[K,V]">yy</a>.<span title="(z: Map[K,V])(op: (Map[K,V], (K, V)) =&gt; Map[K,V])Map[K,V]">foldLeft</span><span class="delimiter">(</span><a href="#spire.std;MapSemiring.plus.xx" title="Map[K,V]">xx</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Map[K,V]" id="spire.std;MapSemiring.plus.$anonfun.z">z</a>, <a title="(K, V)" id="spire.std;MapSemiring.plus.$anonfun.kv">kv</a><span class="delimiter">)</span> =&gt;
      <a href="#spire.std;MapSemiring.plus.$anonfun.z" title="Map[K,V]">z</a>.<span title="(key: K, value: V)scala.collection.immutable.Map[K,V]">updated</span><span class="delimiter">(</span><a href="#spire.std;MapSemiring.plus.$anonfun.kv" title="(K, V)">kv</a>.<span title="=&gt; K">_1</span>, <span class="delimiter">(</span><a href="#spire.std;MapSemiring.plus.xx" title="Map[K,V]">xx</a> <span title="(key: K)Option[V]">get</span> <a href="#spire.std;MapSemiring.plus.$anonfun.kv" title="(K, V)">kv</a>.<span title="=&gt; K">_1</span><span class="delimiter">)</span>.<span title="(f: V =&gt; V)Option[V]">map</span><span class="delimiter">(</span><a title="V" id="spire.std;MapSemiring.plus.$anonfun.$anonfun.u">u</a> =&gt; <a href="#spire.std;MapSemiring.scalar" title="=&gt; spire.algebra.Semiring[V]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: V, y: V)V">plus</a><span class="delimiter">(</span><a href="#spire.std;MapSemiring.plus.$anonfun.$anonfun.u" title="V">u</a>, <a href="#spire.std;MapSemiring.plus.$anonfun.kv" title="(K, V)">kv</a>.<span title="=&gt; V">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(default: =&gt; V)V">getOrElse</span><span class="delimiter">(</span><a href="#spire.std;MapSemiring.plus.$anonfun.kv" title="(K, V)">kv</a>.<span title="=&gt; V">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(x: Map[K,V], y: Map[K,V])Map[K,V]" id="spire.std;MapSemiring.times">times</a><span class="delimiter">(</span><a title="Map[K,V]" id="spire.std;MapSemiring.times.x">x</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="Map[K,V]" id="spire.std;MapSemiring.times.y">y</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span class="delimiter">{</span>
    var <a title="Map[K,V]" id="spire.std;MapSemiring.times.xx">xx</a> = <a href="#spire.std;MapSemiring.times.x" title="Map[K,V]">x</a>
    var <a title="Map[K,V]" id="spire.std;MapSemiring.times.yy">yy</a> = <a href="#spire.std;MapSemiring.times.y" title="Map[K,V]">y</a>
    var <a title="(V, V) =&gt; V" id="spire.std;MapSemiring.times.f">f</a> = <a href="#spire.std;MapSemiring.scalar" title="=&gt; spire.algebra.Semiring[V]">scalar</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: V, y: V)V">times</a> _
    if <span class="delimiter">(</span><a href="#spire.std;MapSemiring.times.x" title="Map[K,V]">x</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std;MapSemiring.times.y" title="Map[K,V]">y</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#spire.std;MapSemiring.times.xx" title="Map[K,V]">xx</a> = <a href="#spire.std;MapSemiring.times.y" title="Map[K,V]">y</a>; <a href="#spire.std;MapSemiring.times.yy" title="Map[K,V]">yy</a> = <a href="#spire.std;MapSemiring.times.x" title="Map[K,V]">x</a>; <a href="#spire.std;MapSemiring.times.f" title="(V, V) =&gt; V">f</a> = <span class="delimiter">(</span>x: <a href="#spire.std;MapSemiring;V" title="V">V</a>, y: <a href="#spire.std;MapSemiring;V" title="V">V</a><span class="delimiter">)</span> =&gt; <a href="#spire.std;MapSemiring.scalar" title="=&gt; spire.algebra.Semiring[V]">scalar</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: V, y: V)V">times</a><span class="delimiter">(</span><a href="#spire.std;MapSemiring.times.$anonfun.y" title="V">y</a>, <a href="#spire.std;MapSemiring.times.$anonfun.x" title="V">x</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#spire.std;MapSemiring.times.yy" title="Map[K,V]">yy</a>.<span title="(z: Map[K,V])(op: (Map[K,V], (K, V)) =&gt; Map[K,V])Map[K,V]">foldLeft</span><span class="delimiter">(</span><a href="#spire.std;MapSemiring.zero" title="=&gt; Map[K,V]">zero</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Map[K,V]" id="spire.std;MapSemiring.times.$anonfun.z">z</a>, <a title="(K, V)" id="spire.std;MapSemiring.times.$anonfun.kv">kv</a><span class="delimiter">)</span> =&gt;
      <span class="delimiter">(</span><a href="#spire.std;MapSemiring.times.xx" title="Map[K,V]">xx</a> <span title="(key: K)Option[V]">get</span> <a href="#spire.std;MapSemiring.times.$anonfun.kv" title="(K, V)">kv</a>.<span title="=&gt; K">_1</span><span class="delimiter">)</span>.<span title="(f: V =&gt; scala.collection.immutable.Map[K,V])Option[scala.collection.immutable.Map[K,V]]">map</span><span class="delimiter">(</span><a title="V" id="spire.std;MapSemiring.times.$anonfun.$anonfun.u">u</a> =&gt; <a href="#spire.std;MapSemiring.times.$anonfun.z" title="Map[K,V]">z</a>.<span title="(key: K, value: V)scala.collection.immutable.Map[K,V]">updated</span><span class="delimiter">(</span><a href="#spire.std;MapSemiring.times.$anonfun.kv" title="(K, V)">kv</a>.<span title="=&gt; K">_1</span>, <a href="#spire.std;MapSemiring.times.f" title="(v1: V, v2: V)V">f</a><span class="delimiter">(</span><a href="#spire.std;MapSemiring.times.$anonfun.$anonfun.u" title="V">u</a>, <a href="#spire.std;MapSemiring.times.$anonfun.kv" title="(K, V)">kv</a>.<span title="=&gt; V">_2</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(default: =&gt; scala.collection.immutable.Map[K,V])scala.collection.immutable.Map[K,V]">getOrElse</span><span class="delimiter">(</span><a href="#spire.std;MapSemiring.times.$anonfun.z" title="Map[K,V]">z</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class MapRng[K, V] extends spire.std.MapSemiring[K,V] with spire.algebra.RingAlgebra[Map[K,V],V] with Serializable" id="spire.std;MapRng">MapRng</a><span class="delimiter">[</span><a title="" id="spire.std;MapRng;K">K</a>, <a title="" id="spire.std;MapRng;V">V</a><span class="delimiter">]</span><a href="#spire.std;MapRng" title="spire.std.MapRng[K,V]" class="delimiter">(</a>override implicit val <a title="spire.algebra.Rng[V]" id="spire.std;MapRng.scalar">scalar</a>: <a href="../algebra/Rng.scala.html#spire.algebra;Rng" title="spire.algebra.Rng[V]">Rng</a><span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#spire.std;MapSemiring" title="spire.std.MapSemiring[K,V]">MapSemiring</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> with <a href="../algebra/RingAlgebra.scala.html#spire.algebra;RingAlgebra" title="spire.algebra.RingAlgebra[Map[K,V],V]">RingAlgebra</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, V<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span> self =&gt;
  def <a title="(x: Map[K,V])Map[K,V]" id="spire.std;MapRng.negate">negate</a><span class="delimiter">(</span><a title="Map[K,V]" id="spire.std;MapRng.negate.x">x</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <a href="#spire.std;MapRng.negate.x" title="Map[K,V]">x</a> <span title="(f: V =&gt; V)scala.collection.immutable.Map[K,V]">mapValues</span> <span class="delimiter">(</span><a href="#spire.std;MapRng.scalar" title="=&gt; spire.algebra.Rng[V]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: V)V">negate</a><span class="delimiter">(</span><a href="#spire.std;MapRng.negate.$anonfun.x$1" title="V">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="(r: V, v: Map[K,V])Map[K,V]" id="spire.std;MapRng.timesl">timesl</a><span class="delimiter">(</span><a title="V" id="spire.std;MapRng.timesl.r">r</a>: <a href="#spire.std;MapRng;V" title="V">V</a>, <a title="Map[K,V]" id="spire.std;MapRng.timesl.v">v</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <a href="#spire.std;MapRng.timesl.v" title="Map[K,V]">v</a> <span title="(f: V =&gt; V)scala.collection.immutable.Map[K,V]">mapValues</span> <span class="delimiter">(</span><a href="#spire.std;MapRng.scalar" title="=&gt; spire.algebra.Rng[V]">scalar</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: V, y: V)V">times</a><span class="delimiter">(</span><a href="#spire.std;MapRng.timesl.r" title="V">r</a>, <a href="#spire.std;MapRng.timesl.$anonfun.x$2" title="V">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class MapVectorSpace[K, V] extends spire.std.MapRng[K,V] with spire.algebra.VectorSpace[Map[K,V],V] with Serializable" id="spire.std;MapVectorSpace">MapVectorSpace</a><span class="delimiter">[</span><a title="" id="spire.std;MapVectorSpace;K">K</a>, <a title="" id="spire.std;MapVectorSpace;V">V</a><span class="delimiter">]</span><a href="#spire.std;MapVectorSpace" title="spire.std.MapVectorSpace[K,V]" class="delimiter">(</a>override implicit val <a title="spire.algebra.Field[V]" id="spire.std;MapVectorSpace.scalar">scalar</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[V]">Field</a><span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#spire.std;MapRng" title="spire.std.MapRng[K,V]">MapRng</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> with <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Map[K,V],V]">VectorSpace</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, V<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  override def <a title="(x: Map[K,V], y: Map[K,V])Map[K,V]" id="spire.std;MapVectorSpace.times">times</a><span class="delimiter">(</span><a title="Map[K,V]" id="spire.std;MapVectorSpace.times.x">x</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="Map[K,V]" id="spire.std;MapVectorSpace.times.y">y</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span class="delimiter">{</span>
    var <a title="Map[K,V]" id="spire.std;MapVectorSpace.times.xx">xx</a> = <a href="#spire.std;MapVectorSpace.times.x" title="Map[K,V]">x</a>
    var <a title="Map[K,V]" id="spire.std;MapVectorSpace.times.yy">yy</a> = <a href="#spire.std;MapVectorSpace.times.y" title="Map[K,V]">y</a>
    var <a title="(V, V) =&gt; V" id="spire.std;MapVectorSpace.times.f">f</a> = <a href="#spire.std;MapVectorSpace.scalar" title="=&gt; spire.algebra.Field[V]">scalar</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: V, y: V)V">times</a> _
    if <span class="delimiter">(</span><a href="#spire.std;MapVectorSpace.times.x" title="Map[K,V]">x</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std;MapVectorSpace.times.y" title="Map[K,V]">y</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#spire.std;MapVectorSpace.times.xx" title="Map[K,V]">xx</a> = <a href="#spire.std;MapVectorSpace.times.y" title="Map[K,V]">y</a>; <a href="#spire.std;MapVectorSpace.times.yy" title="Map[K,V]">yy</a> = <a href="#spire.std;MapVectorSpace.times.x" title="Map[K,V]">x</a> <span class="delimiter">}</span>
    <a href="#spire.std;MapVectorSpace.times.yy" title="Map[K,V]">yy</a>.<span title="(z: Map[K,V])(op: (Map[K,V], (K, V)) =&gt; Map[K,V])Map[K,V]">foldLeft</span><span class="delimiter">(</span><a href="#spire.std;MapSemiring.zero" title="=&gt; Map[K,V]">zero</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Map[K,V]" id="spire.std;MapVectorSpace.times.$anonfun.z">z</a>, <a title="(K, V)" id="spire.std;MapVectorSpace.times.$anonfun.kv">kv</a><span class="delimiter">)</span> =&gt;
      <span class="delimiter">(</span><a href="#spire.std;MapVectorSpace.times.xx" title="Map[K,V]">xx</a> <span title="(key: K)Option[V]">get</span> <a href="#spire.std;MapVectorSpace.times.$anonfun.kv" title="(K, V)">kv</a>.<span title="=&gt; K">_1</span><span class="delimiter">)</span>.<span title="(f: V =&gt; scala.collection.immutable.Map[K,V])Option[scala.collection.immutable.Map[K,V]]">map</span><span class="delimiter">(</span><a title="V" id="spire.std;MapVectorSpace.times.$anonfun.$anonfun.u">u</a> =&gt; <a href="#spire.std;MapVectorSpace.times.$anonfun.z" title="Map[K,V]">z</a>.<span title="(key: K, value: V)scala.collection.immutable.Map[K,V]">updated</span><span class="delimiter">(</span><a href="#spire.std;MapVectorSpace.times.$anonfun.kv" title="(K, V)">kv</a>.<span title="=&gt; K">_1</span>, <a href="#spire.std;MapVectorSpace.scalar" title="=&gt; spire.algebra.Field[V]">scalar</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: V, y: V)V">times</a><span class="delimiter">(</span><a href="#spire.std;MapVectorSpace.times.$anonfun.$anonfun.u" title="V">u</a>, <a href="#spire.std;MapVectorSpace.times.$anonfun.kv" title="(K, V)">kv</a>.<span title="=&gt; V">_2</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(default: =&gt; scala.collection.immutable.Map[K,V])scala.collection.immutable.Map[K,V]">getOrElse</span><span class="delimiter">(</span><a href="#spire.std;MapVectorSpace.times.$anonfun.z" title="Map[K,V]">z</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class MapInnerProductSpace[K, V] extends spire.std.MapVectorSpace[K,V] with spire.algebra.InnerProductSpace[Map[K,V],V] with Serializable" id="spire.std;MapInnerProductSpace">MapInnerProductSpace</a><span class="delimiter">[</span><a title="" id="spire.std;MapInnerProductSpace;K">K</a>, <a title="" id="spire.std;MapInnerProductSpace;V">V</a>: Field<span class="delimiter">]</span> extends <a href="#spire.std;MapVectorSpace" title="spire.std.MapVectorSpace[K,V]">MapVectorSpace</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> with <a href="../algebra/InnerProductSpace.scala.html#spire.algebra;InnerProductSpace" title="spire.algebra.InnerProductSpace[Map[K,V],V]">InnerProductSpace</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, V<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="(x: Map[K,V], y: Map[K,V])V" id="spire.std;MapInnerProductSpace.dot">dot</a><span class="delimiter">(</span><a title="Map[K,V]" id="spire.std;MapInnerProductSpace.dot.x">x</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="Map[K,V]" id="spire.std;MapInnerProductSpace.dot.y">y</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.std;MapInnerProductSpace;V" title="V">V</a> =
    <a href="#spire.std;MapVectorSpace.times" title="(x: Map[K,V], y: Map[K,V])Map[K,V]">times</a><span class="delimiter">(</span><a href="#spire.std;MapInnerProductSpace.dot.x" title="Map[K,V]">x</a>, <a href="#spire.std;MapInnerProductSpace.dot.y" title="Map[K,V]">y</a><span class="delimiter">)</span>.<span title="(z: V)(op: (V, (K, V)) =&gt; V)V">foldLeft</span><span class="delimiter">(</span><a href="#spire.std;MapVectorSpace.scalar" title="=&gt; spire.algebra.Field[V]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; V">zero</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="V" id="spire.std;MapInnerProductSpace.dot.$anonfun.a">a</a>, <a title="(K, V)" id="spire.std;MapInnerProductSpace.dot.$anonfun.b">b</a><span class="delimiter">)</span> =&gt; <a href="#spire.std;MapVectorSpace.scalar" title="=&gt; spire.algebra.Field[V]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: V, y: V)V">plus</a><span class="delimiter">(</span><a href="#spire.std;MapInnerProductSpace.dot.$anonfun.a" title="V">a</a>, <a href="#spire.std;MapInnerProductSpace.dot.$anonfun.b" title="(K, V)">b</a>.<span title="=&gt; V">_2</span><span class="delimiter">)</span> <span class="delimiter">}</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class MapEq[K, V] extends AnyRef with spire.algebra.Eq[Map[K,V]] with Serializable" id="spire.std;MapEq">MapEq</a><span class="delimiter">[</span><a title="" id="spire.std;MapEq;K">K</a>, <a title="" id="spire.std;MapEq;V">V</a><span class="delimiter">]</span><a href="#spire.std;MapEq" title="spire.std.MapEq[K,V]" class="delimiter">(</a>implicit <a title="spire.algebra.Eq[V]" id="spire.std;MapEq.V">V</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[V]">Eq</a><span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[Map[K,V]]">Eq</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="(x: Map[K,V], y: Map[K,V])Boolean" id="spire.std;MapEq.eqv">eqv</a><span class="delimiter">(</span><a title="Map[K,V]" id="spire.std;MapEq.eqv.x">x</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="Map[K,V]" id="spire.std;MapEq.eqv.y">y</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.std;MapEq.eqv.x" title="Map[K,V]">x</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">!=</span> <a href="#spire.std;MapEq.eqv.y" title="Map[K,V]">y</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> false else <span class="delimiter">{</span>
      <a href="#spire.std;MapEq.eqv.x" title="Map[K,V]">x</a> <span title="(p: ((K, V)) =&gt; Boolean)Boolean">forall</span> <a href="#spire.std;MapEq.eqv.$anonfun.x0$1" title="Boolean" class="delimiter">{</a> case <span class="delimiter">(</span><a title="K" id="spire.std;MapEq.eqv.$anonfun.k">k</a>, <a title="V" id="spire.std;MapEq.eqv.$anonfun.v">v</a><span class="delimiter">)</span> =&gt;
        <span class="delimiter">(</span><a href="#spire.std;MapEq.eqv.y" title="Map[K,V]">y</a> <span title="(key: K)Option[V]">get</span> <a href="#spire.std;MapEq.eqv.$anonfun.k" title="K">k</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><a title="V" id="spire.std;MapEq.eqv.$anonfun.e">e</a><span class="delimiter">)</span> if <a href="#spire.std;MapEq.V" title="spire.algebra.Eq[V]">V</a>.<a href="../algebra/Eq.scala.html#spire.algebra;Eq.eqv" title="(x: V, y: V)Boolean">eqv</a><span class="delimiter">(</span><a href="#spire.std;MapEq.eqv.$anonfun.e" title="V">e</a>, <a href="#spire.std;MapEq.eqv.$anonfun.v" title="V">v</a><span class="delimiter">)</span> =&gt; true
          case _ =&gt; false
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class MapVectorEq[K, V] extends AnyRef with spire.algebra.Eq[Map[K,V]] with Serializable" id="spire.std;MapVectorEq">MapVectorEq</a><span class="delimiter">[</span><a title="" id="spire.std;MapVectorEq;K">K</a>, <a title="" id="spire.std;MapVectorEq;V">V</a><span class="delimiter">]</span><a href="#spire.std;MapVectorEq" title="spire.std.MapVectorEq[K,V]" class="delimiter">(</a>implicit <a title="spire.algebra.Eq[V]" id="spire.std;MapVectorEq.V">V</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[V]">Eq</a><span class="delimiter">[</span>V<span class="delimiter">]</span>, <a title="spire.algebra.AdditiveMonoid[V]" id="spire.std;MapVectorEq.scalar">scalar</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[V]">AdditiveMonoid</a><span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[Map[K,V]]">Eq</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="(x: Map[K,V], y: Map[K,V])Boolean" id="spire.std;MapVectorEq.eqv">eqv</a><span class="delimiter">(</span><a title="Map[K,V]" id="spire.std;MapVectorEq.eqv.x">x</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="Map[K,V]" id="spire.std;MapVectorEq.eqv.y">y</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(acc: Map[K,V], it: Iterator[(K, V)])Boolean" id="spire.std;MapVectorEq.eqv.loop">loop</a><span class="delimiter">(</span><a title="Map[K,V]" id="spire.std;MapVectorEq.eqv.loop.acc">acc</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="Iterator[(K, V)]" id="spire.std;MapVectorEq.eqv.loop.it">it</a>: <span title="Iterator[(K, V)]">Iterator</span><span class="delimiter">[</span><span class="delimiter">(</span>K, V<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#spire.std;MapVectorEq.eqv.loop.it" title="Iterator[(K, V)]">it</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a href="#spire.std;MapVectorEq.eqv.loop.k" title="(K, V)" class="delimiter">(</a><a href="#spire.std;MapVectorEq.eqv.loop.x$3" title="K" id="spire.std;MapVectorEq.eqv.loop.k">k</a>, <a href="#spire.std;MapVectorEq.eqv.loop.x$3" title="V" id="spire.std;MapVectorEq.eqv.loop.v0">v0</a><span class="delimiter">)</span> = <a href="#spire.std;MapVectorEq.eqv.loop.it" title="Iterator[(K, V)]">it</a>.<span title="()(K, V)">next</span><span title="(K, V) @unchecked" class="delimiter">(</span><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#spire.std;MapVectorEq.eqv.loop.acc" title="Map[K,V]">acc</a> <span title="(key: K)Option[V]">get</span> <a href="#spire.std;MapVectorEq.eqv.loop.k" title="K">k</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><a title="V" id="spire.std;MapVectorEq.eqv.loop.v1">v1</a><span class="delimiter">)</span> if <a href="#spire.std;MapVectorEq.V" title="spire.algebra.Eq[V]">V</a>.<a href="../algebra/Eq.scala.html#spire.algebra;Eq.eqv" title="(x: V, y: V)Boolean">eqv</a><span class="delimiter">(</span><a href="#spire.std;MapVectorEq.eqv.loop.v0" title="V">v0</a>, <a href="#spire.std;MapVectorEq.eqv.loop.v1" title="V">v1</a><span class="delimiter">)</span> =&gt;
            <a href="#spire.std;MapVectorEq.eqv.loop" title="(acc: Map[K,V], it: Iterator[(K, V)])Boolean">loop</a><span class="delimiter">(</span><a href="#spire.std;MapVectorEq.eqv.loop.acc" title="Map[K,V]">acc</a> <span title="(key: K)scala.collection.immutable.Map[K,V]">-</span> <a href="#spire.std;MapVectorEq.eqv.loop.k" title="K">k</a>, <a href="#spire.std;MapVectorEq.eqv.loop.it" title="Iterator[(K, V)]">it</a><span class="delimiter">)</span>
          case <span title="None.type">None</span> if <a href="#spire.std;MapVectorEq.V" title="spire.algebra.Eq[V]">V</a>.<a href="../algebra/Eq.scala.html#spire.algebra;Eq.eqv" title="(x: V, y: V)Boolean">eqv</a><span class="delimiter">(</span><a href="#spire.std;MapVectorEq.eqv.loop.v0" title="V">v0</a>, <a href="#spire.std;MapVectorEq.scalar" title="spire.algebra.AdditiveMonoid[V]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; V">zero</a><span class="delimiter">)</span> =&gt;
            <a href="#spire.std;MapVectorEq.eqv.loop" title="(acc: Map[K,V], it: Iterator[(K, V)])Boolean">loop</a><span class="delimiter">(</span><a href="#spire.std;MapVectorEq.eqv.loop.acc" title="Map[K,V]">acc</a> <span title="(key: K)scala.collection.immutable.Map[K,V]">-</span> <a href="#spire.std;MapVectorEq.eqv.loop.k" title="K">k</a>, <a href="#spire.std;MapVectorEq.eqv.loop.it" title="Iterator[(K, V)]">it</a><span class="delimiter">)</span>
          case _ =&gt;
            false
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <a href="#spire.std;MapVectorEq.eqv.loop.acc" title="Map[K,V]">acc</a> <span title="(p: ((K, V)) =&gt; Boolean)Boolean">forall</span> <a href="#spire.std;MapVectorEq.eqv.loop.$anonfun.x0$2" title="Boolean" class="delimiter">{</a> case <span class="delimiter">(</span>_, <a title="V" id="spire.std;MapVectorEq.eqv.loop.$anonfun.v">v</a><span class="delimiter">)</span> =&gt; <a href="#spire.std;MapVectorEq.V" title="spire.algebra.Eq[V]">V</a>.<a href="../algebra/Eq.scala.html#spire.algebra;Eq.eqv" title="(x: V, y: V)Boolean">eqv</a><span class="delimiter">(</span><a href="#spire.std;MapVectorEq.eqv.loop.$anonfun.v" title="V">v</a>, <a href="#spire.std;MapVectorEq.scalar" title="spire.algebra.AdditiveMonoid[V]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; V">zero</a><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="#spire.std;MapVectorEq.eqv.loop" title="(acc: Map[K,V], it: Iterator[(K, V)])Boolean">loop</a><span class="delimiter">(</span><a href="#spire.std;MapVectorEq.eqv.x" title="Map[K,V]">x</a>, <a href="#spire.std;MapVectorEq.eqv.y" title="Map[K,V]">y</a>.<span title="=&gt; Iterator[(K, V)]">toIterator</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

trait <a title="trait MapInstances0 extends AnyRef" id="spire.std;MapInstances0">MapInstances0</a> <span title="Unit" class="delimiter">{</span>
  implicit def <a title="[K, V](implicit evidence$2: spire.algebra.Semigroup[V])spire.std.MapMonoid[K,V]" id="spire.std;MapInstances0.MapMonoid">MapMonoid</a><span class="delimiter">[</span><a title="" id="spire.std;MapInstances0.MapMonoid;K">K</a>, <a title="" id="spire.std;MapInstances0.MapMonoid;V">V</a>: Semigroup<span class="delimiter">]</span> = new <a href="#spire.std;MapMonoid" title="spire.std.MapMonoid[K,V]">MapMonoid</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span>

  implicit def <a title="[K, V](implicit evidence$3: spire.algebra.Semiring[V])spire.std.MapSemiring[K,V]" id="spire.std;MapInstances0.MapSemiring">MapSemiring</a><span class="delimiter">[</span><a title="" id="spire.std;MapInstances0.MapSemiring;K">K</a>, <a title="" id="spire.std;MapInstances0.MapSemiring;V">V</a>: Semiring<span class="delimiter">]</span> = new <a href="#spire.std;MapSemiring" title="spire.std.MapSemiring[K,V]">MapSemiring</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span>
<span class="delimiter">}</span>

trait <a title="trait MapInstances1 extends AnyRef with spire.std.MapInstances0" id="spire.std;MapInstances1">MapInstances1</a> extends <a href="#spire.std;MapInstances0" title="spire.std.MapInstances0">MapInstances0</a> <span class="delimiter">{</span>
  implicit def <a title="[K, V](implicit evidence$4: spire.algebra.Rng[V])spire.std.MapRng[K,V]" id="spire.std;MapInstances1.MapRng">MapRng</a><span class="delimiter">[</span><a title="" id="spire.std;MapInstances1.MapRng;K">K</a>, <a title="" id="spire.std;MapInstances1.MapRng;V">V</a>: Rng<span class="delimiter">]</span> = new <a href="#spire.std;MapRng" title="spire.std.MapRng[K,V]">MapRng</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span>
<span class="delimiter">}</span>

trait <a title="trait MapInstances2 extends AnyRef with spire.std.MapInstances1" id="spire.std;MapInstances2">MapInstances2</a> extends <a href="#spire.std;MapInstances1" title="spire.std.MapInstances1">MapInstances1</a> <span class="delimiter">{</span>
  implicit def <a title="[K, V](implicit evidence$5: spire.algebra.Group[V])spire.std.MapGroup[K,V]" id="spire.std;MapInstances2.MapGroup">MapGroup</a><span class="delimiter">[</span><a title="" id="spire.std;MapInstances2.MapGroup;K">K</a>, <a title="" id="spire.std;MapInstances2.MapGroup;V">V</a>: Group<span class="delimiter">]</span> = new <a href="#spire.std;MapGroup" title="spire.std.MapGroup[K,V]">MapGroup</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span>

  implicit def <a title="[K, V](implicit evidence$6: spire.algebra.Field[V])spire.std.MapVectorSpace[K,V]" id="spire.std;MapInstances2.MapVectorSpace">MapVectorSpace</a><span class="delimiter">[</span><a title="" id="spire.std;MapInstances2.MapVectorSpace;K">K</a>, <a title="" id="spire.std;MapInstances2.MapVectorSpace;V">V</a>: Field<span class="delimiter">]</span> = new <a href="#spire.std;MapVectorSpace" title="spire.std.MapVectorSpace[K,V]">MapVectorSpace</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span>
<span class="delimiter">}</span>

trait <a title="trait MapInstances3 extends AnyRef with spire.std.MapInstances2" id="spire.std;MapInstances3">MapInstances3</a> extends <a href="#spire.std;MapInstances2" title="spire.std.MapInstances2">MapInstances2</a> <span class="delimiter">{</span>
  implicit def <a title="[K, V](implicit evidence$7: spire.algebra.Field[V])spire.std.MapInnerProductSpace[K,V]" id="spire.std;MapInstances3.MapInnerProductSpace">MapInnerProductSpace</a><span class="delimiter">[</span><a title="" id="spire.std;MapInstances3.MapInnerProductSpace;K">K</a>, <a title="" id="spire.std;MapInstances3.MapInnerProductSpace;V">V</a>: Field<span class="delimiter">]</span> = new <a href="#spire.std;MapInnerProductSpace" title="spire.std.MapInnerProductSpace[K,V]">MapInnerProductSpace</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span>

  implicit def <a title="[K, V](implicit V0: spire.algebra.Eq[V])spire.std.MapEq[K,V]" id="spire.std;MapInstances3.MapEq">MapEq</a><span class="delimiter">[</span><a title="" id="spire.std;MapInstances3.MapEq;K">K</a>, <a title="" id="spire.std;MapInstances3.MapEq;V">V</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Eq[V]" id="spire.std;MapInstances3.MapEq.V0">V0</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[V]">Eq</a><span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span> = new <a href="#spire.std;MapEq" title="spire.std.MapEq[K,V]">MapEq</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span>
<span class="delimiter">}</span>

trait <a title="trait MapInstances extends AnyRef with spire.std.MapInstances3" id="spire.std;MapInstances">MapInstances</a> extends <a href="#spire.std;MapInstances3" title="spire.std.MapInstances3">MapInstances3</a>

        </pre>
    </body>
</html>
