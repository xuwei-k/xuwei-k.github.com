<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>spire/spire/std/array.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package spire.std

import scala.<span class="delimiter">{</span> specialized =&gt; spec <span class="delimiter">}</span>
import scala.reflect.ClassTag

import spire.algebra._
import spire.NoImplicit

object <a title="spire.std.ArraySupport.type" id="spire.std.ArraySupport">ArraySupport</a> <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type" class="delimiter">{</a>
  import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.order" title="spire.syntax.order.type">order</a>._
  import spire.syntax.<a href="../syntax/package.scala.html#spire.syntax.package.ring" title="spire.syntax.ring.type">ring</a>._

  def <a title="[A](x: Array[A], y: Array[A])(implicit evidence$1: spire.algebra.Eq[A])Boolean" id="spire.std.ArraySupport.eqv">eqv</a><span class="delimiter">[</span>@spec <a title="" id="spire.std.ArraySupport.eqv;A">A</a>: Eq<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.std.ArraySupport.eqv.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std.ArraySupport.eqv.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    var <a title="Int" id="spire.std.ArraySupport.eqv.i">i</a> = <span title="Int(0)" class="int">0</span>
    if <span class="delimiter">(</span><a href="#spire.std.ArraySupport.eqv.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">!=</span> <a href="#spire.std.ArraySupport.eqv.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> return false
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.eqv.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.eqv.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.ArraySupport.eqv.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.eqv.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.ArraySupport.eqv.x" title="(i: Int)A">x</a><a href="#spire.std.ArraySupport.eqv.evidence$1" title="spire.algebra.Eq[A]" class="delimiter">(</a><a href="#spire.std.ArraySupport.eqv.i" title="Int">i</a><span class="delimiter">)</span> <a href="../algebra/Eq.scala.html#spire.algebra;Eq.eqv" title="(x: A, y: A)Boolean">===</a> <a href="#spire.std.ArraySupport.eqv.y" title="(i: Int)A">y</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.eqv.i" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.eqv.i" title="Int">i</a> <a href="#spire.std.ArraySupport.eqv.while$1" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
    <a href="#spire.std.ArraySupport.eqv.i" title="Int">i</a> <span title="(x: Int)Boolean">==</span> <a href="#spire.std.ArraySupport.eqv.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span>
  <span class="delimiter">}</span>

  def <a title="[A](x: Array[A], y: Array[A])(implicit ev: spire.algebra.Eq[A], implicit sc: spire.algebra.AdditiveMonoid[A])Boolean" id="spire.std.ArraySupport.vectorEqv">vectorEqv</a><span class="delimiter">[</span>@spec <a title="" id="spire.std.ArraySupport.vectorEqv;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.std.ArraySupport.vectorEqv.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std.ArraySupport.vectorEqv.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Eq[A]" id="spire.std.ArraySupport.vectorEqv.ev">ev</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[A]">Eq</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.algebra.AdditiveMonoid[A]" id="spire.std.ArraySupport.vectorEqv.sc">sc</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    var <a title="Int" id="spire.std.ArraySupport.vectorEqv.i">i</a> = <span title="Int(0)" class="int">0</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.vectorEqv.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.vectorEqv.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.ArraySupport.vectorEqv.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.vectorEqv.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.ArraySupport.vectorEqv.x" title="(i: Int)A">x</a><a href="#spire.std.ArraySupport.vectorEqv.ev" title="spire.algebra.Eq[A]" class="delimiter">(</a><a href="#spire.std.ArraySupport.vectorEqv.i" title="Int">i</a><span class="delimiter">)</span> <a href="../algebra/Eq.scala.html#spire.algebra;Eq.eqv" title="(x: A, y: A)Boolean">===</a> <a href="#spire.std.ArraySupport.vectorEqv.y" title="(i: Int)A">y</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.vectorEqv.i" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.vectorEqv.i" title="Int">i</a> <a href="#spire.std.ArraySupport.vectorEqv.while$2" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.vectorEqv.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.vectorEqv.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.ArraySupport.vectorEqv.x" title="(i: Int)A">x</a><a href="#spire.std.ArraySupport.vectorEqv.ev" title="spire.algebra.Eq[A]" class="delimiter">(</a><a href="#spire.std.ArraySupport.vectorEqv.i" title="Int">i</a><span class="delimiter">)</span> <a href="../algebra/Eq.scala.html#spire.algebra;Eq.eqv" title="(x: A, y: A)Boolean">===</a> <a href="#spire.std.ArraySupport.vectorEqv.sc" title="spire.algebra.AdditiveMonoid[A]">sc</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.vectorEqv.i" title="Int">i</a> <a href="#spire.std.ArraySupport.vectorEqv.while$3" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.vectorEqv.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.vectorEqv.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.ArraySupport.vectorEqv.y" title="(i: Int)A">y</a><a href="#spire.std.ArraySupport.vectorEqv.ev" title="spire.algebra.Eq[A]" class="delimiter">(</a><a href="#spire.std.ArraySupport.vectorEqv.i" title="Int">i</a><span class="delimiter">)</span> <a href="../algebra/Eq.scala.html#spire.algebra;Eq.eqv" title="(x: A, y: A)Boolean">===</a> <a href="#spire.std.ArraySupport.vectorEqv.sc" title="spire.algebra.AdditiveMonoid[A]">sc</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.vectorEqv.i" title="Int">i</a> <a href="#spire.std.ArraySupport.vectorEqv.while$4" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
    <a href="#spire.std.ArraySupport.vectorEqv.i" title="Int">i</a> <span title="(x: Int)Boolean">&gt;=</span> <a href="#spire.std.ArraySupport.vectorEqv.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.ArraySupport.vectorEqv.i" title="Int">i</a> <span title="(x: Int)Boolean">&gt;=</span> <a href="#spire.std.ArraySupport.vectorEqv.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span>
  <span class="delimiter">}</span>

  def <a title="[A](x: Array[A], y: Array[A])(implicit evidence$2: spire.algebra.Order[A])Int" id="spire.std.ArraySupport.compare">compare</a><span class="delimiter">[</span>@spec <a title="" id="spire.std.ArraySupport.compare;A">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.std.ArraySupport.compare.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std.ArraySupport.compare.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
    var <a title="Int" id="spire.std.ArraySupport.compare.i">i</a> = <span title="Int(0)" class="int">0</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.compare.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.compare.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.ArraySupport.compare.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.compare.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.compare.while$5" title="()Unit" class="delimiter">{</a>
      val cmp = <a href="#spire.std.ArraySupport.compare.x" title="(i: Int)A">x</a><a href="#spire.std.ArraySupport.compare.evidence$2" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.std.ArraySupport.compare.i" title="Int">i</a><span class="delimiter">)</span> <a href="../algebra/Order.scala.html#spire.algebra;Order.compare" title="Int" id="spire.std.ArraySupport.compare.cmp">compare</a> <a href="#spire.std.ArraySupport.compare.y" title="(i: Int)A">y</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.compare.i" title="Int">i</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#spire.std.ArraySupport.compare.cmp" title="Int">cmp</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> return <a href="#spire.std.ArraySupport.compare.cmp" title="Int">cmp</a>
      <a href="#spire.std.ArraySupport.compare.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <span class="delimiter">}</span>
    <a href="#spire.std.ArraySupport.compare.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Int">-</span> <a href="#spire.std.ArraySupport.compare.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span>
  <span class="delimiter">}</span>

  def <a title="[A](x: Array[A], y: Array[A])(implicit ev: spire.algebra.Order[A], implicit sc: spire.algebra.AdditiveMonoid[A])Int" id="spire.std.ArraySupport.vectorCompare">vectorCompare</a><span class="delimiter">[</span>@spec <a title="" id="spire.std.ArraySupport.vectorCompare;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.std.ArraySupport.vectorCompare.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std.ArraySupport.vectorCompare.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.std.ArraySupport.vectorCompare.ev">ev</a>: <a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.algebra.AdditiveMonoid[A]" id="spire.std.ArraySupport.vectorCompare.sc">sc</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
    var <a title="Int" id="spire.std.ArraySupport.vectorCompare.i">i</a> = <span title="Int(0)" class="int">0</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.vectorCompare.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.vectorCompare.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.ArraySupport.vectorCompare.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.vectorCompare.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.vectorCompare.while$6" title="()Unit" class="delimiter">{</a>
      val cmp = <a href="#spire.std.ArraySupport.vectorCompare.x" title="(i: Int)A">x</a><a href="#spire.std.ArraySupport.vectorCompare.ev" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.std.ArraySupport.vectorCompare.i" title="Int">i</a><span class="delimiter">)</span> <a href="../algebra/Order.scala.html#spire.algebra;Order.compare" title="Int" id="spire.std.ArraySupport.vectorCompare.cmp">compare</a> <a href="#spire.std.ArraySupport.vectorCompare.y" title="(i: Int)A">y</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.vectorCompare.i" title="Int">i</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#spire.std.ArraySupport.vectorCompare.cmp" title="Int">cmp</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> return <a href="#spire.std.ArraySupport.vectorCompare.cmp" title="Int">cmp</a>
      <a href="#spire.std.ArraySupport.vectorCompare.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <span class="delimiter">}</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.vectorCompare.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.vectorCompare.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.vectorCompare.while$7" title="()Unit" class="delimiter">{</a>
      if <span class="delimiter">(</span><a href="#spire.std.ArraySupport.vectorCompare.x" title="(i: Int)A">x</a><a href="#spire.std.ArraySupport.vectorCompare.ev" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.std.ArraySupport.vectorCompare.i" title="Int">i</a><span class="delimiter">)</span> <a href="../algebra/Eq.scala.html#spire.algebra;Eq.neqv" title="(x: A, y: A)Boolean">=!=</a> <a href="#spire.std.ArraySupport.vectorCompare.sc" title="spire.algebra.AdditiveMonoid[A]">sc</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span> return <span title="Int(1)" class="int">1</span>
      <a href="#spire.std.ArraySupport.vectorCompare.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <span class="delimiter">}</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.vectorCompare.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.vectorCompare.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.vectorCompare.while$8" title="()Unit" class="delimiter">{</a>
      if <span class="delimiter">(</span><a href="#spire.std.ArraySupport.vectorCompare.y" title="(i: Int)A">y</a><a href="#spire.std.ArraySupport.vectorCompare.ev" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.std.ArraySupport.vectorCompare.i" title="Int">i</a><span class="delimiter">)</span> <a href="../algebra/Eq.scala.html#spire.algebra;Eq.neqv" title="(x: A, y: A)Boolean">=!=</a> <a href="#spire.std.ArraySupport.vectorCompare.sc" title="spire.algebra.AdditiveMonoid[A]">sc</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span> return -<span title="Int(-1)" class="int">1</span>
      <a href="#spire.std.ArraySupport.vectorCompare.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <span class="delimiter">}</span>
    <span title="Int(0)" class="int">0</span>
  <span class="delimiter">}</span>

  def <a title="[A](x: Array[A], y: Array[A])(implicit evidence$3: scala.reflect.ClassTag[A])Array[A]" id="spire.std.ArraySupport.concat">concat</a><span class="delimiter">[</span>@spec <a title="" id="spire.std.ArraySupport.concat;A">A</a>: ClassTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.std.ArraySupport.concat.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std.ArraySupport.concat.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[A]" id="spire.std.ArraySupport.concat.z">z</a> = new Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.std.ArraySupport.concat.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Int">+</span> <a href="#spire.std.ArraySupport.concat.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span>
    <span title="System.type">System</span>.<span title="(x$1: Any, x$2: Int, x$3: Any, x$4: Int, x$5: Int)Unit">arraycopy</span><span class="delimiter">(</span><a href="#spire.std.ArraySupport.concat.x" title="Array[A]">x</a>, <span title="Int(0)" class="int">0</span>, <a href="#spire.std.ArraySupport.concat.z" title="Array[A]">z</a>, <span title="Int(0)" class="int">0</span>, <a href="#spire.std.ArraySupport.concat.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span>
    <span title="System.type">System</span>.<span title="(x$1: Any, x$2: Int, x$3: Any, x$4: Int, x$5: Int)Unit">arraycopy</span><span class="delimiter">(</span><a href="#spire.std.ArraySupport.concat.y" title="Array[A]">y</a>, <span title="Int(0)" class="int">0</span>, <a href="#spire.std.ArraySupport.concat.z" title="Array[A]">z</a>, <a href="#spire.std.ArraySupport.concat.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span>, <a href="#spire.std.ArraySupport.concat.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span>
    <a href="#spire.std.ArraySupport.concat.z" title="Array[A]">z</a>
  <span class="delimiter">}</span>

  def <a title="[A](x: Array[A])(implicit evidence$4: scala.reflect.ClassTag[A], implicit evidence$5: spire.algebra.Ring[A])Array[A]" id="spire.std.ArraySupport.negate">negate</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int, Long, Float, Double<span class="delimiter">)</span> <a title="" id="spire.std.ArraySupport.negate;A">A</a>: ClassTag: Ring<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.std.ArraySupport.negate.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[A]" id="spire.std.ArraySupport.negate.y">y</a> = new Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.std.ArraySupport.negate.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span>
    var <a title="Int" id="spire.std.ArraySupport.negate.i">i</a> = <span title="Int(0)" class="int">0</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.negate.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.negate.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.negate.while$9" title="()Unit" class="delimiter">{</a>
      <a href="#spire.std.ArraySupport.negate.y" title="(i: Int, x: A)Unit">y</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.negate.i" title="Int">i</a><span class="delimiter">)</span> = <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: A)A">-</a><a href="#spire.std.ArraySupport.negate.x" title="(i: Int)A">x</a><a href="#spire.std.ArraySupport.negate.evidence$5" title="spire.algebra.Ring[A]" class="delimiter">(</a><a href="#spire.std.ArraySupport.negate.i" title="Int">i</a><span class="delimiter">)</span>
      <a href="#spire.std.ArraySupport.negate.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <span class="delimiter">}</span>
    <a href="#spire.std.ArraySupport.negate.y" title="Array[A]">y</a>
  <span class="delimiter">}</span>

  def <a title="[A](x: Array[A], y: Array[A])(implicit evidence$6: scala.reflect.ClassTag[A], implicit evidence$7: spire.algebra.AdditiveMonoid[A])Array[A]" id="spire.std.ArraySupport.plus">plus</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int, Long, Float, Double<span class="delimiter">)</span> <a title="" id="spire.std.ArraySupport.plus;A">A</a>: ClassTag: AdditiveMonoid<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.std.ArraySupport.plus.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std.ArraySupport.plus.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[A]" id="spire.std.ArraySupport.plus.z">z</a> = new Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span>spire.math.<a href="../math/package.scala.html#spire.math.package.max(8c1ad44065)" title="(x: Int, y: Int)Int">max</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.plus.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span>, <a href="#spire.std.ArraySupport.plus.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span><span class="delimiter">)</span>
    var <a title="Int" id="spire.std.ArraySupport.plus.i">i</a> = <span title="Int(0)" class="int">0</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.plus.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.plus.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.ArraySupport.plus.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.plus.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.plus.while$10" title="()Unit" class="delimiter">{</a> <a href="#spire.std.ArraySupport.plus.z" title="(i: Int, x: A)Unit">z</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.plus.i" title="Int">i</a><span class="delimiter">)</span> = <a href="#spire.std.ArraySupport.plus.x" title="(i: Int)A">x</a><a href="#spire.std.ArraySupport.plus.evidence$7" title="spire.algebra.AdditiveMonoid[A]" class="delimiter">(</a><a href="#spire.std.ArraySupport.plus.i" title="Int">i</a><span class="delimiter">)</span> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+</a> <a href="#spire.std.ArraySupport.plus.y" title="(i: Int)A">y</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.plus.i" title="Int">i</a><span class="delimiter">)</span>; <a href="#spire.std.ArraySupport.plus.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span> <span class="delimiter">}</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.plus.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.plus.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.plus.while$11" title="()Unit" class="delimiter">{</a> <a href="#spire.std.ArraySupport.plus.z" title="(i: Int, x: A)Unit">z</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.plus.i" title="Int">i</a><span class="delimiter">)</span> = <a href="#spire.std.ArraySupport.plus.x" title="(i: Int)A">x</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.plus.i" title="Int">i</a><span class="delimiter">)</span>; <a href="#spire.std.ArraySupport.plus.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span> <span class="delimiter">}</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.plus.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.plus.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.plus.while$12" title="()Unit" class="delimiter">{</a> <a href="#spire.std.ArraySupport.plus.z" title="(i: Int, x: A)Unit">z</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.plus.i" title="Int">i</a><span class="delimiter">)</span> = <a href="#spire.std.ArraySupport.plus.y" title="(i: Int)A">y</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.plus.i" title="Int">i</a><span class="delimiter">)</span>; <a href="#spire.std.ArraySupport.plus.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span> <span class="delimiter">}</span>
    <a href="#spire.std.ArraySupport.plus.z" title="Array[A]">z</a>
  <span class="delimiter">}</span>

  def <a title="[A](x: Array[A], y: Array[A])(implicit evidence$8: scala.reflect.ClassTag[A], implicit evidence$9: spire.algebra.AdditiveGroup[A])Array[A]" id="spire.std.ArraySupport.minus">minus</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int, Long, Float, Double<span class="delimiter">)</span> <a title="" id="spire.std.ArraySupport.minus;A">A</a>: ClassTag: AdditiveGroup<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.std.ArraySupport.minus.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std.ArraySupport.minus.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[A]" id="spire.std.ArraySupport.minus.z">z</a> = new Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span>spire.math.<a href="../math/package.scala.html#spire.math.package.max(8c1ad44065)" title="(x: Int, y: Int)Int">max</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.minus.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span>, <a href="#spire.std.ArraySupport.minus.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span><span class="delimiter">)</span>
    var <a title="Int" id="spire.std.ArraySupport.minus.i">i</a> = <span title="Int(0)" class="int">0</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.minus.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.minus.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.ArraySupport.minus.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.minus.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.minus.while$13" title="()Unit" class="delimiter">{</a> <a href="#spire.std.ArraySupport.minus.z" title="(i: Int, x: A)Unit">z</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.minus.i" title="Int">i</a><span class="delimiter">)</span> = <a href="#spire.std.ArraySupport.minus.x" title="(i: Int)A">x</a><a href="#spire.std.ArraySupport.minus.evidence$9" title="spire.algebra.AdditiveGroup[A]" class="delimiter">(</a><a href="#spire.std.ArraySupport.minus.i" title="Int">i</a><span class="delimiter">)</span> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: A, y: A)A">-</a> <a href="#spire.std.ArraySupport.minus.y" title="(i: Int)A">y</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.minus.i" title="Int">i</a><span class="delimiter">)</span>; <a href="#spire.std.ArraySupport.minus.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span> <span class="delimiter">}</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.minus.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.minus.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.minus.while$14" title="()Unit" class="delimiter">{</a> <a href="#spire.std.ArraySupport.minus.z" title="(i: Int, x: A)Unit">z</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.minus.i" title="Int">i</a><span class="delimiter">)</span> = <a href="#spire.std.ArraySupport.minus.x" title="(i: Int)A">x</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.minus.i" title="Int">i</a><span class="delimiter">)</span>; <a href="#spire.std.ArraySupport.minus.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span> <span class="delimiter">}</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.minus.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.minus.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.minus.while$15" title="()Unit" class="delimiter">{</a> <a href="#spire.std.ArraySupport.minus.z" title="(i: Int, x: A)Unit">z</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.minus.i" title="Int">i</a><span class="delimiter">)</span> = <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: A)A">-</a><a href="#spire.std.ArraySupport.minus.y" title="(i: Int)A">y</a><a href="#spire.std.ArraySupport.minus.evidence$9" title="spire.algebra.AdditiveGroup[A]" class="delimiter">(</a><a href="#spire.std.ArraySupport.minus.i" title="Int">i</a><span class="delimiter">)</span>; <a href="#spire.std.ArraySupport.minus.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span> <span class="delimiter">}</span>
    <a href="#spire.std.ArraySupport.minus.z" title="Array[A]">z</a>
  <span class="delimiter">}</span>

  def <a title="[A](r: A, x: Array[A])(implicit evidence$10: scala.reflect.ClassTag[A], implicit evidence$11: spire.algebra.MultiplicativeSemigroup[A])Array[A]" id="spire.std.ArraySupport.timesl">timesl</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int, Long, Float, Double<span class="delimiter">)</span> <a title="" id="spire.std.ArraySupport.timesl;A">A</a>: ClassTag: MultiplicativeSemigroup<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="spire.std.ArraySupport.timesl.r">r</a>: <a href="#spire.std.ArraySupport.timesl;A" title="A">A</a>, <a title="Array[A]" id="spire.std.ArraySupport.timesl.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[A]" id="spire.std.ArraySupport.timesl.y">y</a> = new Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.std.ArraySupport.timesl.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span>
    var <a title="Int" id="spire.std.ArraySupport.timesl.i">i</a> = <span title="Int(0)" class="int">0</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.timesl.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.timesl.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.timesl.while$16" title="()Unit" class="delimiter">{</a> <a href="#spire.std.ArraySupport.timesl.y" title="(i: Int, x: A)Unit">y</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.timesl.i" title="Int">i</a><span class="delimiter">)</span> = <a href="#spire.std.ArraySupport.timesl.evidence$11" title="spire.algebra.MultiplicativeSemigroup[A]">r</a> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.std.ArraySupport.timesl.x" title="(i: Int)A">x</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.timesl.i" title="Int">i</a><span class="delimiter">)</span>; <a href="#spire.std.ArraySupport.timesl.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span> <span class="delimiter">}</span>
    <a href="#spire.std.ArraySupport.timesl.y" title="Array[A]">y</a>
  <span class="delimiter">}</span>

  def <a title="[A](x: Array[A], y: Array[A])(implicit sc: spire.algebra.Rig[A])A" id="spire.std.ArraySupport.dot">dot</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int, Long, Float, Double<span class="delimiter">)</span> <a title="" id="spire.std.ArraySupport.dot;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[A]" id="spire.std.ArraySupport.dot.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std.ArraySupport.dot.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Rig[A]" id="spire.std.ArraySupport.dot.sc">sc</a>: <a href="../algebra/Rig.scala.html#spire.algebra;Rig" title="spire.algebra.Rig[A]">Rig</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.std.ArraySupport.dot;A" title="A">A</a> = <span class="delimiter">{</span>
    var <a title="A" id="spire.std.ArraySupport.dot.z">z</a> = <a href="#spire.std.ArraySupport.dot.sc" title="spire.algebra.Rig[A]">sc</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a>
    var <a title="Int" id="spire.std.ArraySupport.dot.i">i</a> = <span title="Int(0)" class="int">0</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.dot.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.dot.x" title="Array[A]">x</a>.<span title="=&gt; Int">length</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.ArraySupport.dot.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.dot.y" title="Array[A]">y</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.dot.while$17" title="()Unit" class="delimiter">{</a> <a href="#spire.std.ArraySupport.dot.z" title="A">z</a> <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">+=</a> <a href="#spire.std.ArraySupport.dot.x" title="(i: Int)A">x</a><a href="#spire.std.ArraySupport.dot.sc" title="spire.algebra.Rig[A]" class="delimiter">(</a><a href="#spire.std.ArraySupport.dot.i" title="Int">i</a><span class="delimiter">)</span> <a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">*</a> <a href="#spire.std.ArraySupport.dot.y" title="(i: Int)A">y</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.dot.i" title="Int">i</a><span class="delimiter">)</span>; <a href="#spire.std.ArraySupport.dot.i" title="Int">i</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span> <span class="delimiter">}</span>
    <a href="#spire.std.ArraySupport.dot.z" title="A">z</a>
  <span class="delimiter">}</span>

  def <a title="[A](dimensions: Int, i: Int)(implicit ct: scala.reflect.ClassTag[A], implicit sc: spire.algebra.Rig[A])Array[A]" id="spire.std.ArraySupport.axis">axis</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.std.ArraySupport.axis;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="spire.std.ArraySupport.axis.dimensions">dimensions</a>: <span title="Int">Int</span>, <a title="Int" id="spire.std.ArraySupport.axis.i">i</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[A]" id="spire.std.ArraySupport.axis.ct">ct</a>: <span title="scala.reflect.ClassTag[A]">ClassTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="spire.algebra.Rig[A]" id="spire.std.ArraySupport.axis.sc">sc</a>: <a href="../algebra/Rig.scala.html#spire.algebra;Rig" title="spire.algebra.Rig[A]">Rig</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[A]" id="spire.std.ArraySupport.axis.v">v</a> = new Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.std.ArraySupport.axis.dimensions" title="Int">dimensions</a><span class="delimiter">)</span>
    var <a title="Int" id="spire.std.ArraySupport.axis.j">j</a> = <span title="Int(0)" class="int">0</span>
    while <span class="delimiter">(</span><a href="#spire.std.ArraySupport.axis.j" title="Int">j</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.axis.v" title="Array[A]">v</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.axis.while$18" title="()Unit" class="delimiter">{</a> <a href="#spire.std.ArraySupport.axis.v" title="(i: Int, x: A)Unit">v</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.axis.j" title="Int">j</a><span class="delimiter">)</span> = <a href="#spire.std.ArraySupport.axis.sc" title="spire.algebra.Rig[A]">sc</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a>; <a href="#spire.std.ArraySupport.axis.j" title="Int">j</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span> <span class="delimiter">}</span>
    if <span class="delimiter">(</span><a href="#spire.std.ArraySupport.axis.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std.ArraySupport.axis.dimensions" title="Int">dimensions</a><span class="delimiter">)</span> <a href="#spire.std.ArraySupport.axis.v" title="(i: Int, x: A)Unit">v</a><span class="delimiter">(</span><a href="#spire.std.ArraySupport.axis.i" title="Int">i</a><span class="delimiter">)</span> = <a href="#spire.std.ArraySupport.axis.sc" title="spire.algebra.Rig[A]">sc</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; A">one</a>
    <a href="#spire.std.ArraySupport.axis.v" title="Array[A]">v</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

trait <a title="trait ArrayInstances0 extends AnyRef" id="spire.std;ArrayInstances0">ArrayInstances0</a> <span title="Unit" class="delimiter">{</span>
  type <a title="[A]spire.NoImplicit[spire.algebra.VectorSpace[Array[A],A]]" id="spire.std;ArrayInstances0;NI0">NI0</a><span class="delimiter">[</span><a title="" id="spire.std;ArrayInstances0;NI0;A">A</a><span class="delimiter">]</span> = <a href="../NoImplicit.scala.html#spire;NoImplicit" title="spire.NoImplicit[spire.algebra.VectorSpace[Array[A],A]]">NoImplicit</a><span class="delimiter">[</span>VectorSpace<span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span><span class="delimiter">]</span>

  implicit def <a title="[A](implicit evidence$12: ArrayInstances0.this.NI0[A], implicit evidence$13: scala.reflect.ClassTag[A], implicit evidence$14: spire.algebra.Ring[A])spire.algebra.Module[Array[A],A]" id="spire.std;ArrayInstances0.ArrayModule">ArrayModule</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int,Long,Float,Double<span class="delimiter">)</span> <a title="" id="spire.std;ArrayInstances0.ArrayModule;A">A</a>: NI0: ClassTag: Ring<span class="delimiter">]</span>: <a href="../algebra/Module.scala.html#spire.algebra;Module" title="spire.algebra.Module[Array[A],A]">Module</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> =
    new <a href="#spire.std;ArrayModule" title="spire.std.ArrayModule[A]">ArrayModule</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
<span class="delimiter">}</span>

trait <a title="trait ArrayInstances1 extends AnyRef with spire.std.ArrayInstances0" id="spire.std;ArrayInstances1">ArrayInstances1</a> extends <a href="#spire.std;ArrayInstances0" title="spire.std.ArrayInstances0">ArrayInstances0</a> <span class="delimiter">{</span>
  type <a title="[A]spire.NoImplicit[spire.algebra.NormedVectorSpace[Array[A],A]]" id="spire.std;ArrayInstances1;NI1">NI1</a><span class="delimiter">[</span><a title="" id="spire.std;ArrayInstances1;NI1;A">A</a><span class="delimiter">]</span> = <a href="../NoImplicit.scala.html#spire;NoImplicit" title="spire.NoImplicit[spire.algebra.NormedVectorSpace[Array[A],A]]">NoImplicit</a><span class="delimiter">[</span>NormedVectorSpace<span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span><span class="delimiter">]</span>

  implicit def <a title="[A](implicit evidence$15: ArrayInstances1.this.NI1[A], implicit evidence$16: scala.reflect.ClassTag[A], implicit evidence$17: spire.algebra.Field[A])spire.algebra.VectorSpace[Array[A],A]" id="spire.std;ArrayInstances1.ArrayVectorSpace">ArrayVectorSpace</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int,Long,Float,Double<span class="delimiter">)</span> <a title="" id="spire.std;ArrayInstances1.ArrayVectorSpace;A">A</a>: NI1: ClassTag: Field<span class="delimiter">]</span>: <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[A],A]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> =
    new <a href="#spire.std;ArrayVectorSpace" title="spire.std.ArrayVectorSpace[A]">ArrayVectorSpace</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  implicit def <a title="[A](implicit evidence$18: spire.algebra.Eq[A])spire.algebra.Eq[Array[A]]" id="spire.std;ArrayInstances1.ArrayEq">ArrayEq</a><span class="delimiter">[</span>@spec <a title="" id="spire.std;ArrayInstances1.ArrayEq;A">A</a>: Eq<span class="delimiter">]</span>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[Array[A]]">Eq</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    new <a href="#spire.std;ArrayEq" title="spire.std.ArrayEq[A]">ArrayEq</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
<span class="delimiter">}</span>

trait <a title="trait ArrayInstances2 extends AnyRef with spire.std.ArrayInstances1" id="spire.std;ArrayInstances2">ArrayInstances2</a> extends <a href="#spire.std;ArrayInstances1" title="spire.std.ArrayInstances1">ArrayInstances1</a> <span class="delimiter">{</span>
  implicit def <a title="[A](implicit evidence$19: spire.algebra.Field[A], implicit evidence$20: scala.reflect.ClassTag[A])spire.algebra.InnerProductSpace[Array[A],A]" id="spire.std;ArrayInstances2.ArrayInnerProductSpace">ArrayInnerProductSpace</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.std;ArrayInstances2.ArrayInnerProductSpace;A">A</a>: Field: ClassTag<span class="delimiter">]</span>: <a href="../algebra/InnerProductSpace.scala.html#spire.algebra;InnerProductSpace" title="spire.algebra.InnerProductSpace[Array[A],A]">InnerProductSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> =
    new <a href="#spire.std;ArrayInnerProductSpace" title="spire.std.ArrayInnerProductSpace[A]">ArrayInnerProductSpace</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  implicit def <a title="[A](implicit evidence$21: spire.algebra.Order[A])spire.algebra.Order[Array[A]]" id="spire.std;ArrayInstances2.ArrayOrder">ArrayOrder</a><span class="delimiter">[</span>@spec <a title="" id="spire.std;ArrayInstances2.ArrayOrder;A">A</a>: Order<span class="delimiter">]</span>: <a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[Array[A]]">Order</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    new <a href="#spire.std;ArrayOrder" title="spire.std.ArrayOrder[A]">ArrayOrder</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
<span class="delimiter">}</span>

trait <a title="trait ArrayInstances3 extends AnyRef with spire.std.ArrayInstances2" id="spire.std;ArrayInstances3">ArrayInstances3</a> extends <a href="#spire.std;ArrayInstances2" title="spire.std.ArrayInstances2">ArrayInstances2</a> <span class="delimiter">{</span>
  implicit def <a title="[A](implicit evidence$22: spire.algebra.Field[A], implicit evidence$23: spire.algebra.NRoot[A], implicit evidence$24: scala.reflect.ClassTag[A])spire.algebra.NormedVectorSpace[Array[A],A]" id="spire.std;ArrayInstances3.ArrayNormedVectorSpace">ArrayNormedVectorSpace</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Float, Double<span class="delimiter">)</span> <a title="" id="spire.std;ArrayInstances3.ArrayNormedVectorSpace;A">A</a>: Field: NRoot: ClassTag<span class="delimiter">]</span>: <a href="../algebra/NormedVectorSpace.scala.html#spire.algebra;NormedVectorSpace" title="spire.algebra.NormedVectorSpace[Array[A],A]">NormedVectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> =
    <a href="#spire.std;ArrayInstances2.ArrayInnerProductSpace" title="[A](implicit evidence$19: spire.algebra.Field[A], implicit evidence$20: scala.reflect.ClassTag[A])spire.algebra.InnerProductSpace[Array[A],A]">ArrayInnerProductSpace</a><a href="#spire.std;ArrayInstances3.ArrayNormedVectorSpace.evidence$22" title="(implicit evidence$19: spire.algebra.Field[A], implicit evidence$20: scala.reflect.ClassTag[A])spire.algebra.InnerProductSpace[Array[A],A]" class="delimiter">[</a><a href="#spire.std;ArrayInstances3.ArrayNormedVectorSpace;A" title="A">A</a><span class="delimiter">]</span>.<a href="../algebra/InnerProductSpace.scala.html#spire.algebra;InnerProductSpace.normed" title="(implicit ev: spire.algebra.NRoot[A])spire.algebra.NormedVectorSpace[Array[A],A]">normed</a>
<span class="delimiter">}</span>

trait <a title="trait ArrayInstances extends AnyRef with spire.std.ArrayInstances3" id="spire.std;ArrayInstances">ArrayInstances</a> extends <a href="#spire.std;ArrayInstances3" title="spire.std.ArrayInstances3">ArrayInstances3</a> <span class="delimiter">{</span>
  implicit def <a title="[A](implicit evidence$25: scala.reflect.ClassTag[A])spire.algebra.Monoid[Array[A]]" id="spire.std;ArrayInstances.ArrayMonoid">ArrayMonoid</a><span class="delimiter">[</span>@spec <a title="" id="spire.std;ArrayInstances.ArrayMonoid;A">A</a>: ClassTag<span class="delimiter">]</span>: <a href="../algebra/Monoid.scala.html#spire.algebra;Monoid" title="spire.algebra.Monoid[Array[A]]">Monoid</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    new <a href="#spire.std;ArrayMonoid" title="spire.std.ArrayMonoid[A]">ArrayMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
private final class <a title="class ArrayModule[A] extends AnyRef with spire.algebra.Module[Array[A],A] with Serializable" id="spire.std;ArrayModule">ArrayModule</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int,Long,Float,Double<span class="delimiter">)</span> <a title="" id="spire.std;ArrayModule;A">A</a>: ClassTag: Ring<span class="delimiter">]</span>
    <span class="delimiter">(</span>implicit <a title="spire.NoImplicit[spire.algebra.VectorSpace[Array[A],A]]" id="spire.std;ArrayModule.nvs">nvs</a>: <a href="../NoImplicit.scala.html#spire;NoImplicit" title="spire.NoImplicit[spire.algebra.VectorSpace[Array[A],A]]">NoImplicit</a><span class="delimiter">[</span>VectorSpace<span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
    extends <a href="../algebra/Module.scala.html#spire.algebra;Module" title="spire.algebra.Module[Array[A],A]">Module</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="=&gt; spire.algebra.Ring[A]" id="spire.std;ArrayModule.scalar">scalar</a> = <a href="../algebra/Ring.scala.html#spire.algebra.Ring.apply" title="[A](implicit r: spire.algebra.Ring[A])spire.algebra.Ring[A]">Ring</a><a href="#spire.std;ArrayModule.evidence$27" title="(implicit r: spire.algebra.Ring[A])spire.algebra.Ring[A]" class="delimiter">[</a><a href="#spire.std;ArrayModule;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="=&gt; Array[A]" id="spire.std;ArrayModule.zero">zero</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = new Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
  def <a title="(x: Array[A])Array[A]" id="spire.std;ArrayModule.negate">negate</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayModule.negate.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.negate" title="(x: Array[A])(implicit evidence$4: scala.reflect.ClassTag[A], implicit evidence$5: spire.algebra.Ring[A])Array[A]">negate</a><a href="#spire.std;ArrayModule.evidence$26" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayModule.negate.x" title="Array[A]">x</a><span class="delimiter">)</span>
  def <a title="(x: Array[A], y: Array[A])Array[A]" id="spire.std;ArrayModule.plus">plus</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayModule.plus.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayModule.plus.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.plus" title="(x: Array[A], y: Array[A])(implicit evidence$6: scala.reflect.ClassTag[A], implicit evidence$7: spire.algebra.AdditiveMonoid[A])Array[A]">plus</a><a href="#spire.std;ArrayModule.evidence$26" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayModule.plus.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayModule.plus.y" title="Array[A]">y</a><span class="delimiter">)</span>
  override def <a title="(x: Array[A], y: Array[A])Array[A]" id="spire.std;ArrayModule.minus">minus</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayModule.minus.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayModule.minus.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.minus" title="(x: Array[A], y: Array[A])(implicit evidence$8: scala.reflect.ClassTag[A], implicit evidence$9: spire.algebra.AdditiveGroup[A])Array[A]">minus</a><a href="#spire.std;ArrayModule.evidence$26" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayModule.minus.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayModule.minus.y" title="Array[A]">y</a><span class="delimiter">)</span>
  def <a title="(r: A, x: Array[A])Array[A]" id="spire.std;ArrayModule.timesl">timesl</a><span class="delimiter">(</span><a title="A" id="spire.std;ArrayModule.timesl.r">r</a>: <a href="#spire.std;ArrayModule;A" title="A">A</a>, <a title="Array[A]" id="spire.std;ArrayModule.timesl.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.timesl" title="(r: A, x: Array[A])(implicit evidence$10: scala.reflect.ClassTag[A], implicit evidence$11: spire.algebra.MultiplicativeSemigroup[A])Array[A]">timesl</a><a href="#spire.std;ArrayModule.evidence$26" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayModule.timesl.r" title="A">r</a>, <a href="#spire.std;ArrayModule.timesl.x" title="Array[A]">x</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
private final class <a title="class ArrayVectorSpace[A] extends AnyRef with spire.algebra.VectorSpace[Array[A],A] with Serializable" id="spire.std;ArrayVectorSpace">ArrayVectorSpace</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int,Float,Long,Double<span class="delimiter">)</span> <a title="" id="spire.std;ArrayVectorSpace;A">A</a>: ClassTag: Field<span class="delimiter">]</span>
    <span class="delimiter">(</span>implicit <a title="spire.NoImplicit[spire.algebra.NormedVectorSpace[Array[A],A]]" id="spire.std;ArrayVectorSpace.nnvs">nnvs</a>: <a href="../NoImplicit.scala.html#spire;NoImplicit" title="spire.NoImplicit[spire.algebra.NormedVectorSpace[Array[A],A]]">NoImplicit</a><span class="delimiter">[</span>NormedVectorSpace<span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
    extends <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[Array[A],A]">VectorSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="=&gt; spire.algebra.Field[A]" id="spire.std;ArrayVectorSpace.scalar">scalar</a> = <a href="../algebra/Field.scala.html#spire.algebra.Field.apply" title="[A](implicit f: spire.algebra.Field[A])spire.algebra.Field[A]">Field</a><a href="#spire.std;ArrayVectorSpace.evidence$29" title="(implicit f: spire.algebra.Field[A])spire.algebra.Field[A]" class="delimiter">[</a><a href="#spire.std;ArrayVectorSpace;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="=&gt; Array[A]" id="spire.std;ArrayVectorSpace.zero">zero</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = new Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
  def <a title="(x: Array[A])Array[A]" id="spire.std;ArrayVectorSpace.negate">negate</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayVectorSpace.negate.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.negate" title="(x: Array[A])(implicit evidence$4: scala.reflect.ClassTag[A], implicit evidence$5: spire.algebra.Ring[A])Array[A]">negate</a><a href="#spire.std;ArrayVectorSpace.evidence$28" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayVectorSpace.negate.x" title="Array[A]">x</a><span class="delimiter">)</span>
  def <a title="(x: Array[A], y: Array[A])Array[A]" id="spire.std;ArrayVectorSpace.plus">plus</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayVectorSpace.plus.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayVectorSpace.plus.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.plus" title="(x: Array[A], y: Array[A])(implicit evidence$6: scala.reflect.ClassTag[A], implicit evidence$7: spire.algebra.AdditiveMonoid[A])Array[A]">plus</a><a href="#spire.std;ArrayVectorSpace.evidence$28" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayVectorSpace.plus.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayVectorSpace.plus.y" title="Array[A]">y</a><span class="delimiter">)</span>
  override def <a title="(x: Array[A], y: Array[A])Array[A]" id="spire.std;ArrayVectorSpace.minus">minus</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayVectorSpace.minus.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayVectorSpace.minus.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.minus" title="(x: Array[A], y: Array[A])(implicit evidence$8: scala.reflect.ClassTag[A], implicit evidence$9: spire.algebra.AdditiveGroup[A])Array[A]">minus</a><a href="#spire.std;ArrayVectorSpace.evidence$28" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayVectorSpace.minus.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayVectorSpace.minus.y" title="Array[A]">y</a><span class="delimiter">)</span>
  def <a title="(r: A, x: Array[A])Array[A]" id="spire.std;ArrayVectorSpace.timesl">timesl</a><span class="delimiter">(</span><a title="A" id="spire.std;ArrayVectorSpace.timesl.r">r</a>: <a href="#spire.std;ArrayVectorSpace;A" title="A">A</a>, <a title="Array[A]" id="spire.std;ArrayVectorSpace.timesl.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.timesl" title="(r: A, x: Array[A])(implicit evidence$10: scala.reflect.ClassTag[A], implicit evidence$11: spire.algebra.MultiplicativeSemigroup[A])Array[A]">timesl</a><a href="#spire.std;ArrayVectorSpace.evidence$28" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayVectorSpace.timesl.r" title="A">r</a>, <a href="#spire.std;ArrayVectorSpace.timesl.x" title="Array[A]">x</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
private final class <a title="class ArrayEq[A] extends AnyRef with spire.algebra.Eq[Array[A]] with Serializable" id="spire.std;ArrayEq">ArrayEq</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int,Float,Long,Double<span class="delimiter">)</span> <a title="" id="spire.std;ArrayEq;A">A</a>: Eq<span class="delimiter">]</span>
    extends <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[Array[A]]">Eq</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="(x: Array[A], y: Array[A])Boolean" id="spire.std;ArrayEq.eqv">eqv</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayEq.eqv.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayEq.eqv.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.eqv" title="(x: Array[A], y: Array[A])(implicit evidence$1: spire.algebra.Eq[A])Boolean">eqv</a><a href="#spire.std;ArrayEq.evidence$30" title="spire.algebra.Eq[A]" class="delimiter">(</a><a href="#spire.std;ArrayEq.eqv.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayEq.eqv.y" title="Array[A]">y</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
private final class <a title="class ArrayInnerProductSpace[A] extends AnyRef with spire.algebra.InnerProductSpace[Array[A],A] with Serializable" id="spire.std;ArrayInnerProductSpace">ArrayInnerProductSpace</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int,Float,Long,Double<span class="delimiter">)</span> <a title="" id="spire.std;ArrayInnerProductSpace;A">A</a>: ClassTag: Field<span class="delimiter">]</span>
    extends <a href="../algebra/InnerProductSpace.scala.html#spire.algebra;InnerProductSpace" title="spire.algebra.InnerProductSpace[Array[A],A]">InnerProductSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="=&gt; spire.algebra.Field[A]" id="spire.std;ArrayInnerProductSpace.scalar">scalar</a> = <a href="../algebra/Field.scala.html#spire.algebra.Field.apply" title="[A](implicit f: spire.algebra.Field[A])spire.algebra.Field[A]">Field</a><a href="#spire.std;ArrayInnerProductSpace.evidence$32" title="(implicit f: spire.algebra.Field[A])spire.algebra.Field[A]" class="delimiter">[</a><a href="#spire.std;ArrayInnerProductSpace;A" title="A">A</a><span class="delimiter">]</span>
  def <a title="=&gt; Array[A]" id="spire.std;ArrayInnerProductSpace.zero">zero</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = new Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
  def <a title="(x: Array[A])Array[A]" id="spire.std;ArrayInnerProductSpace.negate">negate</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayInnerProductSpace.negate.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.negate" title="(x: Array[A])(implicit evidence$4: scala.reflect.ClassTag[A], implicit evidence$5: spire.algebra.Ring[A])Array[A]">negate</a><a href="#spire.std;ArrayInnerProductSpace.evidence$31" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayInnerProductSpace.negate.x" title="Array[A]">x</a><span class="delimiter">)</span>
  def <a title="(x: Array[A], y: Array[A])Array[A]" id="spire.std;ArrayInnerProductSpace.plus">plus</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayInnerProductSpace.plus.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayInnerProductSpace.plus.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.plus" title="(x: Array[A], y: Array[A])(implicit evidence$6: scala.reflect.ClassTag[A], implicit evidence$7: spire.algebra.AdditiveMonoid[A])Array[A]">plus</a><a href="#spire.std;ArrayInnerProductSpace.evidence$31" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayInnerProductSpace.plus.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayInnerProductSpace.plus.y" title="Array[A]">y</a><span class="delimiter">)</span>
  override def <a title="(x: Array[A], y: Array[A])Array[A]" id="spire.std;ArrayInnerProductSpace.minus">minus</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayInnerProductSpace.minus.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayInnerProductSpace.minus.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.minus" title="(x: Array[A], y: Array[A])(implicit evidence$8: scala.reflect.ClassTag[A], implicit evidence$9: spire.algebra.AdditiveGroup[A])Array[A]">minus</a><a href="#spire.std;ArrayInnerProductSpace.evidence$31" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayInnerProductSpace.minus.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayInnerProductSpace.minus.y" title="Array[A]">y</a><span class="delimiter">)</span>
  def <a title="(r: A, x: Array[A])Array[A]" id="spire.std;ArrayInnerProductSpace.timesl">timesl</a><span class="delimiter">(</span><a title="A" id="spire.std;ArrayInnerProductSpace.timesl.r">r</a>: <a href="#spire.std;ArrayInnerProductSpace;A" title="A">A</a>, <a title="Array[A]" id="spire.std;ArrayInnerProductSpace.timesl.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.timesl" title="(r: A, x: Array[A])(implicit evidence$10: scala.reflect.ClassTag[A], implicit evidence$11: spire.algebra.MultiplicativeSemigroup[A])Array[A]">timesl</a><a href="#spire.std;ArrayInnerProductSpace.evidence$31" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayInnerProductSpace.timesl.r" title="A">r</a>, <a href="#spire.std;ArrayInnerProductSpace.timesl.x" title="Array[A]">x</a><span class="delimiter">)</span>
  def <a title="(x: Array[A], y: Array[A])A" id="spire.std;ArrayInnerProductSpace.dot">dot</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayInnerProductSpace.dot.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayInnerProductSpace.dot.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.std;ArrayInnerProductSpace;A" title="A">A</a> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.dot" title="(x: Array[A], y: Array[A])(implicit sc: spire.algebra.Rig[A])A">dot</a><a href="#spire.std;ArrayInnerProductSpace.evidence$32" title="spire.algebra.Field[A]" class="delimiter">(</a><a href="#spire.std;ArrayInnerProductSpace.dot.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayInnerProductSpace.dot.y" title="Array[A]">y</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
private final class <a title="class ArrayOrder[A] extends AnyRef with spire.algebra.Order[Array[A]] with Serializable" id="spire.std;ArrayOrder">ArrayOrder</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int,Float,Long,Double<span class="delimiter">)</span> <a title="" id="spire.std;ArrayOrder;A">A</a>: Order<span class="delimiter">]</span>
    extends <a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[Array[A]]">Order</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  override def <a title="(x: Array[A], y: Array[A])Boolean" id="spire.std;ArrayOrder.eqv">eqv</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayOrder.eqv.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayOrder.eqv.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.eqv" title="(x: Array[A], y: Array[A])(implicit evidence$1: spire.algebra.Eq[A])Boolean">eqv</a><a href="#spire.std;ArrayOrder.evidence$33" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.std;ArrayOrder.eqv.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayOrder.eqv.y" title="Array[A]">y</a><span class="delimiter">)</span>
  def <a title="(x: Array[A], y: Array[A])Int" id="spire.std;ArrayOrder.compare">compare</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayOrder.compare.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayOrder.compare.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.compare" title="(x: Array[A], y: Array[A])(implicit evidence$2: spire.algebra.Order[A])Int">compare</a><a href="#spire.std;ArrayOrder.evidence$33" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.std;ArrayOrder.compare.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayOrder.compare.y" title="Array[A]">y</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
private final class <a title="class ArrayMonoid[A] extends AnyRef with spire.algebra.Monoid[Array[A]] with Serializable" id="spire.std;ArrayMonoid">ArrayMonoid</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int,Float,Long,Double<span class="delimiter">)</span> <a title="" id="spire.std;ArrayMonoid;A">A</a>: ClassTag<span class="delimiter">]</span>
    extends <a href="../algebra/Monoid.scala.html#spire.algebra;Monoid" title="spire.algebra.Monoid[Array[A]]">Monoid</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="=&gt; Array[A]" id="spire.std;ArrayMonoid.id">id</a> = new Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
  def <a title="(x: Array[A], y: Array[A])Array[A]" id="spire.std;ArrayMonoid.op">op</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayMonoid.op.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayMonoid.op.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.concat" title="(x: Array[A], y: Array[A])(implicit evidence$3: scala.reflect.ClassTag[A])Array[A]">concat</a><a href="#spire.std;ArrayMonoid.evidence$34" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayMonoid.op.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayMonoid.op.y" title="Array[A]">y</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class ArrayCoordinateSpace[A] extends AnyRef with spire.algebra.CoordinateSpace[Array[A],A] with Serializable" id="spire.std;ArrayCoordinateSpace">ArrayCoordinateSpace</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int,Long,Float,Double<span class="delimiter">)</span> <a title="" id="spire.std;ArrayCoordinateSpace;A">A</a>: ClassTag<span class="delimiter">]</span><span class="delimiter">(</span>final val <a title="Int" id="spire.std;ArrayCoordinateSpace.dimensions">dimensions</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit val <a title="spire.algebra.Field[A]" id="spire.std;ArrayCoordinateSpace.scalar">scalar</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>
extends <a href="../algebra/CoordinateSpace.scala.html#spire.algebra;CoordinateSpace" title="spire.algebra.CoordinateSpace[Array[A],A]">CoordinateSpace</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="=&gt; Array[A]" id="spire.std;ArrayCoordinateSpace.zero">zero</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = new Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
  def <a title="(x: Array[A])Array[A]" id="spire.std;ArrayCoordinateSpace.negate">negate</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayCoordinateSpace.negate.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.negate" title="(x: Array[A])(implicit evidence$4: scala.reflect.ClassTag[A], implicit evidence$5: spire.algebra.Ring[A])Array[A]">negate</a><a href="#spire.std;ArrayCoordinateSpace.evidence$35" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayCoordinateSpace.negate.x" title="Array[A]">x</a><span class="delimiter">)</span>
  def <a title="(x: Array[A], y: Array[A])Array[A]" id="spire.std;ArrayCoordinateSpace.plus">plus</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayCoordinateSpace.plus.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayCoordinateSpace.plus.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.plus" title="(x: Array[A], y: Array[A])(implicit evidence$6: scala.reflect.ClassTag[A], implicit evidence$7: spire.algebra.AdditiveMonoid[A])Array[A]">plus</a><a href="#spire.std;ArrayCoordinateSpace.evidence$35" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayCoordinateSpace.plus.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayCoordinateSpace.plus.y" title="Array[A]">y</a><span class="delimiter">)</span>
  override def <a title="(x: Array[A], y: Array[A])Array[A]" id="spire.std;ArrayCoordinateSpace.minus">minus</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayCoordinateSpace.minus.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayCoordinateSpace.minus.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.minus" title="(x: Array[A], y: Array[A])(implicit evidence$8: scala.reflect.ClassTag[A], implicit evidence$9: spire.algebra.AdditiveGroup[A])Array[A]">minus</a><a href="#spire.std;ArrayCoordinateSpace.evidence$35" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayCoordinateSpace.minus.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayCoordinateSpace.minus.y" title="Array[A]">y</a><span class="delimiter">)</span>
  def <a title="(r: A, x: Array[A])Array[A]" id="spire.std;ArrayCoordinateSpace.timesl">timesl</a><span class="delimiter">(</span><a title="A" id="spire.std;ArrayCoordinateSpace.timesl.r">r</a>: <a href="#spire.std;ArrayCoordinateSpace;A" title="A">A</a>, <a title="Array[A]" id="spire.std;ArrayCoordinateSpace.timesl.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.timesl" title="(r: A, x: Array[A])(implicit evidence$10: scala.reflect.ClassTag[A], implicit evidence$11: spire.algebra.MultiplicativeSemigroup[A])Array[A]">timesl</a><a href="#spire.std;ArrayCoordinateSpace.evidence$35" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayCoordinateSpace.timesl.r" title="A">r</a>, <a href="#spire.std;ArrayCoordinateSpace.timesl.x" title="Array[A]">x</a><span class="delimiter">)</span>
  override def <a title="(x: Array[A], y: Array[A])A" id="spire.std;ArrayCoordinateSpace.dot">dot</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayCoordinateSpace.dot.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayCoordinateSpace.dot.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.std;ArrayCoordinateSpace;A" title="A">A</a> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.dot" title="(x: Array[A], y: Array[A])(implicit sc: spire.algebra.Rig[A])A">dot</a><a href="#spire.std;ArrayCoordinateSpace.scalar" title="=&gt; spire.algebra.Field[A]" class="delimiter">(</a><a href="#spire.std;ArrayCoordinateSpace.dot.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayCoordinateSpace.dot.y" title="Array[A]">y</a><span class="delimiter">)</span>
  def <a title="(v: Array[A], i: Int)A" id="spire.std;ArrayCoordinateSpace.coord">coord</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayCoordinateSpace.coord.v">v</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Int" id="spire.std;ArrayCoordinateSpace.coord.i">i</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.std;ArrayCoordinateSpace;A" title="A">A</a> = <a href="#spire.std;ArrayCoordinateSpace.coord.v" title="(i: Int)A">v</a><span class="delimiter">(</span><a href="#spire.std;ArrayCoordinateSpace.coord.i" title="Int">i</a><span class="delimiter">)</span>
  def <a title="(i: Int)Array[A]" id="spire.std;ArrayCoordinateSpace.axis">axis</a><span class="delimiter">(</span><a title="Int" id="spire.std;ArrayCoordinateSpace.axis.i">i</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.axis" title="(dimensions: Int, i: Int)(implicit ct: scala.reflect.ClassTag[A], implicit sc: spire.algebra.Rig[A])Array[A]">axis</a><a href="#spire.std;ArrayCoordinateSpace.evidence$35" title="scala.reflect.ClassTag[A]" class="delimiter">(</a><a href="#spire.std;ArrayCoordinateSpace.dimensions" title="=&gt; Int">dimensions</a>, <a href="#spire.std;ArrayCoordinateSpace.axis.i" title="Int">i</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class ArrayVectorEq[A] extends AnyRef with spire.algebra.Eq[Array[A]] with Serializable" id="spire.std;ArrayVectorEq">ArrayVectorEq</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int,Long,Float,Double<span class="delimiter">)</span> <a title="" id="spire.std;ArrayVectorEq;A">A</a>: Eq: AdditiveMonoid<span class="delimiter">]</span>
extends <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[Array[A]]">Eq</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="(x: Array[A], y: Array[A])Boolean" id="spire.std;ArrayVectorEq.eqv">eqv</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayVectorEq.eqv.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayVectorEq.eqv.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.vectorEqv" title="(x: Array[A], y: Array[A])(implicit ev: spire.algebra.Eq[A], implicit sc: spire.algebra.AdditiveMonoid[A])Boolean">vectorEqv</a><a href="#spire.std;ArrayVectorEq.evidence$36" title="spire.algebra.Eq[A]" class="delimiter">(</a><a href="#spire.std;ArrayVectorEq.eqv.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayVectorEq.eqv.y" title="Array[A]">y</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class ArrayVectorOrder[A] extends AnyRef with spire.algebra.Order[Array[A]] with Serializable" id="spire.std;ArrayVectorOrder">ArrayVectorOrder</a><span class="delimiter">[</span>@spec<span class="delimiter">(</span>Int,Long,Float,Double<span class="delimiter">)</span> <a title="" id="spire.std;ArrayVectorOrder;A">A</a>: Order: AdditiveMonoid<span class="delimiter">]</span>
extends <a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[Array[A]]">Order</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  override def <a title="(x: Array[A], y: Array[A])Boolean" id="spire.std;ArrayVectorOrder.eqv">eqv</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayVectorOrder.eqv.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayVectorOrder.eqv.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.vectorEqv" title="(x: Array[A], y: Array[A])(implicit ev: spire.algebra.Eq[A], implicit sc: spire.algebra.AdditiveMonoid[A])Boolean">vectorEqv</a><a href="#spire.std;ArrayVectorOrder.evidence$38" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.std;ArrayVectorOrder.eqv.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayVectorOrder.eqv.y" title="Array[A]">y</a><span class="delimiter">)</span>

  def <a title="(x: Array[A], y: Array[A])Int" id="spire.std;ArrayVectorOrder.compare">compare</a><span class="delimiter">(</span><a title="Array[A]" id="spire.std;ArrayVectorOrder.compare.x">x</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Array[A]" id="spire.std;ArrayVectorOrder.compare.y">y</a>: <span title="Array[A]">Array</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#spire.std.ArraySupport" title="spire.std.ArraySupport.type">ArraySupport</a>.<a href="#spire.std.ArraySupport.vectorCompare" title="(x: Array[A], y: Array[A])(implicit ev: spire.algebra.Order[A], implicit sc: spire.algebra.AdditiveMonoid[A])Int">vectorCompare</a><a href="#spire.std;ArrayVectorOrder.evidence$38" title="spire.algebra.Order[A]" class="delimiter">(</a><a href="#spire.std;ArrayVectorOrder.compare.x" title="Array[A]">x</a>, <a href="#spire.std;ArrayVectorOrder.compare.y" title="Array[A]">y</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
