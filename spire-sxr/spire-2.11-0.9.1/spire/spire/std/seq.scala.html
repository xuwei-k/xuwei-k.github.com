<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>spire/spire/std/seq.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package spire.std

import scala.annotation.tailrec
import scala.collection.SeqLike
import scala.collection.mutable.Builder
import scala.collection.generic.CanBuildFrom

import spire.algebra._
import spire.NoImplicit

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class SeqModule[A, SA &lt;: scala.collection.SeqLike[A,SA]] extends AnyRef with spire.algebra.Module[SA,A] with Serializable" id="spire.std;SeqModule">SeqModule</a><span class="delimiter">[</span><a title="" id="spire.std;SeqModule;A">A</a>, <a title=" &lt;: scala.collection.SeqLike[A,SA]" id="spire.std;SeqModule;SA">SA</a> &lt;: SeqLike<span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">]</span><a href="#spire.std;SeqModule" title="spire.std.SeqModule[A,SA]" class="delimiter">(</a>implicit val <a title="spire.algebra.Ring[A]" id="spire.std;SeqModule.scalar">scalar</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.generic.CanBuildFrom[SA,A,SA]" id="spire.std;SeqModule.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[SA,A,SA]">CanBuildFrom</span><span class="delimiter">[</span>SA,A,SA<span class="delimiter">]</span><span class="delimiter">)</span>
extends <a href="../algebra/Module.scala.html#spire.algebra;Module" title="spire.algebra.Module[SA,A]">Module</a><span class="delimiter">[</span>SA, A<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="=&gt; SA" id="spire.std;SeqModule.zero">zero</a>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a> = <a href="#spire.std;SeqModule.cbf" title="()scala.collection.mutable.Builder[A,SA]">cbf</a><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="()SA">result</span>

  def <a title="(sa: SA)SA" id="spire.std;SeqModule.negate">negate</a><span class="delimiter">(</span><a title="SA" id="spire.std;SeqModule.negate.sa">sa</a>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a><span class="delimiter">)</span>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a> = <a href="#spire.std;SeqModule.negate.sa" title="SA">sa</a> <a href="#spire.std;SeqModule.cbf" title="(f: A =&gt; A)(implicit bf: scala.collection.generic.CanBuildFrom[SA,A,SA])SA">map</a> <span class="delimiter">(</span><a href="#spire.std;SeqModule.scalar" title="=&gt; spire.algebra.Ring[A]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: A)A">negate</a><span class="delimiter">)</span>

  def <a title="(x: SA, y: SA)SA" id="spire.std;SeqModule.plus">plus</a><span class="delimiter">(</span><a title="SA" id="spire.std;SeqModule.plus.x">x</a>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a>, <a title="SA" id="spire.std;SeqModule.plus.y">y</a>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a><span class="delimiter">)</span>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(it: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA" id="spire.std;SeqModule.plus.add1">add1</a><span class="delimiter">(</span><a title="Iterator[A]" id="spire.std;SeqModule.plus.add1.it">it</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.mutable.Builder[A,SA]" id="spire.std;SeqModule.plus.add1.b">b</a>: <span title="scala.collection.mutable.Builder[A,SA]">Builder</span><span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a> = if <span class="delimiter">(</span><a href="#spire.std;SeqModule.plus.add1.it" title="Iterator[A]">it</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.std;SeqModule.plus.add1.b" title="scala.collection.mutable.Builder[A,SA]">b</a> <span title="(elem: A)b.type">+=</span> <a href="#spire.std;SeqModule.plus.add1.it" title="Iterator[A]">it</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#spire.std;SeqModule.plus.add1" title="(it: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA">add1</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.plus.add1.it" title="Iterator[A]">it</a>, <a href="#spire.std;SeqModule.plus.add1.b" title="scala.collection.mutable.Builder[A,SA]">b</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <a href="#spire.std;SeqModule.plus.add1.b" title="scala.collection.mutable.Builder[A,SA]">b</a>.<span title="()SA">result</span>
    <span class="delimiter">}</span>

    @tailrec
    def <a title="(xi: Iterator[A], yi: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA" id="spire.std;SeqModule.plus.add2">add2</a><span class="delimiter">(</span><a title="Iterator[A]" id="spire.std;SeqModule.plus.add2.xi">xi</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Iterator[A]" id="spire.std;SeqModule.plus.add2.yi">yi</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.mutable.Builder[A,SA]" id="spire.std;SeqModule.plus.add2.b">b</a>: <span title="scala.collection.mutable.Builder[A,SA]">Builder</span><span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#spire.std;SeqModule.plus.add2.xi" title="Iterator[A]">xi</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#spire.std;SeqModule.plus.add1" title="(it: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA">add1</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.plus.add2.yi" title="Iterator[A]">yi</a>, <a href="#spire.std;SeqModule.plus.add2.b" title="scala.collection.mutable.Builder[A,SA]">b</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> else if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#spire.std;SeqModule.plus.add2.yi" title="Iterator[A]">yi</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#spire.std;SeqModule.plus.add1" title="(it: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA">add1</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.plus.add2.xi" title="Iterator[A]">xi</a>, <a href="#spire.std;SeqModule.plus.add2.b" title="scala.collection.mutable.Builder[A,SA]">b</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <a href="#spire.std;SeqModule.plus.add2.b" title="scala.collection.mutable.Builder[A,SA]">b</a> <span title="(elem: A)b.type">+=</span> <a href="#spire.std;SeqModule.scalar" title="=&gt; spire.algebra.Ring[A]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">plus</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.plus.add2.xi" title="Iterator[A]">xi</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#spire.std;SeqModule.plus.add2.yi" title="Iterator[A]">yi</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#spire.std;SeqModule.plus.add2" title="(xi: Iterator[A], yi: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA">add2</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.plus.add2.xi" title="Iterator[A]">xi</a>, <a href="#spire.std;SeqModule.plus.add2.yi" title="Iterator[A]">yi</a>, <a href="#spire.std;SeqModule.plus.add2.b" title="scala.collection.mutable.Builder[A,SA]">b</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="#spire.std;SeqModule.plus.add2" title="(xi: Iterator[A], yi: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA">add2</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.plus.x" title="SA">x</a>.<span title="=&gt; Iterator[A]">toIterator</span>, <a href="#spire.std;SeqModule.plus.y" title="SA">y</a>.<span title="=&gt; Iterator[A]">toIterator</span>, <a href="#spire.std;SeqModule.cbf" title="(from: SA)scala.collection.mutable.Builder[A,SA]">cbf</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.plus.x" title="SA">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  override def <a title="(x: SA, y: SA)SA" id="spire.std;SeqModule.minus">minus</a><span class="delimiter">(</span><a title="SA" id="spire.std;SeqModule.minus.x">x</a>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a>, <a title="SA" id="spire.std;SeqModule.minus.y">y</a>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a><span class="delimiter">)</span>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(it: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA" id="spire.std;SeqModule.minus.subl">subl</a><span class="delimiter">(</span><a title="Iterator[A]" id="spire.std;SeqModule.minus.subl.it">it</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.mutable.Builder[A,SA]" id="spire.std;SeqModule.minus.subl.b">b</a>: <span title="scala.collection.mutable.Builder[A,SA]">Builder</span><span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a> = if <span class="delimiter">(</span><a href="#spire.std;SeqModule.minus.subl.it" title="Iterator[A]">it</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.std;SeqModule.minus.subl.b" title="scala.collection.mutable.Builder[A,SA]">b</a> <span title="(elem: A)b.type">+=</span> <a href="#spire.std;SeqModule.minus.subl.it" title="Iterator[A]">it</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#spire.std;SeqModule.minus.subl" title="(it: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA">subl</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.minus.subl.it" title="Iterator[A]">it</a>, <a href="#spire.std;SeqModule.minus.subl.b" title="scala.collection.mutable.Builder[A,SA]">b</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <a href="#spire.std;SeqModule.minus.subl.b" title="scala.collection.mutable.Builder[A,SA]">b</a>.<span title="()SA">result</span>
    <span class="delimiter">}</span>

    @tailrec
    def <a title="(it: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA" id="spire.std;SeqModule.minus.subr">subr</a><span class="delimiter">(</span><a title="Iterator[A]" id="spire.std;SeqModule.minus.subr.it">it</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.mutable.Builder[A,SA]" id="spire.std;SeqModule.minus.subr.b">b</a>: <span title="scala.collection.mutable.Builder[A,SA]">Builder</span><span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a> = if <span class="delimiter">(</span><a href="#spire.std;SeqModule.minus.subr.it" title="Iterator[A]">it</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.std;SeqModule.minus.subr.b" title="scala.collection.mutable.Builder[A,SA]">b</a> <span title="(elem: A)b.type">+=</span> <a href="#spire.std;SeqModule.scalar" title="=&gt; spire.algebra.Ring[A]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.negate" title="(x: A)A">negate</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.minus.subr.it" title="Iterator[A]">it</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#spire.std;SeqModule.minus.subr" title="(it: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA">subr</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.minus.subr.it" title="Iterator[A]">it</a>, <a href="#spire.std;SeqModule.minus.subr.b" title="scala.collection.mutable.Builder[A,SA]">b</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <a href="#spire.std;SeqModule.minus.subr.b" title="scala.collection.mutable.Builder[A,SA]">b</a>.<span title="()SA">result</span>
    <span class="delimiter">}</span>

    @tailrec
    def <a title="(xi: Iterator[A], yi: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA" id="spire.std;SeqModule.minus.sub2">sub2</a><span class="delimiter">(</span><a title="Iterator[A]" id="spire.std;SeqModule.minus.sub2.xi">xi</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Iterator[A]" id="spire.std;SeqModule.minus.sub2.yi">yi</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.mutable.Builder[A,SA]" id="spire.std;SeqModule.minus.sub2.b">b</a>: <span title="scala.collection.mutable.Builder[A,SA]">Builder</span><span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#spire.std;SeqModule.minus.sub2.xi" title="Iterator[A]">xi</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#spire.std;SeqModule.minus.subr" title="(it: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA">subr</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.minus.sub2.yi" title="Iterator[A]">yi</a>, <a href="#spire.std;SeqModule.minus.sub2.b" title="scala.collection.mutable.Builder[A,SA]">b</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> else if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#spire.std;SeqModule.minus.sub2.yi" title="Iterator[A]">yi</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#spire.std;SeqModule.minus.subl" title="(it: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA">subl</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.minus.sub2.xi" title="Iterator[A]">xi</a>, <a href="#spire.std;SeqModule.minus.sub2.b" title="scala.collection.mutable.Builder[A,SA]">b</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <a href="#spire.std;SeqModule.minus.sub2.b" title="scala.collection.mutable.Builder[A,SA]">b</a> <span title="(elem: A)b.type">+=</span> <a href="#spire.std;SeqModule.scalar" title="=&gt; spire.algebra.Ring[A]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveGroup.minus" title="(x: A, y: A)A">minus</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.minus.sub2.xi" title="Iterator[A]">xi</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#spire.std;SeqModule.minus.sub2.yi" title="Iterator[A]">yi</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#spire.std;SeqModule.minus.sub2" title="(xi: Iterator[A], yi: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA">sub2</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.minus.sub2.xi" title="Iterator[A]">xi</a>, <a href="#spire.std;SeqModule.minus.sub2.yi" title="Iterator[A]">yi</a>, <a href="#spire.std;SeqModule.minus.sub2.b" title="scala.collection.mutable.Builder[A,SA]">b</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="#spire.std;SeqModule.minus.sub2" title="(xi: Iterator[A], yi: Iterator[A], b: scala.collection.mutable.Builder[A,SA])SA">sub2</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.minus.x" title="SA">x</a>.<span title="=&gt; Iterator[A]">toIterator</span>, <a href="#spire.std;SeqModule.minus.y" title="SA">y</a>.<span title="=&gt; Iterator[A]">toIterator</span>, <a href="#spire.std;SeqModule.cbf" title="(from: SA)scala.collection.mutable.Builder[A,SA]">cbf</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.minus.x" title="SA">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(r: A, sa: SA)SA" id="spire.std;SeqModule.timesl">timesl</a><span class="delimiter">(</span><a title="A" id="spire.std;SeqModule.timesl.r">r</a>: <a href="#spire.std;SeqModule;A" title="A">A</a>, <a title="SA" id="spire.std;SeqModule.timesl.sa">sa</a>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a><span class="delimiter">)</span>: <a href="#spire.std;SeqModule;SA" title="SA">SA</a> = <a href="#spire.std;SeqModule.timesl.sa" title="SA">sa</a> <a href="#spire.std;SeqModule.cbf" title="(f: A =&gt; A)(implicit bf: scala.collection.generic.CanBuildFrom[SA,A,SA])SA">map</a> <span class="delimiter">(</span><a href="#spire.std;SeqModule.scalar" title="=&gt; spire.algebra.Ring[A]">scalar</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">times</a><span class="delimiter">(</span><a href="#spire.std;SeqModule.timesl.r" title="A">r</a>, <a href="#spire.std;SeqModule.timesl.$anonfun.x$1" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class SeqVectorSpace[A, SA &lt;: scala.collection.SeqLike[A,SA]] extends spire.std.SeqModule[A,SA] with spire.algebra.VectorSpace[SA,A] with Serializable" id="spire.std;SeqVectorSpace">SeqVectorSpace</a><span class="delimiter">[</span><a title="" id="spire.std;SeqVectorSpace;A">A</a>, <a title=" &lt;: scala.collection.SeqLike[A,SA]" id="spire.std;SeqVectorSpace;SA">SA</a> &lt;: SeqLike<span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">]</span><a href="#spire.std;SeqVectorSpace" title="spire.std.SeqVectorSpace[A,SA]" class="delimiter">(</a>implicit override val <a title="spire.algebra.Field[A]" id="spire.std;SeqVectorSpace.scalar">scalar</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.generic.CanBuildFrom[SA,A,SA]" id="spire.std;SeqVectorSpace.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[SA,A,SA]">CanBuildFrom</span><span class="delimiter">[</span>SA,A,SA<span class="delimiter">]</span><span class="delimiter">)</span>
extends <a href="#spire.std;SeqModule" title="spire.std.SeqModule[A,SA]">SeqModule</a><span class="delimiter">[</span>A, SA<span class="delimiter">]</span> with <a href="../algebra/VectorSpace.scala.html#spire.algebra;VectorSpace" title="spire.algebra.VectorSpace[SA,A]">VectorSpace</a><span class="delimiter">[</span>SA, A<span class="delimiter">]</span> with <span title="Serializable">Serializable</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class SeqInnerProductSpace[A, SA &lt;: scala.collection.SeqLike[A,SA]] extends spire.std.SeqVectorSpace[A,SA] with spire.algebra.InnerProductSpace[SA,A] with Serializable" id="spire.std;SeqInnerProductSpace">SeqInnerProductSpace</a><span class="delimiter">[</span><a title="" id="spire.std;SeqInnerProductSpace;A">A</a>: Field, <a title=" &lt;: scala.collection.SeqLike[A,SA]" id="spire.std;SeqInnerProductSpace;SA">SA</a> &lt;: SeqLike<span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[SA,A,SA]" id="spire.std;SeqInnerProductSpace.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[SA,A,SA]">CanBuildFrom</span><span class="delimiter">[</span>SA,A,SA<span class="delimiter">]</span><span class="delimiter">)</span>
extends <a href="#spire.std;SeqVectorSpace" title="spire.std.SeqVectorSpace[A,SA]">SeqVectorSpace</a><span class="delimiter">[</span>A, SA<span class="delimiter">]</span> with <a href="../algebra/InnerProductSpace.scala.html#spire.algebra;InnerProductSpace" title="spire.algebra.InnerProductSpace[SA,A]">InnerProductSpace</a><span class="delimiter">[</span>SA, A<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="(x: SA, y: SA)A" id="spire.std;SeqInnerProductSpace.dot">dot</a><span class="delimiter">(</span><a title="SA" id="spire.std;SeqInnerProductSpace.dot.x">x</a>: <a href="#spire.std;SeqInnerProductSpace;SA" title="SA">SA</a>, <a title="SA" id="spire.std;SeqInnerProductSpace.dot.y">y</a>: <a href="#spire.std;SeqInnerProductSpace;SA" title="SA">SA</a><span class="delimiter">)</span>: <a href="#spire.std;SeqInnerProductSpace;A" title="A">A</a> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(xi: Iterator[A], yi: Iterator[A], acc: A)A" id="spire.std;SeqInnerProductSpace.dot.loop">loop</a><span class="delimiter">(</span><a title="Iterator[A]" id="spire.std;SeqInnerProductSpace.dot.loop.xi">xi</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Iterator[A]" id="spire.std;SeqInnerProductSpace.dot.loop.yi">yi</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A" id="spire.std;SeqInnerProductSpace.dot.loop.acc">acc</a>: <a href="#spire.std;SeqInnerProductSpace;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.std;SeqInnerProductSpace;A" title="A">A</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#spire.std;SeqInnerProductSpace.dot.loop.xi" title="Iterator[A]">xi</a>.<span title="=&gt; Boolean">hasNext</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std;SeqInnerProductSpace.dot.loop.yi" title="Iterator[A]">yi</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#spire.std;SeqInnerProductSpace.dot.loop" title="(xi: Iterator[A], yi: Iterator[A], acc: A)A">loop</a><span class="delimiter">(</span><a href="#spire.std;SeqInnerProductSpace.dot.loop.xi" title="Iterator[A]">xi</a>, <a href="#spire.std;SeqInnerProductSpace.dot.loop.yi" title="Iterator[A]">yi</a>, <a href="#spire.std;SeqVectorSpace.scalar" title="=&gt; spire.algebra.Field[A]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">plus</a><span class="delimiter">(</span><a href="#spire.std;SeqInnerProductSpace.dot.loop.acc" title="A">acc</a>, <a href="#spire.std;SeqVectorSpace.scalar" title="=&gt; spire.algebra.Field[A]">scalar</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeSemigroup.times" title="(x: A, y: A)A">times</a><span class="delimiter">(</span><a href="#spire.std;SeqInnerProductSpace.dot.loop.xi" title="Iterator[A]">xi</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#spire.std;SeqInnerProductSpace.dot.loop.yi" title="Iterator[A]">yi</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <a href="#spire.std;SeqInnerProductSpace.dot.loop.acc" title="A">acc</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="#spire.std;SeqInnerProductSpace.dot.loop" title="(xi: Iterator[A], yi: Iterator[A], acc: A)A">loop</a><span class="delimiter">(</span><a href="#spire.std;SeqInnerProductSpace.dot.x" title="SA">x</a>.<span title="=&gt; Iterator[A]">toIterator</span>, <a href="#spire.std;SeqInnerProductSpace.dot.y" title="SA">y</a>.<span title="=&gt; Iterator[A]">toIterator</span>, <a href="#spire.std;SeqVectorSpace.scalar" title="=&gt; spire.algebra.Field[A]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class SeqCoordinateSpace[A, SA &lt;: scala.collection.SeqLike[A,SA]] extends spire.std.SeqInnerProductSpace[A,SA] with spire.algebra.CoordinateSpace[SA,A] with Serializable" id="spire.std;SeqCoordinateSpace">SeqCoordinateSpace</a><span class="delimiter">[</span><a title="" id="spire.std;SeqCoordinateSpace;A">A</a>: Field, <a title=" &lt;: scala.collection.SeqLike[A,SA]" id="spire.std;SeqCoordinateSpace;SA">SA</a> &lt;: SeqLike<span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>val <a title="Int" id="spire.std;SeqCoordinateSpace.dimensions">dimensions</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[SA,A,SA]" id="spire.std;SeqCoordinateSpace.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[SA,A,SA]">CanBuildFrom</span><span class="delimiter">[</span>SA,A,SA<span class="delimiter">]</span><span class="delimiter">)</span>
extends <a href="#spire.std;SeqInnerProductSpace" title="spire.std.SeqInnerProductSpace[A,SA]">SeqInnerProductSpace</a><span class="delimiter">[</span>A, SA<span class="delimiter">]</span> with <a href="../algebra/CoordinateSpace.scala.html#spire.algebra;CoordinateSpace" title="spire.algebra.CoordinateSpace[SA,A]">CoordinateSpace</a><span class="delimiter">[</span>SA, A<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="(v: SA, i: Int)A" id="spire.std;SeqCoordinateSpace.coord">coord</a><span class="delimiter">(</span><a title="SA" id="spire.std;SeqCoordinateSpace.coord.v">v</a>: <a href="#spire.std;SeqCoordinateSpace;SA" title="SA">SA</a>, <a title="Int" id="spire.std;SeqCoordinateSpace.coord.i">i</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.std;SeqCoordinateSpace;A" title="A">A</a> = <a href="#spire.std;SeqCoordinateSpace.coord.v" title="(idx: Int)A">v</a><span class="delimiter">(</span><a href="#spire.std;SeqCoordinateSpace.coord.i" title="Int">i</a><span class="delimiter">)</span>

  override def <a title="(v: SA, w: SA)A" id="spire.std;SeqCoordinateSpace.dot">dot</a><span class="delimiter">(</span><a title="SA" id="spire.std;SeqCoordinateSpace.dot.v">v</a>: <a href="#spire.std;SeqCoordinateSpace;SA" title="SA">SA</a>, <a title="SA" id="spire.std;SeqCoordinateSpace.dot.w">w</a>: <a href="#spire.std;SeqCoordinateSpace;SA" title="SA">SA</a><span class="delimiter">)</span>: <a href="#spire.std;SeqCoordinateSpace;A" title="A">A</a> = super<span class="delimiter">[</span>SeqInnerProductSpace<span class="delimiter">]</span>.<a href="#spire.std;SeqInnerProductSpace.dot" title="(x: SA, y: SA)A">dot</a><span class="delimiter">(</span><a href="#spire.std;SeqCoordinateSpace.dot.v" title="SA">v</a>, <a href="#spire.std;SeqCoordinateSpace.dot.w" title="SA">w</a><span class="delimiter">)</span>

  def <a title="(i: Int)SA" id="spire.std;SeqCoordinateSpace.axis">axis</a><span class="delimiter">(</span><a title="Int" id="spire.std;SeqCoordinateSpace.axis.i">i</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.std;SeqCoordinateSpace;SA" title="SA">SA</a> = <span class="delimiter">{</span>
    val <a title="scala.collection.mutable.Builder[A,SA]" id="spire.std;SeqCoordinateSpace.axis.b">b</a> = <a href="#spire.std;SeqCoordinateSpace.cbf" title="()scala.collection.mutable.Builder[A,SA]">cbf</a><span class="delimiter">(</span><span class="delimiter">)</span>

    @tailrec def <a title="(j: Int)SA" id="spire.std;SeqCoordinateSpace.axis.loop">loop</a><span class="delimiter">(</span><a title="Int" id="spire.std;SeqCoordinateSpace.axis.loop.j">j</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#spire.std;SeqCoordinateSpace;SA" title="SA">SA</a> = if <span class="delimiter">(</span><a href="#spire.std;SeqCoordinateSpace.axis.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#spire.std;SeqCoordinateSpace.dimensions" title="=&gt; Int">dimensions</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.std;SeqCoordinateSpace.axis.b" title="scala.collection.mutable.Builder[A,SA]">b</a> <span title="(elem: A)b.type">+=</span> <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#spire.std;SeqCoordinateSpace.axis.i" title="Int">i</a> <span title="(x: Int)Boolean">==</span> <a href="#spire.std;SeqCoordinateSpace.axis.loop.j" title="Int">j</a><span class="delimiter">)</span> <a href="#spire.std;SeqVectorSpace.scalar" title="=&gt; spire.algebra.Field[A]">scalar</a>.<a href="../algebra/Multiplicative.scala.html#spire.algebra;MultiplicativeMonoid.one" title="=&gt; A">one</a> else <a href="#spire.std;SeqVectorSpace.scalar" title="=&gt; spire.algebra.Field[A]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span>
      <a href="#spire.std;SeqCoordinateSpace.axis.loop" title="(j: Int)SA">loop</a><span class="delimiter">(</span><a href="#spire.std;SeqCoordinateSpace.axis.loop.j" title="Int">j</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <a href="#spire.std;SeqCoordinateSpace.axis.b" title="scala.collection.mutable.Builder[A,SA]">b</a>.<span title="()SA">result</span>

    <a href="#spire.std;SeqCoordinateSpace.axis.loop" title="(j: Int)SA">loop</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * The L_p norm is equal to the `p`-th root of the sum of each element to the
 * power `p`. For instance, if `p = 1` we have the Manhattan distance. If you'd
 * like the Euclidean norm (`p = 2`), then you'd probably be best to use an
 * `InnerProductSpace` instead.
 */</span>
@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class SeqLpNormedVectorSpace[A, SA &lt;: scala.collection.SeqLike[A,SA]] extends spire.std.SeqVectorSpace[A,SA] with spire.algebra.NormedVectorSpace[SA,A] with Serializable" id="spire.std;SeqLpNormedVectorSpace">SeqLpNormedVectorSpace</a><span class="delimiter">[</span><a title="" id="spire.std;SeqLpNormedVectorSpace;A">A</a>: Field: NRoot: Signed, <a title=" &lt;: scala.collection.SeqLike[A,SA]" id="spire.std;SeqLpNormedVectorSpace;SA">SA</a> &lt;: SeqLike<span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>val <a title="Int" id="spire.std;SeqLpNormedVectorSpace.p">p</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[SA,A,SA]" id="spire.std;SeqLpNormedVectorSpace.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[SA,A,SA]">CanBuildFrom</span><span class="delimiter">[</span>SA,A,SA<span class="delimiter">]</span><span class="delimiter">)</span>
extends <a href="#spire.std;SeqVectorSpace" title="spire.std.SeqVectorSpace[A,SA]">SeqVectorSpace</a><span class="delimiter">[</span>A, SA<span class="delimiter">]</span> with <a href="../algebra/NormedVectorSpace.scala.html#spire.algebra;NormedVectorSpace" title="spire.algebra.NormedVectorSpace[SA,A]">NormedVectorSpace</a><span class="delimiter">[</span>SA, A<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#spire.std;SeqLpNormedVectorSpace.p" title="=&gt; Int">p</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span>, <span title="String(&quot;p must be &gt; 0&quot;)" class="string">&quot;p must be &gt; 0&quot;</span><span class="delimiter">)</span>

  def <a title="(v: SA)A" id="spire.std;SeqLpNormedVectorSpace.norm">norm</a><span class="delimiter">(</span><a title="SA" id="spire.std;SeqLpNormedVectorSpace.norm.v">v</a>: <a href="#spire.std;SeqLpNormedVectorSpace;SA" title="SA">SA</a><span class="delimiter">)</span>: <a href="#spire.std;SeqLpNormedVectorSpace;A" title="A">A</a> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(xi: Iterator[A], acc: A)A" id="spire.std;SeqLpNormedVectorSpace.norm.loop">loop</a><span class="delimiter">(</span><a title="Iterator[A]" id="spire.std;SeqLpNormedVectorSpace.norm.loop.xi">xi</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A" id="spire.std;SeqLpNormedVectorSpace.norm.loop.acc">acc</a>: <a href="#spire.std;SeqLpNormedVectorSpace;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.std;SeqLpNormedVectorSpace;A" title="A">A</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#spire.std;SeqLpNormedVectorSpace.norm.loop.xi" title="Iterator[A]">xi</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#spire.std;SeqLpNormedVectorSpace.norm.loop" title="(xi: Iterator[A], acc: A)A">loop</a><span class="delimiter">(</span><a href="#spire.std;SeqLpNormedVectorSpace.norm.loop.xi" title="Iterator[A]">xi</a>, <a href="#spire.std;SeqVectorSpace.scalar" title="=&gt; spire.algebra.Field[A]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveSemigroup.plus" title="(x: A, y: A)A">plus</a><span class="delimiter">(</span><a href="#spire.std;SeqLpNormedVectorSpace.norm.loop.acc" title="A">acc</a>, <a href="../algebra/Signed.scala.html#spire.algebra.Signed.apply" title="[A](implicit s: spire.algebra.Signed[A])spire.algebra.Signed[A]">Signed</a><a href="#spire.std;SeqLpNormedVectorSpace.evidence$5" title="(implicit s: spire.algebra.Signed[A])spire.algebra.Signed[A]" class="delimiter">[</a><a href="#spire.std;SeqLpNormedVectorSpace;A" title="A">A</a><span class="delimiter">]</span>.<a href="../algebra/Signed.scala.html#spire.algebra;Signed.abs" title="(a: A)A">abs</a><span class="delimiter">(</span><a href="#spire.std;SeqVectorSpace.scalar" title="=&gt; spire.algebra.Field[A]">scalar</a>.<a href="../algebra/Rig.scala.html#spire.algebra;Rig.pow" title="(a: A, n: Int)A">pow</a><span class="delimiter">(</span><a href="#spire.std;SeqLpNormedVectorSpace.norm.loop.xi" title="Iterator[A]">xi</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#spire.std;SeqLpNormedVectorSpace.p" title="=&gt; Int">p</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <a href="../algebra/NRoot.scala.html#spire.algebra.NRoot.apply" title="[A](implicit ev: spire.algebra.NRoot[A])spire.algebra.NRoot[A]">NRoot</a><a href="#spire.std;SeqLpNormedVectorSpace.evidence$4" title="(implicit ev: spire.algebra.NRoot[A])spire.algebra.NRoot[A]" class="delimiter">[</a><a href="#spire.std;SeqLpNormedVectorSpace;A" title="A">A</a><span class="delimiter">]</span>.<a href="../algebra/NRoot.scala.html#spire.algebra;NRoot.nroot" title="(a: A, n: Int)A">nroot</a><span class="delimiter">(</span><a href="#spire.std;SeqLpNormedVectorSpace.norm.loop.acc" title="A">acc</a>, <a href="#spire.std;SeqLpNormedVectorSpace.p" title="=&gt; Int">p</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="#spire.std;SeqLpNormedVectorSpace.norm.loop" title="(xi: Iterator[A], acc: A)A">loop</a><span class="delimiter">(</span><a href="#spire.std;SeqLpNormedVectorSpace.norm.v" title="SA">v</a>.<span title="=&gt; Iterator[A]">toIterator</span>, <a href="#spire.std;SeqVectorSpace.scalar" title="=&gt; spire.algebra.Field[A]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * The norm here uses the absolute maximum of the coordinates (ie. the L_inf
 * norm).
 */</span>
@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class SeqMaxNormedVectorSpace[A, SA &lt;: scala.collection.SeqLike[A,SA]] extends spire.std.SeqVectorSpace[A,SA] with spire.algebra.NormedVectorSpace[SA,A] with Serializable" id="spire.std;SeqMaxNormedVectorSpace">SeqMaxNormedVectorSpace</a><span class="delimiter">[</span><a title="" id="spire.std;SeqMaxNormedVectorSpace;A">A</a>: Field: Order: Signed, <a title=" &lt;: scala.collection.SeqLike[A,SA]" id="spire.std;SeqMaxNormedVectorSpace;SA">SA</a> &lt;: SeqLike<span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[SA,A,SA]" id="spire.std;SeqMaxNormedVectorSpace.cbf">cbf</a>: <span title="scala.collection.generic.CanBuildFrom[SA,A,SA]">CanBuildFrom</span><span class="delimiter">[</span>SA,A,SA<span class="delimiter">]</span><span class="delimiter">)</span> 
extends <a href="#spire.std;SeqVectorSpace" title="spire.std.SeqVectorSpace[A,SA]">SeqVectorSpace</a><span class="delimiter">[</span>A, SA<span class="delimiter">]</span> with <a href="../algebra/NormedVectorSpace.scala.html#spire.algebra;NormedVectorSpace" title="spire.algebra.NormedVectorSpace[SA,A]">NormedVectorSpace</a><span class="delimiter">[</span>SA, A<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="(v: SA)A" id="spire.std;SeqMaxNormedVectorSpace.norm">norm</a><span class="delimiter">(</span><a title="SA" id="spire.std;SeqMaxNormedVectorSpace.norm.v">v</a>: <a href="#spire.std;SeqMaxNormedVectorSpace;SA" title="SA">SA</a><span class="delimiter">)</span>: <a href="#spire.std;SeqMaxNormedVectorSpace;A" title="A">A</a> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(xi: Iterator[A], acc: A)A" id="spire.std;SeqMaxNormedVectorSpace.norm.loop">loop</a><span class="delimiter">(</span><a title="Iterator[A]" id="spire.std;SeqMaxNormedVectorSpace.norm.loop.xi">xi</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A" id="spire.std;SeqMaxNormedVectorSpace.norm.loop.acc">acc</a>: <a href="#spire.std;SeqMaxNormedVectorSpace;A" title="A">A</a><span class="delimiter">)</span>: <a href="#spire.std;SeqMaxNormedVectorSpace;A" title="A">A</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#spire.std;SeqMaxNormedVectorSpace.norm.loop.xi" title="Iterator[A]">xi</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="A" id="spire.std;SeqMaxNormedVectorSpace.norm.loop.x">x</a> = <a href="../algebra/Signed.scala.html#spire.algebra.Signed.apply" title="[A](implicit s: spire.algebra.Signed[A])spire.algebra.Signed[A]">Signed</a><a href="#spire.std;SeqMaxNormedVectorSpace.evidence$8" title="(implicit s: spire.algebra.Signed[A])spire.algebra.Signed[A]" class="delimiter">[</a><a href="#spire.std;SeqMaxNormedVectorSpace;A" title="A">A</a><span class="delimiter">]</span>.<a href="../algebra/Signed.scala.html#spire.algebra;Signed.abs" title="(a: A)A">abs</a><span class="delimiter">(</span><a href="#spire.std;SeqMaxNormedVectorSpace.norm.loop.xi" title="Iterator[A]">xi</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#spire.std;SeqMaxNormedVectorSpace.norm.loop" title="(xi: Iterator[A], acc: A)A">loop</a><span class="delimiter">(</span><a href="#spire.std;SeqMaxNormedVectorSpace.norm.loop.xi" title="Iterator[A]">xi</a>, if <span class="delimiter">(</span><a href="../algebra/Order.scala.html#spire.algebra.Order.apply" title="[A](implicit o: spire.algebra.Order[A])spire.algebra.Order[A]">Order</a><a href="#spire.std;SeqMaxNormedVectorSpace.evidence$7" title="(implicit o: spire.algebra.Order[A])spire.algebra.Order[A]" class="delimiter">[</a><a href="#spire.std;SeqMaxNormedVectorSpace;A" title="A">A</a><span class="delimiter">]</span>.<a href="../algebra/Order.scala.html#spire.algebra;Order.gt" title="(x: A, y: A)Boolean">gt</a><span class="delimiter">(</span><a href="#spire.std;SeqMaxNormedVectorSpace.norm.loop.x" title="A">x</a>, <a href="#spire.std;SeqMaxNormedVectorSpace.norm.loop.acc" title="A">acc</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#spire.std;SeqMaxNormedVectorSpace.norm.loop.x" title="A">x</a> else <a href="#spire.std;SeqMaxNormedVectorSpace.norm.loop.acc" title="A">acc</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <a href="#spire.std;SeqMaxNormedVectorSpace.norm.loop.acc" title="A">acc</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="#spire.std;SeqMaxNormedVectorSpace.norm.loop" title="(xi: Iterator[A], acc: A)A">loop</a><span class="delimiter">(</span><a href="#spire.std;SeqMaxNormedVectorSpace.norm.v" title="SA">v</a>.<span title="=&gt; Iterator[A]">toIterator</span>, <a href="#spire.std;SeqVectorSpace.scalar" title="=&gt; spire.algebra.Field[A]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

private object <a title="spire.std.SeqSupport.type" id="spire.std.SeqSupport">SeqSupport</a> <a href="#spire.std.SeqSupport" title="spire.std.SeqSupport.type" class="delimiter">{</a>
  @tailrec
  final def <a title="[A](x: Iterator[A], y: Iterator[A])(f: (A, A) =&gt; Boolean, g: A =&gt; Boolean)Boolean" id="spire.std.SeqSupport.forall(fd3bf97c8e)">forall</a><span class="delimiter">[</span><a title="" id="spire.std.SeqSupport.forall(fd3bf97c8e);A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterator[A]" id="spire.std.SeqSupport.forall(fd3bf97c8e).x">x</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Iterator[A]" id="spire.std.SeqSupport.forall(fd3bf97c8e).y">y</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, A) =&gt; Boolean" id="spire.std.SeqSupport.forall(fd3bf97c8e).f">f</a>: <span class="delimiter">(</span>A, A<span class="delimiter">)</span> =&gt; Boolean, <a title="A =&gt; Boolean" id="spire.std.SeqSupport.forall(fd3bf97c8e).g">g</a>: A =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#spire.std.SeqSupport.forall(fd3bf97c8e).x" title="Iterator[A]">x</a>.<span title="=&gt; Boolean">hasNext</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.SeqSupport.forall(fd3bf97c8e).y" title="Iterator[A]">y</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.std.SeqSupport.forall(fd3bf97c8e).f" title="(v1: A, v2: A)Boolean">f</a><span class="delimiter">(</span><a href="#spire.std.SeqSupport.forall(fd3bf97c8e).x" title="Iterator[A]">x</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#spire.std.SeqSupport.forall(fd3bf97c8e).y" title="Iterator[A]">y</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.SeqSupport.forall(fd3bf97c8e)" title="(x: Iterator[A], y: Iterator[A])(f: (A, A) =&gt; Boolean, g: A =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#spire.std.SeqSupport.forall(fd3bf97c8e).x" title="Iterator[A]">x</a>, <a href="#spire.std.SeqSupport.forall(fd3bf97c8e).y" title="Iterator[A]">y</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.std.SeqSupport.forall(fd3bf97c8e).f" title="(A, A) =&gt; Boolean">f</a>, <a href="#spire.std.SeqSupport.forall(fd3bf97c8e).g" title="A =&gt; Boolean">g</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.std.SeqSupport.forall(fd3bf97c8e).x" title="Iterator[A]">x</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.std.SeqSupport.forall(fd3bf97c8e).g" title="(v1: A)Boolean">g</a><span class="delimiter">(</span><a href="#spire.std.SeqSupport.forall(fd3bf97c8e).x" title="Iterator[A]">x</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.SeqSupport.forall(fd3bf97c8e)" title="(x: Iterator[A], y: Iterator[A])(f: (A, A) =&gt; Boolean, g: A =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#spire.std.SeqSupport.forall(fd3bf97c8e).x" title="Iterator[A]">x</a>, <a href="#spire.std.SeqSupport.forall(fd3bf97c8e).y" title="Iterator[A]">y</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.std.SeqSupport.forall(fd3bf97c8e).f" title="(A, A) =&gt; Boolean">f</a>, <a href="#spire.std.SeqSupport.forall(fd3bf97c8e).g" title="A =&gt; Boolean">g</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.std.SeqSupport.forall(fd3bf97c8e).y" title="Iterator[A]">y</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#spire.std.SeqSupport.forall(fd3bf97c8e).g" title="(v1: A)Boolean">g</a><span class="delimiter">(</span><a href="#spire.std.SeqSupport.forall(fd3bf97c8e).y" title="Iterator[A]">y</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std.SeqSupport.forall(fd3bf97c8e)" title="(x: Iterator[A], y: Iterator[A])(f: (A, A) =&gt; Boolean, g: A =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#spire.std.SeqSupport.forall(fd3bf97c8e).x" title="Iterator[A]">x</a>, <a href="#spire.std.SeqSupport.forall(fd3bf97c8e).y" title="Iterator[A]">y</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.std.SeqSupport.forall(fd3bf97c8e).f" title="(A, A) =&gt; Boolean">f</a>, <a href="#spire.std.SeqSupport.forall(fd3bf97c8e).g" title="A =&gt; Boolean">g</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      true
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  private val <a title="Any =&gt; Boolean" id="spire.std.SeqSupport.falsef">falsef</a>: Any =&gt; Boolean = <a title="Any" id="spire.std.SeqSupport.falsef.$anonfun.x$2">_</a> =&gt; false

  @inline final def <a title="[A, SA &lt;: scala.collection.SeqLike[A,SA]](x: SA, y: SA)(f: (A, A) =&gt; Boolean, g: A =&gt; Boolean)Boolean" id="spire.std.SeqSupport.forall(1280dd75c5)">forall</a><span class="delimiter">[</span><a title="" id="spire.std.SeqSupport.forall$default$4;A">A</a>, <a title=" &lt;: scala.collection.SeqLike[A,SA]" id="spire.std.SeqSupport.forall$default$4;SA">SA</a> &lt;: SeqLike<span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="SA" id="spire.std.SeqSupport.forall$default$4.x">x</a>: <a href="#spire.std.SeqSupport.forall$default$4;SA" title="SA">SA</a>, <a title="SA" id="spire.std.SeqSupport.forall$default$4.y">y</a>: <a href="#spire.std.SeqSupport.forall$default$4;SA" title="SA">SA</a><span class="delimiter">)</span><span class="delimiter">(</span>
      <a title="(A, A) =&gt; Boolean" id="spire.std.SeqSupport.forall(1280dd75c5).f">f</a>: <span class="delimiter">(</span>A, A<span class="delimiter">)</span> =&gt; Boolean, <a title="A =&gt; Boolean" id="spire.std.SeqSupport.forall$default$4">g</a>: A =&gt; Boolean = <a href="#spire.std.SeqSupport.falsef" title="=&gt; Any =&gt; Boolean">falsef</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <a href="#spire.std.SeqSupport.forall(fd3bf97c8e)" title="(x: Iterator[A], y: Iterator[A])(f: (A, A) =&gt; Boolean, g: A =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#spire.std.SeqSupport.forall$default$4.x" title="SA">x</a>.<span title="=&gt; Iterator[A]">toIterator</span>, <a href="#spire.std.SeqSupport.forall$default$4.y" title="SA">y</a>.<span title="=&gt; Iterator[A]">toIterator</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#spire.std.SeqSupport.forall(1280dd75c5).f" title="(A, A) =&gt; Boolean">f</a>, <a href="#spire.std.SeqSupport.forall$default$4" title="A =&gt; Boolean">g</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

import <a href="#spire.std.SeqSupport" title="spire.std.SeqSupport.type">SeqSupport</a>._

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class SeqEq[A, SA &lt;: scala.collection.SeqLike[A,SA]] extends AnyRef with spire.algebra.Eq[SA] with Serializable" id="spire.std;SeqEq">SeqEq</a><span class="delimiter">[</span><a title="" id="spire.std;SeqEq;A">A</a>: Eq, <a title=" &lt;: scala.collection.SeqLike[A,SA]" id="spire.std;SeqEq;SA">SA</a> &lt;: SeqLike<span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">]</span> extends <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[SA]">Eq</a><span class="delimiter">[</span>SA<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="(x: SA, y: SA)Boolean" id="spire.std;SeqEq.eqv">eqv</a><span class="delimiter">(</span><a title="SA" id="spire.std;SeqEq.eqv.x">x</a>: <a href="#spire.std;SeqEq;SA" title="SA">SA</a>, <a title="SA" id="spire.std;SeqEq.eqv.y">y</a>: <a href="#spire.std;SeqEq;SA" title="SA">SA</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#spire.std.SeqSupport" title="spire.std.SeqSupport.type">forall</a><span title="(x: SA, y: SA)(f: (A, A) =&gt; Boolean, g: A =&gt; Boolean)Boolean" class="delimiter">[</span><a href="#spire.std;SeqEq;A" title="A">A</a>, <a href="#spire.std;SeqEq;SA" title="SA">SA</a><span class="delimiter">]</span><a href="#spire.std.SeqSupport.forall$default$4" title="Any =&gt; Boolean @scala.reflect.internal.annotations.uncheckedBounds" id="spire.std;SeqEq.eqv.x$11" class="delimiter">(</a><a href="#spire.std;SeqEq.eqv.x" title="SA" id="spire.std;SeqEq.eqv.x$8">x</a>, <a href="#spire.std;SeqEq.eqv.y" title="SA" id="spire.std;SeqEq.eqv.x$9">y</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../algebra/Eq.scala.html#spire.algebra.Eq.apply" title="[A](implicit e: spire.algebra.Eq[A])spire.algebra.Eq[A]">Eq</a><a href="#spire.std;SeqEq.evidence$9" title="(implicit e: spire.algebra.Eq[A])spire.algebra.Eq[A]" class="delimiter">[</a><a href="#spire.std;SeqEq;A" title="A">A</a><span class="delimiter">]</span>.<a href="../algebra/Eq.scala.html#spire.algebra;Eq.eqv" title="(x: A, y: A)Boolean">eqv</a><a title="(A, A) =&gt; Boolean @scala.reflect.internal.annotations.uncheckedBounds" id="spire.std;SeqEq.eqv.x$10" class="delimiter">(</a><a href="#spire.std;SeqEq.eqv.x$10.$anonfun.x$3" title="A">_</a>, <a href="#spire.std;SeqEq.eqv.x$10.$anonfun.x$4" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class SeqOrder[A, SA &lt;: scala.collection.SeqLike[A,SA]] extends spire.std.SeqEq[A,SA] with spire.algebra.Order[SA] with Serializable" id="spire.std;SeqOrder">SeqOrder</a><span class="delimiter">[</span><a title="" id="spire.std;SeqOrder;A">A</a>: Order, <a title=" &lt;: scala.collection.SeqLike[A,SA]" id="spire.std;SeqOrder;SA">SA</a> &lt;: SeqLike<span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">]</span> extends <a href="#spire.std;SeqEq" title="spire.std.SeqEq[A,SA]">SeqEq</a><span class="delimiter">[</span>A, SA<span class="delimiter">]</span> with <a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[SA]">Order</a><span class="delimiter">[</span>SA<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  override def <a title="(x: SA, y: SA)Boolean" id="spire.std;SeqOrder.eqv">eqv</a><span class="delimiter">(</span><a title="SA" id="spire.std;SeqOrder.eqv.x">x</a>: <a href="#spire.std;SeqOrder;SA" title="SA">SA</a>, <a title="SA" id="spire.std;SeqOrder.eqv.y">y</a>: <a href="#spire.std;SeqOrder;SA" title="SA">SA</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = super<span class="delimiter">[</span>SeqEq<span class="delimiter">]</span>.<a href="#spire.std;SeqEq.eqv" title="(x: SA, y: SA)Boolean">eqv</a><span class="delimiter">(</span><a href="#spire.std;SeqOrder.eqv.x" title="SA">x</a>, <a href="#spire.std;SeqOrder.eqv.y" title="SA">y</a><span class="delimiter">)</span>

  def <a title="(x: SA, y: SA)Int" id="spire.std;SeqOrder.compare">compare</a><span class="delimiter">(</span><a title="SA" id="spire.std;SeqOrder.compare.x">x</a>: <a href="#spire.std;SeqOrder;SA" title="SA">SA</a>, <a title="SA" id="spire.std;SeqOrder.compare.y">y</a>: <a href="#spire.std;SeqOrder;SA" title="SA">SA</a><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(xi: Iterator[A], yi: Iterator[A])Int" id="spire.std;SeqOrder.compare.loop">loop</a><span class="delimiter">(</span><a title="Iterator[A]" id="spire.std;SeqOrder.compare.loop.xi">xi</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Iterator[A]" id="spire.std;SeqOrder.compare.loop.yi">yi</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#spire.std;SeqOrder.compare.loop.xi" title="Iterator[A]">xi</a>.<span title="=&gt; Boolean">hasNext</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std;SeqOrder.compare.loop.yi" title="Iterator[A]">yi</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="Int" id="spire.std;SeqOrder.compare.loop.cmp">cmp</a> = <a href="../algebra/Order.scala.html#spire.algebra.Order.apply" title="[A](implicit o: spire.algebra.Order[A])spire.algebra.Order[A]">Order</a><a href="#spire.std;SeqOrder.evidence$10" title="(implicit o: spire.algebra.Order[A])spire.algebra.Order[A]" class="delimiter">[</a><a href="#spire.std;SeqOrder;A" title="A">A</a><span class="delimiter">]</span>.<a href="../algebra/Order.scala.html#spire.algebra;Order.compare" title="(x: A, y: A)Int">compare</a><span class="delimiter">(</span><a href="#spire.std;SeqOrder.compare.loop.xi" title="Iterator[A]">xi</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#spire.std;SeqOrder.compare.loop.yi" title="Iterator[A]">yi</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#spire.std;SeqOrder.compare.loop.cmp" title="Int">cmp</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#spire.std;SeqOrder.compare.loop" title="(xi: Iterator[A], yi: Iterator[A])Int">loop</a><span class="delimiter">(</span><a href="#spire.std;SeqOrder.compare.loop.xi" title="Iterator[A]">xi</a>, <a href="#spire.std;SeqOrder.compare.loop.yi" title="Iterator[A]">yi</a><span class="delimiter">)</span> else <a href="#spire.std;SeqOrder.compare.loop.cmp" title="Int">cmp</a>
      <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.std;SeqOrder.compare.loop.xi" title="Iterator[A]">xi</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Int(1)" class="int">1</span>
      <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.std;SeqOrder.compare.loop.yi" title="Iterator[A]">yi</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        -<span title="Int(-1)" class="int">1</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <span title="Int(0)" class="int">0</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="#spire.std;SeqOrder.compare.loop" title="(xi: Iterator[A], yi: Iterator[A])Int">loop</a><span class="delimiter">(</span><a href="#spire.std;SeqOrder.compare.x" title="SA">x</a>.<span title="=&gt; Iterator[A]">toIterator</span>, <a href="#spire.std;SeqOrder.compare.y" title="SA">y</a>.<span title="=&gt; Iterator[A]">toIterator</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class SeqVectorEq[A, SA &lt;: scala.collection.SeqLike[A,SA]] extends AnyRef with spire.algebra.Eq[SA] with Serializable" id="spire.std;SeqVectorEq">SeqVectorEq</a><span class="delimiter">[</span><a title="" id="spire.std;SeqVectorEq;A">A</a>: Eq, <a title=" &lt;: scala.collection.SeqLike[A,SA]" id="spire.std;SeqVectorEq;SA">SA</a> &lt;: SeqLike<span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveMonoid[A]" id="spire.std;SeqVectorEq.scalar">scalar</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>
extends <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[SA]">Eq</a><span class="delimiter">[</span>SA<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  def <a title="(x: SA, y: SA)Boolean" id="spire.std;SeqVectorEq.eqv">eqv</a><span class="delimiter">(</span><a title="SA" id="spire.std;SeqVectorEq.eqv.x">x</a>: <a href="#spire.std;SeqVectorEq;SA" title="SA">SA</a>, <a title="SA" id="spire.std;SeqVectorEq.eqv.y">y</a>: <a href="#spire.std;SeqVectorEq;SA" title="SA">SA</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#spire.std.SeqSupport.forall(1280dd75c5)" title="[A, SA &lt;: scala.collection.SeqLike[A,SA]](x: SA, y: SA)(f: (A, A) =&gt; Boolean, g: A =&gt; Boolean)Boolean">forall</a><span title="(x: SA, y: SA)(f: (A, A) =&gt; Boolean, g: A =&gt; Boolean)Boolean" class="delimiter">[</span><a href="#spire.std;SeqVectorEq;A" title="A">A</a>, <a href="#spire.std;SeqVectorEq;SA" title="SA">SA</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#spire.std;SeqVectorEq.eqv.x" title="SA">x</a>, <a href="#spire.std;SeqVectorEq.eqv.y" title="SA">y</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../algebra/Eq.scala.html#spire.algebra.Eq.apply" title="[A](implicit e: spire.algebra.Eq[A])spire.algebra.Eq[A]">Eq</a><a href="#spire.std;SeqVectorEq.evidence$11" title="(implicit e: spire.algebra.Eq[A])spire.algebra.Eq[A]" class="delimiter">[</a><a href="#spire.std;SeqVectorEq;A" title="A">A</a><span class="delimiter">]</span>.<a href="../algebra/Eq.scala.html#spire.algebra;Eq.eqv" title="(x: A, y: A)Boolean">eqv</a><span class="delimiter">(</span><a href="#spire.std;SeqVectorEq.eqv.$anonfun.x$5" title="A">_</a>, <a href="#spire.std;SeqVectorEq.eqv.$anonfun.x$6" title="A">_</a><span class="delimiter">)</span>, <a href="../algebra/Eq.scala.html#spire.algebra.Eq.apply" title="[A](implicit e: spire.algebra.Eq[A])spire.algebra.Eq[A]">Eq</a><a href="#spire.std;SeqVectorEq.evidence$11" title="(implicit e: spire.algebra.Eq[A])spire.algebra.Eq[A]" class="delimiter">[</a><a href="#spire.std;SeqVectorEq;A" title="A">A</a><span class="delimiter">]</span>.<a href="../algebra/Eq.scala.html#spire.algebra;Eq.eqv" title="(x: A, y: A)Boolean">eqv</a><span class="delimiter">(</span><a href="#spire.std;SeqVectorEq.eqv.$anonfun.x$7" title="A">_</a>, <a href="#spire.std;SeqVectorEq.scalar" title="spire.algebra.AdditiveMonoid[A]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span><span class="delimiter">)</span>
class <a title="class SeqVectorOrder[A, SA &lt;: scala.collection.SeqLike[A,SA]] extends spire.std.SeqVectorEq[A,SA] with spire.algebra.Order[SA] with Serializable" id="spire.std;SeqVectorOrder">SeqVectorOrder</a><span class="delimiter">[</span><a title="" id="spire.std;SeqVectorOrder;A">A</a>: Order, <a title=" &lt;: scala.collection.SeqLike[A,SA]" id="spire.std;SeqVectorOrder;SA">SA</a> &lt;: SeqLike<span class="delimiter">[</span>A, SA<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.AdditiveMonoid[A]" id="spire.std;SeqVectorOrder.scalar">scalar</a>: <a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid" title="spire.algebra.AdditiveMonoid[A]">AdditiveMonoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>
extends <a href="#spire.std;SeqVectorEq" title="spire.std.SeqVectorEq[A,SA]">SeqVectorEq</a><span class="delimiter">[</span>A, SA<span class="delimiter">]</span> with <a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[SA]">Order</a><span class="delimiter">[</span>SA<span class="delimiter">]</span> with <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
  override def <a title="(x: SA, y: SA)Boolean" id="spire.std;SeqVectorOrder.eqv">eqv</a><span class="delimiter">(</span><a title="SA" id="spire.std;SeqVectorOrder.eqv.x">x</a>: <a href="#spire.std;SeqVectorOrder;SA" title="SA">SA</a>, <a title="SA" id="spire.std;SeqVectorOrder.eqv.y">y</a>: <a href="#spire.std;SeqVectorOrder;SA" title="SA">SA</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = super<span class="delimiter">[</span>SeqVectorEq<span class="delimiter">]</span>.<a href="#spire.std;SeqVectorEq.eqv" title="(x: SA, y: SA)Boolean">eqv</a><span class="delimiter">(</span><a href="#spire.std;SeqVectorOrder.eqv.x" title="SA">x</a>, <a href="#spire.std;SeqVectorOrder.eqv.y" title="SA">y</a><span class="delimiter">)</span>

  def <a title="(x: SA, y: SA)Int" id="spire.std;SeqVectorOrder.compare">compare</a><span class="delimiter">(</span><a title="SA" id="spire.std;SeqVectorOrder.compare.x">x</a>: <a href="#spire.std;SeqVectorOrder;SA" title="SA">SA</a>, <a title="SA" id="spire.std;SeqVectorOrder.compare.y">y</a>: <a href="#spire.std;SeqVectorOrder;SA" title="SA">SA</a><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(xi: Iterator[A], yi: Iterator[A])Int" id="spire.std;SeqVectorOrder.compare.loop">loop</a><span class="delimiter">(</span><a title="Iterator[A]" id="spire.std;SeqVectorOrder.compare.loop.xi">xi</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Iterator[A]" id="spire.std;SeqVectorOrder.compare.loop.yi">yi</a>: <span title="Iterator[A]">Iterator</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#spire.std;SeqVectorOrder.compare.loop.xi" title="Iterator[A]">xi</a>.<span title="=&gt; Boolean">hasNext</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#spire.std;SeqVectorOrder.compare.loop.yi" title="Iterator[A]">yi</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="Int" id="spire.std;SeqVectorOrder.compare.loop.cmp">cmp</a> = <a href="../algebra/Order.scala.html#spire.algebra.Order.apply" title="[A](implicit o: spire.algebra.Order[A])spire.algebra.Order[A]">Order</a><a href="#spire.std;SeqVectorOrder.evidence$12" title="(implicit o: spire.algebra.Order[A])spire.algebra.Order[A]" class="delimiter">[</a><a href="#spire.std;SeqVectorOrder;A" title="A">A</a><span class="delimiter">]</span>.<a href="../algebra/Order.scala.html#spire.algebra;Order.compare" title="(x: A, y: A)Int">compare</a><span class="delimiter">(</span><a href="#spire.std;SeqVectorOrder.compare.loop.xi" title="Iterator[A]">xi</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#spire.std;SeqVectorOrder.compare.loop.yi" title="Iterator[A]">yi</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#spire.std;SeqVectorOrder.compare.loop.cmp" title="Int">cmp</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#spire.std;SeqVectorOrder.compare.loop" title="(xi: Iterator[A], yi: Iterator[A])Int">loop</a><span class="delimiter">(</span><a href="#spire.std;SeqVectorOrder.compare.loop.xi" title="Iterator[A]">xi</a>, <a href="#spire.std;SeqVectorOrder.compare.loop.yi" title="Iterator[A]">yi</a><span class="delimiter">)</span> else <a href="#spire.std;SeqVectorOrder.compare.loop.cmp" title="Int">cmp</a>
      <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.std;SeqVectorOrder.compare.loop.xi" title="Iterator[A]">xi</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="../algebra/Order.scala.html#spire.algebra.Order.apply" title="[A](implicit o: spire.algebra.Order[A])spire.algebra.Order[A]">Order</a><a href="#spire.std;SeqVectorOrder.evidence$12" title="(implicit o: spire.algebra.Order[A])spire.algebra.Order[A]" class="delimiter">[</a><a href="#spire.std;SeqVectorOrder;A" title="A">A</a><span class="delimiter">]</span>.<a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: A, y: A)Boolean">eqv</a><span class="delimiter">(</span><a href="#spire.std;SeqVectorOrder.compare.loop.xi" title="Iterator[A]">xi</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#spire.std;SeqVectorOrder.scalar" title="spire.algebra.AdditiveMonoid[A]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#spire.std;SeqVectorOrder.compare.loop" title="(xi: Iterator[A], yi: Iterator[A])Int">loop</a><span class="delimiter">(</span><a href="#spire.std;SeqVectorOrder.compare.loop.xi" title="Iterator[A]">xi</a>, <a href="#spire.std;SeqVectorOrder.compare.loop.yi" title="Iterator[A]">yi</a><span class="delimiter">)</span> else <span title="Int(1)" class="int">1</span>
      <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#spire.std;SeqVectorOrder.compare.loop.yi" title="Iterator[A]">yi</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="../algebra/Order.scala.html#spire.algebra.Order.apply" title="[A](implicit o: spire.algebra.Order[A])spire.algebra.Order[A]">Order</a><a href="#spire.std;SeqVectorOrder.evidence$12" title="(implicit o: spire.algebra.Order[A])spire.algebra.Order[A]" class="delimiter">[</a><a href="#spire.std;SeqVectorOrder;A" title="A">A</a><span class="delimiter">]</span>.<a href="../algebra/Order.scala.html#spire.algebra;Order.eqv" title="(x: A, y: A)Boolean">eqv</a><span class="delimiter">(</span><a href="#spire.std;SeqVectorOrder.compare.loop.yi" title="Iterator[A]">yi</a>.<span title="()A">next</span><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#spire.std;SeqVectorOrder.scalar" title="spire.algebra.AdditiveMonoid[A]">scalar</a>.<a href="../algebra/Additive.scala.html#spire.algebra;AdditiveMonoid.zero" title="=&gt; A">zero</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#spire.std;SeqVectorOrder.compare.loop" title="(xi: Iterator[A], yi: Iterator[A])Int">loop</a><span class="delimiter">(</span><a href="#spire.std;SeqVectorOrder.compare.loop.xi" title="Iterator[A]">xi</a>, <a href="#spire.std;SeqVectorOrder.compare.loop.yi" title="Iterator[A]">yi</a><span class="delimiter">)</span> else -<span title="Int(-1)" class="int">1</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <span title="Int(0)" class="int">0</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="#spire.std;SeqVectorOrder.compare.loop" title="(xi: Iterator[A], yi: Iterator[A])Int">loop</a><span class="delimiter">(</span><a href="#spire.std;SeqVectorOrder.compare.x" title="SA">x</a>.<span title="=&gt; Iterator[A]">toIterator</span>, <a href="#spire.std;SeqVectorOrder.compare.y" title="SA">y</a>.<span title="=&gt; Iterator[A]">toIterator</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

trait <a title="trait SeqInstances0 extends AnyRef" id="spire.std;SeqInstances0">SeqInstances0</a> <span title="Unit" class="delimiter">{</span>
  implicit def <a title="[A, CC[A] &lt;: scala.collection.SeqLike[A,CC[A]]](implicit ring0: spire.algebra.Ring[A], implicit cbf0: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]], implicit ev: spire.NoImplicit[spire.algebra.VectorSpace[CC[A],A]])spire.std.SeqModule[A,CC[A]]" id="spire.std;SeqInstances0.SeqModule">SeqModule</a><span class="delimiter">[</span><a title="" id="spire.std;SeqInstances0.SeqModule;A">A</a>, <a title="[A] &lt;: scala.collection.SeqLike[A,CC[A]]" id="spire.std;SeqInstances0.SeqModule;CC">CC</a><span class="delimiter">[</span><a title="" id="spire.std;SeqInstances0.SeqModule;CC;A">A</a><span class="delimiter">]</span> &lt;: SeqLike<span class="delimiter">[</span>A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>implicit
      <a title="spire.algebra.Ring[A]" id="spire.std;SeqInstances0.SeqModule.ring0">ring0</a>: <a href="../algebra/Ring.scala.html#spire.algebra;Ring" title="spire.algebra.Ring[A]">Ring</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" id="spire.std;SeqInstances0.SeqModule.cbf0">cbf0</a>: <span title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>,
      <a title="spire.NoImplicit[spire.algebra.VectorSpace[CC[A],A]]" id="spire.std;SeqInstances0.SeqModule.ev">ev</a>: <a href="../NoImplicit.scala.html#spire;NoImplicit" title="spire.NoImplicit[spire.algebra.VectorSpace[CC[A],A]]">NoImplicit</a><span class="delimiter">[</span>VectorSpace<span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = new <a href="#spire.std;SeqModule" title="spire.std.SeqModule[A,CC[A]]">SeqModule</a><span class="delimiter">[</span>A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

trait <a title="trait SeqInstances1 extends AnyRef with spire.std.SeqInstances0" id="spire.std;SeqInstances1">SeqInstances1</a> extends <a href="#spire.std;SeqInstances0" title="spire.std.SeqInstances0">SeqInstances0</a> <span class="delimiter">{</span>
  implicit def <a title="[A, CC[A] &lt;: scala.collection.SeqLike[A,CC[A]]](implicit field0: spire.algebra.Field[A], implicit cbf0: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]], implicit ev: spire.NoImplicit[spire.algebra.NormedVectorSpace[CC[A],A]])spire.std.SeqVectorSpace[A,CC[A]]" id="spire.std;SeqInstances1.SeqVectorSpace">SeqVectorSpace</a><span class="delimiter">[</span><a title="" id="spire.std;SeqInstances1.SeqVectorSpace;A">A</a>, <a title="[A] &lt;: scala.collection.SeqLike[A,CC[A]]" id="spire.std;SeqInstances1.SeqVectorSpace;CC">CC</a><span class="delimiter">[</span><a title="" id="spire.std;SeqInstances1.SeqVectorSpace;CC;A">A</a><span class="delimiter">]</span> &lt;: SeqLike<span class="delimiter">[</span>A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.std;SeqInstances1.SeqVectorSpace.field0">field0</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>,
      <a title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" id="spire.std;SeqInstances1.SeqVectorSpace.cbf0">cbf0</a>: <span title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>,
      <a title="spire.NoImplicit[spire.algebra.NormedVectorSpace[CC[A],A]]" id="spire.std;SeqInstances1.SeqVectorSpace.ev">ev</a>: <a href="../NoImplicit.scala.html#spire;NoImplicit" title="spire.NoImplicit[spire.algebra.NormedVectorSpace[CC[A],A]]">NoImplicit</a><span class="delimiter">[</span>NormedVectorSpace<span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = new <a href="#spire.std;SeqVectorSpace" title="spire.std.SeqVectorSpace[A,CC[A]]">SeqVectorSpace</a><span class="delimiter">[</span>A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>

  implicit def <a title="[A, CC[A] &lt;: scala.collection.SeqLike[A,CC[A]]](implicit A0: spire.algebra.Eq[A])spire.std.SeqEq[A,CC[A]]" id="spire.std;SeqInstances1.SeqEq">SeqEq</a><span class="delimiter">[</span><a title="" id="spire.std;SeqInstances1.SeqEq;A">A</a>, <a title="[A] &lt;: scala.collection.SeqLike[A,CC[A]]" id="spire.std;SeqInstances1.SeqEq;CC">CC</a><span class="delimiter">[</span><a title="" id="spire.std;SeqInstances1.SeqEq;CC;A">A</a><span class="delimiter">]</span> &lt;: SeqLike<span class="delimiter">[</span>A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Eq[A]" id="spire.std;SeqInstances1.SeqEq.A0">A0</a>: <a href="../algebra/Eq.scala.html#spire.algebra;Eq" title="spire.algebra.Eq[A]">Eq</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> =
    new <a href="#spire.std;SeqEq" title="spire.std.SeqEq[A,CC[A]]">SeqEq</a><span class="delimiter">[</span>A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

trait <a title="trait SeqInstances2 extends AnyRef with spire.std.SeqInstances1" id="spire.std;SeqInstances2">SeqInstances2</a> extends <a href="#spire.std;SeqInstances1" title="spire.std.SeqInstances1">SeqInstances1</a> <span class="delimiter">{</span>
  implicit def <a title="[A, CC[A] &lt;: scala.collection.SeqLike[A,CC[A]]](implicit field0: spire.algebra.Field[A], implicit cbf0: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])spire.std.SeqInnerProductSpace[A,CC[A]]" id="spire.std;SeqInstances2.SeqInnerProductSpace">SeqInnerProductSpace</a><span class="delimiter">[</span><a title="" id="spire.std;SeqInstances2.SeqInnerProductSpace;A">A</a>, <a title="[A] &lt;: scala.collection.SeqLike[A,CC[A]]" id="spire.std;SeqInstances2.SeqInnerProductSpace;CC">CC</a><span class="delimiter">[</span><a title="" id="spire.std;SeqInstances2.SeqInnerProductSpace;CC;A">A</a><span class="delimiter">]</span> &lt;: SeqLike<span class="delimiter">[</span>A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.std;SeqInstances2.SeqInnerProductSpace.field0">field0</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>,
      <a title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" id="spire.std;SeqInstances2.SeqInnerProductSpace.cbf0">cbf0</a>: <span title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = new <a href="#spire.std;SeqInnerProductSpace" title="spire.std.SeqInnerProductSpace[A,CC[A]]">SeqInnerProductSpace</a><span class="delimiter">[</span>A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>

  implicit def <a title="[A, CC[A] &lt;: scala.collection.SeqLike[A,CC[A]]](implicit A0: spire.algebra.Order[A])spire.std.SeqOrder[A,CC[A]]" id="spire.std;SeqInstances2.SeqOrder">SeqOrder</a><span class="delimiter">[</span><a title="" id="spire.std;SeqInstances2.SeqOrder;A">A</a>, <a title="[A] &lt;: scala.collection.SeqLike[A,CC[A]]" id="spire.std;SeqInstances2.SeqOrder;CC">CC</a><span class="delimiter">[</span><a title="" id="spire.std;SeqInstances2.SeqOrder;CC;A">A</a><span class="delimiter">]</span> &lt;: SeqLike<span class="delimiter">[</span>A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Order[A]" id="spire.std;SeqInstances2.SeqOrder.A0">A0</a>: <a href="../algebra/Order.scala.html#spire.algebra;Order" title="spire.algebra.Order[A]">Order</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> =
    new <a href="#spire.std;SeqOrder" title="spire.std.SeqOrder[A,CC[A]]">SeqOrder</a><span class="delimiter">[</span>A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

trait <a title="trait SeqInstances3 extends AnyRef with spire.std.SeqInstances2" id="spire.std;SeqInstances3">SeqInstances3</a> extends <a href="#spire.std;SeqInstances2" title="spire.std.SeqInstances2">SeqInstances2</a> <span class="delimiter">{</span>
  implicit def <a title="[A, CC[A] &lt;: scala.collection.SeqLike[A,CC[A]]](implicit field0: spire.algebra.Field[A], implicit nroot0: spire.algebra.NRoot[A], implicit cbf0: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])spire.algebra.NormedVectorSpace[CC[A],A]" id="spire.std;SeqInstances3.SeqNormedVectorSpace">SeqNormedVectorSpace</a><span class="delimiter">[</span><a title="" id="spire.std;SeqInstances3.SeqNormedVectorSpace;A">A</a>, <a title="[A] &lt;: scala.collection.SeqLike[A,CC[A]]" id="spire.std;SeqInstances3.SeqNormedVectorSpace;CC">CC</a><span class="delimiter">[</span><a title="" id="spire.std;SeqInstances3.SeqNormedVectorSpace;CC;A">A</a><span class="delimiter">]</span> &lt;: SeqLike<span class="delimiter">[</span>A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="spire.algebra.Field[A]" id="spire.std;SeqInstances3.SeqNormedVectorSpace.field0">field0</a>: <a href="../algebra/Field.scala.html#spire.algebra;Field" title="spire.algebra.Field[A]">Field</a><span class="delimiter">[</span>A<span class="delimiter">]</span>,
      <a title="spire.algebra.NRoot[A]" id="spire.std;SeqInstances3.SeqNormedVectorSpace.nroot0">nroot0</a>: <a href="../algebra/NRoot.scala.html#spire.algebra;NRoot" title="spire.algebra.NRoot[A]">NRoot</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]" id="spire.std;SeqInstances3.SeqNormedVectorSpace.cbf0">cbf0</a>: <span title="scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]]">CanBuildFrom</span><span class="delimiter">[</span>CC<span class="delimiter">[</span>A<span class="delimiter">]</span>, A, CC<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#spire.std;SeqInstances2.SeqInnerProductSpace" title="[A, CC[A] &lt;: scala.collection.SeqLike[A,CC[A]]](implicit field0: spire.algebra.Field[A], implicit cbf0: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])spire.std.SeqInnerProductSpace[A,CC[A]]">SeqInnerProductSpace</a><a href="#spire.std;SeqInstances3.SeqNormedVectorSpace.field0" title="(implicit field0: spire.algebra.Field[A], implicit cbf0: scala.collection.generic.CanBuildFrom[CC[A],A,CC[A]])spire.std.SeqInnerProductSpace[A,CC[A]]" class="delimiter">[</a><a href="#spire.std;SeqInstances3.SeqNormedVectorSpace;A" title="A">A</a>, <a href="#spire.std;SeqInstances3.SeqNormedVectorSpace;CC" title="CC">CC</a><span class="delimiter">]</span>.<a href="../algebra/InnerProductSpace.scala.html#spire.algebra;InnerProductSpace.normed" title="(implicit ev: spire.algebra.NRoot[A])spire.algebra.NormedVectorSpace[CC[A],A]">normed</a>
<span class="delimiter">}</span>

trait <a title="trait SeqInstances extends AnyRef with spire.std.SeqInstances3" id="spire.std;SeqInstances">SeqInstances</a> extends <a href="#spire.std;SeqInstances3" title="spire.std.SeqInstances3">SeqInstances3</a>

        </pre>
    </body>
</html>
