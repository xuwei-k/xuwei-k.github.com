<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scalaz-stream/scalaz/stream/process1.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scalaz.stream

import scala.annotation.tailrec
import scalaz.<span title="scalaz.\/.type">\/</span>._
import scalaz._
import scalaz.syntax.<span title="scalaz.syntax.equal.type">equal</span>._

import <a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>._
import <a href="Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>._
import <a href="Util.scala.html#scalaz.stream.Util" title="scalaz.stream.Util.type">Util</a>._

object <a title="scalaz.stream.process1.type" id="scalaz.stream.process1">process1</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type" class="delimiter">{</a>

  <span class="comment">// nb: methods are in alphabetical order, there are going to be so many that</span>
  <span class="comment">// any other order will just going get confusing</span>

  <span class="comment">/** Await a single value, returning `None` if the input has been exhausted. */</span>
  def <a title="[I]=&gt; scalaz.stream.Process1[I,Option[I]]" id="scalaz.stream.process1.awaitOption">awaitOption</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.awaitOption;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Option[I]]">Process1</a><span class="delimiter">[</span>I, Option<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[I,Option[I]])(rcv: I =&gt; scalaz.stream.Process1[I,Option[I]])scalaz.stream.Process1[I,Option[I]]" class="delimiter">[</span><a href="#scalaz.stream.process1.awaitOption;I" title="I">I</a>, <span title="Option[I]">Option</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: None.type)scalaz.stream.Process0[None.type]">emit</a><span class="delimiter">(</span><span title="None.type">None</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.awaitOption.$anonfun.i">i</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: Some[I])scalaz.stream.Process0[Some[I]]">emit</a><span class="delimiter">(</span><span title="(x: I)Some[I]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.awaitOption.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Behaves like the identity process, but requests `n` elements at a time from its input. */</span>
  def <a title="[I](n: Int)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.buffer">buffer</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.buffer;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scalaz.stream.process1.buffer.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.chunk" title="[I](n: Int)scalaz.stream.Process1[I,Vector[I]]">chunk</a><span title="(n: Int)scalaz.stream.Process1[I,Vector[I]]" class="delimiter">[</span><a href="#scalaz.stream.process1.buffer;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.buffer.n" title="Int">n</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: Vector[I] =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I]">flatMap</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[I])scalaz.stream.Process0[I]">emitAll</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Behaves like the identity process, but requests elements from its
   * input in blocks that end whenever the predicate switches from true to false.
   */</span>
  def <a title="[I](f: I =&gt; Boolean)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.bufferBy">bufferBy</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.bufferBy;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; Boolean" id="scalaz.stream.process1.bufferBy.f">f</a>: I =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.chunkBy" title="(f: I =&gt; Boolean)scalaz.stream.Process1[I,Vector[I]]">chunkBy</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.bufferBy.f" title="I =&gt; Boolean">f</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: Vector[I] =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I]">flatMap</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[I])scalaz.stream.Process0[I]">emitAll</a><span class="delimiter">)</span>

  <span class="comment">/** Behaves like the identity process, but batches all output into a single `Emit`. */</span>
  def <a title="[I]=&gt; scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.bufferAll">bufferAll</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.bufferAll;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.chunkAll" title="[I]=&gt; scalaz.stream.Process1[I,Vector[I]]">chunkAll</a><span title="scalaz.stream.Process1[I,Vector[I]]" class="delimiter">[</span><a href="#scalaz.stream.process1.bufferAll;I" title="I">I</a><span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: Vector[I] =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I]">flatMap</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[I])scalaz.stream.Process0[I]">emitAll</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Groups inputs into chunks of size `n`. The last chunk may have size
   * less than `n`, depending on the number of elements in the input.
   *
   * @example {{{
   * scala&gt; Process(1, 2, 3, 4, 5).chunk(2).toList
   * res0: List[Vector[Int]] = List(Vector(1, 2), Vector(3, 4), Vector(5))
   * }}}
   * @throws IllegalArgumentException if `n` &lt;= 0
   */</span>
  def <a title="[I](n: Int)scalaz.stream.Process1[I,Vector[I]]" id="scalaz.stream.process1.chunk">chunk</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.chunk;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scalaz.stream.process1.chunk.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Vector[I]]">Process1</a><span class="delimiter">[</span>I, Vector<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunk.n" title="Int">n</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span>, <span title="String(&quot;chunk size must be &gt; 0, was: &quot;)" class="string">&quot;chunk size must be &gt; 0, was: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scalaz.stream.process1.chunk.n" title="Int">n</a><span class="delimiter">)</span>
    def <a title="(m: Int, acc: Vector[I])scalaz.stream.Process1[I,Vector[I]]" id="scalaz.stream.process1.chunk.go">go</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream.process1.chunk.go.m">m</a>: <span title="Int">Int</span>, <a title="Vector[I]" id="scalaz.stream.process1.chunk.go.acc">acc</a>: <span title="Vector[I]">Vector</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Vector[I]]">Process1</a><span class="delimiter">[</span>I, Vector<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#scalaz.stream.process1.chunk.go.m" title="Int">m</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: Vector[I])scalaz.stream.Process0[Vector[I]]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunk.go.acc" title="Vector[I]">acc</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,Vector[I]])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,Vector[I]]">++</a> <a href="#scalaz.stream.process1.chunk.go" title="(m: Int, acc: Vector[I])scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunk.n" title="Int">n</a>, <span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      else <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[I,Vector[I]])(rcv: I =&gt; scalaz.stream.Process1[I,Vector[I]])scalaz.stream.Process1[I,Vector[I]]" class="delimiter">[</span><a href="#scalaz.stream.process1.chunk;I" title="I">I</a>, <span title="Vector[I]">Vector</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#scalaz.stream.process1.chunk.go.acc" title="Vector[I]">acc</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: Vector[I])scalaz.stream.Process0[Vector[I]]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunk.go.acc" title="Vector[I]">acc</a><span class="delimiter">)</span> else <a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="I" id="scalaz.stream.process1.chunk.go.$anonfun.i">i</a> =&gt;
        <a href="#scalaz.stream.process1.chunk.go" title="(m: Int, acc: Vector[I])scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunk.go.m" title="Int">m</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>, <a href="#scalaz.stream.process1.chunk.go.acc" title="Vector[I]">acc</a> <span title="(elem: I)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[I],I,Vector[I]])Vector[I]">:+</span> <a href="#scalaz.stream.process1.chunk.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#scalaz.stream.process1.chunk.go" title="(m: Int, acc: Vector[I])scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunk.n" title="Int">n</a>, <span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Collects up all output of this `Process1` into a single `Emit`. */</span>
  def <a title="[I]=&gt; scalaz.stream.Process1[I,Vector[I]]" id="scalaz.stream.process1.chunkAll">chunkAll</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.chunkAll;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Vector[I]]">Process1</a><span class="delimiter">[</span>I, Vector<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.chunkBy" title="[I](f: I =&gt; Boolean)scalaz.stream.Process1[I,Vector[I]]">chunkBy</a><span title="(f: I =&gt; Boolean)scalaz.stream.Process1[I,Vector[I]]" class="delimiter">[</span><a href="#scalaz.stream.process1.chunkAll;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.chunkAll.$anonfun.x$1">_</a> =&gt; false<span class="delimiter">)</span>

  <span class="comment">/**
   * Like `chunk`, but emits a chunk whenever the predicate switches from
   * true to false.
   * {{{
   * scala&gt; Process(1, 2, -1, 3, 4).chunkBy(_ &gt; 0).toList
   * res0: List[Vector[Int]] = List(Vector(1, 2, -1), Vector(3, 4))
   * }}}
   */</span>
  def <a title="[I](f: I =&gt; Boolean)scalaz.stream.Process1[I,Vector[I]]" id="scalaz.stream.process1.chunkBy">chunkBy</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.chunkBy;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; Boolean" id="scalaz.stream.process1.chunkBy.f">f</a>: I =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Vector[I]]">Process1</a><span class="delimiter">[</span>I, Vector<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(acc: Vector[I], last: Boolean)scalaz.stream.Process1[I,Vector[I]]" id="scalaz.stream.process1.chunkBy.go">go</a><span class="delimiter">(</span><a title="Vector[I]" id="scalaz.stream.process1.chunkBy.go.acc">acc</a>: <span title="Vector[I]">Vector</span><span class="delimiter">[</span>I<span class="delimiter">]</span>, <a title="Boolean" id="scalaz.stream.process1.chunkBy.go.last">last</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Vector[I]]">Process1</a><span class="delimiter">[</span>I, Vector<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[I,Vector[I]])(rcv: I =&gt; scalaz.stream.Process1[I,Vector[I]])scalaz.stream.Process1[I,Vector[I]]" class="delimiter">[</span><a href="#scalaz.stream.process1.chunkBy;I" title="I">I</a>,<span title="Vector[I]">Vector</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: Vector[I])scalaz.stream.Process0[Vector[I]]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunkBy.go.acc" title="Vector[I]">acc</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="I" id="scalaz.stream.process1.chunkBy.go.$anonfun.i">i</a> =&gt;
        val chunk = <a href="#scalaz.stream.process1.chunkBy.go.acc" title="Vector[I]">acc</a> <a title="scala.collection.immutable.Vector[I]" id="scalaz.stream.process1.chunkBy.go.$anonfun.chunk">:+</a> <a href="#scalaz.stream.process1.chunkBy.go.$anonfun.i" title="I">i</a>
        val <a title="Boolean" id="scalaz.stream.process1.chunkBy.go.$anonfun.cur">cur</a> = <a href="#scalaz.stream.process1.chunkBy.f" title="(v1: I)Boolean">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunkBy.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#scalaz.stream.process1.chunkBy.go.$anonfun.cur" title="Boolean">cur</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#scalaz.stream.process1.chunkBy.go.last" title="Boolean">last</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: scala.collection.immutable.Vector[I])scalaz.stream.Process0[scala.collection.immutable.Vector[I]]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunkBy.go.$anonfun.chunk" title="scala.collection.immutable.Vector[I]">chunk</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,scala.collection.immutable.Vector[I]])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,scala.collection.immutable.Vector[I]]">++</a> <a href="#scalaz.stream.process1.chunkBy.go" title="(acc: Vector[I], last: Boolean)scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span>, false<span class="delimiter">)</span>
        else <a href="#scalaz.stream.process1.chunkBy.go" title="(acc: Vector[I], last: Boolean)scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunkBy.go.$anonfun.chunk" title="scala.collection.immutable.Vector[I]">chunk</a>, <a href="#scalaz.stream.process1.chunkBy.go.$anonfun.cur" title="Boolean">cur</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#scalaz.stream.process1.chunkBy.go" title="(acc: Vector[I], last: Boolean)scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span>, false<span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Like `chunkBy`, but the predicate depends on the current and previous elements.
   */</span>
  def <a title="[I](f: (I, I) =&gt; Boolean)scalaz.stream.Process1[I,Vector[I]]" id="scalaz.stream.process1.chunkBy2">chunkBy2</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.chunkBy2;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(I, I) =&gt; Boolean" id="scalaz.stream.process1.chunkBy2.f">f</a>: <span class="delimiter">(</span>I, I<span class="delimiter">)</span> =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Vector[I]]">Process1</a><span class="delimiter">[</span>I, Vector<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(acc: Vector[I], last: I)scalaz.stream.Process1[I,Vector[I]]" id="scalaz.stream.process1.chunkBy2.go">go</a><span class="delimiter">(</span><a title="Vector[I]" id="scalaz.stream.process1.chunkBy2.go.acc">acc</a>: <span title="Vector[I]">Vector</span><span class="delimiter">[</span>I<span class="delimiter">]</span>, <a title="I" id="scalaz.stream.process1.chunkBy2.go.last">last</a>: <a href="#scalaz.stream.process1.chunkBy2;I" title="I">I</a><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Vector[I]]">Process1</a><span class="delimiter">[</span>I, Vector<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[I,Vector[I]])(rcv: I =&gt; scalaz.stream.Process1[I,Vector[I]])scalaz.stream.Process1[I,Vector[I]]" class="delimiter">[</span><a href="#scalaz.stream.process1.chunkBy2;I" title="I">I</a>,<span title="Vector[I]">Vector</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: Vector[I])scalaz.stream.Process0[Vector[I]]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunkBy2.go.acc" title="Vector[I]">acc</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="I" id="scalaz.stream.process1.chunkBy2.go.$anonfun.i">i</a> =&gt;
        if <span class="delimiter">(</span><a href="#scalaz.stream.process1.chunkBy2.f" title="(v1: I, v2: I)Boolean">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunkBy2.go.last" title="I">last</a>, <a href="#scalaz.stream.process1.chunkBy2.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scalaz.stream.process1.chunkBy2.go" title="(acc: Vector[I], last: I)scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunkBy2.go.acc" title="Vector[I]">acc</a> <span title="(elem: I)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[I],I,Vector[I]])Vector[I]">:+</span> <a href="#scalaz.stream.process1.chunkBy2.go.$anonfun.i" title="I">i</a>, <a href="#scalaz.stream.process1.chunkBy2.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span>
        else <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: Vector[I])scalaz.stream.Process0[Vector[I]]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunkBy2.go.acc" title="Vector[I]">acc</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,Vector[I]])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,Vector[I]]">++</a> <a href="#scalaz.stream.process1.chunkBy2.go" title="(acc: Vector[I], last: I)scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><span title="(elems: I*)scala.collection.immutable.Vector[I]">Vector</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunkBy2.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span>, <a href="#scalaz.stream.process1.chunkBy2.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: I =&gt; scalaz.stream.Process1[I,Vector[I]])scalaz.stream.Process1[I,Vector[I]]">receive1</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.chunkBy2.$anonfun.i">i</a> =&gt; <a href="#scalaz.stream.process1.chunkBy2.go" title="(acc: Vector[I], last: I)scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><span title="(elems: I*)scala.collection.immutable.Vector[I]">Vector</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.chunkBy2.$anonfun.i" title="I">i</a><span class="delimiter">)</span>, <a href="#scalaz.stream.process1.chunkBy2.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Like `collect` on scala collection.
   * Builds a new process by applying a partial function
   * to all elements of this process on which the function is defined.
   *
   * Elements, for which the partial function is not defined are
   * filtered out from new process
   */</span>
  def <a title="[I, I2](pf: PartialFunction[I,I2])scalaz.stream.Process1[I,I2]" id="scalaz.stream.process1.collect">collect</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.collect;I">I</a>, <a title="" id="scalaz.stream.process1.collect;I2">I2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[I,I2]" id="scalaz.stream.process1.collect.pf">pf</a>: <span title="PartialFunction[I,I2]">PartialFunction</span><span class="delimiter">[</span>I, I2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I2]">Process1</a><span class="delimiter">[</span>I, I2<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.id" title="[I]=&gt; scalaz.stream.Process1[I,I]">id</a><span title="scalaz.stream.Process1[I,I]" class="delimiter">[</span><a href="#scalaz.stream.process1.collect;I" title="I">I</a><span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: I =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I2])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I2]">flatMap</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.collect.pf" title="PartialFunction[I,I2]">pf</a> <span title="(k: I2 =&gt; scalaz.stream.Process0[I2])PartialFunction[I,scalaz.stream.Process0[I2]]">andThen</span> <span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I2)scalaz.stream.Process0[I2]">emit</a><span class="delimiter">)</span> <span title="(that: PartialFunction[I,scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I2]])PartialFunction[I,scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I2]]">orElse</span> <a title="&lt;$anon: I =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I2]&gt; extends scala.runtime.AbstractPartialFunction[I,scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I2]] with Serializable" id="scalaz.stream.process1.collect;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> case _ =&gt; <a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a> <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Like `collect`, but emits only the first element of this process on which
   * the partial function is defined.
   */</span>
  def <a title="[I, I2](pf: PartialFunction[I,I2])scalaz.stream.Process1[I,I2]" id="scalaz.stream.process1.collectFirst">collectFirst</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.collectFirst;I">I</a>, <a title="" id="scalaz.stream.process1.collectFirst;I2">I2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[I,I2]" id="scalaz.stream.process1.collectFirst.pf">pf</a>: <span title="PartialFunction[I,I2]">PartialFunction</span><span class="delimiter">[</span>I, I2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I2]">Process1</a><span class="delimiter">[</span>I, I2<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.collect" title="(pf: PartialFunction[I,I2])scalaz.stream.Process1[I,I2]">collect</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.collectFirst.pf" title="PartialFunction[I,I2]">pf</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process1Ops.once" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I2]">once</a>

  <span class="comment">/**
   * Skips the first element that matches the predicate.
   *
   * @example {{{
   * scala&gt; Process(3, 4, 5, 6).delete(_ % 2 == 0).toList
   * res0: List[Int] = List(3, 5, 6)
   * }}}
   */</span>
  def <a title="[I](f: I =&gt; Boolean)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.delete">delete</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.delete;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; Boolean" id="scalaz.stream.process1.delete.f">f</a>: I =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]">receive1</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.delete.$anonfun.i">i</a> =&gt; if <span class="delimiter">(</span><a href="#scalaz.stream.process1.delete.f" title="(v1: I)Boolean">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.delete.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scalaz.stream.process1.id" title="scalaz.stream.Process1[I,I]">id</a> else <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.delete.$anonfun.i" title="I">i</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I]">++</a> <a href="#scalaz.stream.process1.delete" title="(f: I =&gt; Boolean)scalaz.stream.Process1[I,I]">delete</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.delete.f" title="I =&gt; Boolean">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Remove any leading emitted values that occur before the first successful
   * `Await`. That means that the returned `Process1` will produce output only
   * if it has consumed at least one input element.
   */</span>
  def <a title="[A, B](p: scalaz.stream.Process1[A,B])scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.drainLeading">drainLeading</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.drainLeading;A">A</a>, <a title="" id="scalaz.stream.process1.drainLeading;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.drainLeading.p">p</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: A =&gt; scalaz.stream.Process1[A,B])scalaz.stream.Process1[A,B]">receive1</a><span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.drainLeading.$anonfun.a">a</a> =&gt; <a href="#scalaz.stream.process1.feed1" title="(i: A)(p: scalaz.stream.Process1[A,B])scalaz.stream.Process1[A,B]">feed1</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.drainLeading.$anonfun.a" title="A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.drainLeading.p" title="scalaz.stream.Process1[A,B]">p</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Emits only elements that are distinct from their immediate predecessors.
   *
   * @example {{{
   * scala&gt; import scalaz.std.anyVal._
   * scala&gt; Process(1, 2, 2, 1, 1, 3).distinctConsecutive.toList
   * res0: List[Int] = List(1, 2, 1, 3)
   * }}}
   */</span>
  def <a title="[A](implicit evidence$1: scalaz.Equal[A])scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.distinctConsecutive">distinctConsecutive</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.distinctConsecutive;A">A</a>: Equal<span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.distinctConsecutiveBy" title="(f: A =&gt; A)(implicit evidence$2: scalaz.Equal[A])scalaz.stream.Process1[A,A]">distinctConsecutiveBy</a><a href="#scalaz.stream.process1.distinctConsecutive.evidence$1" title="scalaz.Equal[A]" class="delimiter">(</a><a href="#scalaz.stream.process1.distinctConsecutive.$anonfun.x" title="(x: A)A">identity</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Emits only elements that are distinct from their immediate predecessors
   * according to `f`.
   *
   * @example {{{
   * scala&gt; import scalaz.std.anyVal._
   * scala&gt; Process(&quot;a&quot;, &quot;ab&quot;, &quot;bc&quot;, &quot;c&quot;, &quot;d&quot;).distinctConsecutiveBy(_.length).toList
   * res0: List[String] = List(a, ab, c)
   * }}}
   */</span>
  def <a title="[A, B](f: A =&gt; B)(implicit evidence$2: scalaz.Equal[B])scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.distinctConsecutiveBy">distinctConsecutiveBy</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.distinctConsecutiveBy;A">A</a>, <a title="" id="scalaz.stream.process1.distinctConsecutiveBy;B">B</a>: Equal<span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scalaz.stream.process1.distinctConsecutiveBy.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.filterBy2" title="(f: (A, A) =&gt; Boolean)scalaz.stream.Process1[A,A]">filterBy2</a><span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.distinctConsecutiveBy.$anonfun.a1">a1</a>, <a title="A" id="scalaz.stream.process1.distinctConsecutiveBy.$anonfun.a2">a2</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.process1.distinctConsecutiveBy.f" title="(v1: A)B">f</a><a href="#scalaz.stream.process1.distinctConsecutiveBy.evidence$2" title="(v: B)(implicit F0: scalaz.Equal[B])scalaz.syntax.EqualOps[B]" class="delimiter">(</a><a href="#scalaz.stream.process1.distinctConsecutiveBy.$anonfun.a1" title="A">a1</a><span class="delimiter">)</span> <span title="(other: B)Boolean">=/=</span> <a href="#scalaz.stream.process1.distinctConsecutiveBy.f" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.distinctConsecutiveBy.$anonfun.a2" title="A">a2</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Skips the first `n` elements of the input, then passes through the rest. */</span>
  def <a title="[I](n: Int)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.drop">drop</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.drop;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scalaz.stream.process1.drop.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#scalaz.stream.process1.drop.n" title="Int">n</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#scalaz.stream.process1.id" title="scalaz.stream.Process1[I,I]">id</a>
    else <a href="#scalaz.stream.process1.skip" title="=&gt; scalaz.stream.Process1[Any,Nothing]">skip</a> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I]">++</a> <a href="#scalaz.stream.process1.drop" title="(n: Int)scalaz.stream.Process1[I,I]">drop</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.drop.n" title="Int">n</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

  <span class="comment">/** Emits all but the last element of the input. */</span>
  def <a title="[I]=&gt; scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.dropLast">dropLast</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.dropLast;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.dropLastIf" title="(p: I =&gt; Boolean)scalaz.stream.Process1[I,I]">dropLastIf</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.dropLast.$anonfun.x$2">_</a> =&gt; true<span class="delimiter">)</span>

  <span class="comment">/** Emits all elements of the input but skips the last if the predicate is true. */</span>
  def <a title="[I](p: I =&gt; Boolean)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.dropLastIf">dropLastIf</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.dropLastIf;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; Boolean" id="scalaz.stream.process1.dropLastIf.p">p</a>: I =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(prev: I)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.dropLastIf.go">go</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.dropLastIf.go.prev">prev</a>: <a href="#scalaz.stream.process1.dropLastIf;I" title="I">I</a><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
      <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[I,I])(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]" class="delimiter">[</span><a href="#scalaz.stream.process1.dropLastIf;I" title="I">I</a>,<a href="#scalaz.stream.process1.dropLastIf;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#scalaz.stream.process1.dropLastIf.p" title="(v1: I)Boolean">p</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.dropLastIf.go.prev" title="I">prev</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a> else <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.dropLastIf.go.prev" title="I">prev</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="I" id="scalaz.stream.process1.dropLastIf.go.$anonfun.i">i</a> =&gt;
        <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.dropLastIf.go.prev" title="I">prev</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I]">++</a> <a href="#scalaz.stream.process1.dropLastIf.go" title="(prev: I)scalaz.stream.Process1[I,I]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.dropLastIf.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]">receive1</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.dropLastIf.go" title="(prev: I)scalaz.stream.Process1[I,I]">go</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Emits all but the last `n` elements of the input. */</span>
  def <a title="[I](n: Int)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.dropRight">dropRight</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.dropRight;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scalaz.stream.process1.dropRight.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(acc: Vector[I])scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.dropRight.go">go</a><span class="delimiter">(</span><a title="Vector[I]" id="scalaz.stream.process1.dropRight.go.acc">acc</a>: <span title="Vector[I]">Vector</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
      <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]">receive1</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.dropRight.go.$anonfun.i">i</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.dropRight.go.acc" title="Vector[I]">acc</a>.<span title="=&gt; I">head</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I]">++</a> <a href="#scalaz.stream.process1.dropRight.go" title="(acc: Vector[I])scalaz.stream.Process1[I,I]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.dropRight.go.acc" title="Vector[I]">acc</a>.<span title="=&gt; scala.collection.immutable.Vector[I]">tail</span> <span title="(elem: I)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[I],I,Vector[I]])Vector[I]">:+</span> <a href="#scalaz.stream.process1.dropRight.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#scalaz.stream.process1.dropRight.n" title="Int">n</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#scalaz.stream.process1.id" title="scalaz.stream.Process1[I,I]">id</a>
    else <a href="#scalaz.stream.process1.chunk" title="(n: Int)scalaz.stream.Process1[I,Vector[I]]">chunk</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.dropRight.n" title="Int">n</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process1Ops.once" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,Vector[I]]">once</a>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: Vector[I] =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I]">flatMap</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.dropRight.go" title="(acc: Vector[I])scalaz.stream.Process1[I,I]">go</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Skips elements of the input while the predicate is true,
   * then passes through the remaining inputs.
   */</span>
  def <a title="[I](f: I =&gt; Boolean)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.dropWhile">dropWhile</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.dropWhile;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; Boolean" id="scalaz.stream.process1.dropWhile.f">f</a>: I =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]">receive1</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.dropWhile.$anonfun.i">i</a> =&gt; if <span class="delimiter">(</span><a href="#scalaz.stream.process1.dropWhile.f" title="(v1: I)Boolean">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.dropWhile.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scalaz.stream.process1.dropWhile" title="(f: I =&gt; Boolean)scalaz.stream.Process1[I,I]">dropWhile</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.dropWhile.f" title="I =&gt; Boolean">f</a><span class="delimiter">)</span> else <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.dropWhile.$anonfun.i" title="I">i</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I]">++</a> <a href="#scalaz.stream.process1.id" title="scalaz.stream.Process1[I,I]">id</a><span class="delimiter">)</span>

  <span class="comment">/** Feed a single input to a `Process1`. */</span>
  def <a title="[I, O](i: I)(p: scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]" id="scalaz.stream.process1.feed1">feed1</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.feed1;I">I</a>, <a title="" id="scalaz.stream.process1.feed1;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.feed1.i">i</a>: <a href="#scalaz.stream.process1.feed1;I" title="I">I</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[I,O]" id="scalaz.stream.process1.feed1.p">p</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,O]">Process1</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,O]">Process1</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.feed" title="(i: Seq[I])(p: scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">feed</a><span class="delimiter">(</span><span title="(elems: I*)Seq[I]">Seq</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.feed1.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.feed1.p" title="scalaz.stream.Process1[I,O]">p</a><span class="delimiter">)</span>

  <span class="comment">/** Feed a sequence of inputs to a `Process1`. */</span>
  def <a title="[I, O](i: Seq[I])(p: scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]" id="scalaz.stream.process1.feed">feed</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.feed;I">I</a>, <a title="" id="scalaz.stream.process1.feed;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[I]" id="scalaz.stream.process1.feed.i">i</a>: <span title="Seq[I]">Seq</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[I,O]" id="scalaz.stream.process1.feed.p">p</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,O]">Process1</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,O]">Process1</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(in: Seq[I], out: Vector[O], cur: scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]" id="scalaz.stream.process1.feed.go">go</a><span class="delimiter">(</span><a title="Seq[I]" id="scalaz.stream.process1.feed.go.in">in</a>: <span title="Seq[I]">Seq</span><span class="delimiter">[</span>I<span class="delimiter">]</span>, <a title="Vector[O]" id="scalaz.stream.process1.feed.go.out">out</a>: <span title="Vector[O]">Vector</span><span class="delimiter">[</span>O<span class="delimiter">]</span> , <a title="scalaz.stream.Process1[I,O]" id="scalaz.stream.process1.feed.go.cur">cur</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,O]">Process1</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span>  <span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,O]">Process1</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scalaz.stream.process1.feed.go.in" title="Seq[I]">in</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scalaz.stream.process1.feed.go.cur" title="scalaz.stream.Process1[I,O]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,Any]#Is,O]">step</a> match <span class="delimiter">{</span>
          case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.process1.feed.go.os">os</a><span class="delimiter">)</span>,<span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,Any]#Is,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.process1.feed.go" title="(in: Seq[I], out: Vector[O], cur: scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.feed.go.in" title="Seq[I]">in</a>, <a href="Util.scala.html#scalaz.stream.Util.AppendSyntax(629eae9601)" title="(self: Vector[O])scalaz.stream.Util.AppendSyntax[O]">out</a> <a href="Util.scala.html#scalaz.stream.Util;AppendSyntax.fast_++" title="(other: Seq[O])Vector[O]">fast_++</a> <a href="#scalaz.stream.process1.feed.go.os" title="Seq[O]">os</a>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,Any]#Is,O]">cont</span>.<a href="Process.scala.html#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O]">continue</a><span class="delimiter">)</span>
          case Step<span class="delimiter">(</span><a href="#scalaz.stream.process1.Await1.unapply" title="(self: scalaz.stream.Process1[I,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process1[I,O]]">Await1</a><span class="delimiter">(</span><a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process1[I,O]" id="scalaz.stream.process1.feed.go.rcv">rcv</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,Any]#Is,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.process1.feed.go" title="(in: Seq[I], out: Vector[O], cur: scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.feed.go.in" title="Seq[I]">in</a>.<span title="=&gt; Seq[I]">tail</span>,<a href="#scalaz.stream.process1.feed.go.out" title="Vector[O]">out</a>,<a href="#scalaz.stream.process1.feed.go.rcv" title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process1[I,O]">rcv</a><span class="delimiter">(</span><span title="(v1: I)scalaz.\/[Nothing,I]">right</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.feed.go.in" title="Seq[I]">in</a>.<span title="=&gt; I">head</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,Any]#Is,O]">cont</span><span class="delimiter">)</span>
          case Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.process1.feed.go.rsn">rsn</a><span class="delimiter">)</span> =&gt;  <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[O])scalaz.stream.Process0[O]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.feed.go.out" title="Vector[O]">out</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Process[Nothing,O]">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.feed.go.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> else <a href="#scalaz.stream.process1.feed.go.cur" title="scalaz.stream.Process1[I,O]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.prepend" title="(os: Seq[O])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O]">prepend</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.feed.go.out" title="Vector[O]">out</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#scalaz.stream.process1.feed.go" title="(in: Seq[I], out: Vector[O], cur: scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.feed.i" title="Seq[I]">i</a>, <span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#scalaz.stream.process1.feed.p" title="scalaz.stream.Process1[I,O]">p</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Skips any elements of the input not matching the predicate. */</span>
  def <a title="[I](f: I =&gt; Boolean)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.filter">filter</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.filter;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; Boolean" id="scalaz.stream.process1.filter.f">f</a>: I =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.id" title="[I]=&gt; scalaz.stream.Process1[I,I]">id</a><span title="scalaz.stream.Process1[I,I]" class="delimiter">[</span><a href="#scalaz.stream.process1.filter;I" title="I">I</a><span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: I =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I]">flatMap</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.filter.$anonfun.i">i</a> =&gt; if <span class="delimiter">(</span><a href="#scalaz.stream.process1.filter.f" title="(v1: I)Boolean">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.filter.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.filter.$anonfun.i" title="I">i</a><span class="delimiter">)</span> else <a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Like `filter`, but the predicate `f` depends on the previously emitted and
   * current elements.
   *
   * @example {{{
   * scala&gt; Process(2, 4, 1, 5, 3).filterBy2(_ &lt; _).toList
   * res0: List[Int] = List(2, 4, 5)
   * }}}
   */</span>
  def <a title="[I](f: (I, I) =&gt; Boolean)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.filterBy2">filterBy2</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.filterBy2;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(I, I) =&gt; Boolean" id="scalaz.stream.process1.filterBy2.f">f</a>: <span class="delimiter">(</span>I, I<span class="delimiter">)</span> =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(i: I)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.filterBy2.pass">pass</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.filterBy2.pass.i">i</a>: <a href="#scalaz.stream.process1.filterBy2;I" title="I">I</a><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
      <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.filterBy2.pass.i" title="I">i</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I]">++</a> <a href="#scalaz.stream.process1.filterBy2.go" title="(g: I =&gt; Boolean)scalaz.stream.Process1[I,I]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.filterBy2.f" title="(v1: I, v2: I)Boolean">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.filterBy2.pass.i" title="I">i</a>, <a href="#scalaz.stream.process1.filterBy2.pass.$anonfun.x$4" title="I">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    def <a title="(g: I =&gt; Boolean)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.filterBy2.go">go</a><span class="delimiter">(</span><a title="I =&gt; Boolean" id="scalaz.stream.process1.filterBy2.go.g">g</a>: I =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
      <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]">receive1</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.filterBy2.go.$anonfun.i">i</a> =&gt; if <span class="delimiter">(</span><a href="#scalaz.stream.process1.filterBy2.go.g" title="(v1: I)Boolean">g</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.filterBy2.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scalaz.stream.process1.filterBy2.pass" title="(i: I)scalaz.stream.Process1[I,I]">pass</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.filterBy2.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span> else <a href="#scalaz.stream.process1.filterBy2.go" title="(g: I =&gt; Boolean)scalaz.stream.Process1[I,I]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.filterBy2.go.g" title="I =&gt; Boolean">g</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]">receive1</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.filterBy2.pass" title="(i: I)scalaz.stream.Process1[I,I]">pass</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Skips any elements not satisfying predicate and when found, will emit that
   * element and terminate
   */</span>
  def <a title="[I](f: I =&gt; Boolean)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.find">find</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.find;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; Boolean" id="scalaz.stream.process1.find.f">f</a>: I =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.filter" title="(f: I =&gt; Boolean)scalaz.stream.Process1[I,I]">filter</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.find.f" title="I =&gt; Boolean">f</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process1Ops.once" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I]">once</a>

  <span class="comment">/**
   * Halts with `true` as soon as a matching element is received.
   * Emits a single `false` if no input matches the predicate.
   */</span>
  def <a title="[I](f: I =&gt; Boolean)scalaz.stream.Process1[I,Boolean]" id="scalaz.stream.process1.exists">exists</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.exists;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; Boolean" id="scalaz.stream.process1.exists.f">f</a>: I =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Boolean]">Process1</a><span class="delimiter">[</span>I, Boolean<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.forall" title="[I](f: I =&gt; Boolean)scalaz.stream.Process1[I,Boolean]">forall</a><span title="(f: I =&gt; Boolean)scalaz.stream.Process1[I,Boolean]" class="delimiter">[</span><a href="#scalaz.stream.process1.exists;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#scalaz.stream.process1.exists.f" title="(v1: I)Boolean">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.exists.$anonfun.x$5" title="I">_</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.map" title="(f: Boolean =&gt; Boolean)scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,Boolean]">map</a><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#scalaz.stream.process1.exists.$anonfun.x$6" title="Boolean">_</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Emits a single `true` value if all input matches the predicate.
   * Halts with `false` as soon as a non-matching element is received.
   */</span>
  def <a title="[I](f: I =&gt; Boolean)scalaz.stream.Process1[I,Boolean]" id="scalaz.stream.process1.forall">forall</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.forall;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; Boolean" id="scalaz.stream.process1.forall.f">f</a>: I =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Boolean]">Process1</a><span class="delimiter">[</span>I, Boolean<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[I,Boolean])(rcv: I =&gt; scalaz.stream.Process1[I,Boolean])scalaz.stream.Process1[I,Boolean]" class="delimiter">[</span><a href="#scalaz.stream.process1.forall;I" title="I">I</a>,<span title="Boolean">Boolean</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: Boolean)scalaz.stream.Process0[Boolean]">emit</a><span class="delimiter">(</span>true<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="I" id="scalaz.stream.process1.forall.$anonfun.i">i</a> =&gt;
      if <span class="delimiter">(</span><a href="#scalaz.stream.process1.forall.f" title="(v1: I)Boolean">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.forall.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scalaz.stream.process1.forall" title="(f: I =&gt; Boolean)scalaz.stream.Process1[I,Boolean]">forall</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.forall.f" title="I =&gt; Boolean">f</a><span class="delimiter">)</span> else <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: Boolean)scalaz.stream.Process0[Boolean]">emit</a><span class="delimiter">(</span>false<span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * `Process1` form of `List.fold`.
   * Folds the elements of this Process using the specified associative binary operator.
   *
   * Unlike List.fold the order is always from the `left` side, i.e. it will always
   * honor order of `A`.
   *
   * If Process of `A` is empty, it will just emit `z` and terminate
   * {{{
   * scala&gt; Process(1, 2, 3, 4).fold(0)(_ + _).toList
   * res0: List[Int] = List(10)
   * }}}
   */</span>
  def <a title="[A, B](z: B)(f: (B, A) =&gt; B)scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.fold">fold</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.fold;A">A</a>, <a title="" id="scalaz.stream.process1.fold;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="scalaz.stream.process1.fold.z">z</a>: <a href="#scalaz.stream.process1.fold;B" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, A) =&gt; B" id="scalaz.stream.process1.fold.f">f</a>: <span class="delimiter">(</span>B, A<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.scan" title="(z: B)(f: (B, A) =&gt; B)scalaz.stream.Process1[A,B]">scan</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.fold.z" title="B">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.fold.f" title="(B, A) =&gt; B">f</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process1Ops.last" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]">last</a>

  <span class="comment">/** Alias for `[[reduce]](f)`. */</span>
  def <a title="[A](f: (A, A) =&gt; A)scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.fold1">fold1</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.fold1;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(A, A) =&gt; A" id="scalaz.stream.process1.fold1.f">f</a>: <span class="delimiter">(</span>A, A<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.reduce" title="(f: (A, A) =&gt; A)scalaz.stream.Process1[A,A]">reduce</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.fold1.f" title="(A, A) =&gt; A">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `[[reduceMap]](f)(M)`. */</span>
  def <a title="[A, B](f: A =&gt; B)(implicit M: scalaz.Monoid[B])scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.fold1Map">fold1Map</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.fold1Map;A">A</a>, <a title="" id="scalaz.stream.process1.fold1Map;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scalaz.stream.process1.fold1Map.f">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[B]" id="scalaz.stream.process1.fold1Map.M">M</a>: <span title="scalaz.Monoid[B]">Monoid</span><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.reduceMap" title="(f: A =&gt; B)(implicit M: scalaz.Semigroup[B])scalaz.stream.Process1[A,B]">reduceMap</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.fold1Map.f" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.fold1Map.M" title="scalaz.Monoid[B]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `[[reduceSemigroup]](M)`. */</span>
  def <a title="[A](implicit M: scalaz.Monoid[A])scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.fold1Monoid">fold1Monoid</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.fold1Monoid;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[A]" id="scalaz.stream.process1.fold1Monoid.M">M</a>: <span title="scalaz.Monoid[A]">Monoid</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.reduceSemigroup" title="(implicit M: scalaz.Semigroup[A])scalaz.stream.Process1[A,A]">reduceSemigroup</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.fold1Monoid.M" title="scalaz.Monoid[A]">M</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Like `fold` only uses `f` to map `A` to `B` and uses Monoid `M` for associative operation
   */</span>
  def <a title="[A, B](f: A =&gt; B)(implicit M: scalaz.Monoid[B])scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.foldMap">foldMap</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.foldMap;A">A</a>, <a title="" id="scalaz.stream.process1.foldMap;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scalaz.stream.process1.foldMap.f">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[B]" id="scalaz.stream.process1.foldMap.M">M</a>: <span title="scalaz.Monoid[B]">Monoid</span><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
   <a href="#scalaz.stream.process1.lift" title="(f: A =&gt; B)scalaz.stream.Process1[A,B]">lift</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.foldMap.f" title="A =&gt; B">f</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process1Ops.foldMonoid" title="(implicit M: scalaz.Monoid[B])scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]">foldMonoid</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.foldMap.M" title="scalaz.Monoid[B]">M</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Like `fold` but uses Monoid for folding operation
   */</span>
  def <a title="[A](implicit M: scalaz.Monoid[A])scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.foldMonoid">foldMonoid</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.foldMonoid;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[A]" id="scalaz.stream.process1.foldMonoid.M">M</a>: <span title="scalaz.Monoid[A]">Monoid</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.fold" title="(z: A)(f: (A, A) =&gt; A)scalaz.stream.Process1[A,A]">fold</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.foldMonoid.M" title="scalaz.Monoid[A]">M</a>.<span title="=&gt; A">zero</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.foldMonoid.M" title="scalaz.Monoid[A]">M</a>.<span title="(f1: A, f2: =&gt; A)A">append</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.foldMonoid.$anonfun.x$7" title="A">_</a>, <a href="#scalaz.stream.process1.foldMonoid.$anonfun.x$8" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Alias for `[[reduceSemigroup]](M)`. */</span>
  def <a title="[A](implicit M: scalaz.Semigroup[A])scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.foldSemigroup">foldSemigroup</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.foldSemigroup;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Semigroup[A]" id="scalaz.stream.process1.foldSemigroup.M">M</a>: <span title="scalaz.Semigroup[A]">Semigroup</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.reduceSemigroup" title="(implicit M: scalaz.Semigroup[A])scalaz.stream.Process1[A,A]">reduceSemigroup</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.foldSemigroup.M" title="scalaz.Semigroup[A]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Repeatedly echo the input; satisfies `x |&gt; id == x` and `id |&gt; x == x`. */</span>
  def <a title="[I]=&gt; scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.id">id</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.id;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.await1" title="[I]=&gt; scalaz.stream.Process1[I,I]">await1</a><span title="scalaz.stream.Process1[I,I]" class="delimiter">[</span><a href="#scalaz.stream.process1.id;I" title="I">I</a><span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream;Process.repeat" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I]">repeat</a>

  <span class="comment">/**
   * Adds `separator` between elements of the input. For example,
   * {{{
   * scala&gt; Process(1, 2, 3).intersperse(0).toList
   * res0: List[Int] = List(1, 0, 2, 0, 3)
   * }}}
   */</span>
  def <a title="[A](separator: A)scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.intersperse">intersperse</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.intersperse;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.intersperse.separator">separator</a>: <a href="#scalaz.stream.process1.intersperse;A" title="A">A</a><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.await1" title="[I]=&gt; scalaz.stream.Process1[I,I]">await1</a><span title="scalaz.stream.Process1[A,A]" class="delimiter">[</span><a href="#scalaz.stream.process1.intersperse;A" title="A">A</a><span class="delimiter">]</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[A,Any]#Is[x],A])scalaz.stream.Process[[x]scalaz.stream.Process.Env[A,Any]#Is[x],A]">++</a> <a href="#scalaz.stream.process1.id" title="[I]=&gt; scalaz.stream.Process1[I,I]">id</a><span title="scalaz.stream.Process1[A,A]" class="delimiter">[</span><a href="#scalaz.stream.process1.intersperse;A" title="A">A</a><span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: A =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[A,Any]#Is[x],A])scalaz.stream.Process[[x]scalaz.stream.Process.Env[A,Any]#Is[x],A]">flatMap</a><span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.intersperse.$anonfun.a">a</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.apply" title="(o: A*)scalaz.stream.Process0[A]">Process</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.intersperse.separator" title="A">separator</a>, <a href="#scalaz.stream.process1.intersperse.$anonfun.a" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Skips all but the last element of the input. */</span>
  def <a title="[I]=&gt; scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.last">last</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.last;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(prev: I)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.last.go">go</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.last.go.prev">prev</a>: <a href="#scalaz.stream.process1.last;I" title="I">I</a><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> = <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[I,I])(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]" class="delimiter">[</span><a href="#scalaz.stream.process1.last;I" title="I">I</a>,<a href="#scalaz.stream.process1.last;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.last.go.prev" title="I">prev</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.last.go" title="(prev: I)scalaz.stream.Process1[I,I]">go</a><span class="delimiter">)</span>
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]">receive1</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.last.go" title="(prev: I)scalaz.stream.Process1[I,I]">go</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Skips all but the last element of the input.
   * This `Process` will always emit exactly one value;
   * If the input is empty, `li` is emitted.
   */</span>
  def <a title="[I](li: =&gt; I)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.lastOr">lastOr</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.lastOr;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; I" id="scalaz.stream.process1.lastOr.li">li</a>: =&gt; I<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[I,I])(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]" class="delimiter">[</span><a href="#scalaz.stream.process1.lastOr;I" title="I">I</a>,<a href="#scalaz.stream.process1.lastOr;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.lastOr.li" title="=&gt; I">li</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.lastOr.$anonfun.i">i</a> =&gt; <a href="#scalaz.stream.process1.lastOr" title="(li: =&gt; I)scalaz.stream.Process1[I,I]">lastOr</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.lastOr.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Transform the input using the given function, `f`. */</span>
  def <a title="[I, O](f: I =&gt; O)scalaz.stream.Process1[I,O]" id="scalaz.stream.process1.lift">lift</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.lift;I">I</a>, <a title="" id="scalaz.stream.process1.lift;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; O" id="scalaz.stream.process1.lift.f">f</a>: I =&gt; O<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,O]">Process1</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.id" title="scalaz.stream.Process1[I,I]">id</a> <a href="Process.scala.html#scalaz.stream;Process.map" title="(f: I =&gt; O)scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O]">map</a> <a href="#scalaz.stream.process1.lift.f" title="I =&gt; O">f</a>

  <span class="comment">/**
   * Transform `p` to operate on the first element of a pair, passing
   * through the right value with no modifications. Note that this halts
   * whenever `p` halts.
   *
   * @param f function used to convert `B`s generated during cleanup of `p` to pairs
   */</span>
  def <a title="[A, B, C](f: B =&gt; Option[C])(p: scalaz.stream.Process1[A,B])scalaz.stream.Process1[(A, C),(B, C)]" id="scalaz.stream.process1.liftFirst">liftFirst</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.liftFirst;A">A</a>, <a title="" id="scalaz.stream.process1.liftFirst;B">B</a>, <a title="" id="scalaz.stream.process1.liftFirst;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B =&gt; Option[C]" id="scalaz.stream.process1.liftFirst.f">f</a>: B =&gt; Option<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.liftFirst.p">p</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[(A, C),(B, C)]">Process1</a><span class="delimiter">[</span><span class="delimiter">(</span>A, C<span class="delimiter">)</span>, <span class="delimiter">(</span>B, C<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(curr: scalaz.stream.Process1[A,B])scalaz.stream.Process1[(A, C),(B, C)]" id="scalaz.stream.process1.liftFirst.go">go</a><span class="delimiter">(</span><a title="scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.liftFirst.go.curr">curr</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[(A, C),(B, C)]">Process1</a><span class="delimiter">[</span><span class="delimiter">(</span>A, C<span class="delimiter">)</span>, <span class="delimiter">(</span>B, C<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      val <a title="scalaz.stream.Process1[(A, C),(B, C)]" id="scalaz.stream.process1.liftFirst.go.cleanup">cleanup</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[(A, C),(B, C)]">Process1</a><span class="delimiter">[</span><span class="delimiter">(</span>A, C<span class="delimiter">)</span>, <span class="delimiter">(</span>B, C<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#scalaz.stream.process1.liftFirst.go.curr" title="scalaz.stream.Process1[A,B]">curr</a>.<a href="Process.scala.html#scalaz.stream;Process.disconnect" title="(cause: scalaz.stream.Cause.EarlyCause)scalaz.stream.Process0[B]">disconnect</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: B =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[(A, C),Any]#Is,(B, C)])scalaz.stream.Process[scalaz.stream.Process.Env[(A, C),Any]#Is,(B, C)]">flatMap</a><span class="delimiter">(</span><a title="B" id="scalaz.stream.process1.liftFirst.go.cleanup.$anonfun.b">b</a> =&gt; <a href="#scalaz.stream.process1.liftFirst.f" title="(v1: B)Option[C]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftFirst.go.cleanup.$anonfun.b" title="B">b</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case Some<span class="delimiter">(</span><a title="C" id="scalaz.stream.process1.liftFirst.go.cleanup.$anonfun.c">c</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: (B, C))scalaz.stream.Process0[(B, C)]">emit</a><span class="delimiter">(</span><span title="(_1: B, _2: C)(B, C)" class="delimiter">(</span><a href="#scalaz.stream.process1.liftFirst.go.cleanup.$anonfun.b" title="B">b</a>, <a href="#scalaz.stream.process1.liftFirst.go.cleanup.$anonfun.c" title="C">c</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case <span title="None.type">None</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>
      <span class="delimiter">}</span><span class="delimiter">)</span>
      <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[(A, C),(B, C)])(rcv: ((A, C)) =&gt; scalaz.stream.Process1[(A, C),(B, C)])scalaz.stream.Process1[(A, C),(B, C)]" class="delimiter">[</span><span title="(A, C)" class="delimiter">(</span>A, C<span class="delimiter">)</span>, <span title="(B, C)" class="delimiter">(</span>B, C<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftFirst.go.cleanup" title="scalaz.stream.Process1[(A, C),(B, C)]">cleanup</a><span class="delimiter">)</span> <a href="#scalaz.stream.process1.liftFirst.go.$anonfun.x0$1" title="scalaz.stream.Process1[(A, C),(B, C)]" class="delimiter">{</a> case <span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.liftFirst.go.$anonfun.a">a</a>, <a title="C" id="scalaz.stream.process1.liftFirst.go.$anonfun.c">c</a><span class="delimiter">)</span> =&gt;
        val <a href="#scalaz.stream.process1.liftFirst.go.$anonfun.emitted" title="(Seq[B], scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B])" class="delimiter">(</a><a href="#scalaz.stream.process1.liftFirst.go.$anonfun.x$9" title="Seq[B]" id="scalaz.stream.process1.liftFirst.go.$anonfun.emitted">emitted</a>, <a href="#scalaz.stream.process1.liftFirst.go.$anonfun.x$9" title="scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]" id="scalaz.stream.process1.liftFirst.go.$anonfun.next">next</a><span class="delimiter">)</span> = <a href="Process.scala.html#scalaz.stream.Process.Process1Syntax(ed4aae368f)" title="(self: scalaz.stream.Process1[A,B])scalaz.stream.Process.Process1Syntax[A,B]">curr</a>.<a href="Process.scala.html#scalaz.stream.Process;Process1Syntax.feed1" title="(i: A)scalaz.stream.Process1[A,B]">feed1</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftFirst.go.$anonfun.a" title="A">a</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.unemit" title="=&gt; (Seq[B], scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B])">unemit</a>
        val <a title="scalaz.stream.Process[Nothing,(B, C)]" id="scalaz.stream.process1.liftFirst.go.$anonfun.out">out</a> = <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[B])scalaz.stream.Process0[B]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftFirst.go.$anonfun.emitted" title="Seq[B]">emitted</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.map" title="(f: B =&gt; (B, C))scalaz.stream.Process[Nothing,(B, C)]">map</a><span class="delimiter">(</span><span title="(_1: B, _2: C)(B, C)" class="delimiter">(</span><a href="#scalaz.stream.process1.liftFirst.go.$anonfun.out.$anonfun.x$10" title="B">_</a>, <a href="#scalaz.stream.process1.liftFirst.go.$anonfun.c" title="C">c</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#scalaz.stream.process1.liftFirst.go.$anonfun.next" title="scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]">next</a> match <span class="delimiter">{</span>
          case <a title="scalaz.stream.Process.Halt" id="scalaz.stream.process1.liftFirst.go.$anonfun.h">h</a> @ Halt<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.process1.liftFirst.go.$anonfun.out" title="scalaz.stream.Process[Nothing,(B, C)]">out</a> <a href="Process.scala.html#scalaz.stream;Process.fby" title="(p2: =&gt; scalaz.stream.Process[Nothing,(B, C)])scalaz.stream.Process[Nothing,(B, C)]">fby</a> <a href="#scalaz.stream.process1.liftFirst.go.$anonfun.h" title="scalaz.stream.Process.Halt">h</a>
          case <a title="scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]" id="scalaz.stream.process1.liftFirst.go.$anonfun.other">other</a> =&gt; <a href="#scalaz.stream.process1.liftFirst.go.$anonfun.out" title="scalaz.stream.Process[Nothing,(B, C)]">out</a> <a href="Process.scala.html#scalaz.stream;Process.fby" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[(A, C),Any]#Is,(B, C)])scalaz.stream.Process[scalaz.stream.Process.Env[(A, C),Any]#Is,(B, C)]">fby</a> <a href="#scalaz.stream.process1.liftFirst.go" title="(curr: scalaz.stream.Process1[A,B])scalaz.stream.Process1[(A, C),(B, C)]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftFirst.go.$anonfun.other" title="scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]">other</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#scalaz.stream.process1.liftFirst.go" title="(curr: scalaz.stream.Process1[A,B])scalaz.stream.Process1[(A, C),(B, C)]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftFirst.p" title="scalaz.stream.Process1[A,B]">p</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Transform `p` to operate on the second element of a pair, passing
   * through the left value with no modifications. Note that this halts
   * whenever `p` halts.
   *
   * @param f function used to convert `B`s generated during cleanup of `p` to pairs
   */</span>
  def <a title="[A, B, C](f: B =&gt; Option[C])(p: scalaz.stream.Process1[A,B])scalaz.stream.Process1[(C, A),(C, B)]" id="scalaz.stream.process1.liftSecond">liftSecond</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.liftSecond;A">A</a>, <a title="" id="scalaz.stream.process1.liftSecond;B">B</a>, <a title="" id="scalaz.stream.process1.liftSecond;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B =&gt; Option[C]" id="scalaz.stream.process1.liftSecond.f">f</a>: B =&gt; Option<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.liftSecond.p">p</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[(C, A),(C, B)]">Process1</a><span class="delimiter">[</span><span class="delimiter">(</span>C, A<span class="delimiter">)</span>, <span class="delimiter">(</span>C, B<span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.lift" title="[I, O](f: I =&gt; O)scalaz.stream.Process1[I,O]">lift</a><span title="(f: ((C, A)) =&gt; (A, C))scalaz.stream.Process1[(C, A),(A, C)]" class="delimiter">[</span><span title="(C, A)" class="delimiter">(</span>C, A<span class="delimiter">)</span>, <span title="(A, C)" class="delimiter">(</span>A, C<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftSecond.$anonfun.x$11" title="(C, A)">_</a>.<span title="=&gt; (A, C)">swap</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[(A, C),(C, B)])scalaz.stream.Process[scalaz.stream.Process.Env[(C, A),Any]#Is,(C, B)]">|&gt;</a> <a href="#scalaz.stream.process1.liftFirst" title="(f: B =&gt; Option[C])(p: scalaz.stream.Process1[A,B])scalaz.stream.Process1[(A, C),(B, C)]">liftFirst</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftSecond.f" title="B =&gt; Option[C]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftSecond.p" title="scalaz.stream.Process1[A,B]">p</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.map" title="(f: ((B, C)) =&gt; (C, B))scalaz.stream.Process[scalaz.stream.Process.Env[(A, C),Any]#Is,(C, B)]">map</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftSecond.$anonfun.x$12" title="(B, C)">_</a>.<span title="=&gt; (C, B)">swap</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Transform `p` to operate on the left hand side of an `\/`, passing
   * through any values it receives on the right. Note that this halts
   * whenever `p` halts.
   */</span>
  def <a title="[A, B, C](p: scalaz.stream.Process1[A,B])scalaz.stream.Process1[scalaz.\/[A,C],scalaz.\/[B,C]]" id="scalaz.stream.process1.liftL">liftL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.liftL;A">A</a>, <a title="" id="scalaz.stream.process1.liftL;B">B</a>, <a title="" id="scalaz.stream.process1.liftL;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.liftL.p">p</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[scalaz.\/[A,C],scalaz.\/[B,C]]">Process1</a><span class="delimiter">[</span>A \/ C, B \/ C<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(curr: scalaz.stream.Process1[A,B])scalaz.stream.Process1[scalaz.\/[A,C],scalaz.\/[B,C]]" id="scalaz.stream.process1.liftL.go">go</a><span class="delimiter">(</span><a title="scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.liftL.go.curr">curr</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A,B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[scalaz.\/[A,C],scalaz.\/[B,C]]">Process1</a><span class="delimiter">[</span>A \/ C, B \/ C<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[scalaz.\/[A,C],scalaz.\/[B,C]])(rcv: scalaz.\/[A,C] =&gt; scalaz.stream.Process1[scalaz.\/[A,C],scalaz.\/[B,C]])scalaz.stream.Process1[scalaz.\/[A,C],scalaz.\/[B,C]]" class="delimiter">[</span>A <span title="scalaz.\/[A,C]">\/</span> C, B <span title="scalaz.\/[B,C]">\/</span> C<span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftL.go.curr" title="scalaz.stream.Process1[A,B]">curr</a>.<a href="Process.scala.html#scalaz.stream;Process.disconnect" title="(cause: scalaz.stream.Cause.EarlyCause)scalaz.stream.Process0[B]">disconnect</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.map" title="(f: B =&gt; scalaz.-\/[B])scalaz.stream.Process[Nothing,scalaz.-\/[B]]">map</a><span class="delimiter">(</span><span title="(a: B)scalaz.-\/[B]">-\/</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftL.go.$anonfun.x$13" title="B">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scalaz.stream.process1.liftL.go.$anonfun.x0$2" title="scalaz.stream.Process1[scalaz.\/[A,C],scalaz.\/[B,C]]" class="delimiter">{</a>
        case -\/<span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.liftL.go.$anonfun.a">a</a><span class="delimiter">)</span> =&gt;
          val <a href="#scalaz.stream.process1.liftL.go.$anonfun.bs" title="(Seq[B], scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B])" class="delimiter">(</a><a href="#scalaz.stream.process1.liftL.go.$anonfun.x$14" title="Seq[B]" id="scalaz.stream.process1.liftL.go.$anonfun.bs">bs</a>, <a href="#scalaz.stream.process1.liftL.go.$anonfun.x$14" title="scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]" id="scalaz.stream.process1.liftL.go.$anonfun.next">next</a><span class="delimiter">)</span> = <a href="Process.scala.html#scalaz.stream.Process.Process1Syntax(ed4aae368f)" title="(self: scalaz.stream.Process1[A,B])scalaz.stream.Process.Process1Syntax[A,B]">curr</a>.<a href="Process.scala.html#scalaz.stream.Process;Process1Syntax.feed1" title="(i: A)scalaz.stream.Process1[A,B]">feed1</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftL.go.$anonfun.a" title="A">a</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.unemit" title="=&gt; (Seq[B], scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B])">unemit</a>
          val <a title="scalaz.stream.Process[Nothing,scalaz.-\/[B]]" id="scalaz.stream.process1.liftL.go.$anonfun.out">out</a> =  <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[B])scalaz.stream.Process0[B]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftL.go.$anonfun.bs" title="Seq[B]">bs</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.map" title="(f: B =&gt; scalaz.-\/[B])scalaz.stream.Process[Nothing,scalaz.-\/[B]]">map</a><span class="delimiter">(</span><span title="(a: B)scalaz.-\/[B]">-\/</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftL.go.$anonfun.out.$anonfun.x$15" title="B">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#scalaz.stream.process1.liftL.go.$anonfun.next" title="scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]">next</a> match <span class="delimiter">{</span>
            case Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.process1.liftL.go.$anonfun.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.process1.liftL.go.$anonfun.out" title="scalaz.stream.Process[Nothing,scalaz.-\/[B]]">out</a> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[Nothing,scalaz.-\/[B]])scalaz.stream.Process[Nothing,scalaz.-\/[B]]">++</a> <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftL.go.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
            case <a title="scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]" id="scalaz.stream.process1.liftL.go.$anonfun.other">other</a> =&gt; <a href="#scalaz.stream.process1.liftL.go.$anonfun.out" title="scalaz.stream.Process[Nothing,scalaz.-\/[B]]">out</a> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[A,C],Any]#Is,scalaz.\/[B,C]])scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[A,C],Any]#Is,scalaz.\/[B,C]]">++</a> <a href="#scalaz.stream.process1.liftL.go" title="(curr: scalaz.stream.Process1[A,B])scalaz.stream.Process1[scalaz.\/[A,C],scalaz.\/[B,C]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftL.go.$anonfun.other" title="scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]">other</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        case \/-<span class="delimiter">(</span><a title="C" id="scalaz.stream.process1.liftL.go.$anonfun.c">c</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emitO" title="(o: C)scalaz.stream.Process0[scalaz.\/[Nothing,C]]">emitO</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftL.go.$anonfun.c" title="C">c</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[A,C],Any]#Is,scalaz.\/[B,C]])scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[A,C],Any]#Is,scalaz.\/[B,C]]">++</a> <a href="#scalaz.stream.process1.liftL.go" title="(curr: scalaz.stream.Process1[A,B])scalaz.stream.Process1[scalaz.\/[A,C],scalaz.\/[B,C]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftL.go.curr" title="scalaz.stream.Process1[A,B]">curr</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#scalaz.stream.process1.liftL.go" title="(curr: scalaz.stream.Process1[A,B])scalaz.stream.Process1[scalaz.\/[A,C],scalaz.\/[B,C]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftL.p" title="scalaz.stream.Process1[A,B]">p</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Transform `p` to operate on the right hand side of an `\/`, passing
   * through any values it receives on the left. Note that this halts
   * whenever `p` halts.
   */</span>
  def <a title="[A, B, C](p: scalaz.stream.Process1[B,C])scalaz.stream.Process1[scalaz.\/[A,B],scalaz.\/[A,C]]" id="scalaz.stream.process1.liftR">liftR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.liftR;A">A</a>, <a title="" id="scalaz.stream.process1.liftR;B">B</a>, <a title="" id="scalaz.stream.process1.liftR;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[B,C]" id="scalaz.stream.process1.liftR.p">p</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[B,C]">Process1</a><span class="delimiter">[</span>B, C<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[scalaz.\/[A,B],scalaz.\/[A,C]]">Process1</a><span class="delimiter">[</span>A \/ B, A \/ C<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.lift" title="(f: scalaz.\/[A,B] =&gt; scalaz.\/[B,A])scalaz.stream.Process1[scalaz.\/[A,B],scalaz.\/[B,A]]">lift</a><span class="delimiter">(</span><span class="delimiter">(</span>e: A <span title="scalaz.\/[A,B]">\/</span> B<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.process1.liftR.$anonfun.e" title="scalaz.\/[A,B]">e</a>.<span title="=&gt; scalaz.\/[B,A]">swap</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[scalaz.\/[B,A],scalaz.\/[A,C]])scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[A,B],Any]#Is,scalaz.\/[A,C]]">|&gt;</a> <a href="#scalaz.stream.process1.liftL" title="(p: scalaz.stream.Process1[B,C])scalaz.stream.Process1[scalaz.\/[B,A],scalaz.\/[C,A]]">liftL</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftR.p" title="scalaz.stream.Process1[B,C]">p</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.map" title="(f: scalaz.\/[C,A] =&gt; scalaz.\/[A,C])scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[B,A],Any]#Is,scalaz.\/[A,C]]">map</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.liftR.$anonfun.x$16" title="scalaz.\/[C,A]">_</a>.<span title="=&gt; scalaz.\/[A,C]">swap</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Lifts Process1 to operate on Left side of `wye`, ignoring any right input.
   * Use `wye.flip` to convert it to right side
   */</span>
  def <a title="[I, O](p: scalaz.stream.Process1[I,O])scalaz.stream.Wye[I,Any,O]" id="scalaz.stream.process1.liftY">liftY</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.liftY;I">I</a>,<a title="" id="scalaz.stream.process1.liftY;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[I,O]" id="scalaz.stream.process1.liftY.p">p</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,O]">Process1</a><span class="delimiter">[</span>I,O<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,Any,O]">Wye</a><span class="delimiter">[</span>I,Any,O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#scalaz.stream.process1.liftY.p" title="scalaz.stream.Process1[I,O]">p</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,Any]#Is,O]">step</a> match <span class="delimiter">{</span>
      case Step<span class="delimiter">(</span>Await<span class="delimiter">(</span>_,<a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O]]" id="scalaz.stream.process1.liftY.rcv">rcv</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,Any]#Is,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="Process.scala.html#scalaz.stream.Process;Await" title="(req: scalaz.stream.Process.Env[I,Any]#Y[I], rcv: scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Y,O]])scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,Any]#Y,I,O]">Await</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.L" title="[I]=&gt; scalaz.stream.Process.Env[I,Any]#Is[I]">L</a><span title="scalaz.stream.Process.Env[I,Any]#Is[I]" class="delimiter">[</span><a href="#scalaz.stream.process1.liftY;I" title="I">I</a><span class="delimiter">]</span>: Env<span class="delimiter">[</span>I,Any<span class="delimiter">]</span>#<a href="Process.scala.html#scalaz.stream.Process;Env;Y" title="scalaz.stream.Process.Env[I,Any]#Y[I]">Y</a><span class="delimiter">[</span>I<span class="delimiter">]</span>,<a href="#scalaz.stream.process1.liftY.rcv" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O]]">rcv</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Y[x],O]">onHalt</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span>=&gt; <a href="#scalaz.stream.process1.liftY" title="(p: scalaz.stream.Process1[I,O])scalaz.stream.Wye[I,Any,O]">liftY</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,Any]#Is,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>

      case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.Emit[O]" id="scalaz.stream.process1.liftY.emt">emt</a>@Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.process1.liftY.os">os</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,Any]#Is,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.process1.liftY.emt" title="scalaz.stream.Process.Emit[O]">emt</a> <a href="Process.scala.html#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Y,O]">onHalt</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span>=&gt; <a href="#scalaz.stream.process1.liftY" title="(p: scalaz.stream.Process1[I,O])scalaz.stream.Wye[I,Any,O]">liftY</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,Any]#Is,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>

      case <a title="scalaz.stream.Process.Halt" id="scalaz.stream.process1.liftY.hlt">hlt</a>@Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.process1.liftY.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.process1.liftY.hlt" title="scalaz.stream.Process.Halt">hlt</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Emits the greatest element of the input. */</span>
  def <a title="[A](implicit A: scalaz.Order[A])scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.maximum">maximum</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.maximum;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Order[A]" id="scalaz.stream.process1.maximum.A">A</a>: <span title="scalaz.Order[A]">Order</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A,A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.reduce" title="(f: (A, A) =&gt; A)scalaz.stream.Process1[A,A]">reduce</a><span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.maximum.$anonfun.x">x</a>, <a title="A" id="scalaz.stream.process1.maximum.$anonfun.y">y</a><span class="delimiter">)</span> =&gt; if <span class="delimiter">(</span><a href="#scalaz.stream.process1.maximum.A" title="scalaz.Order[A]">A</a>.<span title="(x: A, y: A)Boolean">greaterThan</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.maximum.$anonfun.x" title="A">x</a>, <a href="#scalaz.stream.process1.maximum.$anonfun.y" title="A">y</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scalaz.stream.process1.maximum.$anonfun.x" title="A">x</a> else <a href="#scalaz.stream.process1.maximum.$anonfun.y" title="A">y</a><span class="delimiter">)</span>

  <span class="comment">/** Emits the element `a` of the input which yields the greatest value of `f(a)`. */</span>
  def <a title="[A, B](f: A =&gt; B)(implicit evidence$3: scalaz.Order[B])scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.maximumBy">maximumBy</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.maximumBy;A">A</a>,<a title="" id="scalaz.stream.process1.maximumBy;B">B</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scalaz.stream.process1.maximumBy.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A,A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.reduce" title="(f: (A, A) =&gt; A)scalaz.stream.Process1[A,A]">reduce</a><span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.maximumBy.$anonfun.x">x</a>, <a title="A" id="scalaz.stream.process1.maximumBy.$anonfun.y">y</a><span class="delimiter">)</span> =&gt; if <span class="delimiter">(</span><span title="scalaz.Order.type">Order</span>.<span title="(f: A =&gt; B)(implicit evidence$1: scalaz.Order[B])scalaz.Order[A]">orderBy</span><a href="#scalaz.stream.process1.maximumBy.evidence$3" title="scalaz.Order[B]" class="delimiter">(</a><a href="#scalaz.stream.process1.maximumBy.f" title="A =&gt; B">f</a><span class="delimiter">)</span>.<span title="(x: A, y: A)Boolean">greaterThan</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.maximumBy.$anonfun.x" title="A">x</a>, <a href="#scalaz.stream.process1.maximumBy.$anonfun.y" title="A">y</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scalaz.stream.process1.maximumBy.$anonfun.x" title="A">x</a> else <a href="#scalaz.stream.process1.maximumBy.$anonfun.y" title="A">y</a><span class="delimiter">)</span>

  <span class="comment">/** Emits the greatest value of `f(a)` for each element `a` of the input. */</span>
  def <a title="[A, B](f: A =&gt; B)(implicit evidence$4: scalaz.Order[B])scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.maximumOf">maximumOf</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.maximumOf;A">A</a>,<a title="" id="scalaz.stream.process1.maximumOf;B">B</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scalaz.stream.process1.maximumOf.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A,B<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.lift" title="(f: A =&gt; B)scalaz.stream.Process1[A,B]">lift</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.maximumOf.f" title="A =&gt; B">f</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process1Ops.maximum" title="(implicit O2: scalaz.Order[B])scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]">maximum</a>

  <span class="comment">/** Emits the smallest element of the input. */</span>
  def <a title="[A](implicit A: scalaz.Order[A])scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.minimum">minimum</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.minimum;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Order[A]" id="scalaz.stream.process1.minimum.A">A</a>: <span title="scalaz.Order[A]">Order</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A,A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.reduce" title="(f: (A, A) =&gt; A)scalaz.stream.Process1[A,A]">reduce</a><span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.minimum.$anonfun.x">x</a>, <a title="A" id="scalaz.stream.process1.minimum.$anonfun.y">y</a><span class="delimiter">)</span> =&gt; if <span class="delimiter">(</span><a href="#scalaz.stream.process1.minimum.A" title="scalaz.Order[A]">A</a>.<span title="(x: A, y: A)Boolean">lessThan</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.minimum.$anonfun.x" title="A">x</a>, <a href="#scalaz.stream.process1.minimum.$anonfun.y" title="A">y</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scalaz.stream.process1.minimum.$anonfun.x" title="A">x</a> else <a href="#scalaz.stream.process1.minimum.$anonfun.y" title="A">y</a><span class="delimiter">)</span>

  <span class="comment">/** Emits the element `a` of the input which yields the smallest value of `f(a)`. */</span>
  def <a title="[A, B](f: A =&gt; B)(implicit evidence$5: scalaz.Order[B])scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.minimumBy">minimumBy</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.minimumBy;A">A</a>,<a title="" id="scalaz.stream.process1.minimumBy;B">B</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scalaz.stream.process1.minimumBy.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A,A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.reduce" title="(f: (A, A) =&gt; A)scalaz.stream.Process1[A,A]">reduce</a><span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.minimumBy.$anonfun.x">x</a>, <a title="A" id="scalaz.stream.process1.minimumBy.$anonfun.y">y</a><span class="delimiter">)</span> =&gt; if <span class="delimiter">(</span><span title="scalaz.Order.type">Order</span>.<span title="(f: A =&gt; B)(implicit evidence$1: scalaz.Order[B])scalaz.Order[A]">orderBy</span><a href="#scalaz.stream.process1.minimumBy.evidence$5" title="scalaz.Order[B]" class="delimiter">(</a><a href="#scalaz.stream.process1.minimumBy.f" title="A =&gt; B">f</a><span class="delimiter">)</span>.<span title="(x: A, y: A)Boolean">lessThan</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.minimumBy.$anonfun.x" title="A">x</a>, <a href="#scalaz.stream.process1.minimumBy.$anonfun.y" title="A">y</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scalaz.stream.process1.minimumBy.$anonfun.x" title="A">x</a> else <a href="#scalaz.stream.process1.minimumBy.$anonfun.y" title="A">y</a><span class="delimiter">)</span>

  <span class="comment">/** Emits the smallest value of `f(a)` for each element `a` of the input. */</span>
  def <a title="[A, B](f: A =&gt; B)(implicit evidence$6: scalaz.Order[B])scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.minimumOf">minimumOf</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.minimumOf;A">A</a>,<a title="" id="scalaz.stream.process1.minimumOf;B">B</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scalaz.stream.process1.minimumOf.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A,B<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.lift" title="(f: A =&gt; B)scalaz.stream.Process1[A,B]">lift</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.minimumOf.f" title="A =&gt; B">f</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process1Ops.minimum" title="(implicit O2: scalaz.Order[B])scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]">minimum</a>

  <span class="comment">/**
   * Split the input and send to either `chanL` or `chanR`, halting when
   * either branch halts.
   *
   * @example {{{
   * scala&gt; import scalaz.\/._
   * scala&gt; import process1._
   * scala&gt; Process(left(1), right('a'), left(2), right('b'))
   *      |   .pipe(multiplex(lift(_ * -1), lift(_.toInt))).toList
   * res0: List[Int] = List(-1, 97, -2, 98)
   * }}}
   */</span>
  def <a title="[I, I2, O](chanL: scalaz.stream.Process1[I,O], chanR: scalaz.stream.Process1[I2,O])scalaz.stream.Process1[scalaz.\/[I,I2],O]" id="scalaz.stream.process1.multiplex">multiplex</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.multiplex;I">I</a>, <a title="" id="scalaz.stream.process1.multiplex;I2">I2</a>, <a title="" id="scalaz.stream.process1.multiplex;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[I,O]" id="scalaz.stream.process1.multiplex.chanL">chanL</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,O]">Process1</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span>, <a title="scalaz.stream.Process1[I2,O]" id="scalaz.stream.process1.multiplex.chanR">chanR</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I2,O]">Process1</a><span class="delimiter">[</span>I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[scalaz.\/[I,I2],O]">Process1</a><span class="delimiter">[</span>I \/ I2, O<span class="delimiter">]</span> =
    <span class="delimiter">(</span><a href="#scalaz.stream.process1.liftL" title="(p: scalaz.stream.Process1[I,O])scalaz.stream.Process1[scalaz.\/[I,I2],scalaz.\/[O,I2]]">liftL</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.multiplex.chanL" title="scalaz.stream.Process1[I,O]">chanL</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[scalaz.\/[O,I2],scalaz.\/[O,O]])scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[I,I2],Any]#Is,scalaz.\/[O,O]]">pipe</a> <a href="#scalaz.stream.process1.liftR" title="(p: scalaz.stream.Process1[I2,O])scalaz.stream.Process1[scalaz.\/[O,I2],scalaz.\/[O,O]]">liftR</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.multiplex.chanR" title="scalaz.stream.Process1[I2,O]">chanR</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.map" title="(f: scalaz.\/[O,O] =&gt; O)scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[I,I2],Any]#Is,O]">map</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.multiplex.$anonfun.x$19" title="scalaz.\/[O,O]">_</a>.<span title="(l: O =&gt; O, r: O =&gt; O)O">fold</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.multiplex.$anonfun.$anonfun.x" title="(x: O)O">identity</a>, <a href="#scalaz.stream.process1.multiplex.$anonfun.$anonfun.x" title="(x: O)O">identity</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Emits the sums of prefixes (running totals) of the input elements.
   * The first value emitted will always be zero.
   *
   * @example {{{
   * scala&gt; Process(1, 2, 3).prefixSums.toList
   * res0: List[Int] = List(0, 1, 3, 6)
   *
   * scala&gt; Process[Int]().prefixSums.toList
   * res1: List[Int] = List(0)
   * }}}
   */</span>
  def <a title="[N](implicit N: Numeric[N])scalaz.stream.Process1[N,N]" id="scalaz.stream.process1.prefixSums">prefixSums</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.prefixSums;N">N</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="Numeric[N]" id="scalaz.stream.process1.prefixSums.N">N</a>: <span title="Numeric[N]">Numeric</span><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[N,N]">Process1</a><span class="delimiter">[</span>N,N<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.scan" title="(z: N)(f: (N, N) =&gt; N)scalaz.stream.Process1[N,N]">scan</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.prefixSums.N" title="Numeric[N]">N</a>.<span title="=&gt; N">zero</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.prefixSums.N" title="Numeric[N]">N</a>.<a href="#scalaz.stream.process1.prefixSums.$anonfun.x" title="(x: N, y: N)N">plus</a><span class="delimiter">)</span>

  <span class="comment">/**
   * `Process1` form of `List.reduce`.
   *
   * Reduces the elements of this Process using the specified associative binary operator.
   * {{{
   * scala&gt; Process(1, 2, 3, 4).reduce(_ + _).toList
   * res0: List[Int] = List(10)
   *
   * scala&gt; Process(1).reduce(_ + _).toList
   * res1: List[Int] = List(1)
   *
   * scala&gt; Process[Int]().reduce(_ + _).toList
   * res2: List[Int] = List()
   * }}}
   *
   * Unlike `List.reduce` will not fail when Process is empty.
   */</span>
  def <a title="[A](f: (A, A) =&gt; A)scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.reduce">reduce</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.reduce;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(A, A) =&gt; A" id="scalaz.stream.process1.reduce.f">f</a>: <span class="delimiter">(</span>A, A<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.scan1" title="(f: (A, A) =&gt; A)scalaz.stream.Process1[A,A]">scan1</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.reduce.f" title="(A, A) =&gt; A">f</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process1Ops.last" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,A]">last</a>

  <span class="comment">/**
   * Like `reduce` only uses `f` to map `A` to `B` and uses Semigroup `M` for
   * associative operation.
   */</span>
  def <a title="[A, B](f: A =&gt; B)(implicit M: scalaz.Semigroup[B])scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.reduceMap">reduceMap</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.reduceMap;A">A</a>, <a title="" id="scalaz.stream.process1.reduceMap;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scalaz.stream.process1.reduceMap.f">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Semigroup[B]" id="scalaz.stream.process1.reduceMap.M">M</a>: <span title="scalaz.Semigroup[B]">Semigroup</span><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.lift" title="(f: A =&gt; B)scalaz.stream.Process1[A,B]">lift</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.reduceMap.f" title="A =&gt; B">f</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process1Ops.reduceSemigroup" title="(implicit M: scalaz.Semigroup[B])scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]">reduceSemigroup</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.reduceMap.M" title="scalaz.Semigroup[B]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `[[reduceSemigroup]](M)`. */</span>
  def <a title="[A](implicit M: scalaz.Monoid[A])scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.reduceMonoid">reduceMonoid</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.reduceMonoid;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[A]" id="scalaz.stream.process1.reduceMonoid.M">M</a>: <span title="scalaz.Monoid[A]">Monoid</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.reduceSemigroup" title="(implicit M: scalaz.Semigroup[A])scalaz.stream.Process1[A,A]">reduceSemigroup</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.reduceMonoid.M" title="scalaz.Monoid[A]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Like `reduce` but uses Semigroup `M` for associative operation. */</span>
  def <a title="[A](implicit M: scalaz.Semigroup[A])scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.reduceSemigroup">reduceSemigroup</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.reduceSemigroup;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Semigroup[A]" id="scalaz.stream.process1.reduceSemigroup.M">M</a>: <span title="scalaz.Semigroup[A]">Semigroup</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.reduce" title="(f: (A, A) =&gt; A)scalaz.stream.Process1[A,A]">reduce</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.reduceSemigroup.M" title="scalaz.Semigroup[A]">M</a>.<span title="(f1: A, f2: =&gt; A)A">append</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.reduceSemigroup.$anonfun.x$20" title="A">_</a>, <a href="#scalaz.stream.process1.reduceSemigroup.$anonfun.x$21" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Repartitions the input with the function `p`. On each step `p` is applied
   * to the input and all elements but the last of the resulting sequence
   * are emitted. The last element is then prepended to the next input using the
   * Semigroup `I`. For example,
   * {{{
   * scala&gt; import scalaz.std.string._
   * scala&gt; Process(&quot;Hel&quot;, &quot;l&quot;, &quot;o Wor&quot;, &quot;ld&quot;).repartition(_.split(&quot; &quot;)).toList
   * res0: List[String] = List(Hello, World)
   * }}}
   */</span>
  def <a title="[I](p: I =&gt; IndexedSeq[I])(implicit I: scalaz.Semigroup[I])scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.repartition">repartition</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.repartition;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; IndexedSeq[I]" id="scalaz.stream.process1.repartition.p">p</a>: I =&gt; IndexedSeq<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Semigroup[I]" id="scalaz.stream.process1.repartition.I">I</a>: <span title="scalaz.Semigroup[I]">Semigroup</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(carry: Option[I])scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.repartition.go">go</a><span class="delimiter">(</span><a title="Option[I]" id="scalaz.stream.process1.repartition.go.carry">carry</a>: <span title="Option[I]">Option</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
      <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[I,I])(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]" class="delimiter">[</span><a href="#scalaz.stream.process1.repartition;I" title="I">I</a>,<a href="#scalaz.stream.process1.repartition;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[I])scalaz.stream.Process0[I]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.repartition.go.carry" title="Option[I]">carry</a>.<span title="=&gt; List[I]">toList</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="I" id="scalaz.stream.process1.repartition.go.$anonfun.i">i</a> =&gt;
        val <a title="I" id="scalaz.stream.process1.repartition.go.$anonfun.next">next</a> = <a href="#scalaz.stream.process1.repartition.go.carry" title="Option[I]">carry</a>.<span title="(ifEmpty: =&gt; I)(f: I =&gt; I)I">fold</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.repartition.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.repartition.go.$anonfun.next.$anonfun.c">c</a> =&gt; <a href="#scalaz.stream.process1.repartition.I" title="scalaz.Semigroup[I]">I</a>.<span title="(f1: I, f2: =&gt; I)I">append</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.repartition.go.$anonfun.next.$anonfun.c" title="I">c</a>, <a href="#scalaz.stream.process1.repartition.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
        val <a title="IndexedSeq[I]" id="scalaz.stream.process1.repartition.go.$anonfun.parts">parts</a> = <a href="#scalaz.stream.process1.repartition.p" title="(v1: I)IndexedSeq[I]">p</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.repartition.go.$anonfun.next" title="I">next</a><span class="delimiter">)</span>
        <a href="#scalaz.stream.process1.repartition.go.$anonfun.parts" title="IndexedSeq[I]">parts</a>.<span title="=&gt; Int">size</span> match <span class="delimiter">{</span>
          case <span title="Int(0)" class="int">0</span> =&gt; <a href="#scalaz.stream.process1.repartition.go" title="(carry: Option[I])scalaz.stream.Process1[I,I]">go</a><span class="delimiter">(</span><span title="None.type">None</span><span class="delimiter">)</span>
          case <span title="Int(1)" class="int">1</span> =&gt; <a href="#scalaz.stream.process1.repartition.go" title="(carry: Option[I])scalaz.stream.Process1[I,I]">go</a><span class="delimiter">(</span><span title="(x: I)Some[I]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.repartition.go.$anonfun.parts" title="IndexedSeq[I]">parts</a>.<span title="=&gt; I">head</span><span class="delimiter">)</span><span class="delimiter">)</span>
          case _ =&gt; <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[I])scalaz.stream.Process0[I]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.repartition.go.$anonfun.parts" title="IndexedSeq[I]">parts</a>.<span title="=&gt; IndexedSeq[I]">init</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I]">++</a> <a href="#scalaz.stream.process1.repartition.go" title="(carry: Option[I])scalaz.stream.Process1[I,I]">go</a><span class="delimiter">(</span><span title="(x: I)Some[I]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.repartition.go.$anonfun.parts" title="IndexedSeq[I]">parts</a>.<span title="=&gt; I">last</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <a href="#scalaz.stream.process1.repartition.go" title="(carry: Option[I])scalaz.stream.Process1[I,I]">go</a><span class="delimiter">(</span><span title="None.type">None</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Repartitions the input with the function `p`. On each step `p` is applied
   * to the input and the first element of the resulting tuple is emitted if it
   * is `Some(x)`. The second element is then prepended to the next input using
   * the Semigroup `I`. In comparison to `repartition` this allows to emit
   * single inputs without prepending them to the next input.
   */</span>
  def <a title="[I](p: I =&gt; (Option[I], Option[I]))(implicit I: scalaz.Semigroup[I])scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.repartition2">repartition2</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.repartition2;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; (Option[I], Option[I])" id="scalaz.stream.process1.repartition2.p">p</a>: I =&gt; <span class="delimiter">(</span>Option<span class="delimiter">[</span>I<span class="delimiter">]</span>, Option<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Semigroup[I]" id="scalaz.stream.process1.repartition2.I">I</a>: <span title="scalaz.Semigroup[I]">Semigroup</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I,I<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(carry: Option[I])scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.repartition2.go">go</a><span class="delimiter">(</span><a title="Option[I]" id="scalaz.stream.process1.repartition2.go.carry">carry</a>: <span title="Option[I]">Option</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I,I<span class="delimiter">]</span> =
      <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[I,I])(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]" class="delimiter">[</span><a href="#scalaz.stream.process1.repartition2;I" title="I">I</a>,<a href="#scalaz.stream.process1.repartition2;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[I])scalaz.stream.Process0[I]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.repartition2.go.carry" title="Option[I]">carry</a>.<span title="=&gt; List[I]">toList</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="I" id="scalaz.stream.process1.repartition2.go.$anonfun.i">i</a> =&gt;
        val <a title="I" id="scalaz.stream.process1.repartition2.go.$anonfun.next">next</a> = <a href="#scalaz.stream.process1.repartition2.go.carry" title="Option[I]">carry</a>.<span title="(ifEmpty: =&gt; I)(f: I =&gt; I)I">fold</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.repartition2.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.repartition2.go.$anonfun.next.$anonfun.c">c</a> =&gt; <a href="#scalaz.stream.process1.repartition2.I" title="scalaz.Semigroup[I]">I</a>.<span title="(f1: I, f2: =&gt; I)I">append</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.repartition2.go.$anonfun.next.$anonfun.c" title="I">c</a>, <a href="#scalaz.stream.process1.repartition2.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
        val <a href="#scalaz.stream.process1.repartition2.go.$anonfun.fst" title="(Option[I], Option[I])" class="delimiter">(</a><a href="#scalaz.stream.process1.repartition2.go.$anonfun.x$22" title="Option[I]" id="scalaz.stream.process1.repartition2.go.$anonfun.fst">fst</a>, <a href="#scalaz.stream.process1.repartition2.go.$anonfun.x$22" title="Option[I]" id="scalaz.stream.process1.repartition2.go.$anonfun.snd">snd</a><span class="delimiter">)</span> = <a href="#scalaz.stream.process1.repartition2.p" title="(v1: I)(Option[I], Option[I])">p</a><span title="(Option[I], Option[I]) @unchecked" class="delimiter">(</span><a href="#scalaz.stream.process1.repartition2.go.$anonfun.next" title="I">next</a><span class="delimiter">)</span>
        <a href="#scalaz.stream.process1.repartition2.go.$anonfun.fst" title="Option[I]">fst</a>.<span title="(ifEmpty: =&gt; scalaz.stream.Process1[I,I])(f: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]">fold</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.repartition2.go" title="(carry: Option[I])scalaz.stream.Process1[I,I]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.repartition2.go.$anonfun.snd" title="Option[I]">snd</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.repartition2.go.$anonfun.$anonfun.head">head</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.repartition2.go.$anonfun.$anonfun.head" title="I">head</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I]">++</a> <a href="#scalaz.stream.process1.repartition2.go" title="(carry: Option[I])scalaz.stream.Process1[I,I]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.repartition2.go.$anonfun.snd" title="Option[I]">snd</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#scalaz.stream.process1.repartition2.go" title="(carry: Option[I])scalaz.stream.Process1[I,I]">go</a><span class="delimiter">(</span><span title="None.type">None</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Throws any input exceptions and passes along successful results. */</span>
  def <a title="[A]=&gt; scalaz.stream.Process1[scalaz.\/[Throwable,A],A]" id="scalaz.stream.process1.rethrow">rethrow</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.rethrow;A">A</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[scalaz.\/[Throwable,A],A]">Process1</a><span class="delimiter">[</span>Throwable \/ A, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.id" title="[I]=&gt; scalaz.stream.Process1[I,I]">id</a><span title="scalaz.stream.Process1[scalaz.\/[Throwable,A],scalaz.\/[Throwable,A]]" class="delimiter">[</span>Throwable <span title="scalaz.\/[Throwable,A]">\/</span> A<span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: scalaz.\/[Throwable,A] =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[scalaz.\/[Throwable,A],Any]#Is[x],A])scalaz.stream.Process[[x]scalaz.stream.Process.Env[scalaz.\/[Throwable,A],Any]#Is[x],A]">flatMap</a> <a href="#scalaz.stream.process1.rethrow.$anonfun.x0$3" title="scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[Throwable,A],Any]#Is,A]" class="delimiter">{</a>
      case -\/<span class="delimiter">(</span><a title="Throwable" id="scalaz.stream.process1.rethrow.$anonfun.err">err</a><span class="delimiter">)</span> =&gt; throw <a href="#scalaz.stream.process1.rethrow.$anonfun.err" title="Throwable">err</a>
      case \/-<span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.rethrow.$anonfun.a">a</a><span class="delimiter">)</span>   =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: A)scalaz.stream.Process0[A]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.rethrow.$anonfun.a" title="A">a</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Similar to List.scan.
   * Produces a process of `B` containing cumulative results of applying the operator to Process of `A`.
   * It will always emit `z`, even when the Process of `A` is empty
   */</span>
  def <a title="[A, B](z: B)(f: (B, A) =&gt; B)scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.scan">scan</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.scan;A">A</a>, <a title="" id="scalaz.stream.process1.scan;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="scalaz.stream.process1.scan.z">z</a>: <a href="#scalaz.stream.process1.scan;B" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, A) =&gt; B" id="scalaz.stream.process1.scan.f">f</a>: <span class="delimiter">(</span>B, A<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: B)scalaz.stream.Process0[B]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.scan.z" title="B">z</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B])scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]">++</a> <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: A =&gt; scalaz.stream.Process1[A,B])scalaz.stream.Process1[A,B]">receive1</a><span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.scan.$anonfun.a">a</a> =&gt; <a href="#scalaz.stream.process1.scan" title="(z: B)(f: (B, A) =&gt; B)scalaz.stream.Process1[A,B]">scan</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.scan.f" title="(v1: B, v2: A)B">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.scan.z" title="B">z</a>, <a href="#scalaz.stream.process1.scan.$anonfun.a" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.scan.f" title="(B, A) =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Similar to `scan`, but unlike it it won't emit the `z` even when there is no input of `A`.
   * {{{
   * scala&gt; Process(1, 2, 3, 4).scan1(_ + _).toList
   * res0: List[Int] = List(1, 3, 6, 10)
   *
   * scala&gt; Process(1).scan1(_ + _).toList
   * res1: List[Int] = List(1)
   *
   * scala&gt; Process[Int]().scan1(_ + _).toList
   * res2: List[Int] = List()
   * }}}
   */</span>
  def <a title="[A](f: (A, A) =&gt; A)scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.scan1">scan1</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.scan1;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(A, A) =&gt; A" id="scalaz.stream.process1.scan1.f">f</a>: <span class="delimiter">(</span>A, A<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: A =&gt; scalaz.stream.Process1[A,A])scalaz.stream.Process1[A,A]">receive1</a><span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.scan1.$anonfun.a">a</a> =&gt; <a href="#scalaz.stream.process1.scan" title="(z: A)(f: (A, A) =&gt; A)scalaz.stream.Process1[A,A]">scan</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.scan1.$anonfun.a" title="A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.scan1.f" title="(A, A) =&gt; A">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Like `scan1` only uses `f` to map `A` to `B` and uses Semigroup `M` for
   * associative operation.
   */</span>
  def <a title="[A, B](f: A =&gt; B)(implicit M: scalaz.Semigroup[B])scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.scan1Map">scan1Map</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.scan1Map;A">A</a>, <a title="" id="scalaz.stream.process1.scan1Map;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scalaz.stream.process1.scan1Map.f">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Semigroup[B]" id="scalaz.stream.process1.scan1Map.M">M</a>: <span title="scalaz.Semigroup[B]">Semigroup</span><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.lift" title="(f: A =&gt; B)scalaz.stream.Process1[A,B]">lift</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.scan1Map.f" title="A =&gt; B">f</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process1Ops.scanSemigroup" title="(implicit M: scalaz.Semigroup[B])scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]">scanSemigroup</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.scan1Map.M" title="scalaz.Semigroup[B]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `[[scanSemigroup]](M)`. */</span>
  def <a title="[A](implicit M: scalaz.Monoid[A])scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.scan1Monoid">scan1Monoid</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.scan1Monoid;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[A]" id="scalaz.stream.process1.scan1Monoid.M">M</a>: <span title="scalaz.Monoid[A]">Monoid</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.scanSemigroup" title="(implicit M: scalaz.Semigroup[A])scalaz.stream.Process1[A,A]">scanSemigroup</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.scan1Monoid.M" title="scalaz.Monoid[A]">M</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Like `scan` only uses `f` to map `A` to `B` and uses Monoid `M` for associative operation
   */</span>
  def <a title="[A, B](f: A =&gt; B)(implicit M: scalaz.Monoid[B])scalaz.stream.Process1[A,B]" id="scalaz.stream.process1.scanMap">scanMap</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.scanMap;A">A</a>, <a title="" id="scalaz.stream.process1.scanMap;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scalaz.stream.process1.scanMap.f">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[B]" id="scalaz.stream.process1.scanMap.M">M</a>: <span title="scalaz.Monoid[B]">Monoid</span><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,B]">Process1</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.lift" title="(f: A =&gt; B)scalaz.stream.Process1[A,B]">lift</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.scanMap.f" title="A =&gt; B">f</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process1Ops.scanMonoid" title="(implicit M: scalaz.Monoid[B])scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,B]">scanMonoid</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.scanMap.M" title="scalaz.Monoid[B]">M</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Like `scan` but uses Monoid for associative operation
   */</span>
  def <a title="[A](implicit M: scalaz.Monoid[A])scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.scanMonoid">scanMonoid</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.scanMonoid;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[A]" id="scalaz.stream.process1.scanMonoid.M">M</a>: <span title="scalaz.Monoid[A]">Monoid</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.scan" title="(z: A)(f: (A, A) =&gt; A)scalaz.stream.Process1[A,A]">scan</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.scanMonoid.M" title="scalaz.Monoid[A]">M</a>.<span title="=&gt; A">zero</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.scanMonoid.M" title="scalaz.Monoid[A]">M</a>.<span title="(f1: A, f2: =&gt; A)A">append</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.scanMonoid.$anonfun.x$23" title="A">_</a>, <a href="#scalaz.stream.process1.scanMonoid.$anonfun.x$24" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Like `scan1` but uses Semigroup `M` for associative operation. */</span>
  def <a title="[A](implicit M: scalaz.Semigroup[A])scalaz.stream.Process1[A,A]" id="scalaz.stream.process1.scanSemigroup">scanSemigroup</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.scanSemigroup;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Semigroup[A]" id="scalaz.stream.process1.scanSemigroup.M">M</a>: <span title="scalaz.Semigroup[A]">Semigroup</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,A]">Process1</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.scan1" title="(f: (A, A) =&gt; A)scalaz.stream.Process1[A,A]">scan1</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.scanSemigroup.M" title="scalaz.Semigroup[A]">M</a>.<span title="(f1: A, f2: =&gt; A)A">append</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.scanSemigroup.$anonfun.x$25" title="A">_</a>, <a href="#scalaz.stream.process1.scanSemigroup.$anonfun.x$26" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Emit the given values, then echo the rest of the input.
   *
   * @example {{{
   * scala&gt; Process(3, 4).shiftRight(1, 2).toList
   * res0: List[Int] = List(1, 2, 3, 4)
   * }}}
   */</span>
  def <a title="[I](head: I*)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.shiftRight">shiftRight</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.shiftRight;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I*" id="scalaz.stream.process1.shiftRight.head">head</a>: <span title="I*">I</span>*<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[I])scalaz.stream.Process0[I]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.shiftRight.head" title="I*">head</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I]">++</a> <a href="#scalaz.stream.process1.id" title="scalaz.stream.Process1[I,I]">id</a>

  <span class="comment">/**
   * Reads a single element of the input, emits nothing, then halts.
   *
   * @example {{{
   * scala&gt; import process1._
   * scala&gt; Process(1, 2, 3).pipe(skip ++ id).toList
   * res0: List[Int] = List(2, 3)
   * }}}
   */</span>
  def <a title="=&gt; scalaz.stream.Process1[Any,Nothing]" id="scalaz.stream.process1.skip">skip</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[Any,Nothing]">Process1</a><span class="delimiter">[</span>Any, Nothing<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: Any =&gt; scalaz.stream.Process1[Any,Nothing])scalaz.stream.Process1[Any,Nothing]">receive1</a><span class="delimiter">(</span><a title="Any" id="scalaz.stream.process1.skip.$anonfun.x$27">_</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Groups inputs in fixed size chunks by passing a &quot;sliding window&quot;
   * of size `n` over them. If the input contains less than or equal to
   * `n` elements, only one chunk of this size will be emitted.
   *
   * @example {{{
   * scala&gt; Process(1, 2, 3, 4).sliding(2).toList
   * res0: List[Vector[Int]] = List(Vector(1, 2), Vector(2, 3), Vector(3, 4))
   * }}}
   * @throws IllegalArgumentException if `n` &lt;= 0
   */</span>
  def <a title="[I](n: Int)scalaz.stream.Process1[I,Vector[I]]" id="scalaz.stream.process1.sliding">sliding</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.sliding;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scalaz.stream.process1.sliding.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Vector[I]]">Process1</a><span class="delimiter">[</span>I, Vector<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.sliding.n" title="Int">n</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span>, <span title="String(&quot;window size must be &gt; 0, was: &quot;)" class="string">&quot;window size must be &gt; 0, was: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scalaz.stream.process1.sliding.n" title="Int">n</a><span class="delimiter">)</span>
    def <a title="(window: Vector[I])scalaz.stream.Process1[I,Vector[I]]" id="scalaz.stream.process1.sliding.go">go</a><span class="delimiter">(</span><a title="Vector[I]" id="scalaz.stream.process1.sliding.go.window">window</a>: <span title="Vector[I]">Vector</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Vector[I]]">Process1</a><span class="delimiter">[</span>I, Vector<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: Vector[I])scalaz.stream.Process0[Vector[I]]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.sliding.go.window" title="Vector[I]">window</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,Vector[I]])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,Vector[I]]">++</a> <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: I =&gt; scalaz.stream.Process1[I,Vector[I]])scalaz.stream.Process1[I,Vector[I]]">receive1</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.sliding.go.$anonfun.i">i</a> =&gt; <a href="#scalaz.stream.process1.sliding.go" title="(window: Vector[I])scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.sliding.go.window" title="Vector[I]">window</a>.<span title="=&gt; scala.collection.immutable.Vector[I]">tail</span> <span title="(elem: I)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[I],I,Vector[I]])Vector[I]">:+</span> <a href="#scalaz.stream.process1.sliding.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#scalaz.stream.process1.chunk" title="(n: Int)scalaz.stream.Process1[I,Vector[I]]">chunk</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.sliding.n" title="Int">n</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process1Ops.once" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,Vector[I]]">once</a>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: Vector[I] =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],Vector[I]])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],Vector[I]]">flatMap</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.sliding.go" title="(window: Vector[I])scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Break the input into chunks where the delimiter matches the predicate.
   * The delimiter does not appear in the output. Two adjacent delimiters in the
   * input result in an empty chunk in the output.
   */</span>
  def <a title="[I](f: I =&gt; Boolean)scalaz.stream.Process1[I,Vector[I]]" id="scalaz.stream.process1.split">split</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.split;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; Boolean" id="scalaz.stream.process1.split.f">f</a>: I =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Vector[I]]">Process1</a><span class="delimiter">[</span>I, Vector<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(acc: Vector[I])scalaz.stream.Process1[I,Vector[I]]" id="scalaz.stream.process1.split.go">go</a><span class="delimiter">(</span><a title="Vector[I]" id="scalaz.stream.process1.split.go.acc">acc</a>: <span title="Vector[I]">Vector</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Vector[I]]">Process1</a><span class="delimiter">[</span>I, Vector<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[I,Vector[I]])(rcv: I =&gt; scalaz.stream.Process1[I,Vector[I]])scalaz.stream.Process1[I,Vector[I]]" class="delimiter">[</span><a href="#scalaz.stream.process1.split;I" title="I">I</a>, <span title="Vector[I]">Vector</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: Vector[I])scalaz.stream.Process0[Vector[I]]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.split.go.acc" title="Vector[I]">acc</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="I" id="scalaz.stream.process1.split.go.$anonfun.i">i</a> =&gt;
        if <span class="delimiter">(</span><a href="#scalaz.stream.process1.split.f" title="(v1: I)Boolean">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.split.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: Vector[I])scalaz.stream.Process0[Vector[I]]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.split.go.acc" title="Vector[I]">acc</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,Vector[I]])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,Vector[I]]">++</a> <a href="#scalaz.stream.process1.split.go" title="(acc: Vector[I])scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
        else <a href="#scalaz.stream.process1.split.go" title="(acc: Vector[I])scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.split.go.acc" title="Vector[I]">acc</a> <span title="(elem: I)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[I],I,Vector[I]])Vector[I]">:+</span> <a href="#scalaz.stream.process1.split.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#scalaz.stream.process1.split.go" title="(acc: Vector[I])scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Break the input into chunks where the input is equal to the given delimiter.
   * The delimiter does not appear in the output. Two adjacent delimiters in the
   * input result in an empty chunk in the output.
   */</span>
  def <a title="[I](i: I)(implicit evidence$7: scalaz.Equal[I])scalaz.stream.Process1[I,Vector[I]]" id="scalaz.stream.process1.splitOn">splitOn</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.splitOn;I">I</a>: Equal<span class="delimiter">]</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.splitOn.i">i</a>: <a href="#scalaz.stream.process1.splitOn;I" title="I">I</a><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Vector[I]]">Process1</a><span class="delimiter">[</span>I, Vector<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.split" title="(f: I =&gt; Boolean)scalaz.stream.Process1[I,Vector[I]]">split</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.splitOn.$anonfun.x$28" title="(v: I)(implicit F0: scalaz.Equal[I])scalaz.syntax.EqualOps[I]">_</a> <span title="(other: I)Boolean">===</span> <a href="#scalaz.stream.process1.splitOn.i" title="I">i</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Breaks the input into chunks that alternatively satisfy and don't satisfy
   * the predicate `f`.
   *
   * @example {{{
   * scala&gt; Process(1, 2, -3, -4, 5, 6).splitWith(_ &lt; 0).toList
   * res0: List[Vector[Int]] = List(Vector(1, 2), Vector(-3, -4), Vector(5, 6))
   * }}}
   */</span>
  def <a title="[I](f: I =&gt; Boolean)scalaz.stream.Process1[I,Vector[I]]" id="scalaz.stream.process1.splitWith">splitWith</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.splitWith;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; Boolean" id="scalaz.stream.process1.splitWith.f">f</a>: I =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Vector[I]]">Process1</a><span class="delimiter">[</span>I, Vector<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(acc: Vector[I], last: Boolean)scalaz.stream.Process1[I,Vector[I]]" id="scalaz.stream.process1.splitWith.go">go</a><span class="delimiter">(</span><a title="Vector[I]" id="scalaz.stream.process1.splitWith.go.acc">acc</a>: <span title="Vector[I]">Vector</span><span class="delimiter">[</span>I<span class="delimiter">]</span>, <a title="Boolean" id="scalaz.stream.process1.splitWith.go.last">last</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,Vector[I]]">Process1</a><span class="delimiter">[</span>I, Vector<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[I,Vector[I]])(rcv: I =&gt; scalaz.stream.Process1[I,Vector[I]])scalaz.stream.Process1[I,Vector[I]]" class="delimiter">[</span><a href="#scalaz.stream.process1.splitWith;I" title="I">I</a>, <span title="Vector[I]">Vector</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: Vector[I])scalaz.stream.Process0[Vector[I]]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.splitWith.go.acc" title="Vector[I]">acc</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="I" id="scalaz.stream.process1.splitWith.go.$anonfun.i">i</a> =&gt;
         val <a title="Boolean" id="scalaz.stream.process1.splitWith.go.$anonfun.cur">cur</a> = <a href="#scalaz.stream.process1.splitWith.f" title="(v1: I)Boolean">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.splitWith.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span>
         if <span class="delimiter">(</span><a href="#scalaz.stream.process1.splitWith.go.$anonfun.cur" title="Boolean">cur</a> <span title="(x: Boolean)Boolean">==</span> <a href="#scalaz.stream.process1.splitWith.go.last" title="Boolean">last</a><span class="delimiter">)</span> <a href="#scalaz.stream.process1.splitWith.go" title="(acc: Vector[I], last: Boolean)scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.splitWith.go.acc" title="Vector[I]">acc</a> <span title="(elem: I)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[I],I,Vector[I]])Vector[I]">:+</span> <a href="#scalaz.stream.process1.splitWith.go.$anonfun.i" title="I">i</a>, <a href="#scalaz.stream.process1.splitWith.go.$anonfun.cur" title="Boolean">cur</a><span class="delimiter">)</span>
         else <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: Vector[I])scalaz.stream.Process0[Vector[I]]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.splitWith.go.acc" title="Vector[I]">acc</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,Vector[I]])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,Vector[I]]">++</a> <a href="#scalaz.stream.process1.splitWith.go" title="(acc: Vector[I], last: Boolean)scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><span title="(elems: I*)scala.collection.immutable.Vector[I]">Vector</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.splitWith.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span>, <a href="#scalaz.stream.process1.splitWith.go.$anonfun.cur" title="Boolean">cur</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: I =&gt; scalaz.stream.Process1[I,Vector[I]])scalaz.stream.Process1[I,Vector[I]]">receive1</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.splitWith.$anonfun.i">i</a> =&gt; <a href="#scalaz.stream.process1.splitWith.go" title="(acc: Vector[I], last: Boolean)scalaz.stream.Process1[I,Vector[I]]">go</a><span class="delimiter">(</span><span title="(elems: I*)scala.collection.immutable.Vector[I]">Vector</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.splitWith.$anonfun.i" title="I">i</a><span class="delimiter">)</span>, <a href="#scalaz.stream.process1.splitWith.f" title="(v1: I)Boolean">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.splitWith.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Remove any `None` inputs. */</span>
  def <a title="[A]=&gt; scalaz.stream.Process1[Option[A],A]" id="scalaz.stream.process1.stripNone">stripNone</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.stripNone;A">A</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[Option[A],A]">Process1</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.collect" title="(pf: PartialFunction[Option[A],A])scalaz.stream.Process1[Option[A],A]">collect</a> <a title="&lt;$anon: Option[A] =&gt; A&gt; extends scala.runtime.AbstractPartialFunction[Option[A],A] with Serializable" id="scalaz.stream.process1.stripNone;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> case Some<span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.stripNone;$anonfun.isDefinedAt.a">a</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.process1.stripNone;$anonfun.isDefinedAt.a" title="A">a</a> <span class="delimiter">}</span>

  <span class="comment">/**
   * Emits the sum of all input elements or zero if the input is empty.
   *
   * @example {{{
   * scala&gt; Process(1, 2, 3).sum.toList
   * res0: List[Int] = List(6)
   *
   * scala&gt; Process[Int]().sum.toList
   * res1: List[Int] = List(0)
   * }}}
   */</span>
  def <a title="[N](implicit N: Numeric[N])scalaz.stream.Process1[N,N]" id="scalaz.stream.process1.sum">sum</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.sum;N">N</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="Numeric[N]" id="scalaz.stream.process1.sum.N">N</a>: <span title="Numeric[N]">Numeric</span><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[N,N]">Process1</a><span class="delimiter">[</span>N,N<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.fold" title="(z: N)(f: (N, N) =&gt; N)scalaz.stream.Process1[N,N]">fold</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.sum.N" title="Numeric[N]">N</a>.<span title="=&gt; N">zero</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.sum.N" title="Numeric[N]">N</a>.<a href="#scalaz.stream.process1.sum.$anonfun.x" title="(x: N, y: N)N">plus</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Emits all elements of the input except the first one.
   *
   * @example {{{
   * scala&gt; Process(1, 2, 3).tail.toList
   * res0: List[Int] = List(2, 3)
   *
   * scala&gt; Process[Int]().tail.toList
   * res1: List[Int] = List()
   * }}}
   */</span>
  def <a title="[I]=&gt; scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.tail">tail</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.tail;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]">receive1</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.tail.$anonfun.x$29">_</a> =&gt; <a href="#scalaz.stream.process1.id" title="scalaz.stream.Process1[I,I]">id</a><span class="delimiter">)</span>

  <span class="comment">/** Passes through `n` elements of the input, then halts. */</span>
  def <a title="[I](n: Int)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.take">take</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.take;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scalaz.stream.process1.take.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#scalaz.stream.process1.take.n" title="Int">n</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>
    else <a href="Process.scala.html#scalaz.stream.Process.await1" title="[I]=&gt; scalaz.stream.Process1[I,I]">await1</a><span title="scalaz.stream.Process1[I,I]" class="delimiter">[</span><a href="#scalaz.stream.process1.take;I" title="I">I</a><span class="delimiter">]</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I]">++</a> <a href="#scalaz.stream.process1.take" title="(n: Int)scalaz.stream.Process1[I,I]">take</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.take.n" title="Int">n</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

  <span class="comment">/** Emits the last `n` elements of the input. */</span>
  def <a title="[I](n: Int)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.takeRight">takeRight</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.takeRight;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scalaz.stream.process1.takeRight.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(acc: Vector[I])scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.takeRight.go">go</a><span class="delimiter">(</span><a title="Vector[I]" id="scalaz.stream.process1.takeRight.go.acc">acc</a>: <span title="Vector[I]">Vector</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
      <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[I,I])(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]" class="delimiter">[</span><a href="#scalaz.stream.process1.takeRight;I" title="I">I</a>, <a href="#scalaz.stream.process1.takeRight;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[I])scalaz.stream.Process0[I]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.takeRight.go.acc" title="Vector[I]">acc</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.takeRight.go.$anonfun.i">i</a> =&gt; <a href="#scalaz.stream.process1.takeRight.go" title="(acc: Vector[I])scalaz.stream.Process1[I,I]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.takeRight.go.acc" title="Vector[I]">acc</a>.<span title="=&gt; scala.collection.immutable.Vector[I]">tail</span> <span title="(elem: I)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[I],I,Vector[I]])Vector[I]">:+</span> <a href="#scalaz.stream.process1.takeRight.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#scalaz.stream.process1.takeRight.n" title="Int">n</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>
    else <a href="#scalaz.stream.process1.chunk" title="(n: Int)scalaz.stream.Process1[I,Vector[I]]">chunk</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.takeRight.n" title="Int">n</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process1Ops.once" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,Vector[I]]">once</a>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: Vector[I] =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#Is[x],I]">flatMap</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.takeRight.go" title="(acc: Vector[I])scalaz.stream.Process1[I,I]">go</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Passes through elements of the input as long as the predicate is true, then halts. */</span>
  def <a title="[I](f: I =&gt; Boolean)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.takeWhile">takeWhile</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.takeWhile;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; Boolean" id="scalaz.stream.process1.takeWhile.f">f</a>: I =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]">receive1</a> <span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.takeWhile.$anonfun.i">i</a> =&gt; if <span class="delimiter">(</span><a href="#scalaz.stream.process1.takeWhile.f" title="(v1: I)Boolean">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.takeWhile.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.takeWhile.$anonfun.i" title="I">i</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I]">++</a> <a href="#scalaz.stream.process1.takeWhile" title="(f: I =&gt; Boolean)scalaz.stream.Process1[I,I]">takeWhile</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.takeWhile.f" title="I =&gt; Boolean">f</a><span class="delimiter">)</span> else <a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a><span class="delimiter">)</span>

  <span class="comment">/** Like `takeWhile`, but emits the first value which tests false. */</span>
  def <a title="[I](f: I =&gt; Boolean)scalaz.stream.Process1[I,I]" id="scalaz.stream.process1.takeThrough">takeThrough</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.takeThrough;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; Boolean" id="scalaz.stream.process1.takeThrough.f">f</a>: I =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]">receive1</a> <span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.takeThrough.$anonfun.i">i</a> =&gt; if <span class="delimiter">(</span><a href="#scalaz.stream.process1.takeThrough.f" title="(v1: I)Boolean">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.takeThrough.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.takeThrough.$anonfun.i" title="I">i</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I]">++</a> <a href="#scalaz.stream.process1.takeThrough" title="(f: I =&gt; Boolean)scalaz.stream.Process1[I,I]">takeThrough</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.takeThrough.f" title="I =&gt; Boolean">f</a><span class="delimiter">)</span> else <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.takeThrough.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Wraps all inputs in `Some`, then outputs a single `None` before halting. */</span>
  def <a title="[A]=&gt; scalaz.stream.Process1[A,Option[A]]" id="scalaz.stream.process1.terminated">terminated</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.terminated;A">A</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,Option[A]]">Process1</a><span class="delimiter">[</span>A, Option<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
     <a href="#scalaz.stream.process1.lift" title="[I, O](f: I =&gt; O)scalaz.stream.Process1[I,O]">lift</a><span title="(f: A =&gt; Option[A])scalaz.stream.Process1[A,Option[A]]" class="delimiter">[</span><a href="#scalaz.stream.process1.terminated;A" title="A">A</a>, <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="(x: A)Some[A]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.terminated.$anonfun.x$30" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.onComplete" title="(p2: =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[A,Any]#Is[x],Option[A]])scalaz.stream.Process[[x]scalaz.stream.Process.Env[A,Any]#Is[x],Option[A]]">onComplete</a> <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: None.type)scalaz.stream.Process0[None.type]">emit</a><span class="delimiter">(</span><span title="None.type">None</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Ungroups chunked input.
   *
   * @example {{{
   * scala&gt; Process(Seq(1, 2), Seq(3)).pipe(process1.unchunk).toList
   * res0: List[Int] = List(1, 2, 3)
   * }}}
   */</span>
  def <a title="[I]=&gt; scalaz.stream.Process1[Seq[I],I]" id="scalaz.stream.process1.unchunk">unchunk</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.unchunk;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[Seq[I],I]">Process1</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>I<span class="delimiter">]</span>, I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.id" title="[I]=&gt; scalaz.stream.Process1[I,I]">id</a><span title="scalaz.stream.Process1[Seq[I],Seq[I]]" class="delimiter">[</span><span title="Seq[I]">Seq</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: Seq[I] =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[Seq[I],Any]#Is[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[Seq[I],Any]#Is[x],I]">flatMap</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[I])scalaz.stream.Process0[I]">emitAll</a><span class="delimiter">)</span>

  <span class="comment">/** Zips the input with an index of type `Int`. */</span>
  def <a title="[A]=&gt; scalaz.stream.Process1[A,(A, Int)]" id="scalaz.stream.process1.zipWithIndex(55865e1c79)">zipWithIndex</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.zipWithIndex(55865e1c79);A">A</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,(A, Int)]">Process1</a><span class="delimiter">[</span>A,<span class="delimiter">(</span>A,Int<span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.zipWithIndex(72501a8a67)" title="[A, N](implicit N: Numeric[N])scalaz.stream.Process1[A,(A, N)]">zipWithIndex</a><span title="(implicit N: Numeric[Int])scalaz.stream.Process1[A,(A, Int)]" class="delimiter">[</span><a href="#scalaz.stream.process1.zipWithIndex(55865e1c79);A" title="A">A</a>,<span title="Int">Int</span><span class="delimiter">]</span>

  <span class="comment">/** Zips the input with an index of type `N`. */</span>
  def <a title="[A, N](implicit N: Numeric[N])scalaz.stream.Process1[A,(A, N)]" id="scalaz.stream.process1.zipWithIndex(72501a8a67)">zipWithIndex</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.zipWithIndex(72501a8a67);A">A</a>,<a title="" id="scalaz.stream.process1.zipWithIndex(72501a8a67);N">N</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="Numeric[N]" id="scalaz.stream.process1.zipWithIndex(72501a8a67).N">N</a>: <span title="Numeric[N]">Numeric</span><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,(A, N)]">Process1</a><span class="delimiter">[</span>A,<span class="delimiter">(</span>A,N<span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.zipWithState" title="(z: N)(next: (A, N) =&gt; N)scalaz.stream.Process1[A,(A, N)]">zipWithState</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithIndex(72501a8a67).N" title="Numeric[N]">N</a>.<span title="=&gt; N">zero</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.zipWithIndex(72501a8a67).$anonfun.x$31">_</a>, <a title="N" id="scalaz.stream.process1.zipWithIndex(72501a8a67).$anonfun.n">n</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.process1.zipWithIndex(72501a8a67).N" title="Numeric[N]">N</a>.<span title="(x: N, y: N)N">plus</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithIndex(72501a8a67).$anonfun.n" title="N">n</a>, <a href="#scalaz.stream.process1.zipWithIndex(72501a8a67).N" title="Numeric[N]">N</a>.<span title="=&gt; N">one</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Zips every element with its previous element wrapped into `Some`.
   * The first element is zipped with `None`.
   */</span>
  def <a title="[I]=&gt; scalaz.stream.Process1[I,(Option[I], I)]" id="scalaz.stream.process1.zipWithPrevious">zipWithPrevious</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.zipWithPrevious;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,(Option[I], I)]">Process1</a><span class="delimiter">[</span>I,<span class="delimiter">(</span>Option<span class="delimiter">[</span>I<span class="delimiter">]</span>,I<span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.zipWithState" title="[A, B](z: B)(next: (A, B) =&gt; B)scalaz.stream.Process1[A,(A, B)]">zipWithState</a><span title="(z: Option[I])(next: (I, Option[I]) =&gt; Option[I])scalaz.stream.Process1[I,(I, Option[I])]" class="delimiter">[</span><a href="#scalaz.stream.process1.zipWithPrevious;I" title="I">I</a>,<span title="Option[I]">Option</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="None.type">None</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.zipWithPrevious.$anonfun.cur">cur</a>, <a title="Option[I]" id="scalaz.stream.process1.zipWithPrevious.$anonfun.x$32">_</a><span class="delimiter">)</span> =&gt; <span title="(x: I)Some[I]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithPrevious.$anonfun.cur" title="I">cur</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.map" title="(f: ((I, Option[I])) =&gt; (Option[I], I))scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,(Option[I], I)]">map</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithPrevious.$anonfun.x$33" title="(I, Option[I])">_</a>.<span title="=&gt; (Option[I], I)">swap</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Zips every element with its next element wrapped into `Some`.
   * The last element is zipped with `None`.
   */</span>
  def <a title="[I]=&gt; scalaz.stream.Process1[I,(I, Option[I])]" id="scalaz.stream.process1.zipWithNext">zipWithNext</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.zipWithNext;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,(I, Option[I])]">Process1</a><span class="delimiter">[</span>I,<span class="delimiter">(</span>I,Option<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(prev: I)scalaz.stream.Process1[I,(I, Option[I])]" id="scalaz.stream.process1.zipWithNext.go">go</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.zipWithNext.go.prev">prev</a>: <a href="#scalaz.stream.process1.zipWithNext;I" title="I">I</a><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,(I, Option[I])]">Process1</a><span class="delimiter">[</span>I,<span class="delimiter">(</span>I,Option<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> =
      <a href="Process.scala.html#scalaz.stream.Process.receive1Or" title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">receive1Or</a><span title="(fb: =&gt; scalaz.stream.Process1[I,(I, Option[I])])(rcv: I =&gt; scalaz.stream.Process1[I,(I, Option[I])])scalaz.stream.Process1[I,(I, Option[I])]" class="delimiter">[</span><a href="#scalaz.stream.process1.zipWithNext;I" title="I">I</a>,<span title="(I, Option[I])" class="delimiter">(</span>I,Option<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: (I, None.type))scalaz.stream.Process0[(I, None.type)]">emit</a><span class="delimiter">(</span><span title="(_1: I, _2: None.type)(I, None.type)" class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithNext.go.prev" title="I">prev</a>, <span title="None.type">None</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.process1.zipWithNext.go.$anonfun.i">i</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: (I, Some[I]))scalaz.stream.Process0[(I, Some[I])]">emit</a><span class="delimiter">(</span><span title="(_1: I, _2: Some[I])(I, Some[I])" class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithNext.go.prev" title="I">prev</a>, <span title="(x: I)Some[I]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithNext.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,(I, Option[I])])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,(I, Option[I])]">++</a> <a href="#scalaz.stream.process1.zipWithNext.go" title="(prev: I)scalaz.stream.Process1[I,(I, Option[I])]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithNext.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: I =&gt; scalaz.stream.Process1[I,(I, Option[I])])scalaz.stream.Process1[I,(I, Option[I])]">receive1</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithNext.go" title="(prev: I)scalaz.stream.Process1[I,(I, Option[I])]">go</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Zips every element with its previous and next elements wrapped into `Some`.
   * The first element is zipped with `None` as the previous element,
   * the last element is zipped with `None` as the next element.
   */</span>
  def <a title="[I]=&gt; scalaz.stream.Process1[I,(Option[I], I, Option[I])]" id="scalaz.stream.process1.zipWithPreviousAndNext">zipWithPreviousAndNext</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.zipWithPreviousAndNext;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,(Option[I], I, Option[I])]">Process1</a><span class="delimiter">[</span>I,<span class="delimiter">(</span>Option<span class="delimiter">[</span>I<span class="delimiter">]</span>,I,Option<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="#scalaz.stream.process1.zipWithPrevious" title="scalaz.stream.Process1[I,(Option[I], I)]">zipWithPrevious</a>.<a href="Process.scala.html#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[(Option[I], I),((Option[I], I), Option[(Option[I], I)])])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,((Option[I], I), Option[(Option[I], I)])]">pipe</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithNext" title="[I]=&gt; scalaz.stream.Process1[I,(I, Option[I])]">zipWithNext</a><span title="scalaz.stream.Process1[(Option[I], I),((Option[I], I), Option[(Option[I], I)])]" class="delimiter">[</span><span title="(Option[I], I)" class="delimiter">(</span>Option<span class="delimiter">[</span>I<span class="delimiter">]</span>,I<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.map" title="(f: (((Option[I], I), Option[(Option[I], I)])) =&gt; (Option[I], I, Option[I]))scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,(Option[I], I, Option[I])]">map</a> <a href="#scalaz.stream.process1.zipWithPreviousAndNext.$anonfun.x0$4" title="(Option[I], I, Option[I])" class="delimiter">{</a>
      case <span class="delimiter">(</span><span class="delimiter">(</span><span title="Option[I]">previous</span>, <span title="I">current</span><span class="delimiter">)</span>, <span title="None.type">None</span><span class="delimiter">)</span>            =&gt;  <span title="(_1: Option[I], _2: I, _3: None.type)(Option[I], I, None.type)" class="delimiter">(</span><span title="Option[I]">previous</span>, <span title="I">current</span>, <span title="None.type">None</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span><span class="delimiter">(</span><span title="Option[I]">previous</span>, <span title="I">current</span><span class="delimiter">)</span>, Some<span class="delimiter">(</span><span class="delimiter">(</span>_, <a title="I" id="scalaz.stream.process1.zipWithPreviousAndNext.$anonfun.next">next</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;  <span title="(_1: Option[I], _2: I, _3: Some[I])(Option[I], I, Some[I])" class="delimiter">(</span><span title="Option[I]">previous</span>, <span title="I">current</span>, <span title="(x: I)Some[I]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithPreviousAndNext.$anonfun.next" title="I">next</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Zips the input with a running total according to `B`, up to but not including the
   * current element. Thus the initial `z` value is the first emitted to the output:
   *
   * {{{
   * scala&gt; Process(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;, &quot;cuatro&quot;).zipWithScan(0)(_.length + _).toList
   * res0: List[(String,Int)] = List((uno,0), (dos,3), (tres,6), (cuatro,10))
   * }}}
   *
   * @see [[zipWithScan1]]
   */</span>
  def <a title="[A, B](z: B)(f: (A, B) =&gt; B)scalaz.stream.Process1[A,(A, B)]" id="scalaz.stream.process1.zipWithScan">zipWithScan</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.zipWithScan;A">A</a>,<a title="" id="scalaz.stream.process1.zipWithScan;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="scalaz.stream.process1.zipWithScan.z">z</a>: <a href="#scalaz.stream.process1.zipWithScan;B" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; B" id="scalaz.stream.process1.zipWithScan.f">f</a>: <span class="delimiter">(</span>A,B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,(A, B)]">Process1</a><span class="delimiter">[</span>A,<span class="delimiter">(</span>A,B<span class="delimiter">)</span><span class="delimiter">]</span> =
   <a href="#scalaz.stream.process1.zipWithState" title="(z: B)(next: (A, B) =&gt; B)scalaz.stream.Process1[A,(A, B)]">zipWithState</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithScan.z" title="B">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithScan.f" title="(A, B) =&gt; B">f</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Zips the input with a running total according to `B`, up to and including the
   * current element. Thus the initial `z` value is not emitted to the output:
   *
   * {{{
   * scala&gt; Process(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;, &quot;cuatro&quot;).zipWithScan1(0)(_.length + _).toList
   * res0: List[(String,Int)] = List((uno,3), (dos,6), (tres,10), (cuatro,16))
   * }}}
   *
   * @see [[zipWithScan]]
   */</span>
  def <a title="[A, B](z: B)(f: (A, B) =&gt; B)scalaz.stream.Process1[A,(A, B)]" id="scalaz.stream.process1.zipWithScan1">zipWithScan1</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.zipWithScan1;A">A</a>,<a title="" id="scalaz.stream.process1.zipWithScan1;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="scalaz.stream.process1.zipWithScan1.z">z</a>: <a href="#scalaz.stream.process1.zipWithScan1;B" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; B" id="scalaz.stream.process1.zipWithScan1.f">f</a>: <span class="delimiter">(</span>A,B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,(A, B)]">Process1</a><span class="delimiter">[</span>A,<span class="delimiter">(</span>A,B<span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: A =&gt; scalaz.stream.Process1[A,(A, B)])scalaz.stream.Process1[A,(A, B)]">receive1</a> <span class="delimiter">{</span> <a title="A" id="scalaz.stream.process1.zipWithScan1.$anonfun.a">a</a> =&gt;
      val <a title="B" id="scalaz.stream.process1.zipWithScan1.$anonfun.z2">z2</a> = <a href="#scalaz.stream.process1.zipWithScan1.f" title="(v1: A, v2: B)B">f</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithScan1.$anonfun.a" title="A">a</a>,<a href="#scalaz.stream.process1.zipWithScan1.z" title="B">z</a><span class="delimiter">)</span>
      <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: (A, B))scalaz.stream.Process0[(A, B)]">emit</a><span class="delimiter">(</span><span title="(_1: A, _2: B)(A, B)" class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithScan1.$anonfun.a" title="A">a</a>,<a href="#scalaz.stream.process1.zipWithScan1.$anonfun.z2" title="B">z2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,(A, B)])scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,(A, B)]">++</a> <a href="#scalaz.stream.process1.zipWithScan1" title="(z: B)(f: (A, B) =&gt; B)scalaz.stream.Process1[A,(A, B)]">zipWithScan1</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithScan1.$anonfun.z2" title="B">z2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithScan1.f" title="(A, B) =&gt; B">f</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Zips the input with state that begins with `z` and is updated by `next`. */</span>
  def <a title="[A, B](z: B)(next: (A, B) =&gt; B)scalaz.stream.Process1[A,(A, B)]" id="scalaz.stream.process1.zipWithState">zipWithState</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.zipWithState;A">A</a>,<a title="" id="scalaz.stream.process1.zipWithState;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="scalaz.stream.process1.zipWithState.z">z</a>: <a href="#scalaz.stream.process1.zipWithState;B" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; B" id="scalaz.stream.process1.zipWithState.next">next</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[A,(A, B)]">Process1</a><span class="delimiter">[</span>A,<span class="delimiter">(</span>A,B<span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.receive1" title="(rcv: A =&gt; scalaz.stream.Process1[A,(A, B)])scalaz.stream.Process1[A,(A, B)]">receive1</a><span class="delimiter">(</span><a title="A" id="scalaz.stream.process1.zipWithState.$anonfun.a">a</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: (A, B))scalaz.stream.Process0[(A, B)]">emit</a><span class="delimiter">(</span><span title="(_1: A, _2: B)(A, B)" class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithState.$anonfun.a" title="A">a</a>, <a href="#scalaz.stream.process1.zipWithState.z" title="B">z</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,(A, B)])scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,(A, B)]">++</a> <a href="#scalaz.stream.process1.zipWithState" title="(z: B)(next: (A, B) =&gt; B)scalaz.stream.Process1[A,(A, B)]">zipWithState</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithState.next" title="(v1: A, v2: B)B">next</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithState.$anonfun.a" title="A">a</a>, <a href="#scalaz.stream.process1.zipWithState.z" title="B">z</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.process1.zipWithState.next" title="(A, B) =&gt; B">next</a><span class="delimiter">)</span><span class="delimiter">)</span>

  object <a title="scalaz.stream.process1.Await1.type" id="scalaz.stream.process1.Await1">Await1</a> <a href="#scalaz.stream.process1.Await1" title="scalaz.stream.process1.Await1.type" class="delimiter">{</a>
    <span class="comment">/** deconstruct for `Await` directive of `Process1` */</span>
    def <a title="[I, O](self: scalaz.stream.Process1[I,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process1[I,O]]" id="scalaz.stream.process1.Await1.unapply">unapply</a><span class="delimiter">[</span><a title="" id="scalaz.stream.process1.Await1.unapply;I">I</a>, <a title="" id="scalaz.stream.process1.Await1.unapply;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[I,O]" id="scalaz.stream.process1.Await1.unapply.self">self</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,O]">Process1</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process1[I,O]]">Option</span><span class="delimiter">[</span>EarlyCause \/ I =&gt; Process1<span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scalaz.stream.process1.Await1.unapply.self" title="scalaz.stream.Process1[I,O]">self</a> match <span class="delimiter">{</span>
      case Await<span class="delimiter">(</span>_, <a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O]]" id="scalaz.stream.process1.Await1.unapply.rcv">rcv</a><span class="delimiter">)</span> =&gt; <span title="(x: scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O])Some[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O]]">Some</span><span class="delimiter">(</span><span class="delimiter">(</span>r:EarlyCause<span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I]">\/</span> I<span class="delimiter">)</span> =&gt; <a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.Await1.unapply.rcv" title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,Any])scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O]]">rcv</a><span class="delimiter">(</span><a href="#scalaz.stream.process1.Await1.unapply.$anonfun.r" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I]">r</a><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O]],scalaz.Free.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O]]])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O]">run</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case _             =&gt; <span title="None.type">None</span>
    <span class="delimiter">}</span>

  <span class="delimiter">}</span>



<span title="AnyRef" class="delimiter">}</span>

private<span class="delimiter">[</span>stream<span class="delimiter">]</span> trait <a title="trait Process1Ops[+F[_], +O] extends AnyRef" id="scalaz.stream;Process1Ops">Process1Ops</a><span class="delimiter">[</span>+<a title="[_]" id="scalaz.stream;Process1Ops;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops;F;_">_</a><span class="delimiter">]</span>,+<a title="" id="scalaz.stream;Process1Ops;O">O</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>
  self: Process<span class="delimiter">[</span>F,O<span class="delimiter">]</span> =&gt;

  <span class="comment">/** Alias for `this |&gt; [[process1.awaitOption]]`. */</span>
  def <a title="=&gt; scalaz.stream.Process[F,Option[O]]" id="scalaz.stream;Process1Ops.awaitOption">awaitOption</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,Option[O]]">Process</a><span class="delimiter">[</span>F,Option<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,Option[O]])scalaz.stream.Process[F,Option[O]]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.awaitOption" title="scalaz.stream.Process1[O,Option[O]]">awaitOption</a>

  <span class="comment">/** Alias for `this |&gt; [[process1.buffer]](n)`. */</span>
  def <a title="(n: Int)scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.buffer">buffer</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream;Process1Ops.buffer.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.buffer" title="(n: Int)scalaz.stream.Process1[O,O]">buffer</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.buffer.n" title="Int">n</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.bufferAll]]`. */</span>
  def <a title="=&gt; scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.bufferAll">bufferAll</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.bufferAll" title="scalaz.stream.Process1[O,O]">bufferAll</a>

  <span class="comment">/** Alias for `this |&gt; [[process1.bufferBy]](f)`. */</span>
  def <a title="(f: O =&gt; Boolean)scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.bufferBy">bufferBy</a><span class="delimiter">(</span><a title="O =&gt; Boolean" id="scalaz.stream;Process1Ops.bufferBy.f">f</a>: O =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.bufferBy" title="(f: O =&gt; Boolean)scalaz.stream.Process1[O,O]">bufferBy</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.bufferBy.f" title="O =&gt; Boolean">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.chunk]](n)`. */</span>
  def <a title="(n: Int)scalaz.stream.Process[F,Vector[O]]" id="scalaz.stream;Process1Ops.chunk">chunk</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream;Process1Ops.chunk.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,Vector[O]]">Process</a><span class="delimiter">[</span>F,Vector<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,Vector[O]])scalaz.stream.Process[F,Vector[O]]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.chunk" title="(n: Int)scalaz.stream.Process1[O,Vector[O]]">chunk</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.chunk.n" title="Int">n</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.chunkAll]]`. */</span>
  def <a title="=&gt; scalaz.stream.Process[F,Vector[O]]" id="scalaz.stream;Process1Ops.chunkAll">chunkAll</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,Vector[O]]">Process</a><span class="delimiter">[</span>F,Vector<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,Vector[O]])scalaz.stream.Process[F,Vector[O]]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.chunkAll" title="scalaz.stream.Process1[O,Vector[O]]">chunkAll</a>

  <span class="comment">/** Alias for `this |&gt; [[process1.chunkBy]](f)`. */</span>
  def <a title="(f: O =&gt; Boolean)scalaz.stream.Process[F,Vector[O]]" id="scalaz.stream;Process1Ops.chunkBy">chunkBy</a><span class="delimiter">(</span><a title="O =&gt; Boolean" id="scalaz.stream;Process1Ops.chunkBy.f">f</a>: O =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,Vector[O]]">Process</a><span class="delimiter">[</span>F,Vector<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,Vector[O]])scalaz.stream.Process[F,Vector[O]]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.chunkBy" title="(f: O =&gt; Boolean)scalaz.stream.Process1[O,Vector[O]]">chunkBy</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.chunkBy.f" title="O =&gt; Boolean">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.chunkBy2]](f)`. */</span>
  def <a title="(f: (O, O) =&gt; Boolean)scalaz.stream.Process[F,Vector[O]]" id="scalaz.stream;Process1Ops.chunkBy2">chunkBy2</a><span class="delimiter">(</span><a title="(O, O) =&gt; Boolean" id="scalaz.stream;Process1Ops.chunkBy2.f">f</a>: <span class="delimiter">(</span>O, O<span class="delimiter">)</span> =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,Vector[O]]">Process</a><span class="delimiter">[</span>F,Vector<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,Vector[O]])scalaz.stream.Process[F,Vector[O]]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.chunkBy2" title="(f: (O, O) =&gt; Boolean)scalaz.stream.Process1[O,Vector[O]]">chunkBy2</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.chunkBy2.f" title="(O, O) =&gt; Boolean">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.collect]](pf)`. */</span>
  def <a title="[O2](pf: PartialFunction[O,O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.collect">collect</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.collect;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[O,O2]" id="scalaz.stream;Process1Ops.collect.pf">pf</a>: <span title="PartialFunction[O,O2]">PartialFunction</span><span class="delimiter">[</span>O,O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.collect" title="(pf: PartialFunction[O,O2])scalaz.stream.Process1[O,O2]">collect</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.collect.pf" title="PartialFunction[O,O2]">pf</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.collectFirst]](pf)`. */</span>
  def <a title="[O2](pf: PartialFunction[O,O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.collectFirst">collectFirst</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.collectFirst;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[O,O2]" id="scalaz.stream;Process1Ops.collectFirst.pf">pf</a>: <span title="PartialFunction[O,O2]">PartialFunction</span><span class="delimiter">[</span>O,O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.collectFirst" title="(pf: PartialFunction[O,O2])scalaz.stream.Process1[O,O2]">collectFirst</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.collectFirst.pf" title="PartialFunction[O,O2]">pf</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.delete]](f)`. */</span>
  def <a title="(f: O =&gt; Boolean)scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.delete">delete</a><span class="delimiter">(</span><a title="O =&gt; Boolean" id="scalaz.stream;Process1Ops.delete.f">f</a>: O =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.delete" title="(f: O =&gt; Boolean)scalaz.stream.Process1[O,O]">delete</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.delete.f" title="O =&gt; Boolean">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.distinctConsecutive]]`. */</span>
  def <a title="[O2 &gt;: O](implicit O2: scalaz.Equal[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.distinctConsecutive">distinctConsecutive</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.distinctConsecutive;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Equal[O2]" id="scalaz.stream;Process1Ops.distinctConsecutive.O2">O2</a>: <span title="scalaz.Equal[O2]">Equal</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.distinctConsecutive" title="(implicit evidence$1: scalaz.Equal[O2])scalaz.stream.Process1[O2,O2]">distinctConsecutive</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.distinctConsecutive.O2" title="scalaz.Equal[O2]">O2</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.distinctConsecutiveBy]](f)`. */</span>
  def <a title="[B](f: O =&gt; B)(implicit evidence$8: scalaz.Equal[B])scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.distinctConsecutiveBy">distinctConsecutiveBy</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.distinctConsecutiveBy;B">B</a>: Equal<span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; B" id="scalaz.stream;Process1Ops.distinctConsecutiveBy.f">f</a>: O =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.distinctConsecutiveBy" title="(f: O =&gt; B)(implicit evidence$2: scalaz.Equal[B])scalaz.stream.Process1[O,O]">distinctConsecutiveBy</a><a href="#scalaz.stream;Process1Ops.distinctConsecutiveBy.evidence$8" title="scalaz.Equal[B]" class="delimiter">(</a><a href="#scalaz.stream;Process1Ops.distinctConsecutiveBy.f" title="O =&gt; B">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.drop]](n)`. */</span>
  def <a title="(n: Int)scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.drop">drop</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream;Process1Ops.drop.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.drop" title="(n: Int)scalaz.stream.Process1[O,O]">drop</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.drop.n" title="Int">n</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.dropLast]]`. */</span>
  def <a title="=&gt; scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.dropLast">dropLast</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.dropLast" title="scalaz.stream.Process1[O,O]">dropLast</a>

  <span class="comment">/** Alias for `this |&gt; [[process1.dropLastIf]](p)`. */</span>
  def <a title="(p: O =&gt; Boolean)scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.dropLastIf">dropLastIf</a><span class="delimiter">(</span><a title="O =&gt; Boolean" id="scalaz.stream;Process1Ops.dropLastIf.p">p</a>: O =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.dropLastIf" title="(p: O =&gt; Boolean)scalaz.stream.Process1[O,O]">dropLastIf</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.dropLastIf.p" title="O =&gt; Boolean">p</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.dropRight]](n)`. */</span>
  def <a title="(n: Int)scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.dropRight">dropRight</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream;Process1Ops.dropRight.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.dropRight" title="(n: Int)scalaz.stream.Process1[O,O]">dropRight</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.dropRight.n" title="Int">n</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.dropWhile]](f)`. */</span>
  def <a title="(f: O =&gt; Boolean)scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.dropWhile">dropWhile</a><span class="delimiter">(</span><a title="O =&gt; Boolean" id="scalaz.stream;Process1Ops.dropWhile.f">f</a>: O =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.dropWhile" title="(f: O =&gt; Boolean)scalaz.stream.Process1[O,O]">dropWhile</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.dropWhile.f" title="O =&gt; Boolean">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.exists]](f)` */</span>
  def <a title="(f: O =&gt; Boolean)scalaz.stream.Process[F,Boolean]" id="scalaz.stream;Process1Ops.exists">exists</a><span class="delimiter">(</span><a title="O =&gt; Boolean" id="scalaz.stream;Process1Ops.exists.f">f</a>: O =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,Boolean]">Process</a><span class="delimiter">[</span>F,Boolean<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,Boolean])scalaz.stream.Process[F,Boolean]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.exists" title="(f: O =&gt; Boolean)scalaz.stream.Process1[O,Boolean]">exists</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.exists.f" title="O =&gt; Boolean">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.filter]](f)`. */</span>
  def <a title="(f: O =&gt; Boolean)scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.filter">filter</a><span class="delimiter">(</span><a title="O =&gt; Boolean" id="scalaz.stream;Process1Ops.filter.f">f</a>: O =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.filter" title="(f: O =&gt; Boolean)scalaz.stream.Process1[O,O]">filter</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.filter.f" title="O =&gt; Boolean">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.filterBy2]](f)`. */</span>
  def <a title="(f: (O, O) =&gt; Boolean)scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.filterBy2">filterBy2</a><span class="delimiter">(</span><a title="(O, O) =&gt; Boolean" id="scalaz.stream;Process1Ops.filterBy2.f">f</a>: <span class="delimiter">(</span>O, O<span class="delimiter">)</span> =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.filterBy2" title="(f: (O, O) =&gt; Boolean)scalaz.stream.Process1[O,O]">filterBy2</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.filterBy2.f" title="(O, O) =&gt; Boolean">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.find]](f)` */</span>
  def <a title="(f: O =&gt; Boolean)scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.find">find</a><span class="delimiter">(</span><a title="O =&gt; Boolean" id="scalaz.stream;Process1Ops.find.f">f</a>: O =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.find" title="(f: O =&gt; Boolean)scalaz.stream.Process1[O,O]">find</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.find.f" title="O =&gt; Boolean">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.forall]](f)` */</span>
  def <a title="(f: O =&gt; Boolean)scalaz.stream.Process[F,Boolean]" id="scalaz.stream;Process1Ops.forall">forall</a><span class="delimiter">(</span><a title="O =&gt; Boolean" id="scalaz.stream;Process1Ops.forall.f">f</a>: O =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,Boolean]">Process</a><span class="delimiter">[</span>F,Boolean<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,Boolean])scalaz.stream.Process[F,Boolean]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.forall" title="(f: O =&gt; Boolean)scalaz.stream.Process1[O,Boolean]">forall</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.forall.f" title="O =&gt; Boolean">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.fold]](b)(f)`. */</span>
  def <a title="[O2 &gt;: O](b: O2)(f: (O2, O2) =&gt; O2)scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.fold">fold</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.fold;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="O2" id="scalaz.stream;Process1Ops.fold.b">b</a>: <a href="#scalaz.stream;Process1Ops.fold;O2" title="O2">O2</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(O2, O2) =&gt; O2" id="scalaz.stream;Process1Ops.fold.f">f</a>: <span class="delimiter">(</span>O2,O2<span class="delimiter">)</span> =&gt; O2<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.fold" title="(z: O2)(f: (O2, O2) =&gt; O2)scalaz.stream.Process1[O2,O2]">fold</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.fold.b" title="O2">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.fold.f" title="(O2, O2) =&gt; O2">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.foldMap]](f)(M)`. */</span>
  def <a title="[M](f: O =&gt; M)(implicit M: scalaz.Monoid[M])scalaz.stream.Process[F,M]" id="scalaz.stream;Process1Ops.foldMap">foldMap</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.foldMap;M">M</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; M" id="scalaz.stream;Process1Ops.foldMap.f">f</a>: O =&gt; M<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[M]" id="scalaz.stream;Process1Ops.foldMap.M">M</a>: <span title="scalaz.Monoid[M]">Monoid</span><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,M]">Process</a><span class="delimiter">[</span>F,M<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,M])scalaz.stream.Process[F,M]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.foldMap" title="(f: O =&gt; M)(implicit M: scalaz.Monoid[M])scalaz.stream.Process1[O,M]">foldMap</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.foldMap.f" title="O =&gt; M">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.foldMap.M" title="scalaz.Monoid[M]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.foldMonoid]](M)` */</span>
  def <a title="[O2 &gt;: O](implicit M: scalaz.Monoid[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.foldMonoid">foldMonoid</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.foldMonoid;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[O2]" id="scalaz.stream;Process1Ops.foldMonoid.M">M</a>: <span title="scalaz.Monoid[O2]">Monoid</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.foldMonoid" title="(implicit M: scalaz.Monoid[O2])scalaz.stream.Process1[O2,O2]">foldMonoid</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.foldMonoid.M" title="scalaz.Monoid[O2]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.foldSemigroup]](M)`. */</span>
  def <a title="[O2 &gt;: O](implicit M: scalaz.Semigroup[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.foldSemigroup">foldSemigroup</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.foldSemigroup;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Semigroup[O2]" id="scalaz.stream;Process1Ops.foldSemigroup.M">M</a>: <span title="scalaz.Semigroup[O2]">Semigroup</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.foldSemigroup" title="(implicit M: scalaz.Semigroup[O2])scalaz.stream.Process1[O2,O2]">foldSemigroup</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.foldSemigroup.M" title="scalaz.Semigroup[O2]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.fold1]](f)`. */</span>
  def <a title="[O2 &gt;: O](f: (O2, O2) =&gt; O2)scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.fold1">fold1</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.fold1;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="(O2, O2) =&gt; O2" id="scalaz.stream;Process1Ops.fold1.f">f</a>: <span class="delimiter">(</span>O2,O2<span class="delimiter">)</span> =&gt; O2<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.fold1" title="(f: (O2, O2) =&gt; O2)scalaz.stream.Process1[O2,O2]">fold1</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.fold1.f" title="(O2, O2) =&gt; O2">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.fold1Map]](f)(M)`. */</span>
  def <a title="[M](f: O =&gt; M)(implicit M: scalaz.Monoid[M])scalaz.stream.Process[F,M]" id="scalaz.stream;Process1Ops.fold1Map">fold1Map</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.fold1Map;M">M</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; M" id="scalaz.stream;Process1Ops.fold1Map.f">f</a>: O =&gt; M<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[M]" id="scalaz.stream;Process1Ops.fold1Map.M">M</a>: <span title="scalaz.Monoid[M]">Monoid</span><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,M]">Process</a><span class="delimiter">[</span>F,M<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,M])scalaz.stream.Process[F,M]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.fold1Map" title="(f: O =&gt; M)(implicit M: scalaz.Monoid[M])scalaz.stream.Process1[O,M]">fold1Map</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.fold1Map.f" title="O =&gt; M">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.fold1Map.M" title="scalaz.Monoid[M]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.fold1Monoid]](M)` */</span>
  def <a title="[O2 &gt;: O](implicit M: scalaz.Monoid[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.fold1Monoid">fold1Monoid</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.fold1Monoid;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[O2]" id="scalaz.stream;Process1Ops.fold1Monoid.M">M</a>: <span title="scalaz.Monoid[O2]">Monoid</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.fold1Monoid" title="(implicit M: scalaz.Monoid[O2])scalaz.stream.Process1[O2,O2]">fold1Monoid</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.fold1Monoid.M" title="scalaz.Monoid[O2]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.intersperse]](sep)`. */</span>
  def <a title="[O2 &gt;: O](sep: O2)scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.intersperse">intersperse</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.intersperse;O2">O2</a>&gt;:O<span class="delimiter">]</span><span class="delimiter">(</span><a title="O2" id="scalaz.stream;Process1Ops.intersperse.sep">sep</a>: <a href="#scalaz.stream;Process1Ops.intersperse;O2" title="O2">O2</a><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.intersperse" title="(separator: O2)scalaz.stream.Process1[O2,O2]">intersperse</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.intersperse.sep" title="O2">sep</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.last]]`. */</span>
  def <a title="=&gt; scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.last">last</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.last" title="scalaz.stream.Process1[O,O]">last</a>

  <span class="comment">/** Alias for `this |&gt; [[process1.last]]`. */</span>
  def <a title="[O2 &gt;: O](o: =&gt; O2)scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.lastOr">lastOr</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.lastOr;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; O2" id="scalaz.stream;Process1Ops.lastOr.o">o</a>: =&gt; O2<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.lastOr" title="(li: =&gt; O2)scalaz.stream.Process1[O2,O2]">lastOr</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.lastOr.o" title="=&gt; O2">o</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.maximum]]`. */</span>
  def <a title="[O2 &gt;: O](implicit O2: scalaz.Order[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.maximum">maximum</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.maximum;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Order[O2]" id="scalaz.stream;Process1Ops.maximum.O2">O2</a>: <span title="scalaz.Order[O2]">Order</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.maximum" title="(implicit A: scalaz.Order[O2])scalaz.stream.Process1[O2,O2]">maximum</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.maximum.O2" title="scalaz.Order[O2]">O2</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.maximumBy]](f)`. */</span>
  def <a title="[B](f: O =&gt; B)(implicit evidence$9: scalaz.Order[B])scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.maximumBy">maximumBy</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.maximumBy;B">B</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; B" id="scalaz.stream;Process1Ops.maximumBy.f">f</a>: O =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.maximumBy" title="(f: O =&gt; B)(implicit evidence$3: scalaz.Order[B])scalaz.stream.Process1[O,O]">maximumBy</a><a href="#scalaz.stream;Process1Ops.maximumBy.evidence$9" title="scalaz.Order[B]" class="delimiter">(</a><a href="#scalaz.stream;Process1Ops.maximumBy.f" title="O =&gt; B">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.maximumOf]](f)`. */</span>
  def <a title="[B](f: O =&gt; B)(implicit evidence$10: scalaz.Order[B])scalaz.stream.Process[F,B]" id="scalaz.stream;Process1Ops.maximumOf">maximumOf</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.maximumOf;B">B</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; B" id="scalaz.stream;Process1Ops.maximumOf.f">f</a>: O =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,B]">Process</a><span class="delimiter">[</span>F,B<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,B])scalaz.stream.Process[F,B]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.maximumOf" title="(f: O =&gt; B)(implicit evidence$4: scalaz.Order[B])scalaz.stream.Process1[O,B]">maximumOf</a><a href="#scalaz.stream;Process1Ops.maximumOf.evidence$10" title="scalaz.Order[B]" class="delimiter">(</a><a href="#scalaz.stream;Process1Ops.maximumOf.f" title="O =&gt; B">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.minimum]]`. */</span>
  def <a title="[O2 &gt;: O](implicit O2: scalaz.Order[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.minimum">minimum</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.minimum;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Order[O2]" id="scalaz.stream;Process1Ops.minimum.O2">O2</a>: <span title="scalaz.Order[O2]">Order</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.minimum" title="(implicit A: scalaz.Order[O2])scalaz.stream.Process1[O2,O2]">minimum</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.minimum.O2" title="scalaz.Order[O2]">O2</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.minimumBy]](f)`. */</span>
  def <a title="[B](f: O =&gt; B)(implicit evidence$11: scalaz.Order[B])scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.minimumBy">minimumBy</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.minimumBy;B">B</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; B" id="scalaz.stream;Process1Ops.minimumBy.f">f</a>: O =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.minimumBy" title="(f: O =&gt; B)(implicit evidence$5: scalaz.Order[B])scalaz.stream.Process1[O,O]">minimumBy</a><a href="#scalaz.stream;Process1Ops.minimumBy.evidence$11" title="scalaz.Order[B]" class="delimiter">(</a><a href="#scalaz.stream;Process1Ops.minimumBy.f" title="O =&gt; B">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.minimumOf]](f)`. */</span>
  def <a title="[B](f: O =&gt; B)(implicit evidence$12: scalaz.Order[B])scalaz.stream.Process[F,B]" id="scalaz.stream;Process1Ops.minimumOf">minimumOf</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.minimumOf;B">B</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; B" id="scalaz.stream;Process1Ops.minimumOf.f">f</a>: O =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,B]">Process</a><span class="delimiter">[</span>F,B<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,B])scalaz.stream.Process[F,B]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.minimumOf" title="(f: O =&gt; B)(implicit evidence$6: scalaz.Order[B])scalaz.stream.Process1[O,B]">minimumOf</a><a href="#scalaz.stream;Process1Ops.minimumOf.evidence$12" title="scalaz.Order[B]" class="delimiter">(</a><a href="#scalaz.stream;Process1Ops.minimumOf.f" title="O =&gt; B">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[Process.await1]]`. */</span>
  def <a title="=&gt; scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.once">once</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="Process.scala.html#scalaz.stream.Process.await1" title="scalaz.stream.Process1[O,O]">await1</a>

  <span class="comment">/** Alias for `this |&gt; [[process1.prefixSums]]` */</span>
  def <a title="[O2 &gt;: O](implicit N: Numeric[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.prefixSums">prefixSums</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.prefixSums;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="Numeric[O2]" id="scalaz.stream;Process1Ops.prefixSums.N">N</a>: <span title="Numeric[O2]">Numeric</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.prefixSums" title="(implicit N: Numeric[O2])scalaz.stream.Process1[O2,O2]">prefixSums</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.prefixSums.N" title="Numeric[O2]">N</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.reduce]](f)`. */</span>
  def <a title="[O2 &gt;: O](f: (O2, O2) =&gt; O2)scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.reduce">reduce</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.reduce;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="(O2, O2) =&gt; O2" id="scalaz.stream;Process1Ops.reduce.f">f</a>: <span class="delimiter">(</span>O2,O2<span class="delimiter">)</span> =&gt; O2<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.reduce" title="(f: (O2, O2) =&gt; O2)scalaz.stream.Process1[O2,O2]">reduce</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.reduce.f" title="(O2, O2) =&gt; O2">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.reduceMap]](f)(M)`. */</span>
  def <a title="[M](f: O =&gt; M)(implicit M: scalaz.Semigroup[M])scalaz.stream.Process[F,M]" id="scalaz.stream;Process1Ops.reduceMap">reduceMap</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.reduceMap;M">M</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; M" id="scalaz.stream;Process1Ops.reduceMap.f">f</a>: O =&gt; M<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Semigroup[M]" id="scalaz.stream;Process1Ops.reduceMap.M">M</a>: <span title="scalaz.Semigroup[M]">Semigroup</span><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,M]">Process</a><span class="delimiter">[</span>F,M<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,M])scalaz.stream.Process[F,M]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.reduceMap" title="(f: O =&gt; M)(implicit M: scalaz.Semigroup[M])scalaz.stream.Process1[O,M]">reduceMap</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.reduceMap.f" title="O =&gt; M">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.reduceMap.M" title="scalaz.Semigroup[M]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.reduceMonoid]](M)`. */</span>
  def <a title="[O2 &gt;: O](implicit M: scalaz.Monoid[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.reduceMonoid">reduceMonoid</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.reduceMonoid;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[O2]" id="scalaz.stream;Process1Ops.reduceMonoid.M">M</a>: <span title="scalaz.Monoid[O2]">Monoid</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.reduceMonoid" title="(implicit M: scalaz.Monoid[O2])scalaz.stream.Process1[O2,O2]">reduceMonoid</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.reduceMonoid.M" title="scalaz.Monoid[O2]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.reduceSemigroup]](M)`. */</span>
  def <a title="[O2 &gt;: O](implicit M: scalaz.Semigroup[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.reduceSemigroup">reduceSemigroup</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.reduceSemigroup;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Semigroup[O2]" id="scalaz.stream;Process1Ops.reduceSemigroup.M">M</a>: <span title="scalaz.Semigroup[O2]">Semigroup</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.reduceSemigroup" title="(implicit M: scalaz.Semigroup[O2])scalaz.stream.Process1[O2,O2]">reduceSemigroup</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.reduceSemigroup.M" title="scalaz.Semigroup[O2]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.repartition]](p)(S)` */</span>
  def <a title="[O2 &gt;: O](p: O2 =&gt; IndexedSeq[O2])(implicit S: scalaz.Semigroup[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.repartition">repartition</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.repartition;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="O2 =&gt; IndexedSeq[O2]" id="scalaz.stream;Process1Ops.repartition.p">p</a>: O2 =&gt; IndexedSeq<span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Semigroup[O2]" id="scalaz.stream;Process1Ops.repartition.S">S</a>: <span title="scalaz.Semigroup[O2]">Semigroup</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.repartition" title="(p: O2 =&gt; IndexedSeq[O2])(implicit I: scalaz.Semigroup[O2])scalaz.stream.Process1[O2,O2]">repartition</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.repartition.p" title="O2 =&gt; IndexedSeq[O2]">p</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.repartition.S" title="scalaz.Semigroup[O2]">S</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.repartition2]](p)(S)` */</span>
  def <a title="[O2 &gt;: O](p: O2 =&gt; (Option[O2], Option[O2]))(implicit S: scalaz.Semigroup[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.repartition2">repartition2</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.repartition2;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="O2 =&gt; (Option[O2], Option[O2])" id="scalaz.stream;Process1Ops.repartition2.p">p</a>: O2 =&gt; <span class="delimiter">(</span>Option<span class="delimiter">[</span>O2<span class="delimiter">]</span>, Option<span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Semigroup[O2]" id="scalaz.stream;Process1Ops.repartition2.S">S</a>: <span title="scalaz.Semigroup[O2]">Semigroup</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.repartition2" title="(p: O2 =&gt; (Option[O2], Option[O2]))(implicit I: scalaz.Semigroup[O2])scalaz.stream.Process1[O2,O2]">repartition2</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.repartition2.p" title="O2 =&gt; (Option[O2], Option[O2])">p</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.repartition2.S" title="scalaz.Semigroup[O2]">S</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.scan]](b)(f)`. */</span>
  def <a title="[B](b: B)(f: (B, O) =&gt; B)scalaz.stream.Process[F,B]" id="scalaz.stream;Process1Ops.scan">scan</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.scan;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="scalaz.stream;Process1Ops.scan.b">b</a>: <a href="#scalaz.stream;Process1Ops.scan;B" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, O) =&gt; B" id="scalaz.stream;Process1Ops.scan.f">f</a>: <span class="delimiter">(</span>B,O<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,B]">Process</a><span class="delimiter">[</span>F,B<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,B])scalaz.stream.Process[F,B]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.scan" title="(z: B)(f: (B, O) =&gt; B)scalaz.stream.Process1[O,B]">scan</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.scan.b" title="B">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.scan.f" title="(B, O) =&gt; B">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.scanMap]](f)(M)`. */</span>
  def <a title="[M](f: O =&gt; M)(implicit M: scalaz.Monoid[M])scalaz.stream.Process[F,M]" id="scalaz.stream;Process1Ops.scanMap">scanMap</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.scanMap;M">M</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; M" id="scalaz.stream;Process1Ops.scanMap.f">f</a>: O =&gt; M<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[M]" id="scalaz.stream;Process1Ops.scanMap.M">M</a>: <span title="scalaz.Monoid[M]">Monoid</span><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,M]">Process</a><span class="delimiter">[</span>F,M<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,M])scalaz.stream.Process[F,M]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.scanMap" title="(f: O =&gt; M)(implicit M: scalaz.Monoid[M])scalaz.stream.Process1[O,M]">scanMap</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.scanMap.f" title="O =&gt; M">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.scanMap.M" title="scalaz.Monoid[M]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.scanMonoid]](M)`. */</span>
  def <a title="[O2 &gt;: O](implicit M: scalaz.Monoid[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.scanMonoid">scanMonoid</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.scanMonoid;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[O2]" id="scalaz.stream;Process1Ops.scanMonoid.M">M</a>: <span title="scalaz.Monoid[O2]">Monoid</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.scanMonoid" title="(implicit M: scalaz.Monoid[O2])scalaz.stream.Process1[O2,O2]">scanMonoid</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.scanMonoid.M" title="scalaz.Monoid[O2]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.scanSemigroup]](M)`. */</span>
  def <a title="[O2 &gt;: O](implicit M: scalaz.Semigroup[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.scanSemigroup">scanSemigroup</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.scanSemigroup;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Semigroup[O2]" id="scalaz.stream;Process1Ops.scanSemigroup.M">M</a>: <span title="scalaz.Semigroup[O2]">Semigroup</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.scanSemigroup" title="(implicit M: scalaz.Semigroup[O2])scalaz.stream.Process1[O2,O2]">scanSemigroup</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.scanSemigroup.M" title="scalaz.Semigroup[O2]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.scan1]](f)`. */</span>
  def <a title="[O2 &gt;: O](f: (O2, O2) =&gt; O2)scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.scan1">scan1</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.scan1;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="(O2, O2) =&gt; O2" id="scalaz.stream;Process1Ops.scan1.f">f</a>: <span class="delimiter">(</span>O2,O2<span class="delimiter">)</span> =&gt; O2<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.scan1" title="(f: (O2, O2) =&gt; O2)scalaz.stream.Process1[O2,O2]">scan1</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.scan1.f" title="(O2, O2) =&gt; O2">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.scan1Map]](f)(M)`. */</span>
  def <a title="[M](f: O =&gt; M)(implicit M: scalaz.Semigroup[M])scalaz.stream.Process[F,M]" id="scalaz.stream;Process1Ops.scan1Map">scan1Map</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.scan1Map;M">M</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; M" id="scalaz.stream;Process1Ops.scan1Map.f">f</a>: O =&gt; M<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Semigroup[M]" id="scalaz.stream;Process1Ops.scan1Map.M">M</a>: <span title="scalaz.Semigroup[M]">Semigroup</span><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,M]">Process</a><span class="delimiter">[</span>F,M<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,M])scalaz.stream.Process[F,M]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.scan1Map" title="(f: O =&gt; M)(implicit M: scalaz.Semigroup[M])scalaz.stream.Process1[O,M]">scan1Map</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.scan1Map.f" title="O =&gt; M">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.scan1Map.M" title="scalaz.Semigroup[M]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.scan1Monoid]](M)`. */</span>
  def <a title="[O2 &gt;: O](implicit M: scalaz.Monoid[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.scan1Monoid">scan1Monoid</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.scan1Monoid;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[O2]" id="scalaz.stream;Process1Ops.scan1Monoid.M">M</a>: <span title="scalaz.Monoid[O2]">Monoid</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.scan1Monoid" title="(implicit M: scalaz.Monoid[O2])scalaz.stream.Process1[O2,O2]">scan1Monoid</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.scan1Monoid.M" title="scalaz.Monoid[O2]">M</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.shiftRight]](head)` */</span>
  def <a title="[O2 &gt;: O](head: O2*)scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.shiftRight">shiftRight</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.shiftRight;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="O2*" id="scalaz.stream;Process1Ops.shiftRight.head">head</a>: <span title="O2*">O2</span>*<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.shiftRight" title="(head: O2*)scalaz.stream.Process1[O2,O2]">shiftRight</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.shiftRight.head" title="O2*">head</a>: _*<span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.sliding]](n)`. */</span>
  def <a title="(n: Int)scalaz.stream.Process[F,Vector[O]]" id="scalaz.stream;Process1Ops.sliding">sliding</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream;Process1Ops.sliding.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,Vector[O]]">Process</a><span class="delimiter">[</span>F,Vector<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,Vector[O]])scalaz.stream.Process[F,Vector[O]]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.sliding" title="(n: Int)scalaz.stream.Process1[O,Vector[O]]">sliding</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.sliding.n" title="Int">n</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.split]](f)` */</span>
  def <a title="(f: O =&gt; Boolean)scalaz.stream.Process[F,Vector[O]]" id="scalaz.stream;Process1Ops.split">split</a><span class="delimiter">(</span><a title="O =&gt; Boolean" id="scalaz.stream;Process1Ops.split.f">f</a>: O =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,Vector[O]]">Process</a><span class="delimiter">[</span>F,Vector<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,Vector[O]])scalaz.stream.Process[F,Vector[O]]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.split" title="(f: O =&gt; Boolean)scalaz.stream.Process1[O,Vector[O]]">split</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.split.f" title="O =&gt; Boolean">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.splitOn]](p)` */</span>
  def <a title="[P &gt;: O](p: P)(implicit P: scalaz.Equal[P])scalaz.stream.Process[F,Vector[P]]" id="scalaz.stream;Process1Ops.splitOn">splitOn</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.splitOn;P">P</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="P" id="scalaz.stream;Process1Ops.splitOn.p">p</a>: <a href="#scalaz.stream;Process1Ops.splitOn;P" title="P">P</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Equal[P]" id="scalaz.stream;Process1Ops.splitOn.P">P</a>: <span title="scalaz.Equal[P]">Equal</span><span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,Vector[P]]">Process</a><span class="delimiter">[</span>F,Vector<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,Vector[P]])scalaz.stream.Process[F,Vector[P]]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.splitOn" title="(i: P)(implicit evidence$7: scalaz.Equal[P])scalaz.stream.Process1[P,Vector[P]]">splitOn</a><a href="#scalaz.stream;Process1Ops.splitOn.P" title="scalaz.Equal[P]" class="delimiter">(</a><a href="#scalaz.stream;Process1Ops.splitOn.p" title="P">p</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.splitWith]](f)` */</span>
  def <a title="(f: O =&gt; Boolean)scalaz.stream.Process[F,Vector[O]]" id="scalaz.stream;Process1Ops.splitWith">splitWith</a><span class="delimiter">(</span><a title="O =&gt; Boolean" id="scalaz.stream;Process1Ops.splitWith.f">f</a>: O =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,Vector[O]]">Process</a><span class="delimiter">[</span>F,Vector<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,Vector[O]])scalaz.stream.Process[F,Vector[O]]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.splitWith" title="(f: O =&gt; Boolean)scalaz.stream.Process1[O,Vector[O]]">splitWith</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.splitWith.f" title="O =&gt; Boolean">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.sum]]` */</span>
  def <a title="[O2 &gt;: O](implicit N: Numeric[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process1Ops.sum">sum</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process1Ops.sum;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="Numeric[O2]" id="scalaz.stream;Process1Ops.sum.N">N</a>: <span title="Numeric[O2]">Numeric</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.sum" title="(implicit N: Numeric[O2])scalaz.stream.Process1[O2,O2]">sum</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.sum.N" title="Numeric[O2]">N</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.tail]]`. */</span>
  def <a title="=&gt; scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.tail">tail</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.tail" title="scalaz.stream.Process1[O,O]">tail</a>

  <span class="comment">/** Alias for `this |&gt; [[process1.take]](n)`. */</span>
  def <a title="(n: Int)scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.take">take</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream;Process1Ops.take.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.take" title="(n: Int)scalaz.stream.Process1[O,O]">take</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.take.n" title="Int">n</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.takeRight]](n)`. */</span>
  def <a title="(n: Int)scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.takeRight">takeRight</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream;Process1Ops.takeRight.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.takeRight" title="(n: Int)scalaz.stream.Process1[O,O]">takeRight</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.takeRight.n" title="Int">n</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.takeThrough]](f)`. */</span>
  def <a title="(f: O =&gt; Boolean)scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.takeThrough">takeThrough</a><span class="delimiter">(</span><a title="O =&gt; Boolean" id="scalaz.stream;Process1Ops.takeThrough.f">f</a>: O =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.takeThrough" title="(f: O =&gt; Boolean)scalaz.stream.Process1[O,O]">takeThrough</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.takeThrough.f" title="O =&gt; Boolean">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.takeWhile]](f)`. */</span>
  def <a title="(f: O =&gt; Boolean)scalaz.stream.Process[F,O]" id="scalaz.stream;Process1Ops.takeWhile">takeWhile</a><span class="delimiter">(</span><a title="O =&gt; Boolean" id="scalaz.stream;Process1Ops.takeWhile.f">f</a>: O =&gt; Boolean<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,O])scalaz.stream.Process[F,O]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.takeWhile" title="(f: O =&gt; Boolean)scalaz.stream.Process1[O,O]">takeWhile</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.takeWhile.f" title="O =&gt; Boolean">f</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.terminated]]`. */</span>
  def <a title="=&gt; scalaz.stream.Process[F,Option[O]]" id="scalaz.stream;Process1Ops.terminated">terminated</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,Option[O]]">Process</a><span class="delimiter">[</span>F,Option<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,Option[O]])scalaz.stream.Process[F,Option[O]]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.terminated" title="scalaz.stream.Process1[O,Option[O]]">terminated</a>

  <span class="comment">/** Alias for `this |&gt; [[process1.zipWithIndex[A]*]]`. */</span>
  def <a title="=&gt; scalaz.stream.Process[F,(O, Int)]" id="scalaz.stream;Process1Ops.zipWithIndex(6a9bd00807)">zipWithIndex</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,(O, Int)]">Process</a><span class="delimiter">[</span>F,<span class="delimiter">(</span>O,Int<span class="delimiter">)</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,(O, Int)])scalaz.stream.Process[F,(O, Int)]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.zipWithIndex(55865e1c79)" title="scalaz.stream.Process1[O,(O, Int)]">zipWithIndex</a>

  <span class="comment">/** Alias for `this |&gt; [[process1.zipWithIndex[A,N]*]]`. */</span>
  def <a title="[N](implicit evidence$13: Numeric[N])scalaz.stream.Process[F,(O, N)]" id="scalaz.stream;Process1Ops.zipWithIndex(49c917a429)">zipWithIndex</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.zipWithIndex(49c917a429);N">N</a>: Numeric<span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,(O, N)]">Process</a><span class="delimiter">[</span>F,<span class="delimiter">(</span>O,N<span class="delimiter">)</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,(O, N)])scalaz.stream.Process[F,(O, N)]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.zipWithIndex(72501a8a67)" title="[A, N](implicit N: Numeric[N])scalaz.stream.Process1[A,(A, N)]">zipWithIndex</a><a href="#scalaz.stream;Process1Ops.zipWithIndex(49c917a429).evidence$13" title="(implicit N: Numeric[N])scalaz.stream.Process1[O,(O, N)]" class="delimiter">[</a><a href="#scalaz.stream;Process1Ops;O" title="O">O</a>,<a href="#scalaz.stream;Process1Ops.zipWithIndex(49c917a429);N" title="N">N</a><span class="delimiter">]</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.zipWithPrevious]]`. */</span>
  def <a title="=&gt; scalaz.stream.Process[F,(Option[O], O)]" id="scalaz.stream;Process1Ops.zipWithPrevious">zipWithPrevious</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,(Option[O], O)]">Process</a><span class="delimiter">[</span>F,<span class="delimiter">(</span>Option<span class="delimiter">[</span>O<span class="delimiter">]</span>,O<span class="delimiter">)</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,(Option[O], O)])scalaz.stream.Process[F,(Option[O], O)]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.zipWithPrevious" title="scalaz.stream.Process1[O,(Option[O], O)]">zipWithPrevious</a>

  <span class="comment">/** Alias for `this |&gt; [[process1.zipWithNext]]`. */</span>
  def <a title="=&gt; scalaz.stream.Process[F,(O, Option[O])]" id="scalaz.stream;Process1Ops.zipWithNext">zipWithNext</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,(O, Option[O])]">Process</a><span class="delimiter">[</span>F,<span class="delimiter">(</span>O,Option<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,(O, Option[O])])scalaz.stream.Process[F,(O, Option[O])]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.zipWithNext" title="scalaz.stream.Process1[O,(O, Option[O])]">zipWithNext</a>

  <span class="comment">/** Alias for `this |&gt; [[process1.zipWithPreviousAndNext]]`. */</span>
  def <a title="=&gt; scalaz.stream.Process[F,(Option[O], O, Option[O])]" id="scalaz.stream;Process1Ops.zipWithPreviousAndNext">zipWithPreviousAndNext</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,(Option[O], O, Option[O])]">Process</a><span class="delimiter">[</span>F,<span class="delimiter">(</span>Option<span class="delimiter">[</span>O<span class="delimiter">]</span>,O,Option<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,(Option[O], O, Option[O])])scalaz.stream.Process[F,(Option[O], O, Option[O])]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.zipWithPreviousAndNext" title="scalaz.stream.Process1[O,(Option[O], O, Option[O])]">zipWithPreviousAndNext</a>

  <span class="comment">/** Alias for `this |&gt; [[process1.zipWithScan]](z)(next)`. */</span>
  def <a title="[B](z: B)(next: (O, B) =&gt; B)scalaz.stream.Process[F,(O, B)]" id="scalaz.stream;Process1Ops.zipWithScan">zipWithScan</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.zipWithScan;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="scalaz.stream;Process1Ops.zipWithScan.z">z</a>: <a href="#scalaz.stream;Process1Ops.zipWithScan;B" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(O, B) =&gt; B" id="scalaz.stream;Process1Ops.zipWithScan.next">next</a>: <span class="delimiter">(</span>O, B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,(O, B)]">Process</a><span class="delimiter">[</span>F,<span class="delimiter">(</span>O,B<span class="delimiter">)</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,(O, B)])scalaz.stream.Process[F,(O, B)]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.zipWithScan" title="(z: B)(f: (O, B) =&gt; B)scalaz.stream.Process1[O,(O, B)]">zipWithScan</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.zipWithScan.z" title="B">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.zipWithScan.next" title="(O, B) =&gt; B">next</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.zipWithScan]](z)(next)`. */</span>
  def <a title="[B](z: B)(next: (O, B) =&gt; B)scalaz.stream.Process[F,(O, B)]" id="scalaz.stream;Process1Ops.zipWithScan1">zipWithScan1</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.zipWithScan1;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="scalaz.stream;Process1Ops.zipWithScan1.z">z</a>: <a href="#scalaz.stream;Process1Ops.zipWithScan1;B" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(O, B) =&gt; B" id="scalaz.stream;Process1Ops.zipWithScan1.next">next</a>: <span class="delimiter">(</span>O, B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,(O, B)]">Process</a><span class="delimiter">[</span>F,<span class="delimiter">(</span>O,B<span class="delimiter">)</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,(O, B)])scalaz.stream.Process[F,(O, B)]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.zipWithScan1" title="(z: B)(f: (O, B) =&gt; B)scalaz.stream.Process1[O,(O, B)]">zipWithScan1</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.zipWithScan1.z" title="B">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.zipWithScan1.next" title="(O, B) =&gt; B">next</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `this |&gt; [[process1.zipWithState]](z)(next)`. */</span>
  def <a title="[B](z: B)(next: (O, B) =&gt; B)scalaz.stream.Process[F,(O, B)]" id="scalaz.stream;Process1Ops.zipWithState">zipWithState</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process1Ops.zipWithState;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="scalaz.stream;Process1Ops.zipWithState.z">z</a>: <a href="#scalaz.stream;Process1Ops.zipWithState;B" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(O, B) =&gt; B" id="scalaz.stream;Process1Ops.zipWithState.next">next</a>: <span class="delimiter">(</span>O, B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,(O, B)]">Process</a><span class="delimiter">[</span>F,<span class="delimiter">(</span>O,B<span class="delimiter">)</span><span class="delimiter">]</span> =
    this <a href="Process.scala.html#scalaz.stream;Process.|>" title="(p2: scalaz.stream.Process1[O,(O, B)])scalaz.stream.Process[F,(O, B)]">|&gt;</a> <a href="#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="#scalaz.stream.process1.zipWithState" title="(z: B)(next: (O, B) =&gt; B)scalaz.stream.Process1[O,(O, B)]">zipWithState</a><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.zipWithState.z" title="B">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process1Ops.zipWithState.next" title="(O, B) =&gt; B">next</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
