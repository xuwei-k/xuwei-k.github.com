<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scalaz-stream/scalaz/stream/async/mutable/Queue.scala</title>
        <script type="text/javascript" src="../../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scalaz.stream.async.mutable

import java.util.concurrent.atomic.AtomicInteger

import scalaz.stream.<a href="../../Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>._
import scalaz.concurrent.<span class="delimiter">{</span>Actor, Strategy, Task<span class="delimiter">}</span>
import scalaz.stream.<a href="../../Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.Halt
import scalaz.stream.async.immutable
import scalaz.stream.<span class="delimiter">{</span>Cause, Util, Process, Sink<span class="delimiter">}</span>
import scalaz.<span class="delimiter">{</span>Either3, -\/, \/, \/-<span class="delimiter">}</span>
import scalaz.<span title="scalaz.\/.type">\/</span>._


<span class="comment">/**
 * Asynchronous queue interface. Operations are all nonblocking in their
 * implementations, but may be 'semantically' blocking. For instance,
 * a queue may have a bound on its size, in which case enqueuing may
 * block until there is an offsetting dequeue.
 */</span>
trait <a title="trait Queue[A] extends AnyRef" id="scalaz.stream.async.mutable;Queue">Queue</a><span class="delimiter">[</span><a title="" id="scalaz.stream.async.mutable;Queue;A">A</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>

  <span class="comment">/**
   * A `Sink` for enqueueing values to this `Queue`.
   */</span>
  def <a title="=&gt; scalaz.stream.Sink[scalaz.concurrent.Task,A]" id="scalaz.stream.async.mutable;Queue.enqueue">enqueue</a>: <a href="../../Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Sink[scalaz.concurrent.Task,A]">Sink</a><span class="delimiter">[</span>Task, A<span class="delimiter">]</span>

  <span class="comment">/**
   * Enqueue one element in this `Queue`. Resulting task will
   * terminate with failure if queue is closed or failed.
   * Please note this will get completed _after_ `a` has been successfully enqueued.
   * @param a `A` to enqueue
   */</span>
  def <a title="(a: A)scalaz.concurrent.Task[Unit]" id="scalaz.stream.async.mutable;Queue.enqueueOne">enqueueOne</a><span class="delimiter">(</span><a title="A" id="scalaz.stream.async.mutable;Queue.enqueueOne.a">a</a>: <a href="#scalaz.stream.async.mutable;Queue;A" title="A">A</a><span class="delimiter">)</span>: <span title="scalaz.concurrent.Task[Unit]">Task</span><span class="delimiter">[</span>Unit<span class="delimiter">]</span>

  <span class="comment">/**
   * Enqueue multiple `A` values in this queue. This has same semantics as sequencing
   * repeated calls to `enqueueOne`.
   */</span>
  def <a title="(xa: Seq[A])scalaz.concurrent.Task[Unit]" id="scalaz.stream.async.mutable;Queue.enqueueAll">enqueueAll</a><span class="delimiter">(</span><a title="Seq[A]" id="scalaz.stream.async.mutable;Queue.enqueueAll.xa">xa</a>: <span title="Seq[A]">Seq</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scalaz.concurrent.Task[Unit]">Task</span><span class="delimiter">[</span>Unit<span class="delimiter">]</span>

  <span class="comment">/**
   * Provides a process that dequeue from this queue.
   * When multiple consumers dequeue from this queue,
   * they dequeue in first-come, first-serve order.
   *
   * Please use `Topic` instead of `Queue` when all subscribers
   * need to see each value enqueued.
   *
   * This process is equivalent to `dequeueBatch(1)`.
   */</span>
  def <a title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,A]" id="scalaz.stream.async.mutable;Queue.dequeue">dequeue</a>: <a href="../../Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,A]">Process</a><span class="delimiter">[</span>Task, A<span class="delimiter">]</span>

  <span class="comment">/**
   * Provides a process that dequeues in chunks.  Whenever *n* elements
   * are available in the queue, `min(n, limit)` elements will be dequeud
   * and produced as a single `Seq`.  Note that this naturally does not
   * *guarantee* that `limit` items are returned in every chunk.  If only
   * one element is available, that one element will be returned in its own
   * sequence.  This method basically just allows a consumer to &quot;catch up&quot;
   * to a rapidly filling queue in the case where some sort of batching logic
   * is applicable.
   */</span>
  def <a title="(limit: Int)scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]" id="scalaz.stream.async.mutable;Queue.dequeueBatch">dequeueBatch</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream.async.mutable;Queue.dequeueBatch.limit">limit</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="../../Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]">Process</a><span class="delimiter">[</span>Task, Seq<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="comment">/**
   * Equivalent to dequeueBatch with an infinite limit.  Only use this
   * method if your underlying algebra (`A`) has some sort of constant
   * time &quot;natural batching&quot;!  If processing a chunk of size n is linearly
   * more expensive than processing a chunk of size 1, you should always
   * use dequeueBatch with some small limit, otherwise you will disrupt
   * fairness in the nondeterministic merge combinators.
   */</span>
  def <a title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]" id="scalaz.stream.async.mutable;Queue.dequeueAvailable">dequeueAvailable</a>: <a href="../../Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]">Process</a><span class="delimiter">[</span>Task, Seq<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="comment">/**
   * The time-varying size of this `Queue`. This signal refreshes
   * only when size changes. Offsetting enqueues and dequeues may
   * not result in refreshes.
   */</span>
  def <a title="=&gt; scalaz.stream.async.immutable.Signal[Int]" id="scalaz.stream.async.mutable;Queue.size">size</a>: scalaz.stream.async.immutable.<a href="../immutable/Signal.scala.html#scalaz.stream.async.immutable;Signal" title="scalaz.stream.async.immutable.Signal[Int]">Signal</a><span class="delimiter">[</span>Int<span class="delimiter">]</span>

  <span class="comment">/**
   * Closes this queue. This halts the `enqueue` `Sink` and
   * `dequeue` `Process` after any already-queued elements are
   * drained.
   *
   * After this any enqueue will fail with `Terminated(End)`,
   * and the enqueue `Sink` will terminate with `End`.
   */</span>
  def <a title="=&gt; scalaz.concurrent.Task[Unit]" id="scalaz.stream.async.mutable;Queue.close">close</a>: <span title="scalaz.concurrent.Task[Unit]">Task</span><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <a href="#scalaz.stream.async.mutable;Queue.failWithCause" title="(c: scalaz.stream.Cause)scalaz.concurrent.Task[Unit]">failWithCause</a><span class="delimiter">(</span><a href="../../Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span>


  <span class="comment">/**
   * Kills the queue. Unlike `close`, this kills all dequeuers immediately.
   * Any subsequent enqueues will fail with `Terminated(Kill)`.
   * The returned `Task` will completed once all dequeuers and enqueuers
   * have been signalled.
   */</span>
  def <a title="=&gt; scalaz.concurrent.Task[Unit]" id="scalaz.stream.async.mutable;Queue.kill">kill</a>: <span title="scalaz.concurrent.Task[Unit]">Task</span><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <a href="#scalaz.stream.async.mutable;Queue.failWithCause" title="(c: scalaz.stream.Cause)scalaz.concurrent.Task[Unit]">failWithCause</a><span class="delimiter">(</span><a href="../../Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span>


  <span class="comment">/**
   * Like `kill`, except it terminates with supplied reason.
   */</span>
  def <a title="(rsn: Throwable)scalaz.concurrent.Task[Unit]" id="scalaz.stream.async.mutable;Queue.fail">fail</a><span class="delimiter">(</span><a title="Throwable" id="scalaz.stream.async.mutable;Queue.fail.rsn">rsn</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span>: <span title="scalaz.concurrent.Task[Unit]">Task</span><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <a href="#scalaz.stream.async.mutable;Queue.failWithCause" title="(c: scalaz.stream.Cause)scalaz.concurrent.Task[Unit]">failWithCause</a><span class="delimiter">(</span><a href="../../Cause.scala.html#scalaz.stream.Cause;Error" title="(rsn: Throwable)scalaz.stream.Cause.Error">Error</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable;Queue.fail.rsn" title="Throwable">rsn</a><span class="delimiter">)</span><span class="delimiter">)</span>

  private<span class="delimiter">[</span>stream<span class="delimiter">]</span> def <a title="(c: scalaz.stream.Cause)scalaz.concurrent.Task[Unit]" id="scalaz.stream.async.mutable;Queue.failWithCause">failWithCause</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.async.mutable;Queue.failWithCause.c">c</a>:<a href="../../Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a><span class="delimiter">)</span>: <span title="scalaz.concurrent.Task[Unit]">Task</span><span class="delimiter">[</span>Unit<span class="delimiter">]</span>
<span class="delimiter">}</span>


private<span class="delimiter">[</span>stream<span class="delimiter">]</span> object <a title="scalaz.stream.async.mutable.Queue.type" id="scalaz.stream.async.mutable.Queue">Queue</a> <a href="#scalaz.stream.async.mutable.Queue" title="scalaz.stream.async.mutable.Queue.type" class="delimiter">{</a>

  <span class="comment">/**
   * Builds a queue, potentially with `source` producing the streams that
   * will enqueue into queue. Up to `bound` size of `A` may enqueue into queue,
   * and then all enqueue processes will wait until dequeue.
   *
   * @param bound   Size of the bound. When &lt;= 0 the queue is `unbounded`.
   * @tparam A
   * @return
   */</span>
  def <a title="[A](bound: Int)(implicit S: scalaz.concurrent.Strategy)scalaz.stream.async.mutable.Queue[A]" id="scalaz.stream.async.mutable.Queue.apply">apply</a><span class="delimiter">[</span><a title="" id="scalaz.stream.async.mutable.Queue.apply$default$1;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scalaz.stream.async.mutable.Queue.apply$default$1">bound</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream.async.mutable.Queue.apply.S">S</a>: <span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <a href="#scalaz.stream.async.mutable;Queue" title="scalaz.stream.async.mutable.Queue[A]">Queue</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>

    sealed trait <a title="trait M extends AnyRef" id="scalaz.stream.async.mutable.Queue.apply;M">M</a>
    case class <a title="class Enqueue extends AnyRef with M with Product with Serializable" id="scalaz.stream.async.mutable.Queue.apply;Enqueue.readResolve">Enqueue</a><span title="Product" class="delimiter">(</span><a title="Seq[A]" id="scalaz.stream.async.mutable.Queue.apply;Enqueue.a">a</a>: <span title="Seq[A]">Seq</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scalaz.\/[Throwable,Unit] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply;Enqueue.cb">cb</a>: Throwable \/ Unit =&gt; Unit<span class="delimiter">)</span> extends <a href="#scalaz.stream.async.mutable.Queue.apply;M" title="M">M</a>
    case class <a title="class Dequeue extends AnyRef with M with Product with Serializable" id="scalaz.stream.async.mutable.Queue.apply;Dequeue.readResolve">Dequeue</a><span title="Product" class="delimiter">(</span><a title="ConsumerRef" id="scalaz.stream.async.mutable.Queue.apply;Dequeue.ref">ref</a>: <a href="#scalaz.stream.async.mutable.Queue.apply;ConsumerRef" title="ConsumerRef">ConsumerRef</a>, <a title="Int" id="scalaz.stream.async.mutable.Queue.apply;Dequeue.limit">limit</a>: <span title="Int">Int</span>, <a title="scalaz.\/[Throwable,Seq[A]] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply;Dequeue.cb">cb</a>: Throwable \/ Seq<span class="delimiter">[</span>A<span class="delimiter">]</span> =&gt; Unit<span class="delimiter">)</span> extends <a href="#scalaz.stream.async.mutable.Queue.apply;M" title="M">M</a>
    case class <a title="class Fail extends AnyRef with M with Product with Serializable" id="scalaz.stream.async.mutable.Queue.apply;Fail.readResolve">Fail</a><span title="Product" class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.async.mutable.Queue.apply;Fail.cause">cause</a>: <a href="../../Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a>, <a title="scalaz.\/[Throwable,Unit] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply;Fail.cb">cb</a>: Throwable \/ Unit =&gt; Unit<span class="delimiter">)</span> extends <a href="#scalaz.stream.async.mutable.Queue.apply;M" title="M">M</a>
    case class <a title="class GetSize extends AnyRef with M with Product with Serializable" id="scalaz.stream.async.mutable.Queue.apply;GetSize.readResolve">GetSize</a><span title="Product" class="delimiter">(</span><a title="scalaz.\/[Throwable,Seq[Int]] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply;GetSize.cb">cb</a>: <span class="delimiter">(</span>Throwable \/ Seq<span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">)</span> extends <a href="#scalaz.stream.async.mutable.Queue.apply;M" title="M">M</a>
    case class <a title="class ConsumerDone extends AnyRef with M with Product with Serializable" id="scalaz.stream.async.mutable.Queue.apply;ConsumerDone.readResolve">ConsumerDone</a><span title="Product" class="delimiter">(</span><a title="ConsumerRef" id="scalaz.stream.async.mutable.Queue.apply;ConsumerDone.ref">ref</a>: <a href="#scalaz.stream.async.mutable.Queue.apply;ConsumerRef" title="ConsumerRef">ConsumerRef</a><span class="delimiter">)</span> extends <a href="#scalaz.stream.async.mutable.Queue.apply;M" title="M">M</a>

    <span class="comment">// reference to identify differed subscribers</span>
    class <a title="class ConsumerRef extends AnyRef" id="scalaz.stream.async.mutable.Queue.apply;ConsumerRef">ConsumerRef</a>


    <span class="comment">//actually queued `A` are stored here</span>
    var <a title="scala.collection.immutable.Vector[A]" id="scalaz.stream.async.mutable.Queue.apply.queued">queued</a> = <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="[A]=&gt; scala.collection.immutable.Vector[A]">empty</span><span title="scala.collection.immutable.Vector[A]" class="delimiter">[</span><a href="#scalaz.stream.async.mutable.Queue.apply$default$1;A" title="A">A</a><span class="delimiter">]</span>

    <span class="comment">// when this queue fails or is closed the reason is stored here</span>
    var <a title="Option[scalaz.stream.Cause]" id="scalaz.stream.async.mutable.Queue.apply.closed">closed</a>: <span title="Option[scalaz.stream.Cause]">Option</span><span class="delimiter">[</span>Cause<span class="delimiter">]</span> = <span title="None.type">None</span>

    <span class="comment">// consumers waiting for `A`</span>
    var <a title="Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]" id="scalaz.stream.async.mutable.Queue.apply.consumers">consumers</a>: <span title="Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">Vector</span><span class="delimiter">[</span><span class="delimiter">(</span>ConsumerRef, Throwable \/ A =&gt; Unit<span class="delimiter">)</span><span class="delimiter">]</span> = <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span>

    <span class="comment">// publishers waiting to be acked to produce next `A`</span>
    var <a title="Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]" id="scalaz.stream.async.mutable.Queue.apply.unAcked">unAcked</a>: <span title="Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]">Vector</span><span class="delimiter">[</span>Throwable \/ Unit =&gt; Unit<span class="delimiter">]</span> = <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span>

    <span class="comment">// if at least one GetSize was received will start to accumulate sizes change.</span>
    <span class="comment">// when defined on left, contains sizes that has to be published to sizes topic</span>
    <span class="comment">// when defined on right, awaiting next change in queue to signal size change</span>
    <span class="comment">// when undefined, signals no subscriber for sizes yet.</span>
    var <a title="Option[scalaz.\/[Vector[Int],scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]]" id="scalaz.stream.async.mutable.Queue.apply.sizes">sizes</a>:  <span title="Option[scalaz.\/[Vector[Int],scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]]">Option</span><span class="delimiter">[</span>Vector<span class="delimiter">[</span>Int<span class="delimiter">]</span> \/ <span class="delimiter">(</span><span class="delimiter">(</span>Throwable \/ Seq<span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">)</span><span class="delimiter">]</span> = <span title="None.type">None</span>

    <span class="comment">// signals to any callback that this queue is closed with reason</span>
    def <a title="[B](cb: scalaz.\/[Throwable,B] =&gt; Unit)Unit" id="scalaz.stream.async.mutable.Queue.apply.signalClosed">signalClosed</a><span class="delimiter">[</span><a title="" id="scalaz.stream.async.mutable.Queue.apply.signalClosed;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.\/[Throwable,B] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply.signalClosed.cb">cb</a>: Throwable \/ B =&gt; Unit<span class="delimiter">)</span> =
      <a href="#scalaz.stream.async.mutable.Queue.apply.closed" title="Option[scalaz.stream.Cause]">closed</a>.<span title="(f: scalaz.stream.Cause =&gt; (() =&gt; Unit))Unit">foreach</span><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.async.mutable.Queue.apply.signalClosed.$anonfun.rsn">rsn</a> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.signalClosed.cb" title="(v1: scalaz.\/[Throwable,B])Unit">cb</a><span class="delimiter">(</span><span title="(a: scalaz.stream.Cause.Terminated)scalaz.-\/[scalaz.stream.Cause.Terminated]">-\/</span><span class="delimiter">(</span><a href="../../Cause.scala.html#scalaz.stream.Cause;Terminated" title="(cause: scalaz.stream.Cause)scalaz.stream.Cause.Terminated">Terminated</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.signalClosed.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">// signals that size has been changed.</span>
    <span class="comment">// either keep the last size or fill the callback</span>
    <span class="comment">// only updates if sizes != None</span>
    def <a title="(sz: Int)Unit" id="scalaz.stream.async.mutable.Queue.apply.signalSize">signalSize</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream.async.mutable.Queue.apply.signalSize.sz">sz</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
      <a href="#scalaz.stream.async.mutable.Queue.apply.sizes" title="Option[scalaz.\/[Vector[Int],scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]]">sizes</a> = <a href="#scalaz.stream.async.mutable.Queue.apply.sizes" title="Option[scalaz.\/[Vector[Int],scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]]">sizes</a>.<span title="(f: scalaz.\/[Vector[Int],scalaz.\/[Throwable,Seq[Int]] =&gt; Unit] =&gt; scalaz.\/[scala.collection.immutable.Vector[Int],Nothing])Option[scalaz.\/[scala.collection.immutable.Vector[Int],Nothing]]">map</span><span class="delimiter">(</span> <a title="scalaz.\/[Vector[Int],scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]" id="scalaz.stream.async.mutable.Queue.apply.signalSize.$anonfun.cur">cur</a> =&gt;
        <span title="(v1: scala.collection.immutable.Vector[Int])scalaz.\/[scala.collection.immutable.Vector[Int],Nothing]">left</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.signalSize.$anonfun.cur" title="scalaz.\/[Vector[Int],scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]">cur</a>.<span title="(l: Vector[Int] =&gt; scala.collection.immutable.Vector[Int], r: (scalaz.\/[Throwable,Seq[Int]] =&gt; Unit) =&gt; scala.collection.immutable.Vector[Int])scala.collection.immutable.Vector[Int]">fold</span> <span class="delimiter">(</span>
            <a title="Vector[Int]" id="scalaz.stream.async.mutable.Queue.apply.signalSize.$anonfun.$anonfun.szs">szs</a> =&gt; <span class="delimiter">{</span> <a href="#scalaz.stream.async.mutable.Queue.apply.signalSize.$anonfun.$anonfun.szs" title="Vector[Int]">szs</a> <span title="(elem: Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[Int],Int,Vector[Int]])Vector[Int]">:+</span> <a href="#scalaz.stream.async.mutable.Queue.apply.signalSize.sz" title="Int">sz</a> <span class="delimiter">}</span>
            , <a title="scalaz.\/[Throwable,Seq[Int]] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply.signalSize.$anonfun.$anonfun.cb">cb</a> =&gt; <span class="delimiter">{</span> <a href="#scalaz.stream.async.mutable.Queue.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.signalSize.$anonfun.$anonfun.cb" title="(v1: scalaz.\/[Throwable,Seq[Int]])Unit">cb</a><span class="delimiter">(</span><span title="(b: Seq[Int])scalaz.\/-[Seq[Int]]">\/-</span><span class="delimiter">(</span><span title="(elems: Int*)Seq[Int]">Seq</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.signalSize.sz" title="Int">sz</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> ; <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="[A]=&gt; scala.collection.immutable.Vector[A]">empty</span><span title="scala.collection.immutable.Vector[Int]" class="delimiter">[</span><span title="Int">Int</span><span class="delimiter">]</span> <span class="delimiter">}</span>
          <span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">)</span>
    <span class="delimiter">}</span>




    <span class="comment">// publishes single size change</span>
    def <a title="(cb: scalaz.\/[Throwable,Seq[Int]] =&gt; Unit)Unit" id="scalaz.stream.async.mutable.Queue.apply.publishSize">publishSize</a><span class="delimiter">(</span><a title="scalaz.\/[Throwable,Seq[Int]] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply.publishSize.cb">cb</a>: <span class="delimiter">(</span>Throwable \/ Seq<span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
      <a href="#scalaz.stream.async.mutable.Queue.apply.sizes" title="Option[scalaz.\/[Vector[Int],scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]]">sizes</a> =
        <a href="#scalaz.stream.async.mutable.Queue.apply.sizes" title="Option[scalaz.\/[Vector[Int],scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]]">sizes</a> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><a title="scalaz.\/[Vector[Int],scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]" id="scalaz.stream.async.mutable.Queue.apply.publishSize.sz">sz</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.publishSize.sz" title="scalaz.\/[Vector[Int],scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]">sz</a> match <span class="delimiter">{</span>
            case -\/<span class="delimiter">(</span><a title="Vector[Int]" id="scalaz.stream.async.mutable.Queue.apply.publishSize.v">v</a><span class="delimiter">)</span> if <a href="#scalaz.stream.async.mutable.Queue.apply.publishSize.v" title="Vector[Int]">v</a>.<span title="=&gt; Boolean">nonEmpty</span> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.publishSize.cb" title="(v1: scalaz.\/[Throwable,Seq[Int]])Unit">cb</a><span class="delimiter">(</span><span title="(b: Vector[Int])scalaz.\/-[Vector[Int]]">\/-</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.publishSize.v" title="Vector[Int]">v</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>; <span title="(x: scalaz.-\/[scala.collection.immutable.Vector[Int]])Some[scalaz.-\/[scala.collection.immutable.Vector[Int]]]">Some</span><span class="delimiter">(</span><span title="(a: scala.collection.immutable.Vector[Int])scalaz.-\/[scala.collection.immutable.Vector[Int]]">-\/</span><span class="delimiter">(</span><span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="[A]=&gt; scala.collection.immutable.Vector[A]">empty</span><span title="scala.collection.immutable.Vector[Int]" class="delimiter">[</span><span title="Int">Int</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>
            case _                    =&gt; <span title="(x: scalaz.\/-[scalaz.\/[Throwable,Seq[Int]] =&gt; Unit])Some[scalaz.\/-[scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]]">Some</span><span class="delimiter">(</span><span title="(b: scalaz.\/[Throwable,Seq[Int]] =&gt; Unit)scalaz.\/-[scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]">\/-</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.publishSize.cb" title="scalaz.\/[Throwable,Seq[Int]] =&gt; Unit">cb</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          case <span title="None.type">None</span> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.publishSize.cb" title="(v1: scalaz.\/[Throwable,Seq[Int]])Unit">cb</a><span class="delimiter">(</span><span title="(b: Seq[Int])scalaz.\/-[Seq[Int]]">\/-</span><span class="delimiter">(</span><span title="(elems: Int*)Seq[Int]">Seq</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>; <span title="(x: scalaz.-\/[scala.collection.immutable.Vector[Int]])Some[scalaz.-\/[scala.collection.immutable.Vector[Int]]]">Some</span><span class="delimiter">(</span><span title="(a: scala.collection.immutable.Vector[Int])scalaz.-\/[scala.collection.immutable.Vector[Int]]">-\/</span><span class="delimiter">(</span><span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="[A]=&gt; scala.collection.immutable.Vector[A]">empty</span><span title="scala.collection.immutable.Vector[Int]" class="delimiter">[</span><span title="Int">Int</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">//dequeue one element from the queue</span>
    def <a title="(ref: ConsumerRef, limit: Int, cb: scalaz.\/[Throwable,Seq[A]] =&gt; Unit)Unit" id="scalaz.stream.async.mutable.Queue.apply.dequeueBatch">dequeueBatch</a><span class="delimiter">(</span><a title="ConsumerRef" id="scalaz.stream.async.mutable.Queue.apply.dequeueBatch.ref">ref</a>: <a href="#scalaz.stream.async.mutable.Queue.apply;ConsumerRef" title="ConsumerRef">ConsumerRef</a>, <a title="Int" id="scalaz.stream.async.mutable.Queue.apply.dequeueBatch.limit">limit</a>: <span title="Int">Int</span>, <a title="scalaz.\/[Throwable,Seq[A]] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply.dequeueBatch.cb">cb</a>: <span class="delimiter">(</span>Throwable \/ Seq<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="scalaz.\/[Throwable,A] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply.dequeueBatch.cb2">cb2</a>: Throwable \/ A =&gt; Unit = <a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.cb2.$anonfun.x0$1" title="Unit" class="delimiter">{</a>
          case <a title="scalaz.-\/[Throwable]" id="scalaz.stream.async.mutable.Queue.apply.dequeueBatch.cb2.$anonfun.l">l</a> @ -\/<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.cb" title="(v1: scalaz.\/[Throwable,Seq[A]])Unit">cb</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.cb2.$anonfun.l" title="scalaz.-\/[Throwable]">l</a><span class="delimiter">)</span>
          case \/-<span class="delimiter">(</span><a title="A" id="scalaz.stream.async.mutable.Queue.apply.dequeueBatch.cb2.$anonfun.a">a</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.cb" title="(v1: scalaz.\/[Throwable,Seq[A]])Unit">cb</a><span class="delimiter">(</span><span title="(b: List[A])scalaz.\/-[List[A]]">\/-</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.cb2.$anonfun.a" title="A">a</a> <a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.cb2.$anonfun.x$1" title="(x: A)List[A]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        val entry: <span title="(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)" class="delimiter">(</span>ConsumerRef, Throwable \/ A =&gt; Unit<span class="delimiter">)</span>  = <span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.ref" title="(self: ConsumerRef)ArrowAssoc[ConsumerRef]">ref</a> <a title="(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)" id="scalaz.stream.async.mutable.Queue.apply.dequeueBatch.entry">-&gt;</a> <a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.cb2" title="scalaz.\/[Throwable,A] =&gt; Unit">cb2</a><span class="delimiter">)</span>
        <a href="#scalaz.stream.async.mutable.Queue.apply.consumers" title="Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">consumers</a> = <a href="#scalaz.stream.async.mutable.Queue.apply.consumers" title="Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">consumers</a> <span title="(elem: (ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)],(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit),Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]])Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">:+</span> <a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.entry" title="(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)">entry</a>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        val <a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.send" title="(scala.collection.immutable.Vector[A], scala.collection.immutable.Vector[A])" class="delimiter">(</a><a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.x$2" title="scala.collection.immutable.Vector[A]" id="scalaz.stream.async.mutable.Queue.apply.dequeueBatch.send">send</a>, <a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.x$2" title="scala.collection.immutable.Vector[A]" id="scalaz.stream.async.mutable.Queue.apply.dequeueBatch.remainder">remainder</a><span class="delimiter">)</span> = if <span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.limit" title="Int">limit</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
          <span title="(_1: scala.collection.immutable.Vector[A], _2: scala.collection.immutable.Vector[A])(scala.collection.immutable.Vector[A], scala.collection.immutable.Vector[A])" class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a>, <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="[A]=&gt; scala.collection.immutable.Vector[A]">empty</span><span title="scala.collection.immutable.Vector[A]" class="delimiter">[</span><a href="#scalaz.stream.async.mutable.Queue.apply$default$1;A" title="A">A</a><span class="delimiter">]</span><span class="delimiter">)</span>
        else
          <a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a> <span title="(n: Int)(scala.collection.immutable.Vector[A], scala.collection.immutable.Vector[A])">splitAt</span> <a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.limit" title="Int">limit</a>

        <a href="#scalaz.stream.async.mutable.Queue.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a> <span class="delimiter">{</span> <a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.cb" title="(v1: scalaz.\/[Throwable,Seq[A]])Unit">cb</a><span class="delimiter">(</span><span title="(b: scala.collection.immutable.Vector[A])scalaz.\/-[scala.collection.immutable.Vector[A]]">\/-</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.send" title="scala.collection.immutable.Vector[A]">send</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>

        <a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a> = <a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.remainder" title="scala.collection.immutable.Vector[A]">remainder</a>
        <a href="#scalaz.stream.async.mutable.Queue.apply.signalSize" title="(sz: Int)Unit">signalSize</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.unAcked" title="Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]">unAcked</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#scalaz.stream.async.mutable.Queue.apply$default$1" title="Int">bound</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&lt;</span> <a href="#scalaz.stream.async.mutable.Queue.apply$default$1" title="Int">bound</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          val ackCount = <a href="#scalaz.stream.async.mutable.Queue.apply$default$1" title="Int">bound</a> <span title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">-</span> <a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a>.<span title="=&gt; Int">size</span> <a title="Int" id="scalaz.stream.async.mutable.Queue.apply.dequeueBatch.ackCount">min</a> <a href="#scalaz.stream.async.mutable.Queue.apply.unAcked" title="Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]">unAcked</a>.<span title="=&gt; Int">size</span>
          <a href="#scalaz.stream.async.mutable.Queue.apply.unAcked" title="Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]">unAcked</a>.<span title="(n: Int)scala.collection.immutable.Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]">take</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.ackCount" title="Int">ackCount</a><span class="delimiter">)</span>.<span title="(f: (scalaz.\/[Throwable,Unit] =&gt; Unit) =&gt; (() =&gt; Unit))Unit">foreach</span><span class="delimiter">(</span><a title="scalaz.\/[Throwable,Unit] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply.dequeueBatch.$anonfun.cb">cb</a> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.$anonfun.cb" title="(v1: scalaz.\/[Throwable,Unit])Unit">cb</a><span class="delimiter">(</span><span title="(b: Unit)scalaz.\/-[Unit]">\/-</span><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#scalaz.stream.async.mutable.Queue.apply.unAcked" title="Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]">unAcked</a> = <a href="#scalaz.stream.async.mutable.Queue.apply.unAcked" title="Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]">unAcked</a>.<span title="(n: Int)scala.collection.immutable.Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]">drop</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch.ackCount" title="Int">ackCount</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    def <a title="(as: Seq[A], cb: scalaz.\/[Throwable,Unit] =&gt; Unit)Unit" id="scalaz.stream.async.mutable.Queue.apply.enqueueOne">enqueueOne</a><span class="delimiter">(</span><a title="Seq[A]" id="scalaz.stream.async.mutable.Queue.apply.enqueueOne.as">as</a>: <span title="Seq[A]">Seq</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scalaz.\/[Throwable,Unit] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply.enqueueOne.cb">cb</a>: Throwable \/ Unit =&gt; Unit<span class="delimiter">)</span> = <span class="delimiter">{</span>
      import scalaz.stream.<a href="../../Util.scala.html#scalaz.stream.Util" title="scalaz.stream.Util.type">Util</a>._
      <a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a> = <a href="../../Util.scala.html#scalaz.stream.Util.AppendSyntax(629eae9601)" title="(self: Vector[A])scalaz.stream.Util.AppendSyntax[A]">queued</a> <a href="../../Util.scala.html#scalaz.stream.Util;AppendSyntax.fast_++" title="(other: Seq[A])Vector[A]">fast_++</a> <a href="#scalaz.stream.async.mutable.Queue.apply.enqueueOne.as" title="Seq[A]">as</a>

      if <span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.consumers" title="Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">consumers</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        val deqCount = <a href="#scalaz.stream.async.mutable.Queue.apply.consumers" title="Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">consumers</a>.<span title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">size</span> <a title="Int" id="scalaz.stream.async.mutable.Queue.apply.enqueueOne.deqCount">min</a> <a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a>.<span title="=&gt; Int">size</span>

        <a href="#scalaz.stream.async.mutable.Queue.apply.consumers" title="Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">consumers</a>.<span title="(n: Int)scala.collection.immutable.Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">take</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.enqueueOne.deqCount" title="Int">deqCount</a><span class="delimiter">)</span>.<span title="(that: scala.collection.GenIterable[A])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)],((ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit), A),scala.collection.immutable.Vector[((ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit), A)]])scala.collection.immutable.Vector[((ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit), A)]">zip</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector.Coll,((ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit), A),scala.collection.immutable.Vector[((ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit), A)]]" class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a>.<span title="(n: Int)scala.collection.immutable.Vector[A]">take</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.enqueueOne.deqCount" title="Int">deqCount</a><span class="delimiter">)</span><span class="delimiter">)</span>
        .<span title="(f: (((ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit), A)) =&gt; () =&gt; Unit)Unit">foreach</span> <a href="#scalaz.stream.async.mutable.Queue.apply.enqueueOne.$anonfun.x0$2" title="() =&gt; Unit" class="delimiter">{</a> case <span class="delimiter">(</span><span class="delimiter">(</span>_,<a title="scalaz.\/[Throwable,A] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply.enqueueOne.$anonfun.cb">cb</a><span class="delimiter">)</span>, <a title="A" id="scalaz.stream.async.mutable.Queue.apply.enqueueOne.$anonfun.a">a</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.enqueueOne.$anonfun.cb" title="(v1: scalaz.\/[Throwable,A])Unit">cb</a><span class="delimiter">(</span><span title="(b: A)scalaz.\/-[A]">\/-</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.enqueueOne.$anonfun.a" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>

        <a href="#scalaz.stream.async.mutable.Queue.apply.consumers" title="Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">consumers</a> = <a href="#scalaz.stream.async.mutable.Queue.apply.consumers" title="Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">consumers</a>.<span title="(n: Int)scala.collection.immutable.Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">drop</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.enqueueOne.deqCount" title="Int">deqCount</a><span class="delimiter">)</span>
        <a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a> = <a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a>.<span title="(n: Int)scala.collection.immutable.Vector[A]">drop</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.enqueueOne.deqCount" title="Int">deqCount</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      if <span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply$default$1" title="Int">bound</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;=</span> <a href="#scalaz.stream.async.mutable.Queue.apply$default$1" title="Int">bound</a><span class="delimiter">)</span> <a href="#scalaz.stream.async.mutable.Queue.apply.unAcked" title="Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]">unAcked</a> = <a href="#scalaz.stream.async.mutable.Queue.apply.unAcked" title="Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]">unAcked</a> <span title="(elem: scalaz.\/[Throwable,Unit] =&gt; Unit)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[scalaz.\/[Throwable,Unit] =&gt; Unit],scalaz.\/[Throwable,Unit] =&gt; Unit,Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]])Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]">:+</span> <a href="#scalaz.stream.async.mutable.Queue.apply.enqueueOne.cb" title="scalaz.\/[Throwable,Unit] =&gt; Unit">cb</a>
      else <a href="#scalaz.stream.async.mutable.Queue.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.enqueueOne.cb" title="(v1: scalaz.\/[Throwable,Unit])Unit">cb</a><span class="delimiter">(</span><span title="(b: Unit)scalaz.\/-[Unit]">\/-</span><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="#scalaz.stream.async.mutable.Queue.apply.signalSize" title="(sz: Int)Unit">signalSize</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    def <a title="(cause: scalaz.stream.Cause, cb: scalaz.\/[Throwable,Unit] =&gt; Unit)Unit" id="scalaz.stream.async.mutable.Queue.apply.stop">stop</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.async.mutable.Queue.apply.stop.cause">cause</a>: <a href="../../Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a>, <a title="scalaz.\/[Throwable,Unit] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply.stop.cb">cb</a>: Throwable \/ Unit =&gt; Unit<span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
      <a href="#scalaz.stream.async.mutable.Queue.apply.closed" title="Option[scalaz.stream.Cause]">closed</a> = <span title="(x: scalaz.stream.Cause)Some[scalaz.stream.Cause]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.stop.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#scalaz.stream.async.mutable.Queue.apply.stop.cause" title="scalaz.stream.Cause">cause</a> <span title="(x$1: Any)Boolean">==</span> <a href="../../Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scalaz.stream.async.mutable.Queue.apply.unAcked" title="Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]">unAcked</a>.<span title="(f: (scalaz.\/[Throwable,Unit] =&gt; Unit) =&gt; (() =&gt; Unit))Unit">foreach</span><span class="delimiter">(</span><span title="scalaz.\/[Throwable,Unit] =&gt; Unit">cb</span> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span class="delimiter">(</span><span title="(v1: scalaz.\/[Throwable,Unit])Unit">cb</span><span class="delimiter">(</span><span title="(a: scalaz.stream.Cause.Terminated)scalaz.-\/[scalaz.stream.Cause.Terminated]">-\/</span><span class="delimiter">(</span><a href="../../Cause.scala.html#scalaz.stream.Cause;Terminated" title="(cause: scalaz.stream.Cause)scalaz.stream.Cause.Terminated">Terminated</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.stop.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.consumers" title="Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">consumers</a>.<span title="(f: ((ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)) =&gt; scalaz.\/[Throwable,A] =&gt; Unit)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)],scalaz.\/[Throwable,A] =&gt; Unit,scala.collection.immutable.Vector[scalaz.\/[Throwable,A] =&gt; Unit]])scala.collection.immutable.Vector[scalaz.\/[Throwable,A] =&gt; Unit]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector.Coll,scalaz.\/[Throwable,A] =&gt; Unit,scala.collection.immutable.Vector[scalaz.\/[Throwable,A] =&gt; Unit]]" class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.stop.$anonfun.x$3" title="(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)">_</a>.<span title="=&gt; scalaz.\/[Throwable,A] =&gt; Unit">_2</span><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[scalaz.\/[Throwable,A] with scalaz.\/[Throwable,Unit] =&gt; Unit])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[scalaz.\/[Throwable,A] =&gt; Unit],scalaz.\/[Throwable,A] with scalaz.\/[Throwable,Unit] =&gt; Unit,scala.collection.immutable.Vector[scalaz.\/[Throwable,A] with scalaz.\/[Throwable,Unit] =&gt; Unit]])scala.collection.immutable.Vector[scalaz.\/[Throwable,A] with scalaz.\/[Throwable,Unit] =&gt; Unit]">++</span> <a href="#scalaz.stream.async.mutable.Queue.apply.unAcked" title="Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]">unAcked</a><span class="delimiter">)</span>.<span title="(f: (scalaz.\/[Throwable,A] with scalaz.\/[Throwable,Unit] =&gt; Unit) =&gt; (() =&gt; Unit))Unit">foreach</span><span class="delimiter">(</span><span title="scalaz.\/[Throwable,A] with scalaz.\/[Throwable,Unit] =&gt; Unit">cb</span> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span class="delimiter">(</span><span title="(v1: scalaz.\/[Throwable,A] with scalaz.\/[Throwable,Unit])Unit">cb</span><span class="delimiter">(</span><span title="(a: scalaz.stream.Cause.Terminated)scalaz.-\/[scalaz.stream.Cause.Terminated]">-\/</span><span class="delimiter">(</span><a href="../../Cause.scala.html#scalaz.stream.Cause;Terminated" title="(cause: scalaz.stream.Cause)scalaz.stream.Cause.Terminated">Terminated</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.stop.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#scalaz.stream.async.mutable.Queue.apply.consumers" title="Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">consumers</a> = <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span>
        <a href="#scalaz.stream.async.mutable.Queue.apply.sizes" title="Option[scalaz.\/[Vector[Int],scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]]">sizes</a>.<span title="(f: scalaz.\/[Vector[Int],scalaz.\/[Throwable,Seq[Int]] =&gt; Unit] =&gt; Option[scalaz.\/[Throwable,Seq[Int]] =&gt; Unit])Option[scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]">flatMap</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.stop.$anonfun.x$4" title="scalaz.\/[Vector[Int],scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]">_</a>.<span title="=&gt; Option[scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]">toOption</span><span class="delimiter">)</span>.<span title="(f: (scalaz.\/[Throwable,Seq[Int]] =&gt; Unit) =&gt; (() =&gt; Unit))Unit">foreach</span><span class="delimiter">(</span><span title="scalaz.\/[Throwable,Seq[Int]] =&gt; Unit">cb</span> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span class="delimiter">(</span><span title="(v1: scalaz.\/[Throwable,Seq[Int]])Unit">cb</span><span class="delimiter">(</span><span title="(a: scalaz.stream.Cause.Terminated)scalaz.-\/[scalaz.stream.Cause.Terminated]">-\/</span><span class="delimiter">(</span><a href="../../Cause.scala.html#scalaz.stream.Cause;Terminated" title="(cause: scalaz.stream.Cause)scalaz.stream.Cause.Terminated">Terminated</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.stop.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#scalaz.stream.async.mutable.Queue.apply.sizes" title="Option[scalaz.\/[Vector[Int],scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]]">sizes</a> = <span title="None.type">None</span>
        <a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a> = <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span>
      <span class="delimiter">}</span>
      <a href="#scalaz.stream.async.mutable.Queue.apply.unAcked" title="Vector[scalaz.\/[Throwable,Unit] =&gt; Unit]">unAcked</a> = <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span>
      <a href="#scalaz.stream.async.mutable.Queue.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span title="Unit" class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.stop.cb" title="(v1: scalaz.\/[Throwable,Unit])Unit">cb</a><span class="delimiter">(</span><span title="(b: Unit)scalaz.\/-[Unit]">\/-</span><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>


    val <a title="scalaz.concurrent.Actor[M]" id="scalaz.stream.async.mutable.Queue.apply.actor">actor</a>: <span title="scalaz.concurrent.Actor[M]">Actor</span><span class="delimiter">[</span>M<span class="delimiter">]</span> = <span title="(handler: M =&gt; Unit, onError: Throwable =&gt; Unit)(implicit strategy: scalaz.concurrent.Strategy)scalaz.concurrent.Actor[M]">Actor</span><span class="delimiter">(</span><span class="delimiter">{</span> <span class="delimiter">(</span>m: <a href="#scalaz.stream.async.mutable.Queue.apply;M" title="M">M</a><span class="delimiter">)</span> =&gt;
      if <span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.closed" title="Option[scalaz.stream.Cause]">closed</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#scalaz.stream.async.mutable.Queue.apply.actor.$anonfun.m" title="M">m</a> match <span class="delimiter">{</span>
        case <a href="#scalaz.stream.async.mutable.Queue.apply;Dequeue.readResolve" title="(x$0: Dequeue)Option[(ConsumerRef, Int, scalaz.\/[Throwable,Seq[A]] =&gt; Unit)]">Dequeue</a><span class="delimiter">(</span><span title="ConsumerRef">ref</span>, <span title="Int">limit</span>, <span title="scalaz.\/[Throwable,Seq[A]] =&gt; Unit">cb</span><span class="delimiter">)</span>     =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch" title="(ref: ConsumerRef, limit: Int, cb: scalaz.\/[Throwable,Seq[A]] =&gt; Unit)Unit">dequeueBatch</a><span class="delimiter">(</span><span title="ConsumerRef">ref</span>, <span title="Int">limit</span>, <span title="scalaz.\/[Throwable,Seq[A]] =&gt; Unit">cb</span><span class="delimiter">)</span>
        case <a href="#scalaz.stream.async.mutable.Queue.apply;Enqueue.readResolve" title="(x$0: Enqueue)Option[(Seq[A], scalaz.\/[Throwable,Unit] =&gt; Unit)]">Enqueue</a><span class="delimiter">(</span><span title="Seq[A]">as</span>, <span title="scalaz.\/[Throwable,Unit] =&gt; Unit">cb</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.enqueueOne" title="(as: Seq[A], cb: scalaz.\/[Throwable,Unit] =&gt; Unit)Unit">enqueueOne</a><span class="delimiter">(</span><span title="Seq[A]">as</span>, <span title="scalaz.\/[Throwable,Unit] =&gt; Unit">cb</span><span class="delimiter">)</span>
        case <a href="#scalaz.stream.async.mutable.Queue.apply;Fail.readResolve" title="(x$0: Fail)Option[(scalaz.stream.Cause, scalaz.\/[Throwable,Unit] =&gt; Unit)]">Fail</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.async.mutable.Queue.apply.actor.$anonfun.cause">cause</a>, <span title="scalaz.\/[Throwable,Unit] =&gt; Unit">cb</span><span class="delimiter">)</span>   =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.stop" title="(cause: scalaz.stream.Cause, cb: scalaz.\/[Throwable,Unit] =&gt; Unit)Unit">stop</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.actor.$anonfun.cause" title="scalaz.stream.Cause">cause</a>, <span title="scalaz.\/[Throwable,Unit] =&gt; Unit">cb</span><span class="delimiter">)</span>
        case <a href="#scalaz.stream.async.mutable.Queue.apply;GetSize.readResolve" title="(x$0: GetSize)Option[scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]">GetSize</a><span class="delimiter">(</span><span title="scalaz.\/[Throwable,Seq[Int]] =&gt; Unit">cb</span><span class="delimiter">)</span>     =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.publishSize" title="(cb: scalaz.\/[Throwable,Seq[Int]] =&gt; Unit)Unit">publishSize</a><span class="delimiter">(</span><span title="scalaz.\/[Throwable,Seq[Int]] =&gt; Unit">cb</span><span class="delimiter">)</span>
        case <a href="#scalaz.stream.async.mutable.Queue.apply;ConsumerDone.readResolve" title="(x$0: ConsumerDone)Option[ConsumerRef]">ConsumerDone</a><span class="delimiter">(</span><span title="ConsumerRef">ref</span><span class="delimiter">)</span> =&gt;  <a href="#scalaz.stream.async.mutable.Queue.apply.consumers" title="Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">consumers</a> = <a href="#scalaz.stream.async.mutable.Queue.apply.consumers" title="Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">consumers</a>.<span title="(p: ((ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)) =&gt; Boolean)scala.collection.immutable.Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">filterNot</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.actor.$anonfun.$anonfun.x$5" title="(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)">_</a>.<span title="=&gt; ConsumerRef">_1</span> <span title="(x$1: Any)Boolean">==</span> <span title="ConsumerRef">ref</span><span class="delimiter">)</span>

      <span class="delimiter">}</span> else <a href="#scalaz.stream.async.mutable.Queue.apply.actor.$anonfun.m" title="M">m</a> match <span class="delimiter">{</span>
        case <a href="#scalaz.stream.async.mutable.Queue.apply;Dequeue.readResolve" title="(x$0: Dequeue)Option[(ConsumerRef, Int, scalaz.\/[Throwable,Seq[A]] =&gt; Unit)]">Dequeue</a><span class="delimiter">(</span><span title="ConsumerRef">ref</span>, <span title="Int">limit</span>, <span title="scalaz.\/[Throwable,Seq[A]] =&gt; Unit">cb</span><span class="delimiter">)</span> if <a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a>.<span title="=&gt; Boolean">nonEmpty</span> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.dequeueBatch" title="(ref: ConsumerRef, limit: Int, cb: scalaz.\/[Throwable,Seq[A]] =&gt; Unit)Unit">dequeueBatch</a><span class="delimiter">(</span><span title="ConsumerRef">ref</span>, <span title="Int">limit</span>, <span title="scalaz.\/[Throwable,Seq[A]] =&gt; Unit">cb</span><span class="delimiter">)</span>
        case <a href="#scalaz.stream.async.mutable.Queue.apply;Dequeue.readResolve" title="(x$0: Dequeue)Option[(ConsumerRef, Int, scalaz.\/[Throwable,Seq[A]] =&gt; Unit)]">Dequeue</a><span class="delimiter">(</span><span title="ConsumerRef">ref</span>, <span title="Int">limit</span>, <span title="scalaz.\/[Throwable,Seq[A]] =&gt; Unit">cb</span><span class="delimiter">)</span>                    =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.signalClosed" title="(cb: scalaz.\/[Throwable,Seq[A]] =&gt; Unit)Unit">signalClosed</a><span class="delimiter">(</span><span title="scalaz.\/[Throwable,Seq[A]] =&gt; Unit">cb</span><span class="delimiter">)</span>
        case <a href="#scalaz.stream.async.mutable.Queue.apply;Enqueue.readResolve" title="(x$0: Enqueue)Option[(Seq[A], scalaz.\/[Throwable,Unit] =&gt; Unit)]">Enqueue</a><span class="delimiter">(</span><span title="Seq[A]">as</span>, <span title="scalaz.\/[Throwable,Unit] =&gt; Unit">cb</span><span class="delimiter">)</span>                     =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.signalClosed" title="(cb: scalaz.\/[Throwable,Unit] =&gt; Unit)Unit">signalClosed</a><span class="delimiter">(</span><span title="scalaz.\/[Throwable,Unit] =&gt; Unit">cb</span><span class="delimiter">)</span>
        case <a href="#scalaz.stream.async.mutable.Queue.apply;GetSize.readResolve" title="(x$0: GetSize)Option[scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]">GetSize</a><span class="delimiter">(</span><span title="scalaz.\/[Throwable,Seq[Int]] =&gt; Unit">cb</span><span class="delimiter">)</span> if <a href="#scalaz.stream.async.mutable.Queue.apply.queued" title="scala.collection.immutable.Vector[A]">queued</a>.<span title="=&gt; Boolean">nonEmpty</span>      =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.publishSize" title="(cb: scalaz.\/[Throwable,Seq[Int]] =&gt; Unit)Unit">publishSize</a><span class="delimiter">(</span><span title="scalaz.\/[Throwable,Seq[Int]] =&gt; Unit">cb</span><span class="delimiter">)</span>
        case <a href="#scalaz.stream.async.mutable.Queue.apply;GetSize.readResolve" title="(x$0: GetSize)Option[scalaz.\/[Throwable,Seq[Int]] =&gt; Unit]">GetSize</a><span class="delimiter">(</span><span title="scalaz.\/[Throwable,Seq[Int]] =&gt; Unit">cb</span><span class="delimiter">)</span>                         =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.signalClosed" title="(cb: scalaz.\/[Throwable,Seq[Int]] =&gt; Unit)Unit">signalClosed</a><span class="delimiter">(</span><span title="scalaz.\/[Throwable,Seq[Int]] =&gt; Unit">cb</span><span class="delimiter">)</span>
        case <a href="#scalaz.stream.async.mutable.Queue.apply;Fail.readResolve" title="(x$0: Fail)Option[(scalaz.stream.Cause, scalaz.\/[Throwable,Unit] =&gt; Unit)]">Fail</a><span class="delimiter">(</span>_, <span title="scalaz.\/[Throwable,Unit] =&gt; Unit">cb</span><span class="delimiter">)</span>                         =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span title="Unit" class="delimiter">(</span><span title="(v1: scalaz.\/[Throwable,Unit])Unit">cb</span><span class="delimiter">(</span><span title="(b: Unit)scalaz.\/-[Unit]">\/-</span><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case <a href="#scalaz.stream.async.mutable.Queue.apply;ConsumerDone.readResolve" title="(x$0: ConsumerDone)Option[ConsumerRef]">ConsumerDone</a><span class="delimiter">(</span><span title="ConsumerRef">ref</span><span class="delimiter">)</span>                   =&gt;  <a href="#scalaz.stream.async.mutable.Queue.apply.consumers" title="Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">consumers</a> = <a href="#scalaz.stream.async.mutable.Queue.apply.consumers" title="Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">consumers</a>.<span title="(p: ((ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)) =&gt; Boolean)scala.collection.immutable.Vector[(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)]">filterNot</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.actor.$anonfun.$anonfun.x$6" title="(ConsumerRef, scalaz.\/[Throwable,A] =&gt; Unit)">_</a>.<span title="=&gt; ConsumerRef">_1</span> <span title="(x$1: Any)Boolean">==</span> <span title="ConsumerRef">ref</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.S" title="scalaz.concurrent.Strategy">S</a><span class="delimiter">)</span>


    new <a title="&lt;$anon: scalaz.stream.async.mutable.Queue[A]&gt; extends AnyRef with scalaz.stream.async.mutable.Queue[A]" id="scalaz.stream.async.mutable.Queue.apply;$anon">Queue</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="=&gt; scalaz.stream.Sink[scalaz.concurrent.Task,A]" id="scalaz.stream.async.mutable.Queue.apply;$anon.enqueue">enqueue</a>: <a href="../../Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Sink[scalaz.concurrent.Task,A]">Sink</a><span class="delimiter">[</span>Task, A<span class="delimiter">]</span> = <a href="../../Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="../../Process.scala.html#scalaz.stream.Process.constant" title="(a: A =&gt; scalaz.concurrent.Task[Unit], chunkSize: Int)scalaz.stream.Process0[A =&gt; scalaz.concurrent.Task[Unit]]">constant</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply;$anon.enqueueOne" title="(a: A)scalaz.concurrent.Task[Unit]">enqueueOne</a> _<span class="delimiter">)</span>
      def <a title="(a: A)scalaz.concurrent.Task[Unit]" id="scalaz.stream.async.mutable.Queue.apply;$anon.enqueueOne">enqueueOne</a><span class="delimiter">(</span><a title="A" id="scalaz.stream.async.mutable.Queue.apply;$anon.enqueueOne.a">a</a>: <a href="#scalaz.stream.async.mutable.Queue.apply$default$1;A" title="A">A</a><span class="delimiter">)</span>: <span title="scalaz.concurrent.Task[Unit]">Task</span><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <a href="#scalaz.stream.async.mutable.Queue.apply;$anon.enqueueAll" title="(xa: Seq[A])scalaz.concurrent.Task[Unit]">enqueueAll</a><span class="delimiter">(</span><span title="(elems: A*)Seq[A]">Seq</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply;$anon.enqueueOne.a" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>

      def <a title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,A]" id="scalaz.stream.async.mutable.Queue.apply;$anon.dequeue">dequeue</a>: <a href="../../Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,A]">Process</a><span class="delimiter">[</span>Task, A<span class="delimiter">]</span> = <a href="#scalaz.stream.async.mutable.Queue.apply;$anon.dequeueBatch" title="(limit: Int)scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]">dequeueBatch</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="../../Process.scala.html#scalaz.stream;Process.flatMap" title="(f: Seq[A] =&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],A])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],A]">flatMap</a> <a href="../../Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="../../Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[A])scalaz.stream.Process0[A]">emitAll</a>

      def <a title="(limit: Int)scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]" id="scalaz.stream.async.mutable.Queue.apply;$anon.dequeueBatch">dequeueBatch</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream.async.mutable.Queue.apply;$anon.dequeueBatch.limit">limit</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="../../Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]">Process</a><span class="delimiter">[</span>Task, Seq<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply;$anon.dequeueBatch.limit" title="Int">limit</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
          throw new <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;batch limit must be greater than zero (got &quot;)">batch limit must be greater than zero (got $</span><a href="#scalaz.stream.async.mutable.Queue.apply;$anon.dequeueBatch.limit" title="Int">limit</a><span title="String(&quot;)&quot;)" class="string">)&quot;</span><span class="delimiter">)</span>
        else
          <a href="#scalaz.stream.async.mutable.Queue.apply;$anon.innerDequeueBatch" title="(limit: Int)scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]">innerDequeueBatch</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply;$anon.dequeueBatch.limit" title="Int">limit</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      def <a title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]" id="scalaz.stream.async.mutable.Queue.apply;$anon.dequeueAvailable">dequeueAvailable</a>: <a href="../../Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]">Process</a><span class="delimiter">[</span>Task, Seq<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scalaz.stream.async.mutable.Queue.apply;$anon.innerDequeueBatch" title="(limit: Int)scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]">innerDequeueBatch</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>

      private def <a title="(limit: Int)scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]" id="scalaz.stream.async.mutable.Queue.apply;$anon.innerDequeueBatch">innerDequeueBatch</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream.async.mutable.Queue.apply;$anon.innerDequeueBatch.limit">limit</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="../../Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]">Process</a><span class="delimiter">[</span>Task, Seq<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
        <a href="../../Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="../../Process.scala.html#scalaz.stream.Process.await" title="(req: scalaz.concurrent.Task[ConsumerRef])(rcv: ConsumerRef =&gt; scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]])scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]">await</a><span class="delimiter">(</span><span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; ConsumerRef)scalaz.concurrent.Task[ConsumerRef]">delay</span><span class="delimiter">(</span>new <a href="#scalaz.stream.async.mutable.Queue.apply;ConsumerRef" title="ConsumerRef">ConsumerRef</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">{</span> <a title="ConsumerRef" id="scalaz.stream.async.mutable.Queue.apply;$anon.innerDequeueBatch.$anonfun.ref">ref</a> =&gt;
          val source = <a href="../../Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a> <a href="../../Process.scala.html#scalaz.stream.Process.repeatEval" title="scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]" id="scalaz.stream.async.mutable.Queue.apply;$anon.innerDequeueBatch.$anonfun.source">repeatEval</a> <span title="scalaz.concurrent.Task.type">Task</span>.<span title="[A](register: (scalaz.\/[Throwable,A] =&gt; Unit) =&gt; Unit)scalaz.concurrent.Task[A]">async</span><span title="(register: (scalaz.\/[Throwable,Seq[A]] =&gt; Unit) =&gt; Unit)scalaz.concurrent.Task[Seq[A]]" class="delimiter">[</span><span title="Seq[A]">Seq</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.\/[Throwable,Seq[A]] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply;$anon.innerDequeueBatch.$anonfun.source.$anonfun.cb">cb</a> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.actor" title="scalaz.concurrent.Actor[M]">actor</a> <span title="(a: M)Unit">!</span> <a href="#scalaz.stream.async.mutable.Queue.apply;Dequeue.readResolve" title="(ref: ConsumerRef, limit: Int, cb: scalaz.\/[Throwable,Seq[A]] =&gt; Unit)Dequeue">Dequeue</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply;$anon.innerDequeueBatch.$anonfun.ref" title="ConsumerRef">ref</a>, <a href="#scalaz.stream.async.mutable.Queue.apply;$anon.innerDequeueBatch.limit" title="Int">limit</a>, <a href="#scalaz.stream.async.mutable.Queue.apply;$anon.innerDequeueBatch.$anonfun.source.$anonfun.cb" title="scalaz.\/[Throwable,Seq[A]] =&gt; Unit">cb</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#scalaz.stream.async.mutable.Queue.apply;$anon.innerDequeueBatch.$anonfun.source" title="scalaz.stream.Process[scalaz.concurrent.Task,Seq[A]]">source</a> <a href="../../Process.scala.html#scalaz.stream;Process.onComplete" title="(p2: =&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],Seq[A]])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],Seq[A]]">onComplete</a> <a href="../../Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="../../Process.scala.html#scalaz.stream.Process.eval_" title="(f: scalaz.concurrent.Task[Unit])scalaz.stream.Process[scalaz.concurrent.Task,Nothing]">eval_</a><span class="delimiter">(</span><span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; Unit)scalaz.concurrent.Task[Unit]">delay</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.actor" title="scalaz.concurrent.Actor[M]">actor</a> <span title="(a: M)Unit">!</span> <a href="#scalaz.stream.async.mutable.Queue.apply;ConsumerDone.readResolve" title="(ref: ConsumerRef)ConsumerDone">ConsumerDone</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply;$anon.innerDequeueBatch.$anonfun.ref" title="ConsumerRef">ref</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      val <a title="scalaz.stream.async.immutable.Signal[Int]" id="scalaz.stream.async.mutable.Queue.apply;$anon.size">size</a>: immutable.<a href="../immutable/Signal.scala.html#scalaz.stream.async.immutable;Signal" title="scalaz.stream.async.immutable.Signal[Int]">Signal</a><span class="delimiter">[</span>Int<span class="delimiter">]</span> = <span class="delimiter">{</span>
        val <a title="scalaz.stream.Process[scalaz.concurrent.Task,Int]" id="scalaz.stream.async.mutable.Queue.apply;$anon.size.sizeSource">sizeSource</a> : <a href="../../Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,Int]">Process</a><span class="delimiter">[</span>Task,Int<span class="delimiter">]</span> =
          <a href="../../Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="../../Process.scala.html#scalaz.stream.Process.repeatEval" title="(f: scalaz.concurrent.Task[Seq[Int]])scalaz.stream.Process[scalaz.concurrent.Task,Seq[Int]]">repeatEval</a><span class="delimiter">(</span><span title="scalaz.concurrent.Task.type">Task</span>.<span title="[A](register: (scalaz.\/[Throwable,A] =&gt; Unit) =&gt; Unit)scalaz.concurrent.Task[A]">async</span><span title="(register: (scalaz.\/[Throwable,Seq[Int]] =&gt; Unit) =&gt; Unit)scalaz.concurrent.Task[Seq[Int]]" class="delimiter">[</span><span title="Seq[Int]">Seq</span><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.\/[Throwable,Seq[Int]] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply;$anon.size.sizeSource.$anonfun.cb">cb</a> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.actor" title="scalaz.concurrent.Actor[M]">actor</a> <span title="(a: M)Unit">!</span> <a href="#scalaz.stream.async.mutable.Queue.apply;GetSize.readResolve" title="(cb: scalaz.\/[Throwable,Seq[Int]] =&gt; Unit)GetSize">GetSize</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply;$anon.size.sizeSource.$anonfun.cb" title="scalaz.\/[Throwable,Seq[Int]] =&gt; Unit">cb</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          .<a href="../../Process.scala.html#scalaz.stream;Process.flatMap" title="(f: Seq[Int] =&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],Int])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],Int]">flatMap</a><span class="delimiter">(</span><a href="../../Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="../../Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[Int])scalaz.stream.Process0[Int]">emitAll</a><span class="delimiter">)</span>
        <a href="Signal.scala.html#scalaz.stream.async.mutable.Signal.apply" title="(source: scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.async.mutable.Signal.Msg[Int]], haltOnSource: Boolean)(implicit S: scalaz.concurrent.Strategy)scalaz.stream.async.mutable.Signal[Int]">Signal</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply;$anon.size.sizeSource" title="scalaz.stream.Process[scalaz.concurrent.Task,Int]">sizeSource</a>.<a href="../../Process.scala.html#scalaz.stream;Process.map" title="(f: Int =&gt; scalaz.stream.async.mutable.Signal.Set[Int])scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.async.mutable.Signal.Set[Int]]">map</a><span class="delimiter">(</span><a href="Signal.scala.html#scalaz.stream.async.mutable.Signal" title="scalaz.stream.async.mutable.Signal.type">Signal</a>.<a href="Signal.scala.html#scalaz.stream.async.mutable.Signal.Set" title="scalaz.stream.async.mutable.Signal.Set.type">Set</a>.<a href="Signal.scala.html#scalaz.stream.async.mutable.Signal;Set" title="(a: Int)scalaz.stream.async.mutable.Signal.Set[Int]">apply</a><span class="delimiter">)</span>, haltOnSource =  true<span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply.S" title="scalaz.concurrent.Strategy">S</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      def <a title="(xa: Seq[A])scalaz.concurrent.Task[Unit]" id="scalaz.stream.async.mutable.Queue.apply;$anon.enqueueAll">enqueueAll</a><span class="delimiter">(</span><a title="Seq[A]" id="scalaz.stream.async.mutable.Queue.apply;$anon.enqueueAll.xa">xa</a>: <span title="Seq[A]">Seq</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scalaz.concurrent.Task[Unit]">Task</span><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(register: (scalaz.\/[Throwable,Unit] =&gt; Unit) =&gt; Unit)scalaz.concurrent.Task[Unit]">async</span><span class="delimiter">(</span><a title="scalaz.\/[Throwable,Unit] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply;$anon.enqueueAll.$anonfun.cb">cb</a> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.actor" title="scalaz.concurrent.Actor[M]">actor</a> <span title="(a: M)Unit">!</span> <a href="#scalaz.stream.async.mutable.Queue.apply;Enqueue.readResolve" title="(a: Seq[A], cb: scalaz.\/[Throwable,Unit] =&gt; Unit)Enqueue">Enqueue</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply;$anon.enqueueAll.xa" title="Seq[A]">xa</a>,<a href="#scalaz.stream.async.mutable.Queue.apply;$anon.enqueueAll.$anonfun.cb" title="scalaz.\/[Throwable,Unit] =&gt; Unit">cb</a><span class="delimiter">)</span><span class="delimiter">)</span>

      private<span class="delimiter">[</span>stream<span class="delimiter">]</span> def <a title="(c: scalaz.stream.Cause)scalaz.concurrent.Task[Unit]" id="scalaz.stream.async.mutable.Queue.apply;$anon.failWithCause">failWithCause</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.async.mutable.Queue.apply;$anon.failWithCause.c">c</a>: <a href="../../Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a><span class="delimiter">)</span>: <span title="scalaz.concurrent.Task[Unit]">Task</span><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <span title="scalaz.concurrent.Task.type">Task</span>.<span title="[A](register: (scalaz.\/[Throwable,A] =&gt; Unit) =&gt; Unit)scalaz.concurrent.Task[A]">async</span><span title="(register: (scalaz.\/[Throwable,Unit] =&gt; Unit) =&gt; Unit)scalaz.concurrent.Task[Unit]" class="delimiter">[</span><span title="Unit">Unit</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.\/[Throwable,Unit] =&gt; Unit" id="scalaz.stream.async.mutable.Queue.apply;$anon.failWithCause.$anonfun.cb">cb</a> =&gt; <a href="#scalaz.stream.async.mutable.Queue.apply.actor" title="scalaz.concurrent.Actor[M]">actor</a> <span title="(a: M)Unit">!</span> <a href="#scalaz.stream.async.mutable.Queue.apply;Fail.readResolve" title="(cause: scalaz.stream.Cause, cb: scalaz.\/[Throwable,Unit] =&gt; Unit)Fail">Fail</a><span class="delimiter">(</span><a href="#scalaz.stream.async.mutable.Queue.apply;$anon.failWithCause.c" title="scalaz.stream.Cause">c</a>,<a href="#scalaz.stream.async.mutable.Queue.apply;$anon.failWithCause.$anonfun.cb" title="scalaz.\/[Throwable,Unit] =&gt; Unit">cb</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="delimiter">}</span>


<span class="delimiter">}</span>

        </pre>
    </body>
</html>
