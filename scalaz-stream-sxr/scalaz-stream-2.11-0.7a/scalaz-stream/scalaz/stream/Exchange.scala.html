<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scalaz-stream/scalaz/stream/Exchange.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scalaz.stream

import scalaz.<span title="scalaz.\/.type">\/</span>._
import scalaz._
import scalaz.concurrent.<span class="delimiter">{</span>Strategy, Task<span class="delimiter">}</span>
import scalaz.stream.<a href="Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>._
import scalaz.stream.<a href="ReceiveY.scala.html#scalaz.stream.ReceiveY" title="scalaz.stream.ReceiveY.type">ReceiveY</a>.<span class="delimiter">{</span>HaltL, HaltR, ReceiveL, ReceiveR<span class="delimiter">}</span>
import scalaz.stream.<a href="wye.scala.html#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.Request


<span class="comment">/**
 * Exchange represents interconnection between two systems.
 * So called remote is resource from which program receives messages of type `I`
 * and can send to it messages of type `O`.
 *
 * Typically this can be sort of connection to external system,
 * like for example tcp connection to internet server.
 *
 * Exchange allows combining this pattern with Processes and
 * allows to use different combinators to specify the Exchange behaviour.
 *
 * Exchange is currently specialized to `scalaz.concurrent.Task`
 *
 * @param read Process reading values from remote system
 * @param write Process writing values to remote system
 *
 * @tparam I  values read from remote system
 * @tparam W  values written to remote system
 */</span>
final case class <a href="#scalaz.stream;Exchange.productElement.x$1" title="class Exchange[I, W] extends AnyRef with Product with Serializable" id="scalaz.stream;Exchange">Exchange</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Exchange;I">I</a>, <a title="" id="scalaz.stream;Exchange;W">W</a><span class="delimiter">]</span><a href="#scalaz.stream;Exchange" title="Product" class="delimiter">(</a><a title="scalaz.stream.Process[scalaz.concurrent.Task,I]" id="scalaz.stream;Exchange.read">read</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,I]">Process</a><span class="delimiter">[</span>Task, I<span class="delimiter">]</span>, <a title="scalaz.stream.Sink[scalaz.concurrent.Task,W]" id="scalaz.stream;Exchange.write">write</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Sink[scalaz.concurrent.Task,W]">Sink</a><span class="delimiter">[</span>Task, W<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

  self =&gt;

  <span class="comment">//alphabetical order from now on</span>

  <span class="comment">/**
   * uses provided function `f` to be applied on any `I` received
   */</span>
  def <a title="[I2](f: I =&gt; I2)scalaz.stream.Exchange[I2,W]" id="scalaz.stream;Exchange.mapO">mapO</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Exchange.mapO;I2">I2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; I2" id="scalaz.stream;Exchange.mapO.f">f</a>: I =&gt; I2<span class="delimiter">)</span>: <a href="#scalaz.stream;Exchange" title="scalaz.stream.Exchange[I2,W]">Exchange</a><span class="delimiter">[</span>I2, W<span class="delimiter">]</span> =
    <a href="#scalaz.stream;Exchange" title="(read: scalaz.stream.Process[scalaz.concurrent.Task,I2], write: scalaz.stream.Sink[scalaz.concurrent.Task,W])scalaz.stream.Exchange[I2,W]">Exchange</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="#scalaz.stream;Exchange.read" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,I]">read</a> <a href="Process.scala.html#scalaz.stream;Process.map" title="(f: I =&gt; I2)scalaz.stream.Process[scalaz.concurrent.Task,I2]">map</a> <a href="#scalaz.stream;Exchange.mapO.f" title="I =&gt; I2">f</a>, <a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="#scalaz.stream;Exchange.write" title="=&gt; scalaz.stream.Sink[scalaz.concurrent.Task,W]">write</a><span class="delimiter">)</span>

  <span class="comment">/**
   * applies provided function to any `W2` that has to be written to provide an `W`
   */</span>
  def <a title="[W2](f: W2 =&gt; W)scalaz.stream.Exchange[I,W2]" id="scalaz.stream;Exchange.mapW">mapW</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Exchange.mapW;W2">W2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="W2 =&gt; W" id="scalaz.stream;Exchange.mapW.f">f</a>: W2 =&gt; W<span class="delimiter">)</span>: <a href="#scalaz.stream;Exchange" title="scalaz.stream.Exchange[I,W2]">Exchange</a><span class="delimiter">[</span>I, W2<span class="delimiter">]</span> =
    <a href="#scalaz.stream;Exchange" title="(read: scalaz.stream.Process[scalaz.concurrent.Task,I], write: scalaz.stream.Sink[scalaz.concurrent.Task,W2])scalaz.stream.Exchange[I,W2]">Exchange</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="#scalaz.stream;Exchange.read" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,I]">read</a>, <a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="Process.scala.html#scalaz.stream.Process.ChannelSyntax(f213a79260)" title="(self: scalaz.stream.Channel[scalaz.concurrent.Task,W,Unit])scalaz.stream.Process.ChannelSyntax[scalaz.concurrent.Task,W,Unit]">write</a> <a href="Process.scala.html#scalaz.stream.Process;ChannelSyntax.contramap" title="(f: W2 =&gt; W)scalaz.stream.Channel[scalaz.concurrent.Task,W2,Unit]">contramap</a> <a href="#scalaz.stream;Exchange.mapW.f" title="W2 =&gt; W">f</a><span class="delimiter">)</span>


  <span class="comment">/**
   * Creates exchange that `pipe` read `I` values through supplied p1.
   * @param p1   Process1 to be used when reading values
   */</span>
  def <a title="[I2](p1: scalaz.stream.Process1[I,I2])scalaz.stream.Exchange[I2,W]" id="scalaz.stream;Exchange.pipeO">pipeO</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Exchange.pipeO;I2">I2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[I,I2]" id="scalaz.stream;Exchange.pipeO.p1">p1</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I2]">Process1</a><span class="delimiter">[</span>I, I2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Exchange" title="scalaz.stream.Exchange[I2,W]">Exchange</a><span class="delimiter">[</span>I2, W<span class="delimiter">]</span> =
    <a href="#scalaz.stream;Exchange" title="(read: scalaz.stream.Process[scalaz.concurrent.Task,I2], write: scalaz.stream.Sink[scalaz.concurrent.Task,W])scalaz.stream.Exchange[I2,W]">Exchange</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="#scalaz.stream;Exchange.read" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,I]">read</a>.<a href="Process.scala.html#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[I,I2])scalaz.stream.Process[scalaz.concurrent.Task,I2]">pipe</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.pipeO.p1" title="scalaz.stream.Process1[I,I2]">p1</a><span class="delimiter">)</span>, <a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="#scalaz.stream;Exchange.write" title="=&gt; scalaz.stream.Sink[scalaz.concurrent.Task,W]">write</a><span class="delimiter">)</span>


  <span class="comment">/**
   * Creates new exchange, that pipes all values to be sent through supplied `p1`
   */</span>
  def <a title="[W2](p1: scalaz.stream.Process1[W2,W])scalaz.stream.Exchange[I,W2]" id="scalaz.stream;Exchange.pipeW">pipeW</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Exchange.pipeW;W2">W2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[W2,W]" id="scalaz.stream;Exchange.pipeW.p1">p1</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[W2,W]">Process1</a><span class="delimiter">[</span>W2, W<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Exchange" title="scalaz.stream.Exchange[I,W2]">Exchange</a><span class="delimiter">[</span>I, W2<span class="delimiter">]</span> =
    <a href="#scalaz.stream;Exchange" title="(read: scalaz.stream.Process[scalaz.concurrent.Task,I], write: scalaz.stream.Sink[scalaz.concurrent.Task,W2])scalaz.stream.Exchange[I,W2]">Exchange</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="#scalaz.stream;Exchange.read" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,I]">read</a>, <a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="Process.scala.html#scalaz.stream.Process.SinkTaskSyntax(c45ec1498d)" title="(self: scalaz.stream.Sink[scalaz.concurrent.Task,W])scalaz.stream.Process.SinkTaskSyntax[W]">write</a>.<a href="Process.scala.html#scalaz.stream.Process;SinkTaskSyntax.pipeIn" title="(p1: scalaz.stream.Process1[W2,W])scalaz.stream.Sink[scalaz.concurrent.Task,W2]">pipeIn</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.pipeW.p1" title="scalaz.stream.Process1[W2,W]">p1</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Creates new exchange, that will pipe read values through supplied `r` and write values through `w`
   * @param r  Process1 to use on all read values
   * @param w  Process1 to use on all written values
   */</span>
  def <a title="[I2, W2](r: scalaz.stream.Process1[I,I2], w: scalaz.stream.Process1[W2,W])scalaz.stream.Exchange[I2,W2]" id="scalaz.stream;Exchange.pipeBoth">pipeBoth</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Exchange.pipeBoth;I2">I2</a>, <a title="" id="scalaz.stream;Exchange.pipeBoth;W2">W2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[I,I2]" id="scalaz.stream;Exchange.pipeBoth.r">r</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I,I2]">Process1</a><span class="delimiter">[</span>I, I2<span class="delimiter">]</span>, <a title="scalaz.stream.Process1[W2,W]" id="scalaz.stream;Exchange.pipeBoth.w">w</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[W2,W]">Process1</a><span class="delimiter">[</span>W2, W<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Exchange" title="scalaz.stream.Exchange[I2,W2]">Exchange</a><span class="delimiter">[</span>I2, W2<span class="delimiter">]</span> =
    <a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="#scalaz.stream;Exchange.pipeO" title="(p1: scalaz.stream.Process1[I,I2])scalaz.stream.Exchange[I2,W]">pipeO</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.pipeBoth.r" title="scalaz.stream.Process1[I,I2]">r</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Exchange.pipeW" title="(p1: scalaz.stream.Process1[W2,W])scalaz.stream.Exchange[I2,W2]">pipeW</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.pipeBoth.w" title="scalaz.stream.Process1[W2,W]">w</a><span class="delimiter">)</span>


  <span class="comment">/**
   * Runs supplied Process of `W` values by sending them to remote system.
   * Any replies from remote system are received as `I` values of the resulting process.
   *
   * Please note this will terminate by default after Left side (receive) terminates.
   * If you want to terminate after Right side (W) terminates, supply terminateOn with `Request.R` or `Request.Both` to
   * terminate on Right or Any side respectively
   *
   * @param p Process of `W` values to send
   * @param terminateOn Terminate on Left side (receive), Right side (W) or Any side terminates
   */</span>
  def <a title="(p: scalaz.stream.Process[scalaz.concurrent.Task,W], terminateOn: scalaz.stream.wye.Request)(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,I]" id="scalaz.stream;Exchange.run">run</a><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.concurrent.Task,W]" id="scalaz.stream;Exchange.run$default$1">p</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,W]">Process</a><span class="delimiter">[</span>Task, W<span class="delimiter">]</span> = <a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>, <a title="scalaz.stream.wye.Request" id="scalaz.stream;Exchange.run$default$2">terminateOn</a>: <a href="wye.scala.html#scalaz.stream.wye;Request" title="scalaz.stream.wye.Request">Request</a> = <a href="wye.scala.html#scalaz.stream.wye.Request" title="scalaz.stream.wye.Request.type">Request</a>.<a href="wye.scala.html#scalaz.stream.wye.Request.L" title="scalaz.stream.wye.Request.L.type">L</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream;Exchange.run.S">S</a>: <span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,I]">Process</a><span class="delimiter">[</span>Task, I<span class="delimiter">]</span> = <span class="delimiter">{</span>
    import scalaz.stream.<a href="wye.scala.html#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>. <span class="delimiter">{</span>mergeHaltL, mergeHaltR, mergeHaltBoth<span class="delimiter">}</span>
    val <a title="scalaz.stream.Wye[I,I,I]" id="scalaz.stream;Exchange.run.y">y</a> = <a href="#scalaz.stream;Exchange.run$default$2" title="scalaz.stream.wye.Request">terminateOn</a> match <span class="delimiter">{</span>
      case <a href="wye.scala.html#scalaz.stream.wye.Request" title="scalaz.stream.wye.Request.type">Request</a>.<a href="wye.scala.html#scalaz.stream.wye.Request.L" title="scalaz.stream.wye.Request.L.type">L</a> =&gt; <a href="wye.scala.html#scalaz.stream.wye.mergeHaltL" title="[I]=&gt; scalaz.stream.Wye[I,I,I]">mergeHaltL</a><span title="scalaz.stream.Wye[I,I,I]" class="delimiter">[</span><a href="#scalaz.stream;Exchange;I" title="I">I</a><span class="delimiter">]</span>
      case <a href="wye.scala.html#scalaz.stream.wye.Request" title="scalaz.stream.wye.Request.type">Request</a>.<a href="wye.scala.html#scalaz.stream.wye.Request.R" title="scalaz.stream.wye.Request.R.type">R</a> =&gt; <a href="wye.scala.html#scalaz.stream.wye.mergeHaltR" title="[I]=&gt; scalaz.stream.Wye[I,I,I]">mergeHaltR</a><span title="scalaz.stream.Wye[I,I,I]" class="delimiter">[</span><a href="#scalaz.stream;Exchange;I" title="I">I</a><span class="delimiter">]</span>
      case <a href="wye.scala.html#scalaz.stream.wye.Request" title="scalaz.stream.wye.Request.type">Request</a>.<a href="wye.scala.html#scalaz.stream.wye.Request.Both" title="scalaz.stream.wye.Request.Both.type">Both</a> =&gt; <a href="wye.scala.html#scalaz.stream.wye.mergeHaltBoth" title="[I]=&gt; scalaz.stream.Wye[I,I,I]">mergeHaltBoth</a><span title="scalaz.stream.Wye[I,I,I]" class="delimiter">[</span><a href="#scalaz.stream;Exchange;I" title="I">I</a><span class="delimiter">]</span>
    <span class="delimiter">}</span>
    <a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="Process.scala.html#scalaz.stream.Process.SourceSyntax" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,I])scalaz.stream.Process.SourceSyntax[I]">read</a>.<a href="wye.scala.html#scalaz.stream;WyeOps.wye" title="(p2: scalaz.stream.Process[scalaz.concurrent.Task,Nothing])(y: scalaz.stream.Wye[I,Nothing,I])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,I]">wye</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.ProcessSyntax(90c98207c6)" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,W])scalaz.stream.Process.ProcessSyntax[scalaz.concurrent.Task,W]">p</a> <a href="Process.scala.html#scalaz.stream.Process;ProcessSyntax.to" title="(f: scalaz.stream.Sink[[x]scalaz.concurrent.Task[x],W])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],Unit]">to</a> <a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="#scalaz.stream;Exchange.write" title="=&gt; scalaz.stream.Sink[scalaz.concurrent.Task,W]">write</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.drain" title="=&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],Nothing]">drain</a><span class="delimiter">)</span><a href="#scalaz.stream;Exchange.run.S" title="scalaz.concurrent.Strategy" class="delimiter">(</a><a href="#scalaz.stream;Exchange.run.y" title="scalaz.stream.Wye[I,I,I]">y</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>


  <span class="comment">/**
   * Creates Exchange that runs read `I` through supplied effect channel.
   * @param ch Channel producing process of `I2` for each `I` received
   */</span>
  def <a title="[I2](ch: scalaz.stream.Channel[scalaz.concurrent.Task,I,scalaz.stream.Process[scalaz.concurrent.Task,I2]])scalaz.stream.Exchange[I2,W]" id="scalaz.stream;Exchange.through">through</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Exchange.through;I2">I2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Channel[scalaz.concurrent.Task,I,scalaz.stream.Process[scalaz.concurrent.Task,I2]]" id="scalaz.stream;Exchange.through.ch">ch</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Channel[scalaz.concurrent.Task,I,scalaz.stream.Process[scalaz.concurrent.Task,I2]]">Channel</a><span class="delimiter">[</span>Task, I, Process<span class="delimiter">[</span>Task, I2<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Exchange" title="scalaz.stream.Exchange[I2,W]">Exchange</a><span class="delimiter">[</span>I2, W<span class="delimiter">]</span> =
    <a href="#scalaz.stream;Exchange" title="(read: scalaz.stream.Process[scalaz.concurrent.Task,I2], write: scalaz.stream.Sink[scalaz.concurrent.Task,W])scalaz.stream.Exchange[I2,W]">Exchange</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="Process.scala.html#scalaz.stream.Process.ProcessSyntax(90c98207c6)" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,I])scalaz.stream.Process.ProcessSyntax[scalaz.concurrent.Task,I]">read</a> <a href="Process.scala.html#scalaz.stream.Process;ProcessSyntax.through" title="(f: scalaz.stream.Channel[[x]scalaz.concurrent.Task[x],I,scalaz.stream.Process[scalaz.concurrent.Task,I2]])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],scalaz.stream.Process[scalaz.concurrent.Task,I2]]">through</a> <a href="#scalaz.stream;Exchange.through.ch" title="scalaz.stream.Channel[scalaz.concurrent.Task,I,scalaz.stream.Process[scalaz.concurrent.Task,I2]]">ch</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: scalaz.stream.Process[scalaz.concurrent.Task,I2] =&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],I2])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],I2]">flatMap</a> <a href="#scalaz.stream;Exchange.through.$anonfun.x" title="(x: scalaz.stream.Process[scalaz.concurrent.Task,I2])scalaz.stream.Process[scalaz.concurrent.Task,I2]">identity</a>, <a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="#scalaz.stream;Exchange.write" title="=&gt; scalaz.stream.Sink[scalaz.concurrent.Task,W]">write</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Transform this Exchange to another Exchange where queueing, and transformation of this `I` and `W`
   * is controlled by supplied WyeW.
   *
   * Please note the `W` queue of values to be sent to server is unbounded any may cause excessive heap usage, if the
   * remote system will read `W` too slow. If you want to control this flow, use rather `flow`.
   *
   * @param y WyeW to control queueing and transformation
   *
   */</span>
  def <a title="[I2, W2](y: scalaz.stream.WyeW[W,I,W2,I2])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Exchange[I2,W2]" id="scalaz.stream;Exchange.wye">wye</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Exchange.wye;I2">I2</a>,<a title="" id="scalaz.stream;Exchange.wye;W2">W2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.WyeW[W,I,W2,I2]" id="scalaz.stream;Exchange.wye.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.WyeW[W,I,W2,I2]">WyeW</a><span class="delimiter">[</span>W, I, W2, I2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream;Exchange.wye.S">S</a>: <span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Exchange" title="scalaz.stream.Exchange[I2,W2]">Exchange</a><span class="delimiter">[</span>I2, W2<span class="delimiter">]</span> =
   <a href="#scalaz.stream;Exchange.flow" title="(y: scalaz.stream.WyeW[W,scalaz.\/[Int,I],W2,I2])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Exchange[I2,W2]">flow</a><a href="#scalaz.stream;Exchange.wye.S" title="scalaz.concurrent.Strategy" class="delimiter">(</a>scalaz.stream.<a href="wye.scala.html#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="wye.scala.html#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[scalaz.\/[Int,I],I])(y: scalaz.stream.Wye[I,W2,scalaz.\/[W,I2]])scalaz.stream.Wye[scalaz.\/[Int,I],W2,scalaz.\/[W,I2]]">attachL</a><span class="delimiter">(</span><a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="process1.scala.html#scalaz.stream.process1.collect" title="[I, I2](pf: PartialFunction[I,I2])scalaz.stream.Process1[I,I2]">collect</a><span title="(pf: PartialFunction[scalaz.\/[Int,I],I])scalaz.stream.Process1[scalaz.\/[Int,I],I]" class="delimiter">[</span>Int <span title="scalaz.\/[Int,I]">\/</span> I,<a href="#scalaz.stream;Exchange;I" title="I">I</a><span class="delimiter">]</span> <a title="&lt;$anon: scalaz.\/[Int,I] =&gt; I&gt; extends scala.runtime.AbstractPartialFunction[scalaz.\/[Int,I],I] with Serializable" id="scalaz.stream;Exchange.wye;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> case \/-<span class="delimiter">(</span><a title="I" id="scalaz.stream;Exchange.wye;$anonfun.isDefinedAt.i">i</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Exchange.wye;$anonfun.isDefinedAt.i" title="I">i</a> <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.wye.y" title="scalaz.stream.WyeW[W,I,W2,I2]">y</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Transform this Exchange to another Exchange where queueing, flow control and transformation of this `I` and `W`
   * is controlled by supplied WyeW.
   *
   * Note this allows for fine-grained flow-control of written `W` to server based on Int passed to left side of
   * supplied WyeW that contains actual size of queued values to be written to server.
   *
   *
   * @param y WyeW to control queueing, flow control and transformation
   */</span>
  def <a title="[I2, W2](y: scalaz.stream.WyeW[W,scalaz.\/[Int,I],W2,I2])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Exchange[I2,W2]" id="scalaz.stream;Exchange.flow">flow</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Exchange.flow;I2">I2</a>,<a title="" id="scalaz.stream;Exchange.flow;W2">W2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.WyeW[W,scalaz.\/[Int,I],W2,I2]" id="scalaz.stream;Exchange.flow.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.WyeW[W,scalaz.\/[Int,I],W2,I2]">WyeW</a><span class="delimiter">[</span>W, Int \/ I, W2, I2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream;Exchange.flow.S">S</a>: <span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Exchange" title="scalaz.stream.Exchange[I2,W2]">Exchange</a><span class="delimiter">[</span>I2, W2<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scalaz.stream.async.mutable.Queue[W]" id="scalaz.stream;Exchange.flow.wq">wq</a> = async.<a href="async/package.scala.html#scalaz.stream.async.package.unboundedQueue" title="[A](implicit S: scalaz.concurrent.Strategy)scalaz.stream.async.mutable.Queue[A]">unboundedQueue</a><a href="#scalaz.stream;Exchange.flow.S" title="(implicit S: scalaz.concurrent.Strategy)scalaz.stream.async.mutable.Queue[W]" class="delimiter">[</a><a href="#scalaz.stream;Exchange;W" title="W">W</a><span class="delimiter">]</span>
    val <a title="scalaz.stream.async.mutable.Queue[W2]" id="scalaz.stream;Exchange.flow.w2q">w2q</a> = async.<a href="async/package.scala.html#scalaz.stream.async.package.unboundedQueue" title="[A](implicit S: scalaz.concurrent.Strategy)scalaz.stream.async.mutable.Queue[A]">unboundedQueue</a><a href="#scalaz.stream;Exchange.flow.S" title="(implicit S: scalaz.concurrent.Strategy)scalaz.stream.async.mutable.Queue[W2]" class="delimiter">[</a><a href="#scalaz.stream;Exchange.flow;W2" title="W2">W2</a><span class="delimiter">]</span>

    def <a title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,Nothing]" id="scalaz.stream;Exchange.flow.cleanup">cleanup</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,Nothing]">Process</a><span class="delimiter">[</span>Task, Nothing<span class="delimiter">]</span> = <a href="Process.scala.html#scalaz.stream.Process.eval_" title="(f: scalaz.concurrent.Task[Unit])scalaz.stream.Process[scalaz.concurrent.Task,Nothing]">eval_</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.flow.wq" title="scalaz.stream.async.mutable.Queue[W]">wq</a>.<a href="async/mutable/Queue.scala.html#scalaz.stream.async.mutable;Queue.close" title="=&gt; scalaz.concurrent.Task[Unit]">close</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],Nothing])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],Nothing]">++</a> <a href="Process.scala.html#scalaz.stream.Process.eval_" title="(f: scalaz.concurrent.Task[Unit])scalaz.stream.Process[scalaz.concurrent.Task,Nothing]">eval_</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.flow.w2q" title="scalaz.stream.async.mutable.Queue[W2]">w2q</a>.<a href="async/mutable/Queue.scala.html#scalaz.stream.async.mutable;Queue.close" title="=&gt; scalaz.concurrent.Task[Unit]">close</a><span class="delimiter">)</span>
    def <a title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,I]" id="scalaz.stream;Exchange.flow.receive">receive</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,I]">Process</a><span class="delimiter">[</span>Task, I<span class="delimiter">]</span> = <a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="#scalaz.stream;Exchange.read" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,I]">read</a> <a href="Process.scala.html#scalaz.stream;Process.onComplete" title="(p2: =&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],I])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],I]">onComplete</a> <a href="#scalaz.stream;Exchange.flow.cleanup" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,Nothing]">cleanup</a>
    def <a title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,Unit]" id="scalaz.stream;Exchange.flow.send">send</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,Unit]">Process</a><span class="delimiter">[</span>Task, Unit<span class="delimiter">]</span> = <a href="#scalaz.stream;Exchange.flow.wq" title="scalaz.stream.async.mutable.Queue[W]">wq</a>.<a href="Process.scala.html#scalaz.stream.Process.ProcessSyntax(90c98207c6)" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,W])scalaz.stream.Process.ProcessSyntax[scalaz.concurrent.Task,W]">dequeue</a> <a href="Process.scala.html#scalaz.stream.Process;ProcessSyntax.to" title="(f: scalaz.stream.Sink[[x]scalaz.concurrent.Task[x],W])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],Unit]">to</a> <a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="#scalaz.stream;Exchange.write" title="=&gt; scalaz.stream.Sink[scalaz.concurrent.Task,W]">write</a>

    def <a title="=&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],I2]" id="scalaz.stream;Exchange.flow.sendAndReceive">sendAndReceive</a> = <span class="delimiter">{</span>
      val <a href="#scalaz.stream;Exchange.flow.sendAndReceive.o" title="(Seq[scalaz.\/[W,I2]], scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[Int,I],W2]#Y,scalaz.\/[W,I2]])" class="delimiter">(</a><a href="#scalaz.stream;Exchange.flow.sendAndReceive.x$1" title="Seq[scalaz.\/[W,I2]]" id="scalaz.stream;Exchange.flow.sendAndReceive.o">o</a>, <a href="#scalaz.stream;Exchange.flow.sendAndReceive.x$1" title="scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[Int,I],W2]#Y,scalaz.\/[W,I2]]" id="scalaz.stream;Exchange.flow.sendAndReceive.ny">ny</a><span class="delimiter">)</span> = <a href="#scalaz.stream;Exchange.flow.y" title="scalaz.stream.WyeW[W,scalaz.\/[Int,I],W2,I2]">y</a>.<a href="Process.scala.html#scalaz.stream;Process.unemit" title="=&gt; (Seq[scalaz.\/[W,I2]], scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[Int,I],W2]#Y,scalaz.\/[W,I2]])">unemit</a>
      <span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[scalaz.\/[W,I2]])scalaz.stream.Process0[scalaz.\/[W,I2]]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.flow.sendAndReceive.o" title="Seq[scalaz.\/[W,I2]]">o</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process.SourceSyntax" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[W,I2]])scalaz.stream.Process.SourceSyntax[scalaz.\/[W,I2]]">++</a> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.flow.wq" title="scalaz.stream.async.mutable.Queue[W]">wq</a>.<a href="async/mutable/Queue.scala.html#scalaz.stream.async.mutable;Queue.size" title="=&gt; scalaz.stream.async.immutable.Signal[Int]">size</a>.<a href="Process.scala.html#scalaz.stream.Process.SourceSyntax" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,Int])scalaz.stream.Process.SourceSyntax[Int]">discrete</a> <a href="Process.scala.html#scalaz.stream.Process.SourceSyntax" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[Int,I]])scalaz.stream.Process.SourceSyntax[scalaz.\/[Int,I]]">either</a> <a href="#scalaz.stream;Exchange.flow.receive" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,I]">receive</a><span class="delimiter">)</span>.<a href="wye.scala.html#scalaz.stream;WyeOps.wye" title="(p2: scalaz.stream.Process[scalaz.concurrent.Task,W2])(y: scalaz.stream.Wye[scalaz.\/[Int,I],W2,scalaz.\/[W,I2]])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[W,I2]]">wye</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.flow.w2q" title="scalaz.stream.async.mutable.Queue[W2]">w2q</a>.<a href="async/mutable/Queue.scala.html#scalaz.stream.async.mutable;Queue.dequeue" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,W2]">dequeue</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.flow.sendAndReceive.ny" title="scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[Int,I],W2]#Y,scalaz.\/[W,I2]]">ny</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.flow.S" title="scalaz.concurrent.Strategy">S</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.onComplete" title="(p2: =&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],scalaz.\/[W,I2]])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],scalaz.\/[W,I2]]">onComplete</a> <a href="#scalaz.stream;Exchange.flow.cleanup" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,Nothing]">cleanup</a><span class="delimiter">)</span> <a href="wye.scala.html#scalaz.stream;WyeOps.either" title="(p2: scalaz.stream.Process[scalaz.concurrent.Task,Unit])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[scalaz.\/[W,I2],Unit]]">either</a> <a href="#scalaz.stream;Exchange.flow.send" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,Unit]">send</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: scalaz.\/[scalaz.\/[W,I2],Unit] =&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],I2])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],I2]">flatMap</a> <a href="#scalaz.stream;Exchange.flow.sendAndReceive.$anonfun.x0$1" title="scalaz.stream.Process[scalaz.concurrent.Task,I2]" class="delimiter">{</a>
        case \/-<span class="delimiter">(</span><span title="Unit">o</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>
        case -\/<span class="delimiter">(</span>-\/<span class="delimiter">(</span><span title="W">o</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.eval_" title="(f: scalaz.concurrent.Task[Unit])scalaz.stream.Process[scalaz.concurrent.Task,Nothing]">eval_</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.flow.wq" title="scalaz.stream.async.mutable.Queue[W]">wq</a>.<a href="async/mutable/Queue.scala.html#scalaz.stream.async.mutable;Queue.enqueueOne" title="(a: W)scalaz.concurrent.Task[Unit]">enqueueOne</a><span class="delimiter">(</span><span title="W">o</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case -\/<span class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="I2" id="scalaz.stream;Exchange.flow.sendAndReceive.$anonfun.b">b</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I2)scalaz.stream.Process0[I2]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.flow.sendAndReceive.$anonfun.b" title="I2">b</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="#scalaz.stream;Exchange" title="(read: scalaz.stream.Process[scalaz.concurrent.Task,I2], write: scalaz.stream.Sink[scalaz.concurrent.Task,W2])scalaz.stream.Exchange[I2,W2]">Exchange</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.flow.sendAndReceive" title="=&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],I2]">sendAndReceive</a>, <a href="#scalaz.stream;Exchange.flow.w2q" title="scalaz.stream.async.mutable.Queue[W2]">w2q</a>.<a href="async/mutable/Queue.scala.html#scalaz.stream.async.mutable;Queue.enqueue" title="=&gt; scalaz.stream.Sink[scalaz.concurrent.Task,W2]">enqueue</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Transforms this exchange to another exchange, that for every received `I` will consult supplied Writer1
   * and eventually transforms `I` to `I2` or to `W` that is sent to remote system.
   *
   *
   * Please note that if external system is slow on reading `W` this can lead to excessive heap usage. If you
   * want to avoid for this to happen, please use `flow` instead.
   *
   * @param w  Writer that processes received `I` and either echoes `I2` or writes `W` to external system
   *
   */</span>
  def <a title="[I2](w: scalaz.stream.Writer1[W,I,I2])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Exchange[I2,W]" id="scalaz.stream;Exchange.readThrough">readThrough</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Exchange.readThrough;I2">I2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Writer1[W,I,I2]" id="scalaz.stream;Exchange.readThrough.w">w</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Writer1[W,I,I2]">Writer1</a><span class="delimiter">[</span>W, I, I2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream;Exchange.readThrough.S">S</a>: <span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span> : <a href="#scalaz.stream;Exchange" title="scalaz.stream.Exchange[I2,W]">Exchange</a><span class="delimiter">[</span>I2,W<span class="delimiter">]</span>  = <span class="delimiter">{</span>
    def <a title="=&gt; scalaz.stream.WyeW[W,scalaz.\/[Int,I],W,I2]" id="scalaz.stream;Exchange.readThrough.liftWriter">liftWriter</a> : <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.WyeW[W,scalaz.\/[Int,I],W,I2]">WyeW</a><span class="delimiter">[</span>W, Int \/ I, W, I2<span class="delimiter">]</span> = <span class="delimiter">{</span>
      def <a title="(cur: scalaz.stream.Writer1[W,I,I2])scalaz.stream.WyeW[W,scalaz.\/[Int,I],W,I2]" id="scalaz.stream;Exchange.readThrough.liftWriter.go">go</a><span class="delimiter">(</span><a title="scalaz.stream.Writer1[W,I,I2]" id="scalaz.stream;Exchange.readThrough.liftWriter.go.cur">cur</a>:<a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Writer1[W,I,I2]">Writer1</a><span class="delimiter">[</span>W, I, I2<span class="delimiter">]</span><span class="delimiter">)</span>:<a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.WyeW[W,scalaz.\/[Int,I],W,I2]">WyeW</a><span class="delimiter">[</span>W, Int \/ I, W, I2<span class="delimiter">]</span> = <span class="delimiter">{</span>
        <a href="Process.scala.html#scalaz.stream.Process.awaitBoth" title="[I, I2]=&gt; scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]">awaitBoth</a><span title="scalaz.stream.Wye[scalaz.\/[Int,I],W,scalaz.stream.ReceiveY[scalaz.\/[Int,I],W]]" class="delimiter">[</span>Int<span title="scalaz.\/[Int,I]">\/</span>I,<a href="#scalaz.stream;Exchange;W" title="W">W</a><span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: scalaz.stream.ReceiveY[scalaz.\/[Int,I],W] =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[scalaz.\/[Int,I],W]#Y[x],scalaz.\/[W,I2]])scalaz.stream.Process[[x]scalaz.stream.Process.Env[scalaz.\/[Int,I],W]#Y[x],scalaz.\/[W,I2]]">flatMap</a><a href="#scalaz.stream;Exchange.readThrough.liftWriter.go.$anonfun.x0$2" title="scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[Int,I],W]#Y,scalaz.\/[W,I2]]" class="delimiter">{</a>
          case ReceiveL<span class="delimiter">(</span>-\/<span class="delimiter">(</span>_<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Exchange.readThrough.liftWriter.go" title="(cur: scalaz.stream.Writer1[W,I,I2])scalaz.stream.WyeW[W,scalaz.\/[Int,I],W,I2]">go</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.readThrough.liftWriter.go.cur" title="scalaz.stream.Writer1[W,I,I2]">cur</a><span class="delimiter">)</span>
          case ReceiveL<span class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="I" id="scalaz.stream;Exchange.readThrough.liftWriter.go.$anonfun.i">i</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
            <a href="Process.scala.html#scalaz.stream.Process.Process1Syntax(ed4aae368f)" title="(self: scalaz.stream.Process1[I,scalaz.\/[W,I2]])scalaz.stream.Process.Process1Syntax[I,scalaz.\/[W,I2]]">cur</a>.<a href="Process.scala.html#scalaz.stream.Process;Process1Syntax.feed1" title="(i: I)scalaz.stream.Process1[I,scalaz.\/[W,I2]]">feed1</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.readThrough.liftWriter.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.unemit" title="=&gt; (Seq[scalaz.\/[W,I2]], scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,scalaz.\/[W,I2]])">unemit</a> match <span class="delimiter">{</span>
              case <span class="delimiter">(</span><span title="Seq[scalaz.\/[W,I2]]">out</span>,<a title="scalaz.stream.Process.Halt" id="scalaz.stream;Exchange.readThrough.liftWriter.go.$anonfun.hlt">hlt</a>@Halt<span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[scalaz.\/[W,I2]])scalaz.stream.Process0[scalaz.\/[W,I2]]">emitAll</a><span class="delimiter">(</span><span title="Seq[scalaz.\/[W,I2]]">out</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[Nothing,scalaz.\/[W,I2]])scalaz.stream.Process[Nothing,scalaz.\/[W,I2]]">++</a> <a href="#scalaz.stream;Exchange.readThrough.liftWriter.go.$anonfun.hlt" title="scalaz.stream.Process.Halt">hlt</a>
              case <span class="delimiter">(</span><span title="Seq[scalaz.\/[W,I2]]">out</span>,<a title="scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,scalaz.\/[W,I2]]" id="scalaz.stream;Exchange.readThrough.liftWriter.go.$anonfun.next">next</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[scalaz.\/[W,I2]])scalaz.stream.Process0[scalaz.\/[W,I2]]">emitAll</a><span class="delimiter">(</span><span title="Seq[scalaz.\/[W,I2]]">out</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[Int,I],W]#Y,scalaz.\/[W,I2]])scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[Int,I],W]#Y,scalaz.\/[W,I2]]">++</a> <a href="#scalaz.stream;Exchange.readThrough.liftWriter.go" title="(cur: scalaz.stream.Writer1[W,I,I2])scalaz.stream.WyeW[W,scalaz.\/[Int,I],W,I2]">go</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.readThrough.liftWriter.go.$anonfun.next" title="scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,scalaz.\/[W,I2]]">next</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          case ReceiveR<span class="delimiter">(</span><a title="W" id="scalaz.stream;Exchange.readThrough.liftWriter.go.$anonfun.w">w</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.tell" title="(s: W)scalaz.stream.Process0[scalaz.\/[W,Nothing]]">tell</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.readThrough.liftWriter.go.$anonfun.w" title="W">w</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[Int,I],W]#Y,scalaz.\/[W,I2]])scalaz.stream.Process[scalaz.stream.Process.Env[scalaz.\/[Int,I],W]#Y,scalaz.\/[W,I2]]">++</a> <a href="#scalaz.stream;Exchange.readThrough.liftWriter.go" title="(cur: scalaz.stream.Writer1[W,I,I2])scalaz.stream.WyeW[W,scalaz.\/[Int,I],W,I2]">go</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.readThrough.liftWriter.go.cur" title="scalaz.stream.Writer1[W,I,I2]">cur</a><span class="delimiter">)</span>
          case HaltL<span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span><span class="delimiter">)</span>
          case HaltR<span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Exchange.readThrough.liftWriter.go" title="(cur: scalaz.stream.Writer1[W,I,I2])scalaz.stream.WyeW[W,scalaz.\/[Int,I],W,I2]">go</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.readThrough.liftWriter.go.cur" title="scalaz.stream.Writer1[W,I,I2]">cur</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#scalaz.stream;Exchange.readThrough.liftWriter.go" title="(cur: scalaz.stream.Writer1[W,I,I2])scalaz.stream.WyeW[W,scalaz.\/[Int,I],W,I2]">go</a><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.readThrough.w" title="scalaz.stream.Writer1[W,I,I2]">w</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#scalaz.stream;Exchange" title="Exchange.this.type">self</a>.<a href="#scalaz.stream;Exchange.flow" title="[I2, W2](y: scalaz.stream.WyeW[W,scalaz.\/[Int,I],W2,I2])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Exchange[I2,W2]">flow</a><span title="(y: scalaz.stream.WyeW[W,scalaz.\/[Int,I],W,I2])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Exchange[I2,W]" class="delimiter">[</span><a href="#scalaz.stream;Exchange.readThrough;I2" title="I2">I2</a>,<a href="#scalaz.stream;Exchange;W" title="W">W</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.readThrough.liftWriter" title="=&gt; scalaz.stream.WyeW[W,scalaz.\/[Int,I],W,I2]">liftWriter</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Exchange.readThrough.S" title="scalaz.concurrent.Strategy">S</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

object <a title="scalaz.stream.Exchange.type" id="scalaz.stream.Exchange.readResolve">Exchange</a> <a href="#scalaz.stream.Exchange.readResolve" title="scalaz.stream.Exchange.type" class="delimiter">{</a>

  <span class="comment">/**
   * Provides `loopBack` exchange, that loops data written to it back to `read` side, via supplied Process1.
   *
   * If process1 starts with emitting some data, they are `read` first.
   *
   * This exchange will terminate `read` side once the `p` terminates.
   *
   * Note that the `write` side is run off the thread that actually writes the messages, forcing the `read` side
   * to be run on different thread.
   *
   * This primitive may be used also for asynchronous processing that needs to be forked to different thread.
   *
   * @param p   Process to consult when looping data through
   */</span>
  def <a title="[I, W](p: scalaz.stream.Process1[W,I])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Exchange[I,W]]" id="scalaz.stream.Exchange.loopBack">loopBack</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Exchange.loopBack;I">I</a>, <a title="" id="scalaz.stream.Exchange.loopBack;W">W</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[W,I]" id="scalaz.stream.Exchange.loopBack.p">p</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[W,I]">Process1</a><span class="delimiter">[</span>W, I<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream.Exchange.loopBack.S">S</a>: <span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Exchange[I,W]]">Process</a><span class="delimiter">[</span>Task, Exchange<span class="delimiter">[</span>I, W<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>

    def <a title="(cur: scalaz.stream.Process1[W,I])scalaz.stream.WyeW[Nothing,Nothing,W,I]" id="scalaz.stream.Exchange.loopBack.loop">loop</a><span class="delimiter">(</span><a title="scalaz.stream.Process1[W,I]" id="scalaz.stream.Exchange.loopBack.loop.cur">cur</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[W,I]">Process1</a><span class="delimiter">[</span>W, I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.WyeW[Nothing,Nothing,W,I]">WyeW</a><span class="delimiter">[</span>Nothing, Nothing, W, I<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="Process.scala.html#scalaz.stream.Process.awaitR" title="[I2]=&gt; scalaz.stream.Tee[Any,I2,I2]">awaitR</a><span title="scalaz.stream.Tee[Any,W,W]" class="delimiter">[</span><a href="#scalaz.stream.Exchange.loopBack;W" title="W">W</a><span class="delimiter">]</span> <a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: W =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Nothing,W]#Y,scalaz.\/[Nothing,I]])scalaz.stream.Process[scalaz.stream.Process.Env[Nothing,W]#Y,scalaz.\/[Nothing,I]]">flatMap</a> <a href="#scalaz.stream.Exchange.loopBack.loop.$anonfun.x0$3" title="scalaz.stream.Process[scalaz.stream.Process.Env[Nothing,W]#Y,scalaz.\/[Nothing,I]]" class="delimiter">{</a>
        case <a title="W" id="scalaz.stream.Exchange.loopBack.loop.$anonfun.w">w</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.Process1Syntax(ed4aae368f)" title="(self: scalaz.stream.Process1[W,I])scalaz.stream.Process.Process1Syntax[W,I]">cur</a>.<a href="Process.scala.html#scalaz.stream.Process;Process1Syntax.feed1" title="(i: W)scalaz.stream.Process1[W,I]">feed1</a><span class="delimiter">(</span><a href="#scalaz.stream.Exchange.loopBack.loop.$anonfun.w" title="W">w</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.unemit" title="=&gt; (Seq[I], scalaz.stream.Process[scalaz.stream.Process.Env[W,Any]#Is,I])">unemit</a> match <span class="delimiter">{</span>
          case <span class="delimiter">(</span><span title="Seq[I]">o</span>, <a title="scalaz.stream.Process.Halt" id="scalaz.stream.Exchange.loopBack.loop.$anonfun.hlt">hlt</a>@Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.Exchange.loopBack.loop.$anonfun.rsn">rsn</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[scalaz.\/[Nothing,I]])scalaz.stream.Process0[scalaz.\/[Nothing,I]]">emitAll</a><span class="delimiter">(</span><span title="Seq[I]">o</span>.<span title="(f: I =&gt; scalaz.\/[Nothing,I])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[I],scalaz.\/[Nothing,I],Seq[scalaz.\/[Nothing,I]]])Seq[scalaz.\/[Nothing,I]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scalaz.\/[Nothing,I],Seq[scalaz.\/[Nothing,I]]]" class="delimiter">(</span><span title="I =&gt; scalaz.\/[Nothing,I]">right</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[Nothing,scalaz.\/[Nothing,I]])scalaz.stream.Process[Nothing,scalaz.\/[Nothing,I]]">++</a> <a href="#scalaz.stream.Exchange.loopBack.loop.$anonfun.hlt" title="scalaz.stream.Process.Halt">hlt</a>
          case <span class="delimiter">(</span><span title="Seq[I]">o</span>, <a title="scalaz.stream.Process[scalaz.stream.Process.Env[W,Any]#Is,I]" id="scalaz.stream.Exchange.loopBack.loop.$anonfun.np">np</a><span class="delimiter">)</span>            =&gt; <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[scalaz.\/[Nothing,I]])scalaz.stream.Process0[scalaz.\/[Nothing,I]]">emitAll</a><span class="delimiter">(</span><span title="Seq[I]">o</span>.<span title="(f: I =&gt; scalaz.\/[Nothing,I])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[I],scalaz.\/[Nothing,I],Seq[scalaz.\/[Nothing,I]]])Seq[scalaz.\/[Nothing,I]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,scalaz.\/[Nothing,I],Seq[scalaz.\/[Nothing,I]]]" class="delimiter">(</span><span title="I =&gt; scalaz.\/[Nothing,I]">right</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Nothing,W]#Y,scalaz.\/[Nothing,I]])scalaz.stream.Process[scalaz.stream.Process.Env[Nothing,W]#Y,scalaz.\/[Nothing,I]]">++</a> <a href="#scalaz.stream.Exchange.loopBack.loop" title="(cur: scalaz.stream.Process1[W,I])scalaz.stream.WyeW[Nothing,Nothing,W,I]">loop</a><span class="delimiter">(</span><a href="#scalaz.stream.Exchange.loopBack.loop.$anonfun.np" title="scalaz.stream.Process[scalaz.stream.Process.Env[W,Any]#Is,I]">np</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="Process.scala.html#scalaz.stream.Process.await" title="(req: scalaz.concurrent.Task[scalaz.stream.async.mutable.Queue[W]])(rcv: scalaz.stream.async.mutable.Queue[W] =&gt; scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Exchange[I,W]])scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Exchange[I,W]]">await</a><span class="delimiter">(</span><span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; scalaz.stream.async.mutable.Queue[W])scalaz.concurrent.Task[scalaz.stream.async.mutable.Queue[W]]">delay</span> <span class="delimiter">{</span>
      async.<a href="async/package.scala.html#scalaz.stream.async.package.unboundedQueue" title="[A](implicit S: scalaz.concurrent.Strategy)scalaz.stream.async.mutable.Queue[A]">unboundedQueue</a><a href="#scalaz.stream.Exchange.loopBack.S" title="(implicit S: scalaz.concurrent.Strategy)scalaz.stream.async.mutable.Queue[W]" class="delimiter">[</a><a href="#scalaz.stream.Exchange.loopBack;W" title="W">W</a><span class="delimiter">]</span>
    <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">{</span> <a title="scalaz.stream.async.mutable.Queue[W]" id="scalaz.stream.Exchange.loopBack.$anonfun.q">q</a> =&gt;
      val <a href="#scalaz.stream.Exchange.loopBack.$anonfun.out" title="(Seq[I], scalaz.stream.Process[scalaz.stream.Process.Env[W,Any]#Is,I])" class="delimiter">(</a><a href="#scalaz.stream.Exchange.loopBack.$anonfun.x$2" title="Seq[I]" id="scalaz.stream.Exchange.loopBack.$anonfun.out">out</a>, <a href="#scalaz.stream.Exchange.loopBack.$anonfun.x$2" title="scalaz.stream.Process[scalaz.stream.Process.Env[W,Any]#Is,I]" id="scalaz.stream.Exchange.loopBack.$anonfun.np">np</a><span class="delimiter">)</span> = <a href="#scalaz.stream.Exchange.loopBack.p" title="scalaz.stream.Process1[W,I]">p</a>.<a href="Process.scala.html#scalaz.stream;Process.unemit" title="=&gt; (Seq[I], scalaz.stream.Process[scalaz.stream.Process.Env[W,Any]#Is,I])">unemit</a>
      val <a title="scalaz.stream.Exchange[Nothing,W]" id="scalaz.stream.Exchange.loopBack.$anonfun.ex">ex</a> = <a href="#scalaz.stream;Exchange" title="[I, W](read: scalaz.stream.Process[scalaz.concurrent.Task,I], write: scalaz.stream.Sink[scalaz.concurrent.Task,W])scalaz.stream.Exchange[I,W]">Exchange</a><span title="(read: scalaz.stream.Process[scalaz.concurrent.Task,Nothing], write: scalaz.stream.Sink[scalaz.concurrent.Task,W])scalaz.stream.Exchange[Nothing,W]" class="delimiter">[</span><span title="Nothing">Nothing</span>, <a href="#scalaz.stream.Exchange.loopBack;W" title="W">W</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>, <a href="#scalaz.stream.Exchange.loopBack.$anonfun.q" title="scalaz.stream.async.mutable.Queue[W]">q</a>.<a href="async/mutable/Queue.scala.html#scalaz.stream.async.mutable;Queue.enqueue" title="=&gt; scalaz.stream.Sink[scalaz.concurrent.Task,W]">enqueue</a><span class="delimiter">)</span>
      <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: scalaz.stream.Exchange[I,W])scalaz.stream.Process0[scalaz.stream.Exchange[I,W]]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.Exchange.loopBack.$anonfun.ex" title="scalaz.stream.Exchange[Nothing,W]">ex</a>.<a href="#scalaz.stream;Exchange.wye" title="(y: scalaz.stream.WyeW[W,Nothing,W,I])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Exchange[I,W]">wye</a><a href="#scalaz.stream.Exchange.loopBack.S" title="scalaz.concurrent.Strategy" class="delimiter">(</a><a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[I])scalaz.stream.Process0[I]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.Exchange.loopBack.$anonfun.out" title="Seq[I]">out</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.map" title="(f: I =&gt; scalaz.\/[Nothing,I])scalaz.stream.Process[Nothing,scalaz.\/[Nothing,I]]">map</a><span class="delimiter">(</span><span title="I =&gt; scalaz.\/[Nothing,I]">right</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Nothing,W]#Y,scalaz.\/[Nothing,I]])scalaz.stream.Process[scalaz.stream.Process.Env[Nothing,W]#Y,scalaz.\/[Nothing,I]]">++</a> <a href="#scalaz.stream.Exchange.loopBack.loop" title="(cur: scalaz.stream.Process1[W,I])scalaz.stream.WyeW[Nothing,Nothing,W,I]">loop</a><span class="delimiter">(</span><a href="#scalaz.stream.Exchange.loopBack.$anonfun.np" title="scalaz.stream.Process[scalaz.stream.Process.Env[W,Any]#Is,I]">np</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.onComplete" title="(p2: =&gt; scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Exchange[I,W]])scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Exchange[I,W]]">onComplete</a> <a href="Process.scala.html#scalaz.stream.Process.eval_" title="(f: scalaz.concurrent.Task[Unit])scalaz.stream.Process[scalaz.concurrent.Task,Nothing]">eval_</a><span class="delimiter">(</span><a href="#scalaz.stream.Exchange.loopBack.$anonfun.q" title="scalaz.stream.async.mutable.Queue[W]">q</a>.<a href="async/mutable/Queue.scala.html#scalaz.stream.async.mutable;Queue.close" title="=&gt; scalaz.concurrent.Task[Unit]">close</a><span class="delimiter">)</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="delimiter">}</span>


  <span class="comment">/**
   * Exchange that is always halted
   */</span>
  def <a title="[I, W]=&gt; scalaz.stream.Exchange[I,W]" id="scalaz.stream.Exchange.halted">halted</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Exchange.halted;I">I</a>,<a title="" id="scalaz.stream.Exchange.halted;W">W</a><span class="delimiter">]</span>: <a href="#scalaz.stream;Exchange" title="scalaz.stream.Exchange[I,W]">Exchange</a><span class="delimiter">[</span>I,W<span class="delimiter">]</span> = <a href="#scalaz.stream;Exchange" title="(read: scalaz.stream.Process[scalaz.concurrent.Task,I], write: scalaz.stream.Sink[scalaz.concurrent.Task,W])scalaz.stream.Exchange[I,W]">Exchange</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>,<a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a><span class="delimiter">)</span>

<span class="delimiter">}</span>


        </pre>
    </body>
</html>
