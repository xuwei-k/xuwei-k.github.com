<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scalaz-stream/scalaz/stream/ReceiveY.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scalaz.stream

import scalaz.<span class="delimiter">{</span>Monoid, Applicative, Equal, Monad<span class="delimiter">}</span>


sealed trait <a title="trait ReceiveY[+A, +B] extends AnyRef" id="scalaz.stream;ReceiveY">ReceiveY</a><span class="delimiter">[</span>+<a title="" id="scalaz.stream;ReceiveY;A">A</a>,+<a title="" id="scalaz.stream;ReceiveY;B">B</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>
  import <a href="#scalaz.stream.ReceiveY" title="scalaz.stream.ReceiveY.type">ReceiveY</a>._

  def <a title="=&gt; scalaz.stream.ReceiveY[B,A]" id="scalaz.stream;ReceiveY.flip">flip</a>: <a href="#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[B,A]">ReceiveY</a><span class="delimiter">[</span>B,A<span class="delimiter">]</span> = this match <span class="delimiter">{</span>
    case ReceiveL<span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.ReceiveY.ReceiveR.readResolve" title="(get: A)scalaz.stream.ReceiveY.ReceiveR[A]">ReceiveR</a><span class="delimiter">(</span><span title="A">x</span><span class="delimiter">)</span>
    case ReceiveR<span class="delimiter">(</span><span title="B">x</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.ReceiveY.ReceiveL.readResolve" title="(get: B)scalaz.stream.ReceiveY.ReceiveL[B]">ReceiveL</a><span class="delimiter">(</span><span title="B">x</span><span class="delimiter">)</span>
    case HaltL<span class="delimiter">(</span><span title="scalaz.stream.Cause">e</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.ReceiveY.HaltR.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.ReceiveY.HaltR">HaltR</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">e</span><span class="delimiter">)</span>
    case HaltR<span class="delimiter">(</span><span title="scalaz.stream.Cause">e</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.ReceiveY.HaltL.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.ReceiveY.HaltL">HaltL</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">e</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="[A2](f: A =&gt; A2)scalaz.stream.ReceiveY[A2,B]" id="scalaz.stream;ReceiveY.mapL">mapL</a><span class="delimiter">[</span><a title="" id="scalaz.stream;ReceiveY.mapL;A2">A2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; A2" id="scalaz.stream;ReceiveY.mapL.f">f</a>: A =&gt; A2<span class="delimiter">)</span>: <a href="#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[A2,B]">ReceiveY</a><span class="delimiter">[</span>A2,B<span class="delimiter">]</span> = this match <span class="delimiter">{</span>
    case ReceiveL<span class="delimiter">(</span><a title="A" id="scalaz.stream;ReceiveY.mapL.a">a</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.ReceiveY.ReceiveL.readResolve" title="(get: A2)scalaz.stream.ReceiveY.ReceiveL[A2]">ReceiveL</a><span class="delimiter">(</span><a href="#scalaz.stream;ReceiveY.mapL.f" title="(v1: A)A2">f</a><span class="delimiter">(</span><a href="#scalaz.stream;ReceiveY.mapL.a" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
    case <a title="scalaz.stream.ReceiveY.ReceiveR[B]" id="scalaz.stream;ReceiveY.mapL.t">t</a>@ReceiveR<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;ReceiveY.mapL.t" title="scalaz.stream.ReceiveY.ReceiveR[B]">t</a>
    case <a title="scalaz.stream.ReceiveY.HaltOne" id="scalaz.stream;ReceiveY.mapL.h">h</a>:<a href="#scalaz.stream.ReceiveY;HaltOne" title="scalaz.stream.ReceiveY.HaltOne">HaltOne</a> =&gt; <a href="#scalaz.stream;ReceiveY.mapL.h" title="scalaz.stream.ReceiveY.HaltOne">h</a>
  <span class="delimiter">}</span>

  def <a title="[B2](f: B =&gt; B2)scalaz.stream.ReceiveY[A,B2]" id="scalaz.stream;ReceiveY.mapR">mapR</a><span class="delimiter">[</span><a title="" id="scalaz.stream;ReceiveY.mapR;B2">B2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B =&gt; B2" id="scalaz.stream;ReceiveY.mapR.f">f</a>: B =&gt; B2<span class="delimiter">)</span>: <a href="#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[A,B2]">ReceiveY</a><span class="delimiter">[</span>A,B2<span class="delimiter">]</span> = this match <span class="delimiter">{</span>
    case ReceiveR<span class="delimiter">(</span><a title="B" id="scalaz.stream;ReceiveY.mapR.b">b</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.ReceiveY.ReceiveR.readResolve" title="(get: B2)scalaz.stream.ReceiveY.ReceiveR[B2]">ReceiveR</a><span class="delimiter">(</span><a href="#scalaz.stream;ReceiveY.mapR.f" title="(v1: B)B2">f</a><span class="delimiter">(</span><a href="#scalaz.stream;ReceiveY.mapR.b" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
    case <a title="scalaz.stream.ReceiveY.ReceiveL[A]" id="scalaz.stream;ReceiveY.mapR.t">t</a>@ReceiveL<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;ReceiveY.mapR.t" title="scalaz.stream.ReceiveY.ReceiveL[A]">t</a>
    case <a title="scalaz.stream.ReceiveY.HaltOne" id="scalaz.stream;ReceiveY.mapR.h">h</a>:<a href="#scalaz.stream.ReceiveY;HaltOne" title="scalaz.stream.ReceiveY.HaltOne">HaltOne</a> =&gt; <a href="#scalaz.stream;ReceiveY.mapR.h" title="scalaz.stream.ReceiveY.HaltOne">h</a>
  <span class="delimiter">}</span>

  def <a title="=&gt; Boolean" id="scalaz.stream;ReceiveY.isL">isL</a>: <span title="Boolean">Boolean</span> = this match <span class="delimiter">{</span>
    case ReceiveL<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; true
    case _ =&gt; false
  <span class="delimiter">}</span>

  def <a title="=&gt; Boolean" id="scalaz.stream;ReceiveY.isR">isR</a>: <span title="Boolean">Boolean</span> = this match <span class="delimiter">{</span>
    case ReceiveR<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; true
    case _ =&gt; false
  <span class="delimiter">}</span>

  def <a title="=&gt; Boolean" id="scalaz.stream;ReceiveY.isHalted">isHalted</a> = <a href="#scalaz.stream;ReceiveY.haltedBy" title="=&gt; Option[scalaz.stream.Cause]">haltedBy</a>.<span title="=&gt; Boolean">isDefined</span>

  def <a title="=&gt; Option[scalaz.stream.Cause]" id="scalaz.stream;ReceiveY.haltedBy">haltedBy</a>: <span title="Option[scalaz.stream.Cause]">Option</span><span class="delimiter">[</span>Cause<span class="delimiter">]</span> = this match <span class="delimiter">{</span>
    case <a title="scalaz.stream.ReceiveY.HaltOne" id="scalaz.stream;ReceiveY.haltedBy.h">h</a>:<a href="#scalaz.stream.ReceiveY;HaltOne" title="scalaz.stream.ReceiveY.HaltOne">HaltOne</a> =&gt; <span title="(x: scalaz.stream.Cause)Some[scalaz.stream.Cause]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream;ReceiveY.haltedBy.h" title="scalaz.stream.ReceiveY.HaltOne">h</a>.<a href="#scalaz.stream.ReceiveY;HaltOne.cause" title="=&gt; scalaz.stream.Cause">cause</a><span class="delimiter">)</span>
    case _ =&gt; <span title="None.type">None</span>
  <span class="delimiter">}</span>


<span class="delimiter">}</span>

object <a title="scalaz.stream.ReceiveY.type" id="scalaz.stream.ReceiveY">ReceiveY</a> <a href="#scalaz.stream.ReceiveY" title="scalaz.stream.ReceiveY.type" class="delimiter">{</a>
  case class <a href="#scalaz.stream.ReceiveY;ReceiveL.productElement.x$1" title="class ReceiveL[+A] extends AnyRef with scalaz.stream.ReceiveY[A,Nothing] with Product with Serializable" id="scalaz.stream.ReceiveY.ReceiveL.readResolve">ReceiveL</a><span class="delimiter">[</span>+<a title="" id="scalaz.stream.ReceiveY;ReceiveL;A">A</a><span class="delimiter">]</span><span title="Product" class="delimiter">(</span><a title="A" id="scalaz.stream.ReceiveY;ReceiveL.get">get</a>: <a href="#scalaz.stream.ReceiveY;ReceiveL;A" title="A">A</a><span class="delimiter">)</span> extends <a href="#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[A,Nothing]">ReceiveY</a><span class="delimiter">[</span>A, Nothing<span class="delimiter">]</span>
  case class <a href="#scalaz.stream.ReceiveY;ReceiveR.productElement.x$1" title="class ReceiveR[+B] extends AnyRef with scalaz.stream.ReceiveY[Nothing,B] with Product with Serializable" id="scalaz.stream.ReceiveY.ReceiveR.readResolve">ReceiveR</a><span class="delimiter">[</span>+<a title="" id="scalaz.stream.ReceiveY;ReceiveR;B">B</a><span class="delimiter">]</span><span title="Product" class="delimiter">(</span><a title="B" id="scalaz.stream.ReceiveY;ReceiveR.get">get</a>: <a href="#scalaz.stream.ReceiveY;ReceiveR;B" title="B">B</a><span class="delimiter">)</span> extends <a href="#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[Nothing,B]">ReceiveY</a><span class="delimiter">[</span>Nothing, B<span class="delimiter">]</span>
  sealed trait <a title="trait HaltOne extends AnyRef with scalaz.stream.ReceiveY[Nothing,Nothing]" id="scalaz.stream.ReceiveY;HaltOne">HaltOne</a> extends <a href="#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[Nothing,Nothing]">ReceiveY</a><span class="delimiter">[</span>Nothing, Nothing<span class="delimiter">]</span> <span class="delimiter">{</span>
    val <a title="=&gt; scalaz.stream.Cause" id="scalaz.stream.ReceiveY;HaltOne.cause">cause</a>: <a href="Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a>
  <span class="delimiter">}</span>
  case class <a title="class HaltL extends AnyRef with scalaz.stream.ReceiveY.HaltOne with Product with Serializable" id="scalaz.stream.ReceiveY.HaltL.readResolve">HaltL</a><span title="Product" class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.ReceiveY;HaltL.cause">cause</a>:<a href="Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a><span class="delimiter">)</span> extends <a href="#scalaz.stream.ReceiveY;HaltOne" title="scalaz.stream.ReceiveY.HaltOne">HaltOne</a>
  case class <a title="class HaltR extends AnyRef with scalaz.stream.ReceiveY.HaltOne with Product with Serializable" id="scalaz.stream.ReceiveY.HaltR.readResolve">HaltR</a><span title="Product" class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.ReceiveY;HaltR.cause">cause</a>:<a href="Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a><span class="delimiter">)</span> extends <a href="#scalaz.stream.ReceiveY;HaltOne" title="scalaz.stream.ReceiveY.HaltOne">HaltOne</a>
  object <a title="scalaz.stream.ReceiveY.HaltOne.type" id="scalaz.stream.ReceiveY.HaltOne">HaltOne</a> <a href="#scalaz.stream.ReceiveY.HaltOne" title="scalaz.stream.ReceiveY.HaltOne.type" class="delimiter">{</a>
    def <a title="(ry: scalaz.stream.ReceiveY[Any,Any])Option[scalaz.stream.Cause]" id="scalaz.stream.ReceiveY.HaltOne.unapply">unapply</a><span class="delimiter">(</span><a title="scalaz.stream.ReceiveY[Any,Any]" id="scalaz.stream.ReceiveY.HaltOne.unapply.ry">ry</a>:<a href="#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[Any,Any]">ReceiveY</a><span class="delimiter">[</span>Any,Any<span class="delimiter">]</span><span class="delimiter">)</span> : <span title="Option[scalaz.stream.Cause]">Option</span><span class="delimiter">[</span>Cause<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#scalaz.stream.ReceiveY.HaltOne.unapply.ry" title="scalaz.stream.ReceiveY[Any,Any]">ry</a> match <span class="delimiter">{</span>
        case <a title="scalaz.stream.ReceiveY.HaltOne" id="scalaz.stream.ReceiveY.HaltOne.unapply.h">h</a>:<a href="#scalaz.stream.ReceiveY;HaltOne" title="scalaz.stream.ReceiveY.HaltOne">HaltOne</a> =&gt; <span title="(x: scalaz.stream.Cause)Some[scalaz.stream.Cause]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.HaltOne.unapply.h" title="scalaz.stream.ReceiveY.HaltOne">h</a>.<a href="#scalaz.stream.ReceiveY;HaltOne.cause" title="=&gt; scalaz.stream.Cause">cause</a><span class="delimiter">)</span>
        case _ =&gt; <span title="None.type">None</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  implicit def <a title="[X, Y](implicit X: scalaz.Equal[X], implicit Y: scalaz.Equal[Y])scalaz.Equal[scalaz.stream.ReceiveY[X,Y]]" id="scalaz.stream.ReceiveY.receiveYequal">receiveYequal</a><span class="delimiter">[</span><a title="" id="scalaz.stream.ReceiveY.receiveYequal;X">X</a>, <a title="" id="scalaz.stream.ReceiveY.receiveYequal;Y">Y</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Equal[X]" id="scalaz.stream.ReceiveY.receiveYequal.X">X</a>: <span title="scalaz.Equal[X]">Equal</span><span class="delimiter">[</span>X<span class="delimiter">]</span>, <a title="scalaz.Equal[Y]" id="scalaz.stream.ReceiveY.receiveYequal.Y">Y</a>: <span title="scalaz.Equal[Y]">Equal</span><span class="delimiter">[</span>Y<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scalaz.Equal[scalaz.stream.ReceiveY[X,Y]]">Equal</span><span class="delimiter">[</span>ReceiveY<span class="delimiter">[</span>X, Y<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span title="scalaz.Equal.type">Equal</span>.<span title="(f: (scalaz.stream.ReceiveY[X,Y], scalaz.stream.ReceiveY[X,Y]) =&gt; Boolean)scalaz.Equal[scalaz.stream.ReceiveY[X,Y]]">equal</span><a href="#scalaz.stream.ReceiveY.receiveYequal.$anonfun.x0$1" title="Boolean" class="delimiter">{</a>
      case <span class="delimiter">(</span>ReceiveL<span class="delimiter">(</span><span title="X">a</span><span class="delimiter">)</span>, ReceiveL<span class="delimiter">(</span><span title="X">b</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.ReceiveY.receiveYequal.X" title="scalaz.Equal[X]">X</a>.<span title="(a1: X, a2: X)Boolean">equal</span><span class="delimiter">(</span><span title="X">a</span>, <span title="X">b</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>ReceiveR<span class="delimiter">(</span><span title="Y">a</span><span class="delimiter">)</span>, ReceiveR<span class="delimiter">(</span><span title="Y">b</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.ReceiveY.receiveYequal.Y" title="scalaz.Equal[Y]">Y</a>.<span title="(a1: Y, a2: Y)Boolean">equal</span><span class="delimiter">(</span><span title="Y">a</span>, <span title="Y">b</span><span class="delimiter">)</span>
      case _ =&gt; false
    <span class="delimiter">}</span>

  implicit def <a title="[X](implicit X: scalaz.Monoid[X])scalaz.Monad[[y]scalaz.stream.ReceiveY[X,y]]" id="scalaz.stream.ReceiveY.receiveYInstance">receiveYInstance</a><span class="delimiter">[</span><a title="" id="scalaz.stream.ReceiveY.receiveYInstance;X">X</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Monoid[X]" id="scalaz.stream.ReceiveY.receiveYInstance.X">X</a>: <span title="scalaz.Monoid[X]">Monoid</span><span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">)</span> =
    new <a title="&lt;$anon: scalaz.Monad[[y]scalaz.stream.ReceiveY[X,y]]&gt; extends AnyRef with scalaz.Monad[[y]scalaz.stream.ReceiveY[X,y]]" id="scalaz.stream.ReceiveY.receiveYInstance;$anon">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span>type f<span class="delimiter">[</span>y<span class="delimiter">]</span> = ReceiveY<span class="delimiter">[</span>X,y<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="[Y](x: =&gt; Y)scalaz.stream.ReceiveY[X,Y]" id="scalaz.stream.ReceiveY.receiveYInstance;$anon.point">point</a><span class="delimiter">[</span><a title="" id="scalaz.stream.ReceiveY.receiveYInstance;$anon.point;Y">Y</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Y" id="scalaz.stream.ReceiveY.receiveYInstance;$anon.point.x">x</a>: =&gt; Y<span class="delimiter">)</span>: <a href="#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[X,Y]">ReceiveY</a><span class="delimiter">[</span>X,Y<span class="delimiter">]</span> = <a href="#scalaz.stream.ReceiveY.ReceiveR.readResolve" title="(get: Y)scalaz.stream.ReceiveY.ReceiveR[Y]">ReceiveR</a><span class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.receiveYInstance;$anon.point.x" title="=&gt; Y">x</a><span class="delimiter">)</span>
      def <a title="[Y, Y2](t: scalaz.stream.ReceiveY[X,Y])(f: Y =&gt; scalaz.stream.ReceiveY[X,Y2])scalaz.stream.ReceiveY[X,Y2]" id="scalaz.stream.ReceiveY.receiveYInstance;$anon.bind">bind</a><span class="delimiter">[</span><a title="" id="scalaz.stream.ReceiveY.receiveYInstance;$anon.bind;Y">Y</a>,<a title="" id="scalaz.stream.ReceiveY.receiveYInstance;$anon.bind;Y2">Y2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.ReceiveY[X,Y]" id="scalaz.stream.ReceiveY.receiveYInstance;$anon.bind.t">t</a>: <a href="#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[X,Y]">ReceiveY</a><span class="delimiter">[</span>X,Y<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Y =&gt; scalaz.stream.ReceiveY[X,Y2]" id="scalaz.stream.ReceiveY.receiveYInstance;$anon.bind.f">f</a>: Y =&gt; ReceiveY<span class="delimiter">[</span>X,Y2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[X,Y2]">ReceiveY</a><span class="delimiter">[</span>X,Y2<span class="delimiter">]</span> =
        <a href="#scalaz.stream.ReceiveY.receiveYInstance;$anon.bind.t" title="scalaz.stream.ReceiveY[X,Y]">t</a> match <span class="delimiter">{</span>
          case <a title="scalaz.stream.ReceiveY.ReceiveL[X]" id="scalaz.stream.ReceiveY.receiveYInstance;$anon.bind.a">a</a>@ReceiveL<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.ReceiveY.receiveYInstance;$anon.bind.a" title="scalaz.stream.ReceiveY.ReceiveL[X]">a</a>
          case ReceiveR<span class="delimiter">(</span><a title="Y" id="scalaz.stream.ReceiveY.receiveYInstance;$anon.bind.x">x</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.ReceiveY.receiveYInstance;$anon.bind.f" title="(v1: Y)scalaz.stream.ReceiveY[X,Y2]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.receiveYInstance;$anon.bind.x" title="Y">x</a><span class="delimiter">)</span>
          case <a title="scalaz.stream.ReceiveY.HaltOne" id="scalaz.stream.ReceiveY.receiveYInstance;$anon.bind.h">h</a>:<a href="#scalaz.stream.ReceiveY;HaltOne" title="scalaz.stream.ReceiveY.HaltOne">HaltOne</a> =&gt; <a href="#scalaz.stream.ReceiveY.receiveYInstance;$anon.bind.h" title="scalaz.stream.ReceiveY.HaltOne">h</a>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  def <a title="[A, B](a: Seq[A], b: Seq[B])Stream[scalaz.stream.ReceiveY[A,B]]" id="scalaz.stream.ReceiveY.align">align</a><span class="delimiter">[</span><a title="" id="scalaz.stream.ReceiveY.align;A">A</a>,<a title="" id="scalaz.stream.ReceiveY.align;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[A]" id="scalaz.stream.ReceiveY.align.a">a</a>: <span title="Seq[A]">Seq</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Seq[B]" id="scalaz.stream.ReceiveY.align.b">b</a>: <span title="Seq[B]">Seq</span><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Stream[scalaz.stream.ReceiveY[A,B]]">Stream</span><span class="delimiter">[</span>ReceiveY<span class="delimiter">[</span>A,B<span class="delimiter">]</span><span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.align.a" title="Seq[A]">a</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#scalaz.stream.ReceiveY.align.b" title="Seq[B]">b</a>.<span title="=&gt; scala.collection.SeqView[B,Seq[B]]">view</span>.<span title="(f: B =&gt; scalaz.stream.ReceiveY.ReceiveR[B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.SeqView[B,Seq[B]],scalaz.stream.ReceiveY.ReceiveR[B],scala.collection.SeqView[scalaz.stream.ReceiveY.ReceiveR[B],Seq[_]]])scala.collection.SeqView[scalaz.stream.ReceiveY.ReceiveR[B],Seq[_]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.SeqView.Coll,scalaz.stream.ReceiveY.ReceiveR[B],scala.collection.SeqView[scalaz.stream.ReceiveY.ReceiveR[B],Seq[_]]]" class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.ReceiveR.readResolve" title="(get: B)scalaz.stream.ReceiveY.ReceiveR[B]">ReceiveR</a><span class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.align.$anonfun.x$1" title="B">_</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; scala.collection.immutable.Stream[scalaz.stream.ReceiveY.ReceiveR[B]]">toStream</span>
    else <a href="#scalaz.stream.ReceiveY.align.a" title="Seq[A]">a</a>.<span title="=&gt; scala.collection.SeqView[A,Seq[A]]">view</span>.<span title="(f: A =&gt; scalaz.stream.ReceiveY.ReceiveL[A])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.SeqView[A,Seq[A]],scalaz.stream.ReceiveY.ReceiveL[A],scala.collection.SeqView[scalaz.stream.ReceiveY.ReceiveL[A],Seq[_]]])scala.collection.SeqView[scalaz.stream.ReceiveY.ReceiveL[A],Seq[_]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.SeqView.Coll,scalaz.stream.ReceiveY.ReceiveL[A],scala.collection.SeqView[scalaz.stream.ReceiveY.ReceiveL[A],Seq[_]]]" class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.ReceiveL.readResolve" title="(get: A)scalaz.stream.ReceiveY.ReceiveL[A]">ReceiveL</a><span class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.align.$anonfun.x$2" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; scala.collection.immutable.Stream[scalaz.stream.ReceiveY.ReceiveL[A]]">toStream</span>

  def <a title="[A, B](s: Seq[scalaz.stream.ReceiveY[A,B]])(Stream[A], Stream[B])" id="scalaz.stream.ReceiveY.unalign">unalign</a><span class="delimiter">[</span><a title="" id="scalaz.stream.ReceiveY.unalign;A">A</a>,<a title="" id="scalaz.stream.ReceiveY.unalign;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[scalaz.stream.ReceiveY[A,B]]" id="scalaz.stream.ReceiveY.unalign.s">s</a>: <span title="Seq[scalaz.stream.ReceiveY[A,B]]">Seq</span><span class="delimiter">[</span>ReceiveY<span class="delimiter">[</span>A,B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Stream[A], Stream[B])" class="delimiter">(</span>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, Stream<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> =
    <span title="(_1: Stream[A], _2: Stream[B])(Stream[A], Stream[B])" class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.concatLeft" title="(s: Seq[scalaz.stream.ReceiveY[A,B]])Stream[A]">concatLeft</a><span class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.unalign.s" title="Seq[scalaz.stream.ReceiveY[A,B]]">s</a><span class="delimiter">)</span>, <a href="#scalaz.stream.ReceiveY.concatRight" title="(s: Seq[scalaz.stream.ReceiveY[A,B]])Stream[B]">concatRight</a><span class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.unalign.s" title="Seq[scalaz.stream.ReceiveY[A,B]]">s</a><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="[A, B](s: Seq[scalaz.stream.ReceiveY[A,B]])Stream[A]" id="scalaz.stream.ReceiveY.concatLeft">concatLeft</a><span class="delimiter">[</span><a title="" id="scalaz.stream.ReceiveY.concatLeft;A">A</a>,<a title="" id="scalaz.stream.ReceiveY.concatLeft;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[scalaz.stream.ReceiveY[A,B]]" id="scalaz.stream.ReceiveY.concatLeft.s">s</a>: <span title="Seq[scalaz.stream.ReceiveY[A,B]]">Seq</span><span class="delimiter">[</span>ReceiveY<span class="delimiter">[</span>A,B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Stream[A]">Stream</span><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.ReceiveY.concatLeft.s" title="Seq[scalaz.stream.ReceiveY[A,B]]">s</a>.<span title="=&gt; scala.collection.SeqView[scalaz.stream.ReceiveY[A,B],Seq[scalaz.stream.ReceiveY[A,B]]]">view</span>.<span title="(f: scalaz.stream.ReceiveY[A,B] =&gt; scala.collection.GenTraversableOnce[A])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.SeqView[scalaz.stream.ReceiveY[A,B],Seq[scalaz.stream.ReceiveY[A,B]]],A,scala.collection.SeqView[A,Seq[_]]])scala.collection.SeqView[A,Seq[_]]">flatMap</span> <a href="#scalaz.stream.ReceiveY.concatLeft.$anonfun.x0$2" title="List[A]" class="delimiter">{</a> case ReceiveL<span class="delimiter">(</span><a title="A" id="scalaz.stream.ReceiveY.concatLeft.$anonfun.a">a</a><span class="delimiter">)</span> =&gt; <span title="(xs: A*)List[A]">List</span><span class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.concatLeft.$anonfun.a" title="A">a</a><span class="delimiter">)</span>; case _ =&gt; List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>.<span title="=&gt; scala.collection.immutable.Stream[A]">toStream</span>

  def <a title="[A, B](s: Seq[scalaz.stream.ReceiveY[A,B]])Stream[B]" id="scalaz.stream.ReceiveY.concatRight">concatRight</a><span class="delimiter">[</span><a title="" id="scalaz.stream.ReceiveY.concatRight;A">A</a>,<a title="" id="scalaz.stream.ReceiveY.concatRight;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[scalaz.stream.ReceiveY[A,B]]" id="scalaz.stream.ReceiveY.concatRight.s">s</a>: <span title="Seq[scalaz.stream.ReceiveY[A,B]]">Seq</span><span class="delimiter">[</span>ReceiveY<span class="delimiter">[</span>A,B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Stream[B]">Stream</span><span class="delimiter">[</span>B<span class="delimiter">]</span> =
    <a href="#scalaz.stream.ReceiveY.concatRight.s" title="Seq[scalaz.stream.ReceiveY[A,B]]">s</a>.<span title="=&gt; scala.collection.SeqView[scalaz.stream.ReceiveY[A,B],Seq[scalaz.stream.ReceiveY[A,B]]]">view</span>.<span title="(f: scalaz.stream.ReceiveY[A,B] =&gt; scala.collection.GenTraversableOnce[B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.SeqView[scalaz.stream.ReceiveY[A,B],Seq[scalaz.stream.ReceiveY[A,B]]],B,scala.collection.SeqView[B,Seq[_]]])scala.collection.SeqView[B,Seq[_]]">flatMap</span> <a href="#scalaz.stream.ReceiveY.concatRight.$anonfun.x0$3" title="List[B]" class="delimiter">{</a> case ReceiveR<span class="delimiter">(</span><a title="B" id="scalaz.stream.ReceiveY.concatRight.$anonfun.b">b</a><span class="delimiter">)</span> =&gt; <span title="(xs: B*)List[B]">List</span><span class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.concatRight.$anonfun.b" title="B">b</a><span class="delimiter">)</span>; case _ =&gt; List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>.<span title="=&gt; scala.collection.immutable.Stream[B]">toStream</span>

  import scalaz.syntax.<span class="delimiter">{</span>ApplyOps, ApplicativeOps, FunctorOps, MonadOps<span class="delimiter">}</span>

  trait <a title="trait ReceiveT[X] extends AnyRef" id="scalaz.stream.ReceiveY;ReceiveT">ReceiveT</a><span class="delimiter">[</span><a title="" id="scalaz.stream.ReceiveY;ReceiveT;X">X</a><span class="delimiter">]</span> <span class="delimiter">{</span> type <a title="[y]scalaz.stream.ReceiveY[X,y]" id="scalaz.stream.ReceiveY;ReceiveT;f">f</a><span class="delimiter">[</span><a title="" id="scalaz.stream.ReceiveY;ReceiveT;f;y">y</a><span class="delimiter">]</span> = <a href="#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[X,y]">ReceiveY</a><span class="delimiter">[</span>X,y<span class="delimiter">]</span> <span class="delimiter">}</span>

  implicit def <a title="[X, A](f: scalaz.stream.ReceiveY[X,A])(implicit evidence$1: scalaz.Monoid[X])scalaz.syntax.MonadOps[[y]scalaz.stream.ReceiveY[X,y],A]" id="scalaz.stream.ReceiveY.toMonadOps">toMonadOps</a><span class="delimiter">[</span><a title="" id="scalaz.stream.ReceiveY.toMonadOps;X">X</a>:Monoid,<a title="" id="scalaz.stream.ReceiveY.toMonadOps;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.ReceiveY[X,A]" id="scalaz.stream.ReceiveY.toMonadOps.f">f</a>: <a href="#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[X,A]">ReceiveY</a><span class="delimiter">[</span>X,A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scalaz.syntax.MonadOps[[y]scalaz.stream.ReceiveY[X,y],A]">MonadOps</span><span class="delimiter">[</span>ReceiveT<span class="delimiter">[</span>X<span class="delimiter">]</span>#f,A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.ReceiveY.receiveYInstance" title="(implicit X: scalaz.Monoid[X])scalaz.Monad[[y]scalaz.stream.ReceiveY[X,y]]">receiveYInstance</a>.<span title="=&gt; scalaz.syntax.MonadSyntax[[y]scalaz.stream.ReceiveY[X,y]]">monadSyntax</span>.<span title="(v: scalaz.stream.ReceiveY[X,A])scalaz.syntax.MonadOps[[y]scalaz.stream.ReceiveY[X,y],A]">ToMonadOps</span><span class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.toMonadOps.f" title="scalaz.stream.ReceiveY[X,A]">f</a><span class="delimiter">)</span>
  implicit def <a title="[X, A](f: scalaz.stream.ReceiveY[X,A])(implicit evidence$2: scalaz.Monoid[X])scalaz.syntax.ApplicativeOps[[y]scalaz.stream.ReceiveY[X,y],A]" id="scalaz.stream.ReceiveY.toApplicativeOps">toApplicativeOps</a><span class="delimiter">[</span><a title="" id="scalaz.stream.ReceiveY.toApplicativeOps;X">X</a>:Monoid,<a title="" id="scalaz.stream.ReceiveY.toApplicativeOps;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.ReceiveY[X,A]" id="scalaz.stream.ReceiveY.toApplicativeOps.f">f</a>: <a href="#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[X,A]">ReceiveY</a><span class="delimiter">[</span>X,A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scalaz.syntax.ApplicativeOps[[y]scalaz.stream.ReceiveY[X,y],A]">ApplicativeOps</span><span class="delimiter">[</span>ReceiveT<span class="delimiter">[</span>X<span class="delimiter">]</span>#f,A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.ReceiveY.receiveYInstance" title="(implicit X: scalaz.Monoid[X])scalaz.Monad[[y]scalaz.stream.ReceiveY[X,y]]">receiveYInstance</a>.<span title="=&gt; scalaz.syntax.ApplicativeSyntax[[y]scalaz.stream.ReceiveY[X,y]]">applicativeSyntax</span>.<span title="(v: scalaz.stream.ReceiveY[X,A])scalaz.syntax.ApplicativeOps[[y]scalaz.stream.ReceiveY[X,y],A]">ToApplicativeOps</span><span class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.toApplicativeOps.f" title="scalaz.stream.ReceiveY[X,A]">f</a><span class="delimiter">)</span>
  implicit def <a title="[X, A](f: scalaz.stream.ReceiveY[X,A])(implicit evidence$3: scalaz.Monoid[X])scalaz.syntax.ApplyOps[[y]scalaz.stream.ReceiveY[X,y],A]" id="scalaz.stream.ReceiveY.toApplyOps">toApplyOps</a><span class="delimiter">[</span><a title="" id="scalaz.stream.ReceiveY.toApplyOps;X">X</a>:Monoid,<a title="" id="scalaz.stream.ReceiveY.toApplyOps;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.ReceiveY[X,A]" id="scalaz.stream.ReceiveY.toApplyOps.f">f</a>: <a href="#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[X,A]">ReceiveY</a><span class="delimiter">[</span>X,A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scalaz.syntax.ApplyOps[[y]scalaz.stream.ReceiveY[X,y],A]">ApplyOps</span><span class="delimiter">[</span>ReceiveT<span class="delimiter">[</span>X<span class="delimiter">]</span>#f,A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.ReceiveY.receiveYInstance" title="(implicit X: scalaz.Monoid[X])scalaz.Monad[[y]scalaz.stream.ReceiveY[X,y]]">receiveYInstance</a>.<span title="=&gt; scalaz.syntax.ApplySyntax[[y]scalaz.stream.ReceiveY[X,y]]">applySyntax</span>.<span title="(v: scalaz.stream.ReceiveY[X,A])scalaz.syntax.ApplyOps[[y]scalaz.stream.ReceiveY[X,y],A]">ToApplyOps</span><span class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.toApplyOps.f" title="scalaz.stream.ReceiveY[X,A]">f</a><span class="delimiter">)</span>
  implicit def <a title="[X, A](f: scalaz.stream.ReceiveY[X,A])(implicit evidence$4: scalaz.Monoid[X])scalaz.syntax.FunctorOps[[y]scalaz.stream.ReceiveY[X,y],A]" id="scalaz.stream.ReceiveY.toFunctorOps">toFunctorOps</a><span class="delimiter">[</span><a title="" id="scalaz.stream.ReceiveY.toFunctorOps;X">X</a>:Monoid,<a title="" id="scalaz.stream.ReceiveY.toFunctorOps;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.ReceiveY[X,A]" id="scalaz.stream.ReceiveY.toFunctorOps.f">f</a>: <a href="#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[X,A]">ReceiveY</a><span class="delimiter">[</span>X,A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scalaz.syntax.FunctorOps[[y]scalaz.stream.ReceiveY[X,y],A]">FunctorOps</span><span class="delimiter">[</span>ReceiveT<span class="delimiter">[</span>X<span class="delimiter">]</span>#f,A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.ReceiveY.receiveYInstance" title="(implicit X: scalaz.Monoid[X])scalaz.Monad[[y]scalaz.stream.ReceiveY[X,y]]">receiveYInstance</a>.<span title="=&gt; scalaz.syntax.FunctorSyntax[[y]scalaz.stream.ReceiveY[X,y]]">functorSyntax</span>.<span title="(v: scalaz.stream.ReceiveY[X,A])scalaz.syntax.FunctorOps[[y]scalaz.stream.ReceiveY[X,y],A]">ToFunctorOps</span><span class="delimiter">(</span><a href="#scalaz.stream.ReceiveY.toFunctorOps.f" title="scalaz.stream.ReceiveY[X,A]">f</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
