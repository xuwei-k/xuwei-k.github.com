<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scalaz-stream/scalaz/stream/tee.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scalaz.stream

import <a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>._
import scala.annotation.tailrec
import scalaz.<span class="delimiter">{</span>\/-, \/<span class="delimiter">}</span>
import scalaz.<span title="scalaz.\/.type">\/</span>._
import scalaz.stream.<a href="Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>._
import scalaz.stream.<a href="Util.scala.html#scalaz.stream.Util" title="scalaz.stream.Util.type">Util</a>._

object <a title="scalaz.stream.tee.type" id="scalaz.stream.tee">tee</a> <a href="#scalaz.stream.tee" title="scalaz.stream.tee.type" class="delimiter">{</a>

  <span class="comment">/**
   * Alternate pulling from the left, then right,
   * repeatedly, starting on the left, and emitting only values
   * from the right. When the left is exhausted, behaves like `passR`.
   */</span>
  def <a title="[I]=&gt; scalaz.stream.Tee[Any,I,I]" id="scalaz.stream.tee.drainL">drainL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.drainL;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[Any,I,I]">Tee</a><span class="delimiter">[</span>Any, I, I<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.awaitL" title="[I]=&gt; scalaz.stream.Tee[I,Any,I]">awaitL</a><span title="scalaz.stream.Tee[Any,Any,Any]" class="delimiter">[</span><span title="Any">Any</span><span class="delimiter">]</span>.<a href="process1.scala.html#scalaz.stream;Process1Ops.awaitOption" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Any,Any]#T,Option[Any]]">awaitOption</a>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: Option[Any] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Any,I]#T,I])scalaz.stream.Process[scalaz.stream.Process.Env[Any,I]#T,I]">flatMap</a> <a href="#scalaz.stream.tee.drainL.$anonfun.x0$1" title="scalaz.stream.Process[scalaz.stream.Process.Env[Any,I]#T,I]" class="delimiter">{</a>
      case <span title="None.type">None</span> =&gt; <a href="#scalaz.stream.tee.passR" title="scalaz.stream.Tee[Any,I,I]">passR</a>
      case Some<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.awaitR" title="[I2]=&gt; scalaz.stream.Tee[Any,I2,I2]">awaitR</a><span title="scalaz.stream.Tee[Any,I,I]" class="delimiter">[</span><a href="#scalaz.stream.tee.drainL;I" title="I">I</a><span class="delimiter">]</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[Any,I]#T[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[Any,I]#T[x],I]">++</a> <a href="#scalaz.stream.tee.drainL" title="scalaz.stream.Tee[Any,I,I]">drainL</a>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Alternate pulling from the left, then right,
   * repeatedly, starting on the left, and emitting only values
   * from the left. When the right is exhausted, behaves like `passL`.
   */</span>
  def <a title="[I]=&gt; scalaz.stream.Tee[I,Any,I]" id="scalaz.stream.tee.drainR">drainR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.drainR;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,Any,I]">Tee</a><span class="delimiter">[</span>I, Any, I<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.awaitL" title="[I]=&gt; scalaz.stream.Tee[I,Any,I]">awaitL</a><span title="scalaz.stream.Tee[I,Any,I]" class="delimiter">[</span><a href="#scalaz.stream.tee.drainR;I" title="I">I</a><span class="delimiter">]</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#T[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Any]#T[x],I]">++</a> <a href="Process.scala.html#scalaz.stream.Process.awaitR" title="[I2]=&gt; scalaz.stream.Tee[Any,I2,I2]">awaitR</a><span title="scalaz.stream.Tee[Any,Any,Any]" class="delimiter">[</span><span title="Any">Any</span><span class="delimiter">]</span>.<a href="process1.scala.html#scalaz.stream;Process1Ops.awaitOption" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Any,Any]#T,Option[Any]]">awaitOption</a>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: Option[Any] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#T,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#T,I]">flatMap</a> <a href="#scalaz.stream.tee.drainR.$anonfun.x0$2" title="scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#T,I]" class="delimiter">{</a>
      case <span title="None.type">None</span> =&gt; <a href="#scalaz.stream.tee.passL" title="scalaz.stream.Tee[I,Any,I]">passL</a>
      case Some<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.tee.drainR" title="scalaz.stream.Tee[I,Any,I]">drainR</a>
    <span class="delimiter">}</span>

  <span class="comment">/** A `Tee` which alternates between emitting values from the left input and the right input. */</span>
  def <a title="[I]=&gt; scalaz.stream.Tee[I,I,I]" id="scalaz.stream.tee.interleave">interleave</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.interleave;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I,I]">Tee</a><span class="delimiter">[</span>I, I, I<span class="delimiter">]</span> =
  <a href="Process.scala.html#scalaz.stream.Process.repeat" title="(p: scalaz.stream.Process[scalaz.stream.Process.Env[I,I]#T,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I]#T,I]">repeat</a> <span class="delimiter">{</span> for <span class="delimiter">{</span>
      <a title="I" id="scalaz.stream.tee.interleave.$anonfun.i1">i1</a> &lt;- <a href="Process.scala.html#scalaz.stream.Process.awaitL" title="[I]=&gt; scalaz.stream.Tee[I,Any,I]">awaitL</a><a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: I =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I]#T[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I]#T[x],I]" class="delimiter">[</a><a href="#scalaz.stream.tee.interleave;I" title="I">I</a><span class="delimiter">]</span>
      <a title="I" id="scalaz.stream.tee.interleave.$anonfun.$anonfun.i2">i2</a> &lt;- <a href="Process.scala.html#scalaz.stream.Process.awaitR" title="[I2]=&gt; scalaz.stream.Tee[Any,I2,I2]">awaitR</a><a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: I =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[Any,I]#T[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[Any,I]#T[x],I]" class="delimiter">[</a><a href="#scalaz.stream.tee.interleave;I" title="I">I</a><span class="delimiter">]</span>
      <a title="I" id="scalaz.stream.tee.interleave.$anonfun.$anonfun.$anonfun.r">r</a> &lt;- <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.interleave.$anonfun.i1" title="I">i1</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.map" title="(f: I =&gt; I)scalaz.stream.Process[Nothing,I]">++</a> <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.interleave.$anonfun.$anonfun.i2" title="I">i2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> yield <a href="#scalaz.stream.tee.interleave.$anonfun.$anonfun.$anonfun.r" title="I">r</a> <span class="delimiter">}</span>

  <span class="comment">/** A `Tee` which ignores all input from left. */</span>
  def <a title="[I2]=&gt; scalaz.stream.Tee[Any,I2,I2]" id="scalaz.stream.tee.passR">passR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.passR;I2">I2</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[Any,I2,I2]">Tee</a><span class="delimiter">[</span>Any, I2, I2<span class="delimiter">]</span> = <a href="Process.scala.html#scalaz.stream.Process.awaitR" title="[I2]=&gt; scalaz.stream.Tee[Any,I2,I2]">awaitR</a><span title="scalaz.stream.Tee[Any,I2,I2]" class="delimiter">[</span><a href="#scalaz.stream.tee.passR;I2" title="I2">I2</a><span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream;Process.repeat" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Any,I2]#T,I2]">repeat</a>

  <span class="comment">/** A `Tee` which ignores all input from the right. */</span>
  def <a title="[I]=&gt; scalaz.stream.Tee[I,Any,I]" id="scalaz.stream.tee.passL">passL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.passL;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,Any,I]">Tee</a><span class="delimiter">[</span>I, Any, I<span class="delimiter">]</span> = <a href="Process.scala.html#scalaz.stream.Process.awaitL" title="[I]=&gt; scalaz.stream.Tee[I,Any,I]">awaitL</a><span title="scalaz.stream.Tee[I,Any,I]" class="delimiter">[</span><a href="#scalaz.stream.tee.passL;I" title="I">I</a><span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream;Process.repeat" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#T,I]">repeat</a>

  <span class="comment">/** Echoes the right branch until the left branch becomes `true`, then halts. */</span>
  def <a title="[I]=&gt; scalaz.stream.Tee[Boolean,I,I]" id="scalaz.stream.tee.until">until</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.until;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[Boolean,I,I]">Tee</a><span class="delimiter">[</span>Boolean, I, I<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.awaitL" title="[I]=&gt; scalaz.stream.Tee[I,Any,I]">awaitL</a><span title="scalaz.stream.Tee[Boolean,Any,Boolean]" class="delimiter">[</span><span title="Boolean">Boolean</span><span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: Boolean =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Boolean,I]#T,I])scalaz.stream.Process[scalaz.stream.Process.Env[Boolean,I]#T,I]">flatMap</a><span class="delimiter">(</span><a title="Boolean" id="scalaz.stream.tee.until.$anonfun.kill">kill</a> =&gt; if <span class="delimiter">(</span><a href="#scalaz.stream.tee.until.$anonfun.kill" title="Boolean">kill</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a> else <a href="Process.scala.html#scalaz.stream.Process.awaitR" title="[I2]=&gt; scalaz.stream.Tee[Any,I2,I2]">awaitR</a><span title="scalaz.stream.Tee[Any,I,I]" class="delimiter">[</span><a href="#scalaz.stream.tee.until;I" title="I">I</a><span class="delimiter">]</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Boolean,I]#T,I])scalaz.stream.Process[scalaz.stream.Process.Env[Boolean,I]#T,I]">++</a> <a href="#scalaz.stream.tee.until" title="scalaz.stream.Tee[Boolean,I,I]">until</a><span class="delimiter">)</span>

  <span class="comment">/** Echoes the right branch when the left branch is `true`. */</span>
  def <a title="[I]=&gt; scalaz.stream.Tee[Boolean,I,I]" id="scalaz.stream.tee.when">when</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.when;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[Boolean,I,I]">Tee</a><span class="delimiter">[</span>Boolean, I, I<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.awaitL" title="[I]=&gt; scalaz.stream.Tee[I,Any,I]">awaitL</a><span title="scalaz.stream.Tee[Boolean,Any,Boolean]" class="delimiter">[</span><span title="Boolean">Boolean</span><span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: Boolean =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Boolean,I]#T,I])scalaz.stream.Process[scalaz.stream.Process.Env[Boolean,I]#T,I]">flatMap</a><span class="delimiter">(</span><a title="Boolean" id="scalaz.stream.tee.when.$anonfun.ok">ok</a> =&gt; if <span class="delimiter">(</span><a href="#scalaz.stream.tee.when.$anonfun.ok" title="Boolean">ok</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process.awaitR" title="[I2]=&gt; scalaz.stream.Tee[Any,I2,I2]">awaitR</a><span title="scalaz.stream.Tee[Any,I,I]" class="delimiter">[</span><a href="#scalaz.stream.tee.when;I" title="I">I</a><span class="delimiter">]</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Boolean,I]#T,I])scalaz.stream.Process[scalaz.stream.Process.Env[Boolean,I]#T,I]">++</a> <a href="#scalaz.stream.tee.when" title="scalaz.stream.Tee[Boolean,I,I]">when</a> else <a href="#scalaz.stream.tee.when" title="scalaz.stream.Tee[Boolean,I,I]">when</a><span class="delimiter">)</span>

  <span class="comment">/** Defined as `zipWith((_,_))` */</span>
  def <a title="[I, I2]=&gt; scalaz.stream.Tee[I,I2,(I, I2)]" id="scalaz.stream.tee.zip">zip</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.zip;I">I</a>, <a title="" id="scalaz.stream.tee.zip;I2">I2</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,(I, I2)]">Tee</a><span class="delimiter">[</span>I, I2, <span class="delimiter">(</span>I, I2<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#scalaz.stream.tee.zipWith" title="(f: (I, I2) =&gt; (I, I2))scalaz.stream.Tee[I,I2,(I, I2)]">zipWith</a><span class="delimiter">(</span><span title="(_1: I, _2: I2)(I, I2)" class="delimiter">(</span><a href="#scalaz.stream.tee.zip.$anonfun.x$1" title="I">_</a>, <a href="#scalaz.stream.tee.zip.$anonfun.x$2" title="I2">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Defined as `zipWith((arg,f) =&gt; f(arg)` */</span>
  def <a title="[I, I2]=&gt; scalaz.stream.Tee[I,I =&gt; I2,I2]" id="scalaz.stream.tee.zipApply">zipApply</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.zipApply;I">I</a>,<a title="" id="scalaz.stream.tee.zipApply;I2">I2</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I =&gt; I2,I2]">Tee</a><span class="delimiter">[</span>I, I =&gt; I2, I2<span class="delimiter">]</span> = <a href="#scalaz.stream.tee.zipWith" title="(f: (I, I =&gt; I2) =&gt; I2)scalaz.stream.Tee[I,I =&gt; I2,I2]">zipWith</a><span class="delimiter">(</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.tee.zipApply.$anonfun.arg">arg</a>,<a title="I =&gt; I2" id="scalaz.stream.tee.zipApply.$anonfun.f">f</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.tee.zipApply.$anonfun.f" title="(v1: I)I2">f</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.zipApply.$anonfun.arg" title="I">arg</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A version of `zip` that pads the shorter stream with values. */</span>
  def <a title="[I, I2](padI: I, padI2: I2)scalaz.stream.Tee[I,I2,(I, I2)]" id="scalaz.stream.tee.zipAll">zipAll</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.zipAll;I">I</a>, <a title="" id="scalaz.stream.tee.zipAll;I2">I2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.tee.zipAll.padI">padI</a>: <a href="#scalaz.stream.tee.zipAll;I" title="I">I</a>, <a title="I2" id="scalaz.stream.tee.zipAll.padI2">padI2</a>: <a href="#scalaz.stream.tee.zipAll;I2" title="I2">I2</a><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,(I, I2)]">Tee</a><span class="delimiter">[</span>I, I2, <span class="delimiter">(</span>I, I2<span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="#scalaz.stream.tee.zipWithAll" title="(padI: I, padI2: I2)(f: (I, I2) =&gt; (I, I2))scalaz.stream.Tee[I,I2,(I, I2)]">zipWithAll</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.zipAll.padI" title="I">padI</a>, <a href="#scalaz.stream.tee.zipAll.padI2" title="I2">padI2</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(_1: I, _2: I2)(I, I2)" class="delimiter">(</span><a href="#scalaz.stream.tee.zipAll.$anonfun.x$3" title="I">_</a>, <a href="#scalaz.stream.tee.zipAll.$anonfun.x$4" title="I2">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Zip together two inputs, then apply the given function,
   * halting as soon as either input is exhausted.
   * This implementation reads from the left, then the right.
   */</span>
  def <a title="[I, I2, O](f: (I, I2) =&gt; O)scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.zipWith">zipWith</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.zipWith;I">I</a>, <a title="" id="scalaz.stream.tee.zipWith;I2">I2</a>, <a title="" id="scalaz.stream.tee.zipWith;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(I, I2) =&gt; O" id="scalaz.stream.tee.zipWith.f">f</a>: <span class="delimiter">(</span>I, I2<span class="delimiter">)</span> =&gt; O<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    for <span class="delimiter">{</span>
      <a title="I" id="scalaz.stream.tee.zipWith.$anonfun.i">i</a> &lt;- <a href="Process.scala.html#scalaz.stream.Process.awaitL" title="[I]=&gt; scalaz.stream.Tee[I,Any,I]">awaitL</a><a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: I =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O]" class="delimiter">[</a><a href="#scalaz.stream.tee.zipWith;I" title="I">I</a><span class="delimiter">]</span>
      <a title="I2" id="scalaz.stream.tee.zipWith.$anonfun.$anonfun.i2">i2</a> &lt;- <a href="Process.scala.html#scalaz.stream.Process.awaitR" title="[I2]=&gt; scalaz.stream.Tee[Any,I2,I2]">awaitR</a><a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: I2 =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[Any,I2]#T[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[Any,I2]#T[x],O]" class="delimiter">[</a><a href="#scalaz.stream.tee.zipWith;I2" title="I2">I2</a><span class="delimiter">]</span>
      <a title="O" id="scalaz.stream.tee.zipWith.$anonfun.$anonfun.$anonfun.r">r</a> &lt;- <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: O)scalaz.stream.Process0[O]">emit</a><a href="Process.scala.html#scalaz.stream;Process.map" title="(f: O =&gt; O)scalaz.stream.Process[Nothing,O]" class="delimiter">(</a><a href="#scalaz.stream.tee.zipWith.f" title="(v1: I, v2: I2)O">f</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.zipWith.$anonfun.i" title="I">i</a>, <a href="#scalaz.stream.tee.zipWith.$anonfun.$anonfun.i2" title="I2">i2</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> yield <a href="#scalaz.stream.tee.zipWith.$anonfun.$anonfun.$anonfun.r" title="O">r</a>
  <span class="delimiter">}</span> <a href="Process.scala.html#scalaz.stream;Process.repeat" title="=&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O]">repeat</a>


  <span class="comment">/** A version of `zipWith` that pads the shorter stream with values. */</span>
  def <a title="[I, I2, O](padI: I, padI2: I2)(f: (I, I2) =&gt; O)scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.zipWithAll">zipWithAll</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.zipWithAll;I">I</a>, <a title="" id="scalaz.stream.tee.zipWithAll;I2">I2</a>, <a title="" id="scalaz.stream.tee.zipWithAll;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.tee.zipWithAll.padI">padI</a>: <a href="#scalaz.stream.tee.zipWithAll;I" title="I">I</a>, <a title="I2" id="scalaz.stream.tee.zipWithAll.padI2">padI2</a>: <a href="#scalaz.stream.tee.zipWithAll;I2" title="I2">I2</a><span class="delimiter">)</span><span class="delimiter">(</span>
    <a title="(I, I2) =&gt; O" id="scalaz.stream.tee.zipWithAll.f">f</a>: <span class="delimiter">(</span>I, I2<span class="delimiter">)</span> =&gt; O<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="=&gt; scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.zipWithAll.fbR">fbR</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> = <a href="#scalaz.stream.tee.receiveR" title="(rcv: I2 =&gt; scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">receiveR</a> <span class="delimiter">{</span> <a title="I2" id="scalaz.stream.tee.zipWithAll.fbR.$anonfun.i2">i2</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: O)scalaz.stream.Process0[O]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.zipWithAll.f" title="(v1: I, v2: I2)O">f</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.zipWithAll.padI" title="I">padI</a>, <a href="#scalaz.stream.tee.zipWithAll.fbR.$anonfun.i2" title="I2">i2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">++</a> <a href="#scalaz.stream.tee.zipWithAll.fbR" title="=&gt; scalaz.stream.Tee[I,I2,O]">fbR</a> <span class="delimiter">}</span>
    def <a title="=&gt; scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.zipWithAll.fbL">fbL</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> = <a href="#scalaz.stream.tee.receiveL" title="(rcv: I =&gt; scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">receiveL</a> <span class="delimiter">{</span> <a title="I" id="scalaz.stream.tee.zipWithAll.fbL.$anonfun.i">i</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: O)scalaz.stream.Process0[O]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.zipWithAll.f" title="(v1: I, v2: I2)O">f</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.zipWithAll.fbL.$anonfun.i" title="I">i</a>, <a href="#scalaz.stream.tee.zipWithAll.padI2" title="I2">padI2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">++</a> <a href="#scalaz.stream.tee.zipWithAll.fbL" title="=&gt; scalaz.stream.Tee[I,I2,O]">fbL</a> <span class="delimiter">}</span>

    def <a title="=&gt; scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.zipWithAll.go">go</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#scalaz.stream.tee.receiveLOr" title="[I, I2, O](fb: =&gt; scalaz.stream.Tee[I,I2,O])(rcvL: I =&gt; scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">receiveLOr</a><span title="(fb: =&gt; scalaz.stream.Tee[I,I2,O])(rcvL: I =&gt; scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]" class="delimiter">[</span><a href="#scalaz.stream.tee.zipWithAll;I" title="I">I</a>, <a href="#scalaz.stream.tee.zipWithAll;I2" title="I2">I2</a>, <a href="#scalaz.stream.tee.zipWithAll;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.zipWithAll.fbR" title="=&gt; scalaz.stream.Tee[I,I2,O]">fbR</a><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="I" id="scalaz.stream.tee.zipWithAll.go.$anonfun.i">i</a> =&gt;
        <a href="#scalaz.stream.tee.receiveROr" title="[I, I2, O](fb: =&gt; scalaz.stream.Tee[I,I2,O])(rcvR: I2 =&gt; scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">receiveROr</a><span title="(fb: =&gt; scalaz.stream.Tee[I,I2,O])(rcvR: I2 =&gt; scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]" class="delimiter">[</span><a href="#scalaz.stream.tee.zipWithAll;I" title="I">I</a>, <a href="#scalaz.stream.tee.zipWithAll;I2" title="I2">I2</a>, <a href="#scalaz.stream.tee.zipWithAll;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: O)scalaz.stream.Process0[O]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.zipWithAll.f" title="(v1: I, v2: I2)O">f</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.zipWithAll.go.$anonfun.i" title="I">i</a>, <a href="#scalaz.stream.tee.zipWithAll.padI2" title="I2">padI2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">++</a> <a href="#scalaz.stream.tee.zipWithAll.fbL" title="=&gt; scalaz.stream.Tee[I,I2,O]">fbL</a><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="I2" id="scalaz.stream.tee.zipWithAll.go.$anonfun.$anonfun.i2">i2</a> =&gt;
          <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: O)scalaz.stream.Process0[O]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.zipWithAll.f" title="(v1: I, v2: I2)O">f</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.zipWithAll.go.$anonfun.i" title="I">i</a>, <a href="#scalaz.stream.tee.zipWithAll.go.$anonfun.$anonfun.i2" title="I2">i2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">++</a> <a href="#scalaz.stream.tee.zipWithAll.go" title="=&gt; scalaz.stream.Tee[I,I2,O]">go</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#scalaz.stream.tee.zipWithAll.go" title="=&gt; scalaz.stream.Tee[I,I2,O]">go</a>
  <span class="delimiter">}</span>


  <span class="comment">/** Feed a sequence of inputs to the left side of a `Tee`. */</span>
  def <a title="[I, I2, O](i: Seq[I])(p: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.feedL">feedL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.feedL;I">I</a>, <a title="" id="scalaz.stream.tee.feedL;I2">I2</a>, <a title="" id="scalaz.stream.tee.feedL;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[I]" id="scalaz.stream.tee.feedL.i">i</a>: <span title="Seq[I]">Seq</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.feedL.p">p</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(in: Seq[I], out: Vector[Seq[O]], cur: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.feedL.go">go</a><span class="delimiter">(</span><a title="Seq[I]" id="scalaz.stream.tee.feedL.go.in">in</a>: <span title="Seq[I]">Seq</span><span class="delimiter">[</span>I<span class="delimiter">]</span>, <a title="Vector[Seq[O]]" id="scalaz.stream.tee.feedL.go.out">out</a>: <span title="Vector[Seq[O]]">Vector</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.feedL.go.cur">cur</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scalaz.stream.tee.feedL.go.in" title="Seq[I]">in</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span>  <a href="#scalaz.stream.tee.feedL.go.cur" title="scalaz.stream.Tee[I,I2,O]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#T,O]">step</a> match <span class="delimiter">{</span>
        case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.tee.feedL.go.os">os</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.tee.feedL.go" title="(in: Seq[I], out: Vector[Seq[O]], cur: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedL.go.in" title="Seq[I]">in</a>, <a href="#scalaz.stream.tee.feedL.go.out" title="Vector[Seq[O]]">out</a> <span title="(elem: Seq[O])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[Seq[O]],Seq[O],Vector[Seq[O]]])Vector[Seq[O]]">:+</span> <a href="#scalaz.stream.tee.feedL.go.os" title="Seq[O]">os</a>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span>.<a href="Process.scala.html#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">continue</a><span class="delimiter">)</span>

        case Step<span class="delimiter">(</span><span title="scalaz.stream.tee.TeeAwaitL[I,I2,O]">awt</span>@<a href="#scalaz.stream.tee.AwaitL.unapply" title="(self: scalaz.stream.tee.TeeAwaitL[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Tee[I,I2,O]]">AwaitL</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O] forSome { type I &gt;: I; type I &gt;: I }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.tee.feedL.go" title="(in: Seq[I], out: Vector[Seq[O]], cur: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedL.go.in" title="Seq[I]">in</a>.<span title="=&gt; Seq[I]">tail</span>, <a href="#scalaz.stream.tee.feedL.go.out" title="Vector[Seq[O]]">out</a>, <span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">rcv</span><span class="delimiter">(</span><span title="(v1: I)scalaz.\/[Nothing,I]">right</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedL.go.in" title="Seq[I]">in</a>.<span title="=&gt; I">head</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span>

        case Step<span class="delimiter">(</span><span title="scalaz.stream.tee.TeeAwaitR[I,I2,O]">awt</span>@<a href="#scalaz.stream.tee.AwaitR.unapply" title="(self: scalaz.stream.tee.TeeAwaitR[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Tee[I,I2,O]]">AwaitR</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O] forSome { type I2 &gt;: I2; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[O])scalaz.stream.Process0[O]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedL.go.out" title="Vector[Seq[O]]">out</a>.<span title="(implicit asTraversable: Seq[O] =&gt; scala.collection.GenTraversableOnce[O])scala.collection.immutable.Vector[O]">flatten</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">onHalt</a> <a href="#scalaz.stream.tee.feedL.go.$anonfun.x0$3" title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]" class="delimiter">{</a>
            case <a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a> =&gt;   <span title="scalaz.stream.tee.TeeAwaitR[I,I2,O]">awt</span>.<a href="Process.scala.html#scalaz.stream.Process;Await.extend" title="(f: scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,I2]#T,scalaz.stream.Process.Env[Any,I2]#T[I2],O]">extend</a><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]" id="scalaz.stream.tee.feedL.go.$anonfun.$anonfun.p">p</a> =&gt; <a href="#scalaz.stream.tee.feedL" title="(i: Seq[I])(p: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">feedL</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedL.go.in" title="Seq[I]">in</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedL.go.$anonfun.$anonfun.p" title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">p</a> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>
            case <a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.tee.feedL.go.$anonfun.early">early</a> : <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a> =&gt; <a href="#scalaz.stream.tee.feedL" title="(i: Seq[I])(p: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">feedL</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedL.go.in" title="Seq[I]">in</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedL.go.$anonfun.early" title="scalaz.stream.Cause.EarlyCause">early</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>

        case Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.tee.feedL.go.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[O])scalaz.stream.Process0[O]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedL.go.out" title="Vector[Seq[O]]">out</a>.<span title="(implicit asTraversable: Seq[O] =&gt; scala.collection.GenTraversableOnce[O])scala.collection.immutable.Vector[O]">flatten</span><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Process[Nothing,O]">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedL.go.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>

      <span class="delimiter">}</span> else <a href="#scalaz.stream.tee.feedL.go.cur" title="scalaz.stream.Tee[I,I2,O]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.prepend" title="(os: Seq[O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">prepend</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedL.go.out" title="Vector[Seq[O]]">out</a>.<span title="(implicit asTraversable: Seq[O] =&gt; scala.collection.GenTraversableOnce[O])scala.collection.immutable.Vector[O]">flatten</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#scalaz.stream.tee.feedL.go" title="(in: Seq[I], out: Vector[Seq[O]], cur: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedL.i" title="Seq[I]">i</a>, <span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#scalaz.stream.tee.feedL.p" title="scalaz.stream.Tee[I,I2,O]">p</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Feed a sequence of inputs to the right side of a `Tee`. */</span>
  def <a title="[I, I2, O](i: Seq[I2])(p: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.feedR">feedR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.feedR;I">I</a>, <a title="" id="scalaz.stream.tee.feedR;I2">I2</a>, <a title="" id="scalaz.stream.tee.feedR;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[I2]" id="scalaz.stream.tee.feedR.i">i</a>: <span title="Seq[I2]">Seq</span><span class="delimiter">[</span>I2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.feedR.p">p</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(in: Seq[I2], out: Vector[Seq[O]], cur: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.feedR.go">go</a><span class="delimiter">(</span><a title="Seq[I2]" id="scalaz.stream.tee.feedR.go.in">in</a>: <span title="Seq[I2]">Seq</span><span class="delimiter">[</span>I2<span class="delimiter">]</span>, <a title="Vector[Seq[O]]" id="scalaz.stream.tee.feedR.go.out">out</a>: <span title="Vector[Seq[O]]">Vector</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.feedR.go.cur">cur</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scalaz.stream.tee.feedR.go.in" title="Seq[I2]">in</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#scalaz.stream.tee.feedR.go.cur" title="scalaz.stream.Tee[I,I2,O]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#T,O]">step</a> match <span class="delimiter">{</span>
        case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.tee.feedR.go.os">os</a><span class="delimiter">)</span>,<span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.tee.feedR.go" title="(in: Seq[I2], out: Vector[Seq[O]], cur: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedR.go.in" title="Seq[I2]">in</a>, <a href="#scalaz.stream.tee.feedR.go.out" title="Vector[Seq[O]]">out</a> <span title="(elem: Seq[O])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[Seq[O]],Seq[O],Vector[Seq[O]]])Vector[Seq[O]]">:+</span> <a href="#scalaz.stream.tee.feedR.go.os" title="Seq[O]">os</a>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span>.<a href="Process.scala.html#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">continue</a><span class="delimiter">)</span>

        case Step<span class="delimiter">(</span><span title="scalaz.stream.tee.TeeAwaitL[I,I2,O]">awt</span>@<a href="#scalaz.stream.tee.AwaitL.unapply" title="(self: scalaz.stream.tee.TeeAwaitL[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Tee[I,I2,O]]">AwaitL</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O] forSome { type I &gt;: I; type I &gt;: I }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[O])scalaz.stream.Process0[O]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedR.go.out" title="Vector[Seq[O]]">out</a>.<span title="(implicit asTraversable: Seq[O] =&gt; scala.collection.GenTraversableOnce[O])scala.collection.immutable.Vector[O]">flatten</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">onHalt</a> <a href="#scalaz.stream.tee.feedR.go.$anonfun.x0$4" title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]" class="delimiter">{</a>
            case <a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a> =&gt;  <span title="scalaz.stream.tee.TeeAwaitL[I,I2,O]">awt</span>.<a href="Process.scala.html#scalaz.stream.Process;Await.extend" title="(f: scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,I2]#T,scalaz.stream.Process.Env[I,Any]#Is[I],O]">extend</a><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]" id="scalaz.stream.tee.feedR.go.$anonfun.$anonfun.p">p</a> =&gt; <a href="#scalaz.stream.tee.feedR" title="(i: Seq[I2])(p: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">feedR</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedR.go.in" title="Seq[I2]">in</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedR.go.$anonfun.$anonfun.p" title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">p</a> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>
            case <a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.tee.feedR.go.$anonfun.early">early</a> : <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a> =&gt; <a href="#scalaz.stream.tee.feedR" title="(i: Seq[I2])(p: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">feedR</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedR.go.in" title="Seq[I2]">in</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedR.go.$anonfun.early" title="scalaz.stream.Cause.EarlyCause">early</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>

        case Step<span class="delimiter">(</span><span title="scalaz.stream.tee.TeeAwaitR[I,I2,O]">awt</span>@<a href="#scalaz.stream.tee.AwaitR.unapply" title="(self: scalaz.stream.tee.TeeAwaitR[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Tee[I,I2,O]]">AwaitR</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O] forSome { type I2 &gt;: I2; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.tee.feedR.go" title="(in: Seq[I2], out: Vector[Seq[O]], cur: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedR.go.in" title="Seq[I2]">in</a>.<span title="=&gt; Seq[I2]">tail</span>, <a href="#scalaz.stream.tee.feedR.go.out" title="Vector[Seq[O]]">out</a>, <span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">rcv</span><span class="delimiter">(</span><span title="(v1: I2)scalaz.\/[Nothing,I2]">right</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedR.go.in" title="Seq[I2]">in</a>.<span title="=&gt; I2">head</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span>

        case Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.tee.feedR.go.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[O])scalaz.stream.Process0[O]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedR.go.out" title="Vector[Seq[O]]">out</a>.<span title="(implicit asTraversable: Seq[O] =&gt; scala.collection.GenTraversableOnce[O])scala.collection.immutable.Vector[O]">flatten</span><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Process[Nothing,O]">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedR.go.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>

      <span class="delimiter">}</span> else <a href="#scalaz.stream.tee.feedR.go.cur" title="scalaz.stream.Tee[I,I2,O]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.prepend" title="(os: Seq[O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">prepend</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedR.go.out" title="Vector[Seq[O]]">out</a>.<span title="(implicit asTraversable: Seq[O] =&gt; scala.collection.GenTraversableOnce[O])scala.collection.immutable.Vector[O]">flatten</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#scalaz.stream.tee.feedR.go" title="(in: Seq[I2], out: Vector[Seq[O]], cur: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.feedR.i" title="Seq[I2]">i</a>, <span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#scalaz.stream.tee.feedR.p" title="scalaz.stream.Tee[I,I2,O]">p</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Feed one input to the left branch of this `Tee`. */</span>
  def <a title="[I, I2, O](i: I)(t: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.feed1L">feed1L</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.feed1L;I">I</a>, <a title="" id="scalaz.stream.tee.feed1L;I2">I2</a>, <a title="" id="scalaz.stream.tee.feed1L;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.tee.feed1L.i">i</a>: <a href="#scalaz.stream.tee.feed1L;I" title="I">I</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.feed1L.t">t</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.tee.feedL" title="(i: Seq[I])(p: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">feedL</a><span class="delimiter">(</span><span title="(elems: I*)scala.collection.immutable.Vector[I]">Vector</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.feed1L.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.feed1L.t" title="scalaz.stream.Tee[I,I2,O]">t</a><span class="delimiter">)</span>

  <span class="comment">/** Feed one input to the right branch of this `Tee`. */</span>
  def <a title="[I, I2, O](i2: I2)(t: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.feed1R">feed1R</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.feed1R;I">I</a>, <a title="" id="scalaz.stream.tee.feed1R;I2">I2</a>, <a title="" id="scalaz.stream.tee.feed1R;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I2" id="scalaz.stream.tee.feed1R.i2">i2</a>: <a href="#scalaz.stream.tee.feed1R;I2" title="I2">I2</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.feed1R.t">t</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.tee.feedR" title="(i: Seq[I2])(p: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">feedR</a><span class="delimiter">(</span><span title="(elems: I2*)scala.collection.immutable.Vector[I2]">Vector</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.feed1R.i2" title="I2">i2</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.feed1R.t" title="scalaz.stream.Tee[I,I2,O]">t</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Signals, that _left_ side of tee terminated.
   * That causes all succeeding AwaitL to terminate with `cause` giving chance
   * to emit any values or read on right.
   */</span>
  def <a title="[I, I2, O](cause: scalaz.stream.Cause.EarlyCause)(tee: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[Nothing,I2,O]" id="scalaz.stream.tee.disconnectL">disconnectL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.disconnectL;I">I</a>, <a title="" id="scalaz.stream.tee.disconnectL;I2">I2</a>, <a title="" id="scalaz.stream.tee.disconnectL;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.tee.disconnectL.cause">cause</a>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.disconnectL.tee">tee</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[Nothing,I2,O]">Tee</a><span class="delimiter">[</span>Nothing, I2, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#scalaz.stream.tee.disconnectL.tee" title="scalaz.stream.Tee[I,I2,O]">tee</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#T,O]">step</a> match <span class="delimiter">{</span>
      case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.Emit[O]" id="scalaz.stream.tee.disconnectL.emt">emt</a>@Emit<span class="delimiter">(</span>_<span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.tee.disconnectL.emt" title="scalaz.stream.Process.Emit[O]">emt</a> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[Nothing,I2]#T[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[Nothing,I2]#T[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span>.<a href="Process.scala.html#scalaz.stream.Process;Cont.extend" title="(f: scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Nothing,I2]#T,O])scalaz.stream.Process.Cont[scalaz.stream.Process.Env[Nothing,I2]#T,O]">extend</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(tee: scalaz.stream.Tee[Nothing,I2,O])scalaz.stream.Tee[Nothing,I2,O]">disconnectL</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectL.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectL.$anonfun.x$11" title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case Step<span class="delimiter">(</span><a href="#scalaz.stream.tee.AwaitL.unapply" title="(self: scalaz.stream.tee.TeeAwaitL[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Tee[I,I2,O]]">AwaitL</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O] forSome { type I &gt;: I; type I &gt;: I }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.suspend" title="(p: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Nothing,I2]#T,O])scalaz.stream.Process[scalaz.stream.Process.Env[Nothing,I2]#T,O]">suspend</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(tee: scalaz.stream.Tee[Nothing,I2,O])scalaz.stream.Tee[Nothing,I2,O]">disconnectL</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectL.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectL.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case Step<span class="delimiter">(</span><a title="scalaz.stream.tee.TeeAwaitR[I,I2,O]" id="scalaz.stream.tee.disconnectL.awt">awt</a>@<a href="#scalaz.stream.tee.AwaitR.unapply" title="(self: scalaz.stream.tee.TeeAwaitR[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Tee[I,I2,O]]">AwaitR</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O] forSome { type I2 &gt;: I2; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.tee.disconnectL.awt" title="scalaz.stream.tee.TeeAwaitR[I,I2,O]">awt</a>.<a href="Process.scala.html#scalaz.stream.Process;Await.extend" title="(f: scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Nothing,I2]#T,O])scalaz.stream.Process.Await[scalaz.stream.Process.Env[Nothing,I2]#T,scalaz.stream.Process.Env[Any,I2]#T[I2],O]">extend</a><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]" id="scalaz.stream.tee.disconnectL.$anonfun.p">p</a> =&gt; <a href="#scalaz.stream.tee.disconnectL" title="[I, I2, O](cause: scalaz.stream.Cause.EarlyCause)(tee: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[Nothing,I2,O]">disconnectL</a><span title="(cause: scalaz.stream.Cause.EarlyCause)(tee: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[Nothing,I2,O]" class="delimiter">[</span><a href="#scalaz.stream.tee.disconnectL;I" title="I">I</a>,<a href="#scalaz.stream.tee.disconnectL;I2" title="I2">I2</a>,<a href="#scalaz.stream.tee.disconnectL;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectL.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectL.$anonfun.p" title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">p</a> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case <a title="scalaz.stream.Process.Halt" id="scalaz.stream.tee.disconnectL.hlt">hlt</a>@Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.tee.disconnectL.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectL.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  <span class="comment">/**
   * Signals, that _right_ side of tee terminated.
   * That causes all succeeding AwaitR to terminate with `cause` giving chance
   * to emit any values or read on left.
   */</span>
  def <a title="[I, I2, O](cause: scalaz.stream.Cause.EarlyCause)(tee: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,Nothing,O]" id="scalaz.stream.tee.disconnectR">disconnectR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.disconnectR;I">I</a>, <a title="" id="scalaz.stream.tee.disconnectR;I2">I2</a>, <a title="" id="scalaz.stream.tee.disconnectR;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.tee.disconnectR.cause">cause</a>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.disconnectR.tee">tee</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,Nothing,O]">Tee</a><span class="delimiter">[</span>I, Nothing, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#scalaz.stream.tee.disconnectR.tee" title="scalaz.stream.Tee[I,I2,O]">tee</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#T,O]">step</a> match <span class="delimiter">{</span>
      case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.Emit[O]" id="scalaz.stream.tee.disconnectR.emt">emt</a>@Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.tee.disconnectR.os">os</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span> =&gt;  <a href="#scalaz.stream.tee.disconnectR.emt" title="scalaz.stream.Process.Emit[O]">emt</a> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Nothing]#T[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,Nothing]#T[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span>.<a href="Process.scala.html#scalaz.stream.Process;Cont.extend" title="(f: scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Nothing]#T,O])scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,Nothing]#T,O]">extend</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(tee: scalaz.stream.Tee[I,Nothing,O])scalaz.stream.Tee[I,Nothing,O]">disconnectR</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectR.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectR.$anonfun.x$15" title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case Step<span class="delimiter">(</span><a href="#scalaz.stream.tee.AwaitR.unapply" title="(self: scalaz.stream.tee.TeeAwaitR[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Tee[I,I2,O]]">AwaitR</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O] forSome { type I2 &gt;: I2; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.suspend" title="(p: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Nothing]#T,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,Nothing]#T,O]">suspend</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(tee: scalaz.stream.Tee[I,Nothing,O])scalaz.stream.Tee[I,Nothing,O]">disconnectR</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectR.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectR.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case Step<span class="delimiter">(</span><a title="scalaz.stream.tee.TeeAwaitL[I,I2,O]" id="scalaz.stream.tee.disconnectR.awt">awt</a>@<a href="#scalaz.stream.tee.AwaitL.unapply" title="(self: scalaz.stream.tee.TeeAwaitL[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Tee[I,I2,O]]">AwaitL</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O] forSome { type I &gt;: I; type I &gt;: I }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.tee.disconnectR.awt" title="scalaz.stream.tee.TeeAwaitL[I,I2,O]">awt</a>.<a href="Process.scala.html#scalaz.stream.Process;Await.extend" title="(f: scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Nothing]#T,O])scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,Nothing]#T,scalaz.stream.Process.Env[I,Any]#Is[I],O]">extend</a><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]" id="scalaz.stream.tee.disconnectR.$anonfun.p">p</a> =&gt; <a href="#scalaz.stream.tee.disconnectR" title="[I, I2, O](cause: scalaz.stream.Cause.EarlyCause)(tee: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,Nothing,O]">disconnectR</a><span title="(cause: scalaz.stream.Cause.EarlyCause)(tee: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,Nothing,O]" class="delimiter">[</span><a href="#scalaz.stream.tee.disconnectR;I" title="I">I</a>,<a href="#scalaz.stream.tee.disconnectR;I2" title="I2">I2</a>,<a href="#scalaz.stream.tee.disconnectR;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectR.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectR.$anonfun.p" title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">p</a> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#T[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#T,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.tee.disconnectR.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.disconnectR.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  <span class="comment">/**
   * Awaits to receive input from Left side,
   * than if that request terminates with `End` or is terminated abnormally
   * runs the supplied `continue` or `cleanup`.
   * Otherwise `rcv` is run to produce next state.
   *
   * If  you don't need `continue` or `cleanup` use rather `awaitL.flatMap`
   */</span>
  def <a title="[I, I2, O](rcv: I =&gt; scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.receiveL">receiveL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.receiveL;I">I</a>, <a title="" id="scalaz.stream.tee.receiveL;I2">I2</a>, <a title="" id="scalaz.stream.tee.receiveL;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.receiveL.rcv">rcv</a>: I =&gt; Tee<span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.await" title="[F[_], A, O](req: F[A])(rcv: A =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">await</a><span title="(req: scalaz.stream.Process.Env[I,I2]#T[I])(rcv: I =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]" class="delimiter">[</span>Env<span class="delimiter">[</span>I, I2<span class="delimiter">]</span>#<a href="Process.scala.html#scalaz.stream.Process;Env;T" title="scalaz.stream.Process.Env[I,I2]#T">T</a>, <a href="#scalaz.stream.tee.receiveL;I" title="I">I</a>, <a href="#scalaz.stream.tee.receiveL;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.L" title="scalaz.stream.Process.Env[Any,Any]#Is[Any]">L</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.receiveL.rcv" title="I =&gt; scalaz.stream.Tee[I,I2,O]">rcv</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Awaits to receive input from Right side,
   * than if that request terminates with `End` or is terminated abnormally
   * runs the supplied continue.
   * Otherwise `rcv` is run to produce next state.
   *
   * If  you don't need `continue` or `cleanup` use rather `awaitR.flatMap`
   */</span>
  def <a title="[I, I2, O](rcv: I2 =&gt; scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.receiveR">receiveR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.receiveR;I">I</a>, <a title="" id="scalaz.stream.tee.receiveR;I2">I2</a>, <a title="" id="scalaz.stream.tee.receiveR;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I2 =&gt; scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.receiveR.rcv">rcv</a>: I2 =&gt; Tee<span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.await" title="[F[_], A, O](req: F[A])(rcv: A =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">await</a><span title="(req: scalaz.stream.Process.Env[I,I2]#T[I2])(rcv: I2 =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]" class="delimiter">[</span>Env<span class="delimiter">[</span>I, I2<span class="delimiter">]</span>#<a href="Process.scala.html#scalaz.stream.Process;Env;T" title="scalaz.stream.Process.Env[I,I2]#T">T</a>, <a href="#scalaz.stream.tee.receiveR;I2" title="I2">I2</a>, <a href="#scalaz.stream.tee.receiveR;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.R" title="scalaz.stream.Process.Env[Any,Any]#T[Any]">R</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.receiveR.rcv" title="I2 =&gt; scalaz.stream.Tee[I,I2,O]">rcv</a><span class="delimiter">)</span>

  <span class="comment">/** syntax sugar for receiveL */</span>
  def <a title="[I, I2, O](fb: =&gt; scalaz.stream.Tee[I,I2,O])(rcvL: I =&gt; scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.receiveLOr">receiveLOr</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.receiveLOr;I">I</a>, <a title="" id="scalaz.stream.tee.receiveLOr;I2">I2</a>, <a title="" id="scalaz.stream.tee.receiveLOr;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.receiveLOr.fb">fb</a>: =&gt; Tee<span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="I =&gt; scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.receiveLOr.rcvL">rcvL</a>: I =&gt; Tee<span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.awaitOr" title="[F[_], A, O](req: F[A])(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[F,O])(rcv: A =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">awaitOr</a><span title="(req: scalaz.stream.Process.Env[I,I2]#T[I])(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])(rcv: I =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]" class="delimiter">[</span>Env<span class="delimiter">[</span>I, I2<span class="delimiter">]</span>#<a href="Process.scala.html#scalaz.stream.Process;Env;T" title="scalaz.stream.Process.Env[I,I2]#T">T</a>, <a href="#scalaz.stream.tee.receiveLOr;I" title="I">I</a>, <a href="#scalaz.stream.tee.receiveLOr;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.L" title="scalaz.stream.Process.Env[Any,Any]#Is[Any]">L</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.tee.receiveLOr.$anonfun.rsn">rsn</a> =&gt; <a href="#scalaz.stream.tee.receiveLOr.fb" title="=&gt; scalaz.stream.Tee[I,I2,O]">fb</a>.<a href="Process.scala.html#scalaz.stream;Process.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.receiveLOr.$anonfun.rsn" title="scalaz.stream.Cause.EarlyCause">rsn</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.receiveLOr.rcvL" title="I =&gt; scalaz.stream.Tee[I,I2,O]">rcvL</a><span class="delimiter">)</span>

  <span class="comment">/** syntax sugar for receiveR */</span>
  def <a title="[I, I2, O](fb: =&gt; scalaz.stream.Tee[I,I2,O])(rcvR: I2 =&gt; scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.receiveROr">receiveROr</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.receiveROr;I">I</a>, <a title="" id="scalaz.stream.tee.receiveROr;I2">I2</a>, <a title="" id="scalaz.stream.tee.receiveROr;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.receiveROr.fb">fb</a>: =&gt; Tee<span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="I2 =&gt; scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.tee.receiveROr.rcvR">rcvR</a>: I2 =&gt; Tee<span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.awaitOr" title="[F[_], A, O](req: F[A])(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[F,O])(rcv: A =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">awaitOr</a><span title="(req: scalaz.stream.Process.Env[I,I2]#T[I2])(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])(rcv: I2 =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]" class="delimiter">[</span>Env<span class="delimiter">[</span>I, I2<span class="delimiter">]</span>#<a href="Process.scala.html#scalaz.stream.Process;Env;T" title="scalaz.stream.Process.Env[I,I2]#T">T</a>, <a href="#scalaz.stream.tee.receiveROr;I2" title="I2">I2</a>, <a href="#scalaz.stream.tee.receiveROr;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.R" title="scalaz.stream.Process.Env[Any,Any]#T[Any]">R</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.tee.receiveROr.$anonfun.rsn">rsn</a> =&gt; <a href="#scalaz.stream.tee.receiveROr.fb" title="=&gt; scalaz.stream.Tee[I,I2,O]">fb</a>.<a href="Process.scala.html#scalaz.stream;Process.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.receiveROr.$anonfun.rsn" title="scalaz.stream.Cause.EarlyCause">rsn</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.receiveROr.rcvR" title="I2 =&gt; scalaz.stream.Tee[I,I2,O]">rcvR</a><span class="delimiter">)</span>


  <span class="comment">//////////////////////////////////////////////////////////////////////</span>
  <span class="comment">// De-constructors</span>
  <span class="comment">//////////////////////////////////////////////////////////////////////</span>
  type <a title="[I, I2, O]scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,I2]#T,scalaz.stream.Process.Env[I,Any]#Is[I],O]" id="scalaz.stream.tee;TeeAwaitL">TeeAwaitL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee;TeeAwaitL;I">I</a>, <a title="" id="scalaz.stream.tee;TeeAwaitL;I2">I2</a>, <a title="" id="scalaz.stream.tee;TeeAwaitL;O">O</a><span class="delimiter">]</span> = <a href="Process.scala.html#scalaz.stream.Process;Await" title="scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,I2]#T,scalaz.stream.Process.Env[I,Any]#Is[I],O]">Await</a><span class="delimiter">[</span>Env<span class="delimiter">[</span>I, I2<span class="delimiter">]</span>#T, Env<span class="delimiter">[</span>I, Any<span class="delimiter">]</span>#Is<span class="delimiter">[</span>I<span class="delimiter">]</span>, O<span class="delimiter">]</span>
  type <a title="[I, I2, O]scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,I2]#T,scalaz.stream.Process.Env[Any,I2]#T[I2],O]" id="scalaz.stream.tee;TeeAwaitR">TeeAwaitR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee;TeeAwaitR;I">I</a>, <a title="" id="scalaz.stream.tee;TeeAwaitR;I2">I2</a>, <a title="" id="scalaz.stream.tee;TeeAwaitR;O">O</a><span class="delimiter">]</span> = <a href="Process.scala.html#scalaz.stream.Process;Await" title="scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,I2]#T,scalaz.stream.Process.Env[Any,I2]#T[I2],O]">Await</a><span class="delimiter">[</span>Env<span class="delimiter">[</span>I, I2<span class="delimiter">]</span>#T, Env<span class="delimiter">[</span>Any, I2<span class="delimiter">]</span>#T<span class="delimiter">[</span>I2<span class="delimiter">]</span>, O<span class="delimiter">]</span>


  object <a title="scalaz.stream.tee.AwaitL.type" id="scalaz.stream.tee.AwaitL">AwaitL</a> <a href="#scalaz.stream.tee.AwaitL" title="scalaz.stream.tee.AwaitL.type" class="delimiter">{</a>
    def <a title="[I, I2, O](self: scalaz.stream.tee.TeeAwaitL[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Tee[I,I2,O]]" id="scalaz.stream.tee.AwaitL.unapply">unapply</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.AwaitL.unapply;I">I</a>, <a title="" id="scalaz.stream.tee.AwaitL.unapply;I2">I2</a>, <a title="" id="scalaz.stream.tee.AwaitL.unapply;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.tee.TeeAwaitL[I,I2,O]" id="scalaz.stream.tee.AwaitL.unapply.self">self</a>: <a href="Process.scala.html#scalaz.stream.Process;Await" title="scalaz.stream.tee.TeeAwaitL[I,I2,O]">TeeAwaitL</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>:
    <span title="Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Tee[I,I2,O]]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>EarlyCause \/ I =&gt; Tee<span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#scalaz.stream.tee.AwaitL.unapply.self" title="scalaz.stream.tee.TeeAwaitL[I,I2,O]">self</a> match <span class="delimiter">{</span>
      case Await<span class="delimiter">(</span><a title="scalaz.stream.Process.Env[I,I2]#T[scalaz.stream.Process.Env[I,Any]#Is[I]]" id="scalaz.stream.tee.AwaitL.unapply.req">req</a>, <a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.Process.Env[I,Any]#Is[I]] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]]" id="scalaz.stream.tee.AwaitL.unapply.rcv">rcv</a><span class="delimiter">)</span>
        if <a href="#scalaz.stream.tee.AwaitL.unapply.req" title="scalaz.stream.Process.Env[I,I2]#T[scalaz.stream.Process.Env[I,Any]#Is[I]]">req</a>.<a href="Process.scala.html#scalaz.stream.Process;Env;Y.tag" title="=&gt; Int">tag</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span> =&gt; <span title="(x: scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])Some[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]]">Some</span><span class="delimiter">(</span><span class="delimiter">(</span>r: EarlyCause <span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I]">\/</span> I<span class="delimiter">)</span> =&gt;
        <a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.AwaitL.unapply.rcv" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.Process.Env[I,Any]#Is[I]] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]]">rcv</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process.Trampoline[scalaz.stream.Tee[I,I2,O]]" class="delimiter">[</span><span class="delimiter">(</span>EarlyCause \/ I<span class="delimiter">)</span> =&gt; Trampoline<span class="delimiter">[</span>Tee<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.AwaitL.unapply.$anonfun.r" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I]">r</a><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Tee[I,I2,O]],scalaz.Free.Trampoline[scalaz.stream.Tee[I,I2,O]]])scalaz.stream.Tee[I,I2,O]">run</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case _                               =&gt; <span title="None.type">None</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Like `AwaitL.unapply` only allows fast test that wye is awaiting on left side */</span>
    object <a title="scalaz.stream.tee.AwaitL.is.type" id="scalaz.stream.tee.AwaitL.is">is</a> <a href="#scalaz.stream.tee.AwaitL.is" title="scalaz.stream.tee.AwaitL.is.type" class="delimiter">{</a>
      def <a title="[I, I2, O](self: scalaz.stream.tee.TeeAwaitL[I,I2,O])Boolean" id="scalaz.stream.tee.AwaitL.is.unapply">unapply</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.AwaitL.is.unapply;I">I</a>, <a title="" id="scalaz.stream.tee.AwaitL.is.unapply;I2">I2</a>, <a title="" id="scalaz.stream.tee.AwaitL.is.unapply;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.tee.TeeAwaitL[I,I2,O]" id="scalaz.stream.tee.AwaitL.is.unapply.self">self</a>: <a href="Process.scala.html#scalaz.stream.Process;Await" title="scalaz.stream.tee.TeeAwaitL[I,I2,O]">TeeAwaitL</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#scalaz.stream.tee.AwaitL.is.unapply.self" title="scalaz.stream.tee.TeeAwaitL[I,I2,O]">self</a> match <span class="delimiter">{</span>
        case Await<span class="delimiter">(</span><a title="scalaz.stream.Process.Env[I,I2]#T[scalaz.stream.Process.Env[I,Any]#Is[I]]" id="scalaz.stream.tee.AwaitL.is.unapply.req">req</a>, <a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.Process.Env[I,Any]#Is[I]] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]]" id="scalaz.stream.tee.AwaitL.is.unapply.rcv">rcv</a><span class="delimiter">)</span> if <a href="#scalaz.stream.tee.AwaitL.is.unapply.req" title="scalaz.stream.Process.Env[I,I2]#T[scalaz.stream.Process.Env[I,Any]#Is[I]]">req</a>.<a href="Process.scala.html#scalaz.stream.Process;Env;Y.tag" title="=&gt; Int">tag</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span> =&gt; true
        case _                               =&gt; false
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span title="AnyRef" class="delimiter">}</span>

  object <a title="scalaz.stream.tee.AwaitR.type" id="scalaz.stream.tee.AwaitR">AwaitR</a> <a href="#scalaz.stream.tee.AwaitR" title="scalaz.stream.tee.AwaitR.type" class="delimiter">{</a>
    def <a title="[I, I2, O](self: scalaz.stream.tee.TeeAwaitR[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Tee[I,I2,O]]" id="scalaz.stream.tee.AwaitR.unapply">unapply</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.AwaitR.unapply;I">I</a>, <a title="" id="scalaz.stream.tee.AwaitR.unapply;I2">I2</a>, <a title="" id="scalaz.stream.tee.AwaitR.unapply;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.tee.TeeAwaitR[I,I2,O]" id="scalaz.stream.tee.AwaitR.unapply.self">self</a>: <a href="Process.scala.html#scalaz.stream.Process;Await" title="scalaz.stream.tee.TeeAwaitR[I,I2,O]">TeeAwaitR</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>:
    <span title="Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Tee[I,I2,O]]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>EarlyCause \/ I2 =&gt; Tee<span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#scalaz.stream.tee.AwaitR.unapply.self" title="scalaz.stream.tee.TeeAwaitR[I,I2,O]">self</a> match <span class="delimiter">{</span>
      case Await<span class="delimiter">(</span><a title="scalaz.stream.Process.Env[I,I2]#T[scalaz.stream.Process.Env[Any,I2]#T[I2]]" id="scalaz.stream.tee.AwaitR.unapply.req">req</a>, <a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.Process.Env[Any,I2]#T[I2]] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]]" id="scalaz.stream.tee.AwaitR.unapply.rcv">rcv</a><span class="delimiter">)</span>
        if <a href="#scalaz.stream.tee.AwaitR.unapply.req" title="scalaz.stream.Process.Env[I,I2]#T[scalaz.stream.Process.Env[Any,I2]#T[I2]]">req</a>.<a href="Process.scala.html#scalaz.stream.Process;Env;Y.tag" title="=&gt; Int">tag</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span> =&gt; <span title="(x: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])Some[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]]">Some</span><span class="delimiter">(</span><span class="delimiter">(</span>r: EarlyCause <span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2]">\/</span> I2<span class="delimiter">)</span> =&gt;
        <a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream.tee.AwaitR.unapply.rcv" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.Process.Env[Any,I2]#T[I2]] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]]">rcv</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process.Trampoline[scalaz.stream.Tee[I,I2,O]]" class="delimiter">[</span><span class="delimiter">(</span>EarlyCause \/ I2<span class="delimiter">)</span> =&gt; Trampoline<span class="delimiter">[</span>Tee<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.tee.AwaitR.unapply.$anonfun.r" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2]">r</a><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Tee[I,I2,O]],scalaz.Free.Trampoline[scalaz.stream.Tee[I,I2,O]]])scalaz.stream.Tee[I,I2,O]">run</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case _                               =&gt; <span title="None.type">None</span>
    <span class="delimiter">}</span>


    <span class="comment">/** Like `AwaitR.unapply` only allows fast test that wye is awaiting on left side */</span>
    object <a title="scalaz.stream.tee.AwaitR.is.type" id="scalaz.stream.tee.AwaitR.is">is</a> <a href="#scalaz.stream.tee.AwaitR.is" title="scalaz.stream.tee.AwaitR.is.type" class="delimiter">{</a>
      def <a title="[I, I2, O](self: scalaz.stream.tee.TeeAwaitR[I,I2,O])Boolean" id="scalaz.stream.tee.AwaitR.is.unapply">unapply</a><span class="delimiter">[</span><a title="" id="scalaz.stream.tee.AwaitR.is.unapply;I">I</a>, <a title="" id="scalaz.stream.tee.AwaitR.is.unapply;I2">I2</a>, <a title="" id="scalaz.stream.tee.AwaitR.is.unapply;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.tee.TeeAwaitR[I,I2,O]" id="scalaz.stream.tee.AwaitR.is.unapply.self">self</a>: <a href="Process.scala.html#scalaz.stream.Process;Await" title="scalaz.stream.tee.TeeAwaitR[I,I2,O]">TeeAwaitR</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#scalaz.stream.tee.AwaitR.is.unapply.self" title="scalaz.stream.tee.TeeAwaitR[I,I2,O]">self</a> match <span class="delimiter">{</span>
        case Await<span class="delimiter">(</span><a title="scalaz.stream.Process.Env[I,I2]#T[scalaz.stream.Process.Env[Any,I2]#T[I2]]" id="scalaz.stream.tee.AwaitR.is.unapply.req">req</a>, <a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.Process.Env[Any,I2]#T[I2]] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#T,O]]" id="scalaz.stream.tee.AwaitR.is.unapply.rcv">rcv</a><span class="delimiter">)</span> if <a href="#scalaz.stream.tee.AwaitR.is.unapply.req" title="scalaz.stream.Process.Env[I,I2]#T[scalaz.stream.Process.Env[Any,I2]#T[I2]]">req</a>.<a href="Process.scala.html#scalaz.stream.Process;Env;Y.tag" title="=&gt; Int">tag</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span> =&gt; true
        case _                               =&gt; false
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span title="AnyRef" class="delimiter">}</span>
<span title="AnyRef" class="delimiter">}</span>

<span class="comment">/**
 * Operations on process that uses `tee`
 */</span>
private<span class="delimiter">[</span>stream<span class="delimiter">]</span> trait <a title="trait TeeOps[+F[_], +O] extends AnyRef" id="scalaz.stream;TeeOps">TeeOps</a><span class="delimiter">[</span>+<a title="[_]" id="scalaz.stream;TeeOps;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream;TeeOps;F;_">_</a><span class="delimiter">]</span>, +<a title="" id="scalaz.stream;TeeOps;O">O</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>

  self: Process<span class="delimiter">[</span>F, O<span class="delimiter">]</span> =&gt;

  <span class="comment">/** Alternate emitting elements from `this` and `p2`, starting with `this`. */</span>
  def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](p2: scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]" id="scalaz.stream;TeeOps.interleave">interleave</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;TeeOps.interleave;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;TeeOps.interleave;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream;TeeOps.interleave;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F2,O2]" id="scalaz.stream;TeeOps.interleave.p2">p2</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> =
    this.<a href="Process.scala.html#scalaz.stream;Process.tee" title="(p2: scalaz.stream.Process[F2,O2])(t: scalaz.stream.Tee[O,O2,O2])scalaz.stream.Process[F2,O2]">tee</a><span class="delimiter">(</span><a href="#scalaz.stream;TeeOps.interleave.p2" title="scalaz.stream.Process[F2,O2]">p2</a><span class="delimiter">)</span><span class="delimiter">(</span>scalaz.stream.<a href="#scalaz.stream.tee" title="scalaz.stream.tee.type">tee</a>.<a href="#scalaz.stream.tee.interleave" title="[I]=&gt; scalaz.stream.Tee[I,I,I]">interleave</a><span title="scalaz.stream.Tee[O2,O2,O2]" class="delimiter">[</span><a href="#scalaz.stream;TeeOps.interleave;O2" title="O2">O2</a><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="comment">/** Call `tee` with the `zipWith` `Tee[O,O2,O3]` defined in `tee.scala`. */</span>
  def <a title="[F2[x] &gt;: F[x], O2, O3](p2: scalaz.stream.Process[F2,O2])(f: (O, O2) =&gt; O3)scalaz.stream.Process[F2,O3]" id="scalaz.stream;TeeOps.zipWith">zipWith</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;TeeOps.zipWith;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;TeeOps.zipWith;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title="" id="scalaz.stream;TeeOps.zipWith;O2">O2</a>, <a title="" id="scalaz.stream;TeeOps.zipWith;O3">O3</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F2,O2]" id="scalaz.stream;TeeOps.zipWith.p2">p2</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(O, O2) =&gt; O3" id="scalaz.stream;TeeOps.zipWith.f">f</a>: <span class="delimiter">(</span>O, O2<span class="delimiter">)</span> =&gt; O3<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F2,O3]">Process</a><span class="delimiter">[</span>F2, O3<span class="delimiter">]</span> =
    this.<a href="Process.scala.html#scalaz.stream;Process.tee" title="(p2: scalaz.stream.Process[F2,O2])(t: scalaz.stream.Tee[O,O2,O3])scalaz.stream.Process[F2,O3]">tee</a><span class="delimiter">(</span><a href="#scalaz.stream;TeeOps.zipWith.p2" title="scalaz.stream.Process[F2,O2]">p2</a><span class="delimiter">)</span><span class="delimiter">(</span>scalaz.stream.<a href="#scalaz.stream.tee" title="scalaz.stream.tee.type">tee</a>.<a href="#scalaz.stream.tee.zipWith" title="(f: (O, O2) =&gt; O3)scalaz.stream.Tee[O,O2,O3]">zipWith</a><span class="delimiter">(</span><a href="#scalaz.stream;TeeOps.zipWith.f" title="(O, O2) =&gt; O3">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Call `tee` with the `zip` `Tee[O,O2,O3]` defined in `tee.scala`. */</span>
  def <a title="[F2[x] &gt;: F[x], O2](p2: scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,(O, O2)]" id="scalaz.stream;TeeOps.zip">zip</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;TeeOps.zip;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;TeeOps.zip;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title="" id="scalaz.stream;TeeOps.zip;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F2,O2]" id="scalaz.stream;TeeOps.zip.p2">p2</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F2,(O, O2)]">Process</a><span class="delimiter">[</span>F2, <span class="delimiter">(</span>O, O2<span class="delimiter">)</span><span class="delimiter">]</span> =
    this.<a href="Process.scala.html#scalaz.stream;Process.tee" title="(p2: scalaz.stream.Process[F2,O2])(t: scalaz.stream.Tee[O,O2,(O, O2)])scalaz.stream.Process[F2,(O, O2)]">tee</a><span class="delimiter">(</span><a href="#scalaz.stream;TeeOps.zip.p2" title="scalaz.stream.Process[F2,O2]">p2</a><span class="delimiter">)</span><span class="delimiter">(</span>scalaz.stream.<a href="#scalaz.stream.tee" title="scalaz.stream.tee.type">tee</a>.<a href="#scalaz.stream.tee.zip" title="scalaz.stream.Tee[O,O2,(O, O2)]">zip</a><span class="delimiter">)</span>

  <span class="comment">/**
   * When `condition` is `true`, lets through any values in `this` process, otherwise blocks
   * until `condition` becomes true again. Note that the `condition` is checked before
   * each and every read from `this`, so `condition` should return very quickly or be
   * continuous to avoid holding up the output `Process`. Use `condition.forwardFill` to
   * convert an infrequent discrete `Process` to a continuous one for use with this
   * function.
   */</span>
  def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](condition: scalaz.stream.Process[F2,Boolean])scalaz.stream.Process[F2,O2]" id="scalaz.stream;TeeOps.when">when</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;TeeOps.when;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;TeeOps.when;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream;TeeOps.when;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F2,Boolean]" id="scalaz.stream;TeeOps.when.condition">condition</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F2,Boolean]">Process</a><span class="delimiter">[</span>F2, Boolean<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> =
    <a href="#scalaz.stream;TeeOps.when.condition" title="scalaz.stream.Process[F2,Boolean]">condition</a>.<a href="Process.scala.html#scalaz.stream;Process.tee" title="(p2: scalaz.stream.Process[[x]F2[x],O])(t: scalaz.stream.Tee[Boolean,O,O])scalaz.stream.Process[[x]F2[x],O]">tee</a><span class="delimiter">(</span>this<span class="delimiter">)</span><span class="delimiter">(</span>scalaz.stream.<a href="#scalaz.stream.tee" title="scalaz.stream.tee.type">tee</a>.<a href="#scalaz.stream.tee.when" title="scalaz.stream.Tee[Boolean,O,O]">when</a><span class="delimiter">)</span>


  <span class="comment">/** Delay running this `Process` until `awaken` becomes true for the first time. */</span>
  def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](awaken: scalaz.stream.Process[F2,Boolean])scalaz.stream.Process[F2,O2]" id="scalaz.stream;TeeOps.sleepUntil">sleepUntil</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;TeeOps.sleepUntil;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;TeeOps.sleepUntil;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream;TeeOps.sleepUntil;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F2,Boolean]" id="scalaz.stream;TeeOps.sleepUntil.awaken">awaken</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F2,Boolean]">Process</a><span class="delimiter">[</span>F2, Boolean<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="Process.scala.html#scalaz.stream.Process.sleepUntil" title="(awaken: scalaz.stream.Process[F2,Boolean])(p: scalaz.stream.Process[F2,O])scalaz.stream.Process[F2,O]">sleepUntil</a><span class="delimiter">(</span><a href="#scalaz.stream;TeeOps.sleepUntil.awaken" title="scalaz.stream.Process[F2,Boolean]">awaken</a><span class="delimiter">)</span><span class="delimiter">(</span>this<span class="delimiter">)</span>

  <span class="comment">/**
   * Halts this `Process` as soon as `condition` becomes `true`. Note that `condition`
   * is checked before each and every read from `this`, so `condition` should return
   * very quickly or be continuous to avoid holding up the output `Process`. Use
   * `condition.forwardFill` to convert an infrequent discrete `Process` to a
   * continuous one for use with this function.
   */</span>
  def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](condition: scalaz.stream.Process[F2,Boolean])scalaz.stream.Process[F2,O2]" id="scalaz.stream;TeeOps.until">until</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;TeeOps.until;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;TeeOps.until;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream;TeeOps.until;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F2,Boolean]" id="scalaz.stream;TeeOps.until.condition">condition</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F2,Boolean]">Process</a><span class="delimiter">[</span>F2, Boolean<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> =
    <a href="#scalaz.stream;TeeOps.until.condition" title="scalaz.stream.Process[F2,Boolean]">condition</a>.<a href="Process.scala.html#scalaz.stream;Process.tee" title="(p2: scalaz.stream.Process[[x]F2[x],O])(t: scalaz.stream.Tee[Boolean,O,O])scalaz.stream.Process[[x]F2[x],O]">tee</a><span class="delimiter">(</span>this<span class="delimiter">)</span><span class="delimiter">(</span>scalaz.stream.<a href="#scalaz.stream.tee" title="scalaz.stream.tee.type">tee</a>.<a href="#scalaz.stream.tee.until" title="scalaz.stream.Tee[Boolean,O,O]">until</a><span class="delimiter">)</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
