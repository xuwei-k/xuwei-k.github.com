<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scalaz-stream/scalaz/stream/merge/package.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scalaz.stream

import scalaz.concurrent.<span class="delimiter">{</span>Strategy, Task<span class="delimiter">}</span>


package object <a title="scalaz.stream.merge.package.type" id="scalaz.stream.merge.package">merge</a> <a href="#scalaz.stream.merge.package" title="scalaz.stream.merge.package.type" class="delimiter">{</a>


  <span class="comment">/**
   * Merges non-deterministically processes that are output of the `source` process.
   *
   * Merging stops when all processes generated by source have stopped, and all source process stopped as well.
   * Merging will also stop when resulting process terminated. In that case the cleanup of all `source`
   * processes is run, followed by cleanup of resulting process.
   *
   * When one of the source processes fails the mergeN process will fail with that reason.
   *
   * Merging is non-deterministic, but is fair in sense that every process is consulted, once it has `A` ready.
   * That means processes that are `faster` provide it's `A` more often than slower processes.
   *
   * Internally mergeN keeps small buffer that reads ahead up to `n` values of `A` where `n` equals to number
   * of active source streams. That does not mean that every `source` process is consulted in this read-ahead
   * cache, it just tries to be as much fair as possible when processes provide their `A` on almost the same speed.
   *
   */</span>
  def <a title="[A](source: scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Process[scalaz.concurrent.Task,A]])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,A]" id="scalaz.stream.merge.package.mergeN(b0691a9630)">mergeN</a><span class="delimiter">[</span><a title="" id="scalaz.stream.merge.package.mergeN(b0691a9630);A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Process[scalaz.concurrent.Task,A]]" id="scalaz.stream.merge.package.mergeN(b0691a9630).source">source</a>: <a href="../Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Process[scalaz.concurrent.Task,A]]">Process</a><span class="delimiter">[</span>Task, Process<span class="delimiter">[</span>Task, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream.merge.package.mergeN(b0691a9630).S">S</a>: <span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <a href="../Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,A]">Process</a><span class="delimiter">[</span>Task, A<span class="delimiter">]</span> =
    scalaz.stream.nondeterminism.<a href="../nondeterminism/nondeterminism.scala.html#scalaz.stream.nondeterminism.package.njoin" title="(maxOpen: Int, maxQueued: Int)(source: scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Process[scalaz.concurrent.Task,A]])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,A]">njoin</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.merge.package.mergeN(b0691a9630).source" title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Process[scalaz.concurrent.Task,A]]">source</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.merge.package.mergeN(b0691a9630).S" title="scalaz.concurrent.Strategy">S</a><span class="delimiter">)</span>

  <span class="comment">/**
   * MergeN variant, that allows to specify maximum of open `source` processes.
   * If, the maxOpen is &lt;= 0 it acts like standard mergeN, where the number of processes open is not limited.
   * However, when the maxOpen &gt; 0, then at any time only `maxOpen` processes will be running at any time
   *
   * This allows for limiting the eventual concurrent processing of opened streams not only by supplied strategy,
   * but also by providing a `maxOpen` value.
   *
   *
   * @param maxOpen   Max number of open (running) processes at a time
   * @param source    source of processes to merge
   */</span>
  def <a title="[A](maxOpen: Int)(source: scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Process[scalaz.concurrent.Task,A]])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,A]" id="scalaz.stream.merge.package.mergeN(f9817b4a33)">mergeN</a><span class="delimiter">[</span><a title="" id="scalaz.stream.merge.package.mergeN(f9817b4a33);A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scalaz.stream.merge.package.mergeN(f9817b4a33).maxOpen">maxOpen</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Process[scalaz.concurrent.Task,A]]" id="scalaz.stream.merge.package.mergeN(f9817b4a33).source">source</a>: <a href="../Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Process[scalaz.concurrent.Task,A]]">Process</a><span class="delimiter">[</span>Task, Process<span class="delimiter">[</span>Task, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream.merge.package.mergeN(f9817b4a33).S">S</a>: <span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <a href="../Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,A]">Process</a><span class="delimiter">[</span>Task, A<span class="delimiter">]</span> =
    scalaz.stream.nondeterminism.<a href="../nondeterminism/nondeterminism.scala.html#scalaz.stream.nondeterminism.package.njoin" title="(maxOpen: Int, maxQueued: Int)(source: scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Process[scalaz.concurrent.Task,A]])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,A]">njoin</a><span class="delimiter">(</span><a href="#scalaz.stream.merge.package.mergeN(f9817b4a33).maxOpen" title="Int">maxOpen</a>, <a href="#scalaz.stream.merge.package.mergeN(f9817b4a33).maxOpen" title="Int">maxOpen</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.merge.package.mergeN(f9817b4a33).source" title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.stream.Process[scalaz.concurrent.Task,A]]">source</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.merge.package.mergeN(f9817b4a33).S" title="scalaz.concurrent.Strategy">S</a><span class="delimiter">)</span>


<span class="delimiter">}</span>

        </pre>
    </body>
</html>
