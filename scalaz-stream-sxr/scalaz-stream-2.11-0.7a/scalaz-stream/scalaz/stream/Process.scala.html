<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scalaz-stream/scalaz/stream/Process.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scalaz.stream

import java.util.concurrent.atomic.AtomicReference

import <a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>._

import java.util.concurrent.atomic.<span class="delimiter">{</span>AtomicBoolean, AtomicReference<span class="delimiter">}</span>

import scala.annotation.tailrec
import scala.collection.SortedMap
import scala.concurrent.duration._
import scalaz.<span class="delimiter">{</span>\/-, Catchable, Functor, Monad, Monoid, Nondeterminism, \/, -\/, ~&gt;<span class="delimiter">}</span>
import scalaz.<span title="scalaz.\/.type">\/</span>._
import scalaz.concurrent.<span class="delimiter">{</span>Actor, Future, Strategy, Task<span class="delimiter">}</span>
import scalaz.stream.<a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.Await1
import scalaz.syntax.<span title="scalaz.syntax.monad.type">monad</span>._

import scala.annotation.unchecked.uncheckedVariance

<span class="comment">/**
 * An effectful stream of `O` values. In between emitting values
 * a `Process` may request evaluation of `F` effects.
 * A `Process[Nothing,A]` is a pure `Process` with no effects.
 * A `Process[Task,A]` may have `Task` effects. A `Process`
 * halts due to some `Cause`, generally `End` (indicating normal
 * termination) or `Error(t)` for some `t: Throwable` indicating
 * abnormal termination due to some uncaught error.
 */</span>
sealed trait <a title="trait Process[+F[_], +O] extends AnyRef with scalaz.stream.Process1Ops[F,O] with scalaz.stream.TeeOps[F,O]" id="scalaz.stream;Process">Process</a><span class="delimiter">[</span>+<a title="[_]" id="scalaz.stream;Process;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process;F;_">_</a><span class="delimiter">]</span>, +<a title="" id="scalaz.stream;Process;O">O</a><span class="delimiter">]</span>
  extends <a href="process1.scala.html#scalaz.stream;Process1Ops" title="scalaz.stream.Process1Ops[F,O]">Process1Ops</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span>
          with <a href="tee.scala.html#scalaz.stream;TeeOps" title="scalaz.stream.TeeOps[F,O]">TeeOps</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> <span class="delimiter">{</span>

 import scalaz.stream.<a href="#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>._
 import scalaz.stream.<a href="Util.scala.html#scalaz.stream.Util" title="scalaz.stream.Util.type">Util</a>._

  <span class="comment">/**
   * Generate a `Process` dynamically for each output of this `Process`, and
   * sequence these processes using `append`.
   */</span>
  final def <a title="[F2[x] &gt;: F[x], O2](f: O =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.flatMap">flatMap</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.flatMap;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.flatMap;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title="" id="scalaz.stream;Process.flatMap;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.flatMap.f">f</a>: O =&gt; Process<span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">// Util.debug(s&quot;FMAP $this&quot;)</span>
    this match <span class="delimiter">{</span>
      case Halt<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; this.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scalaz.stream.Process[F2,O2]" class="delimiter">[</span><a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">]</span>
      case Emit<span class="delimiter">(</span><span title="Seq[O]">os</span><span class="delimiter">)</span> if <span title="Seq[O]">os</span>.<span title="=&gt; Boolean">isEmpty</span> =&gt; this.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scalaz.stream.Process[F2,O2]" class="delimiter">[</span><a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">]</span>
      case Emit<span class="delimiter">(</span><span title="Seq[O]">os</span><span class="delimiter">)</span> =&gt; <span title="Seq[O]">os</span>.<span title="=&gt; Seq[O]">tail</span>.<span title="(z: scalaz.stream.Process[F2,O2])(op: (scalaz.stream.Process[F2,O2], O) =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">foldLeft</span><span class="delimiter">(</span><a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.flatMap.f" title="(v1: O)scalaz.stream.Process[F2,O2]">f</a><span class="delimiter">(</span><span title="Seq[O]">os</span>.<span title="=&gt; O">head</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.flatMap.$anonfun.p">p</a>, <a title="O" id="scalaz.stream;Process.flatMap.$anonfun.n">n</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.flatMap.$anonfun.p" title="scalaz.stream.Process[F2,O2]">p</a> <a href="#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[[x]F2[x],O2])scalaz.stream.Process[[x]F2[x],O2]">++</a> <a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.flatMap.f" title="(v1: O)scalaz.stream.Process[F2,O2]">f</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.flatMap.$anonfun.n" title="O">n</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case <a title="scalaz.stream.Process.Await[F,Any,O]" id="scalaz.stream;Process.flatMap.aw">aw</a>@Await<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.flatMap.aw" title="scalaz.stream.Process.Await[F,Any,O]">aw</a>.<a href="#scalaz.stream.Process;Await.extend" title="(f: scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process.Await[F2,Any,O2]">extend</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.flatMap.$anonfun.x$1" title="scalaz.stream.Process[F,O]">_</a> <a href="#scalaz.stream;Process.flatMap" title="(f: O =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">flatMap</a> <a href="#scalaz.stream;Process.flatMap.f" title="O =&gt; scalaz.stream.Process[F2,O2]">f</a><span class="delimiter">)</span>
      case <a title="scalaz.stream.Process.Append[F,O]" id="scalaz.stream;Process.flatMap.ap">ap</a>@Append<span class="delimiter">(</span><a title="scalaz.stream.Process.HaltEmitOrAwait[F,O]" id="scalaz.stream;Process.flatMap.p">p</a>, <a title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]" id="scalaz.stream;Process.flatMap.n">n</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.flatMap.ap" title="scalaz.stream.Process.Append[F,O]">ap</a>.<a href="#scalaz.stream.Process;Append.extend" title="(f: scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">extend</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.flatMap.$anonfun.x$2" title="scalaz.stream.Process[F,O]">_</a> <a href="#scalaz.stream;Process.flatMap" title="(f: O =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">flatMap</a> <a href="#scalaz.stream;Process.flatMap.f" title="O =&gt; scalaz.stream.Process[F2,O2]">f</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="comment">/** Transforms the output values of this `Process` using `f`. */</span>
  final def <a title="[O2](f: O =&gt; O2)scalaz.stream.Process[F,O2]" id="scalaz.stream;Process.map">map</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.map;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; O2" id="scalaz.stream;Process.map.f">f</a>: O =&gt; O2<span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F, O2<span class="delimiter">]</span> =
    <a href="#scalaz.stream;Process.flatMap" title="(f: O =&gt; scalaz.stream.Process[[x]F[x],O2])scalaz.stream.Process[[x]F[x],O2]">flatMap</a> <span class="delimiter">{</span> <a title="O" id="scalaz.stream;Process.map.$anonfun.o">o</a> =&gt; <a href="#scalaz.stream.Process.emit" title="(o: O2)scalaz.stream.Process0[O2]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.map.f" title="(v1: O)O2">f</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.map.$anonfun.o" title="O">o</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">}</span>

  <span class="comment">/**
   * If this process halts due to `Cause.End`, runs `p2` after `this`.
   * Otherwise halts with whatever caused `this` to `Halt`.
   */</span>
  final def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](p2: =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.append">append</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.append;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.append;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream;Process.append;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.append.p2">p2</a>: =&gt; Process<span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">onHalt</a> <a href="#scalaz.stream;Process.append.$anonfun.x0$1" title="scalaz.stream.Process[F2,O2]" class="delimiter">{</a>
      case <a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a> =&gt; <a href="#scalaz.stream;Process.append.p2" title="=&gt; scalaz.stream.Process[F2,O2]">p2</a>
      case <a title="scalaz.stream.Cause" id="scalaz.stream;Process.append.$anonfun.cause">cause</a> =&gt; <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.append.$anonfun.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Alias for `append` */</span>
  final def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](p2: =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.++">++</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.++;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.++;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream;Process.++;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.++.p2">p2</a>: =&gt; Process<span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> = <a href="#scalaz.stream;Process.append" title="(p2: =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">append</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.++.p2" title="=&gt; scalaz.stream.Process[F2,O2]">p2</a><span class="delimiter">)</span>

  <span class="comment">/** Alias for `append` */</span>
  final def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](p2: =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.fby">fby</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.fby;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.fby;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream;Process.fby;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.fby.p2">p2</a>: =&gt; Process<span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> = <a href="#scalaz.stream;Process.append" title="(p2: =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">append</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.fby.p2" title="=&gt; scalaz.stream.Process[F2,O2]">p2</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Run one step of an incremental traversal of this `Process`.
   * This function is mostly intended for internal use. As it allows
   * a `Process` to be observed and captured during its execution,
   * users are responsible for ensuring resource safety.
   */</span>
  final def <a title="=&gt; scalaz.stream.Process.HaltOrStep[F,O]" id="scalaz.stream;Process.step">step</a>: <a href="#scalaz.stream.Process;HaltOrStep" title="scalaz.stream.Process.HaltOrStep[F,O]">HaltOrStep</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scalaz.stream.Process.Emit[Nothing]" id="scalaz.stream;Process.step.empty">empty</a>: <a href="#scalaz.stream.Process.Emit.readResolve" title="scalaz.stream.Process.Emit[Nothing]">Emit</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> = <a href="#scalaz.stream.Process.Emit.readResolve" title="(seq: Seq[Nothing])scalaz.stream.Process.Emit[Nothing]">Emit</a><span class="delimiter">(</span><span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
    @tailrec
    def <a title="(cur: scalaz.stream.Process[F,O], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]], cnt: Int)scalaz.stream.Process.HaltOrStep[F,O]" id="scalaz.stream;Process.step.go">go</a><span class="delimiter">(</span><a title="scalaz.stream.Process[F,O]" id="scalaz.stream;Process.step.go.cur">cur</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span>, <a title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]" id="scalaz.stream;Process.step.go.stack">stack</a>: <span title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">Vector</span><span class="delimiter">[</span>Cause =&gt; Trampoline<span class="delimiter">[</span>Process<span class="delimiter">[</span>F,O<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Int" id="scalaz.stream;Process.step.go.cnt">cnt</a>: <span title="Int">Int</span><span class="delimiter">)</span> : <a href="#scalaz.stream.Process;HaltOrStep" title="scalaz.stream.Process.HaltOrStep[F,O]">HaltOrStep</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scalaz.stream;Process.step.go.stack" title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#scalaz.stream;Process.step.go.cur" title="scalaz.stream.Process[F,O]">cur</a> match <span class="delimiter">{</span>
        case Halt<span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span> if <a href="#scalaz.stream;Process.step.go.cnt" title="Int">cnt</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span>  =&gt; <a href="#scalaz.stream.Process.Step.readResolve" title="(head: scalaz.stream.Process.EmitOrAwait[F,O], next: scalaz.stream.Process.Cont[F,O])scalaz.stream.Process.Step[F,O]">Step</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.step.empty" title="scalaz.stream.Process.Emit[Nothing]">empty</a>,<a href="#scalaz.stream.Process;Cont" title="(stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process.Cont[F,O]">Cont</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.step.go.stack" title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case Halt<span class="delimiter">(</span><span title="scalaz.stream.Cause">cause</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.step.go" title="(cur: scalaz.stream.Process[F,O], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]], cnt: Int)scalaz.stream.Process.HaltOrStep[F,O]">go</a><span class="delimiter">(</span><a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.step.go.stack" title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a>.<span title="(v1: scalaz.stream.Cause)scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]">head</span><span class="delimiter">(</span><span title="scalaz.stream.Cause">cause</span><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Process[F,O]],scalaz.Free.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process[F,O]">run</span><span class="delimiter">)</span>, <a href="#scalaz.stream;Process.step.go.stack" title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a>.<span title="=&gt; scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">tail</span>, <a href="#scalaz.stream;Process.step.go.cnt" title="Int">cnt</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
        case Emit<span class="delimiter">(</span><span title="Seq[O]">os</span><span class="delimiter">)</span> if <span title="Seq[O]">os</span>.<span title="=&gt; Boolean">isEmpty</span> =&gt; <a href="#scalaz.stream.Process.Step.readResolve" title="(head: scalaz.stream.Process.EmitOrAwait[F,O], next: scalaz.stream.Process.Cont[F,O])scalaz.stream.Process.Step[F,O]">Step</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.step.empty" title="scalaz.stream.Process.Emit[Nothing]">empty</a>,<a href="#scalaz.stream.Process;Cont" title="(stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process.Cont[F,O]">Cont</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.step.go.stack" title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case <span title="scalaz.stream.Process.Emit[O]">emt</span>@<span class="delimiter">(</span>Emit<span class="delimiter">(</span><span title="Seq[O]">os</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Step.readResolve" title="(head: scalaz.stream.Process.EmitOrAwait[F,O], next: scalaz.stream.Process.Cont[F,O])scalaz.stream.Process.Step[F,O]">Step</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Emit[O]">emt</span>,<a href="#scalaz.stream.Process;Cont" title="(stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process.Cont[F,O]">Cont</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.step.go.stack" title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case <span title="scalaz.stream.Process.Await[F,Any,O]">awt</span>@Await<span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Step.readResolve" title="(head: scalaz.stream.Process.EmitOrAwait[F,O], next: scalaz.stream.Process.Cont[F,O])scalaz.stream.Process.Step[F,O]">Step</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Await[F,Any,O]">awt</span>,<a href="#scalaz.stream.Process;Cont" title="(stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process.Cont[F,O]">Cont</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.step.go.stack" title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case Append<span class="delimiter">(</span><span title="scalaz.stream.Process.HaltEmitOrAwait[F,O]">h</span>,<span title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">st</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.step.go" title="(cur: scalaz.stream.Process[F,O], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]], cnt: Int)scalaz.stream.Process.HaltOrStep[F,O]">go</a><span class="delimiter">(</span><span title="scalaz.stream.Process.HaltEmitOrAwait[F,O]">h</span>, <a href="Util.scala.html#scalaz.stream.Util.AppendSyntax(629eae9601)" title="(self: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Util.AppendSyntax[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">st</a> <a href="Util.scala.html#scalaz.stream.Util;AppendSyntax.fast_++" title="(other: Seq[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]])Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">fast_++</a> <a href="#scalaz.stream;Process.step.go.stack" title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a>, <a href="#scalaz.stream;Process.step.go.cnt" title="Int">cnt</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <a href="#scalaz.stream;Process.step.go.cur" title="scalaz.stream.Process[F,O]">cur</a> match <span class="delimiter">{</span>
        case <a title="scalaz.stream.Process.Halt" id="scalaz.stream;Process.step.go.hlt">hlt</a>@Halt<span class="delimiter">(</span><span title="scalaz.stream.Cause">cause</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.step.go.hlt" title="scalaz.stream.Process.Halt">hlt</a>
        case <span title="scalaz.stream.Process.Emit[O]">emt</span>@Emit<span class="delimiter">(</span><span title="Seq[O]">os</span><span class="delimiter">)</span> if <span title="Seq[O]">os</span>.<span title="=&gt; Boolean">isEmpty</span> =&gt; <a href="#scalaz.stream.Process.halt0" title="=&gt; scalaz.stream.Process.Halt">halt0</a>
        case <span title="scalaz.stream.Process.Emit[O]">emt</span>@Emit<span class="delimiter">(</span><span title="Seq[O]">os</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Step.readResolve" title="(head: scalaz.stream.Process.EmitOrAwait[Nothing,O], next: scalaz.stream.Process.Cont[Nothing,O])scalaz.stream.Process.Step[Nothing,O]">Step</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Emit[O]">emt</span>,<a href="#scalaz.stream.Process;Cont" title="(stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[Nothing,Nothing]]])scalaz.stream.Process.Cont[Nothing,Nothing]">Cont</a><span class="delimiter">(</span><span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case <span title="scalaz.stream.Process.Await[F,Any,O]">awt</span>@Await<span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Step.readResolve" title="(head: scalaz.stream.Process.EmitOrAwait[F,O], next: scalaz.stream.Process.Cont[F,O])scalaz.stream.Process.Step[F,O]">Step</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Await[F,Any,O]">awt</span>,<a href="#scalaz.stream.Process;Cont" title="(stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[Nothing,Nothing]]])scalaz.stream.Process.Cont[Nothing,Nothing]">Cont</a><span class="delimiter">(</span><span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case Append<span class="delimiter">(</span><span title="scalaz.stream.Process.HaltEmitOrAwait[F,O]">h</span>,<span title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">st</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.step.go" title="(cur: scalaz.stream.Process[F,O], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]], cnt: Int)scalaz.stream.Process.HaltOrStep[F,O]">go</a><span class="delimiter">(</span><span title="scalaz.stream.Process.HaltEmitOrAwait[F,O]">h</span>,<span title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">st</span>, <a href="#scalaz.stream;Process.step.go.cnt" title="Int">cnt</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#scalaz.stream;Process.step.go" title="(cur: scalaz.stream.Process[F,O], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]], cnt: Int)scalaz.stream.Process.HaltOrStep[F,O]">go</a><span class="delimiter">(</span>this,<span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span>, <span title="Int(10)" class="int">10</span><span class="delimiter">)</span>   <span class="comment">// *any* value &gt;= 1 works here. higher values improve throughput but reduce concurrency and fairness. 10 is a totally wild guess</span>

  <span class="delimiter">}</span>

  <span class="comment">/**
   * `p.suspendStep` propagates exceptions to `p`.
   */</span>
  final def <a title="=&gt; scalaz.stream.Process0[scalaz.stream.Process.HaltOrStep[F,O]]" id="scalaz.stream;Process.suspendStep">suspendStep</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[scalaz.stream.Process.HaltOrStep[F,O]]">Process0</a><span class="delimiter">[</span>HaltOrStep<span class="delimiter">[</span>F, O<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a> <a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[Nothing,scalaz.stream.Process.HaltOrStep[F,O]])scalaz.stream.Process[Nothing,scalaz.stream.Process.HaltOrStep[F,O]]">onHalt</a> <a href="#scalaz.stream;Process.suspendStep.$anonfun.x0$2" title="scalaz.stream.Process0[scalaz.stream.Process.HaltOrStep[F,O]]" class="delimiter">{</a>
      case <a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a> =&gt; <a href="#scalaz.stream.Process.emit" title="(o: scalaz.stream.Process.HaltOrStep[F,O])scalaz.stream.Process0[scalaz.stream.Process.HaltOrStep[F,O]]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[F,O]">step</a><span class="delimiter">)</span>
      case <a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream;Process.suspendStep.$anonfun.early">early</a>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a> =&gt; <a href="#scalaz.stream.Process.emit" title="(o: scalaz.stream.Process.HaltOrStep[F,O])scalaz.stream.Process0[scalaz.stream.Process.HaltOrStep[F,O]]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.injectCause" title="(early: scalaz.stream.Cause.EarlyCause)scalaz.stream.Process[F,O]">injectCause</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.suspendStep.$anonfun.early" title="scalaz.stream.Cause.EarlyCause">early</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[F,O]">step</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * When this `Process` halts, call `f` to produce the next state.
   * Note that this function may be used to swallow or handle errors.
   */</span>
  final def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](f: scalaz.stream.Cause =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.onHalt">onHalt</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.onHalt;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.onHalt;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream;Process.onHalt;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Cause =&gt; scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.onHalt.f">f</a>: Cause =&gt; Process<span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> = <span class="delimiter">{</span>
     val <a title="scalaz.stream.Cause =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]]" id="scalaz.stream;Process.onHalt.next">next</a> = <span class="delimiter">(</span>t: <a href="Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Trampoline" title="=&gt; scalaz.Trampoline.type">Trampoline</a>.<span title="(a: =&gt; scalaz.stream.Process[F2,O2])scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]]">delay</span><span class="delimiter">(</span><a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.onHalt.f" title="(v1: scalaz.stream.Cause)scalaz.stream.Process[F2,O2]">f</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.onHalt.next.$anonfun.t" title="scalaz.stream.Cause">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
     this match <span class="delimiter">{</span>
       case <span class="delimiter">(</span><a title="&lt;refinement of scalaz.stream.Process[F,O] with scalaz.stream.Process.Append[F2,O2] @unchecked&gt; extends scalaz.stream.Process[F,O] with scalaz.stream.Process.Append[F2,O2] @unchecked" id="scalaz.stream;Process.onHalt.append">append</a>: Append<span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> @<a href="#scalaz.stream.Process.Append.readResolve" title="scalaz.stream.Process.Append[F2,O2] @unchecked">unchecked</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Append.readResolve" title="(head: scalaz.stream.Process.HaltEmitOrAwait[F2,O2], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]])scalaz.stream.Process.Append[F2,O2]">Append</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.onHalt.append" title="&lt;refinement of scalaz.stream.Process[F,O] with scalaz.stream.Process.Append[F2,O2] @unchecked&gt; extends scalaz.stream.Process[F,O] with scalaz.stream.Process.Append[F2,O2] @unchecked">append</a>.<a href="#scalaz.stream.Process;Append.head" title="=&gt; scalaz.stream.Process.HaltEmitOrAwait[F2,O2]">head</a>, <a href="#scalaz.stream;Process.onHalt.append" title="&lt;refinement of scalaz.stream.Process[F,O] with scalaz.stream.Process.Append[F2,O2] @unchecked&gt; extends scalaz.stream.Process[F,O] with scalaz.stream.Process.Append[F2,O2] @unchecked">append</a>.<a href="#scalaz.stream.Process;Append.stack" title="=&gt; Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]]">stack</a> <span title="(elem: scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]],scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]],Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]]])Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]]">:+</span> <a href="#scalaz.stream;Process.onHalt.next" title="scalaz.stream.Cause =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]]">next</a><span class="delimiter">)</span>
       case <a title="scalaz.stream.Process.Emit[O]" id="scalaz.stream;Process.onHalt.emt">emt</a>@Emit<span class="delimiter">(</span>_<span class="delimiter">)</span>      =&gt; <a href="#scalaz.stream.Process.Append.readResolve" title="(head: scalaz.stream.Process.HaltEmitOrAwait[F2,O2], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]])scalaz.stream.Process.Append[F2,O2]">Append</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.onHalt.emt" title="scalaz.stream.Process.Emit[O]">emt</a>, <span title="(elems: scalaz.stream.Cause =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]]*)scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]]]">Vector</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.onHalt.next" title="scalaz.stream.Cause =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]]">next</a><span class="delimiter">)</span><span class="delimiter">)</span>
       case <a title="scalaz.stream.Process.Await[F,Any,O]" id="scalaz.stream;Process.onHalt.awt">awt</a>@Await<span class="delimiter">(</span>_, _<span class="delimiter">)</span>  =&gt; <a href="#scalaz.stream.Process.Append.readResolve" title="(head: scalaz.stream.Process.HaltEmitOrAwait[F2,O2], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]])scalaz.stream.Process.Append[F2,O2]">Append</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.onHalt.awt" title="scalaz.stream.Process.Await[F,Any,O]">awt</a>, <span title="(elems: scalaz.stream.Cause =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]]*)scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]]]">Vector</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.onHalt.next" title="scalaz.stream.Cause =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]]">next</a><span class="delimiter">)</span><span class="delimiter">)</span>
       case <a title="scalaz.stream.Process.Halt" id="scalaz.stream;Process.onHalt.hlt">hlt</a>@Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream;Process.onHalt.rsn">rsn</a><span class="delimiter">)</span>    =&gt; <a href="#scalaz.stream.Process.Append.readResolve" title="(head: scalaz.stream.Process.HaltEmitOrAwait[F2,O2], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]])scalaz.stream.Process.Append[F2,O2]">Append</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.onHalt.hlt" title="scalaz.stream.Process.Halt">hlt</a>, <span title="(elems: scalaz.stream.Cause =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]]*)scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]]]">Vector</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.onHalt.next" title="scalaz.stream.Cause =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]]">next</a><span class="delimiter">)</span><span class="delimiter">)</span>
     <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  <span class="comment">//////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="comment">//</span>
  <span class="comment">// Pipe and Tee</span>
  <span class="comment">//</span>
  <span class="comment">/////////////////////////////////////////////////////////////////////////////////////</span>


  <span class="comment">/**
   * Feed the output of this `Process` as input of `p1`. The implementation
   * will fuse the two processes, so this process will only generate
   * values as they are demanded by `p1`. If `p1` signals termination, `this`
   * is killed with same reason giving it an opportunity to cleanup.
   */</span>
  final def <a title="[O2](p1: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process.pipe">pipe</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.pipe;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[O,O2]" id="scalaz.stream;Process.pipe.p1">p1</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[O,O2]">Process1</a><span class="delimiter">[</span>O, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F, O2<span class="delimiter">]</span> =
    <a href="#scalaz.stream;Process.pipe.p1" title="scalaz.stream.Process1[O,O2]">p1</a>.<a href="#scalaz.stream;Process.suspendStep" title="=&gt; scalaz.stream.Process0[scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[O,Any]#Is,O2]]">suspendStep</a>.<a href="#scalaz.stream;Process.flatMap" title="(f: scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[O,Any]#Is,O2] =&gt; scalaz.stream.Process[F,O2])scalaz.stream.Process[F,O2]">flatMap</a><span class="delimiter">(</span><span class="delimiter">{</span> <a title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[O,Any]#Is,O2]" id="scalaz.stream;Process.pipe.$anonfun.s1">s1</a> =&gt;
      <a href="#scalaz.stream;Process.pipe.$anonfun.s1" title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[O,Any]#Is,O2]">s1</a> match <span class="delimiter">{</span>
        case <a title="scalaz.stream.Process.Step[scalaz.stream.Process.Env[O,Any]#Is,O2]" id="scalaz.stream;Process.pipe.$anonfun.s">s</a>@Step<span class="delimiter">(</span><a title="scalaz.stream.Process.EmitOrAwait[scalaz.stream.Process.Env[O,Any]#Is,O2]" id="scalaz.stream;Process.pipe.$anonfun.awt1">awt1</a>@<a href="process1.scala.html#scalaz.stream.process1.Await1.unapply" title="(self: scalaz.stream.Process1[O,O2])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,O] =&gt; scalaz.stream.Process1[O,O2]]">Await1</a><span class="delimiter">(</span><a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,O] =&gt; scalaz.stream.Process1[O,O2]" id="scalaz.stream;Process.pipe.$anonfun.rcv1">rcv1</a><span class="delimiter">)</span>, <a title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[O,Any]#Is,O2]" id="scalaz.stream;Process.pipe.$anonfun.cont1">cont1</a><span class="delimiter">)</span> =&gt;
          val <a title="scalaz.stream.Process[scalaz.stream.Process.Env[O,Any]#Is,O2]" id="scalaz.stream;Process.pipe.$anonfun.nextP1">nextP1</a> = <a href="#scalaz.stream;Process.pipe.$anonfun.s" title="scalaz.stream.Process.Step[scalaz.stream.Process.Env[O,Any]#Is,O2]">s</a>.<a href="#scalaz.stream.Process;Step.toProcess" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[O,Any]#Is,O2]">toProcess</a>
          this.<a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[F,O]">step</a> match <span class="delimiter">{</span>
            case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.Await[F,Any,O]" id="scalaz.stream;Process.pipe.$anonfun.awt">awt</a>@Await<span class="delimiter">(</span>_, _<span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.pipe.$anonfun.awt" title="scalaz.stream.Process.Await[F,Any,O]">awt</a>.<a href="#scalaz.stream.Process;Await.extend" title="(f: scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[[x]F[x],O2])scalaz.stream.Process.Await[[x]F[x],Any,O2]">extend</a><span class="delimiter">(</span><a title="scalaz.stream.Process[F,O]" id="scalaz.stream;Process.pipe.$anonfun.$anonfun.p">p</a> =&gt; <span class="delimiter">(</span><a href="#scalaz.stream;Process.pipe.$anonfun.$anonfun.p" title="scalaz.stream.Process[F,O]">p</a> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span> <a href="#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[O,O2])scalaz.stream.Process[[x]F[x],O2]">pipe</a> <a href="#scalaz.stream;Process.pipe.$anonfun.nextP1" title="scalaz.stream.Process[scalaz.stream.Process.Env[O,Any]#Is,O2]">nextP1</a><span class="delimiter">)</span>
            case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><span title="Seq[O]">os</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span>        =&gt; <span title="scalaz.stream.Process.Cont[F,O]">cont</span>.<a href="#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[F,O]">continue</a> <a href="#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">pipe</a> <a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="process1.scala.html#scalaz.stream.process1.feed" title="(i: Seq[O])(p: scalaz.stream.Process1[O,O2])scalaz.stream.Process1[O,O2]">feed</a><span class="delimiter">(</span><span title="Seq[O]">os</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.pipe.$anonfun.nextP1" title="scalaz.stream.Process[scalaz.stream.Process.Env[O,Any]#Is,O2]">nextP1</a><span class="delimiter">)</span>
            case <span title="scalaz.stream.Process.Halt">hlt</span>@Halt<span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span>               =&gt; <span title="scalaz.stream.Process.Halt">hlt</span> <a href="#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[Nothing,O2])scalaz.stream.Process[Nothing,O2]">pipe</a> <a href="#scalaz.stream;Process.pipe.$anonfun.nextP1" title="scalaz.stream.Process[scalaz.stream.Process.Env[O,Any]#Is,O2]">nextP1</a>.<a href="#scalaz.stream;Process.disconnect" title="(cause: scalaz.stream.Cause.EarlyCause)scalaz.stream.Process0[O2]">disconnect</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.swallowKill" title="=&gt; scalaz.stream.Process[Nothing,O2]">swallowKill</a>
            case <span title="scalaz.stream.Process.Halt">hlt</span>@Halt<span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">rsn</span>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a><span class="delimiter">)</span>   =&gt; <span title="scalaz.stream.Process.Halt">hlt</span> <a href="#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[Nothing,O2])scalaz.stream.Process[Nothing,O2]">pipe</a> <a href="#scalaz.stream;Process.pipe.$anonfun.nextP1" title="scalaz.stream.Process[scalaz.stream.Process.Env[O,Any]#Is,O2]">nextP1</a>.<a href="#scalaz.stream;Process.disconnect" title="(cause: scalaz.stream.Cause.EarlyCause)scalaz.stream.Process0[O2]">disconnect</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">rsn</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>

        case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.Emit[O2]" id="scalaz.stream;Process.pipe.$anonfun.emt">emt</a>@Emit<span class="delimiter">(</span><span title="Seq[O2]">os</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[O,Any]#Is,O2]">cont</span><span class="delimiter">)</span>      =&gt;
          <span class="comment">// When the pipe is killed from the outside it is killed at the beginning or after emit.</span>
          <span class="comment">// This ensures that Kill from the outside is not swallowed.</span>
          <a href="#scalaz.stream;Process.pipe.$anonfun.emt" title="scalaz.stream.Process.Emit[O2]">emt</a> <a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[F,O2])scalaz.stream.Process[F,O2]">onHalt</a> <a href="#scalaz.stream;Process.pipe.$anonfun.$anonfun.x0$3" title="scalaz.stream.Process[F,O2]" class="delimiter">{</a>
            case <a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a> =&gt; this.<a href="#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">pipe</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[O,Any]#Is,O2]">cont</span>.<a href="#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[O,Any]#Is,O2]">continue</a><span class="delimiter">)</span>
            case <a title="scalaz.stream.Cause" id="scalaz.stream;Process.pipe.$anonfun.$anonfun.early">early</a> =&gt; this.<a href="#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">pipe</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.pipe.$anonfun.$anonfun.early" title="scalaz.stream.Cause">early</a><span class="delimiter">)</span> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[O,Any]#Is[x],O2])scalaz.stream.Process[[x]scalaz.stream.Process.Env[O,Any]#Is[x],O2]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[O,Any]#Is,O2]">cont</span><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Process[F,O2]">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.pipe.$anonfun.$anonfun.early" title="scalaz.stream.Cause">early</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>

        case Halt<span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span><span class="delimiter">)</span>           =&gt; this.<a href="#scalaz.stream;Process.kill" title="=&gt; scalaz.stream.Process[F,Nothing]">kill</a> <a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[[x]F[x],Nothing])scalaz.stream.Process[[x]F[x],Nothing]">onHalt</a> <span class="delimiter">{</span> <a title="scalaz.stream.Cause" id="scalaz.stream;Process.pipe.$anonfun.$anonfun.x$5">_</a> =&gt; <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="comment">/** Operator alias for `pipe`. */</span>
  final def <a title="[O2](p2: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process.|>">|&gt;</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.|>;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[O,O2]" id="scalaz.stream;Process.|>.p2">p2</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[O,O2]">Process1</a><span class="delimiter">[</span>O, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F, O2<span class="delimiter">]</span> = <a href="#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[O,O2])scalaz.stream.Process[F,O2]">pipe</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.|>.p2" title="scalaz.stream.Process1[O,O2]">p2</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Use a `Tee` to interleave or combine the outputs of `this` and
   * `p2`. This can be used for zipping, interleaving, and so forth.
   * Nothing requires that the `Tee` read elements from each
   * `Process` in lockstep. It could read fifty elements from one
   * side, then two elements from the other, then combine or
   * interleave these values in some way, etc.
   *
   * If at any point the `Tee` awaits on a side that has halted,
   * we gracefully kill off the other side, then halt.
   *
   * If at any point `t` terminates with cause `c`, both sides are killed, and
   * the resulting `Process` terminates with `c`.
   */</span>
  final def <a title="[F2[x] &gt;: F[x], O2, O3](p2: scalaz.stream.Process[F2,O2])(t: scalaz.stream.Tee[O,O2,O3])scalaz.stream.Process[F2,O3]" id="scalaz.stream;Process.tee">tee</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.tee;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.tee;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title="" id="scalaz.stream;Process.tee;O2">O2</a>, <a title="" id="scalaz.stream;Process.tee;O3">O3</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.tee.p2">p2</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Tee[O,O2,O3]" id="scalaz.stream;Process.tee.t">t</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Tee[O,O2,O3]">Tee</a><span class="delimiter">[</span>O, O2, O3<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O3]">Process</a><span class="delimiter">[</span>F2, O3<span class="delimiter">]</span> = <span class="delimiter">{</span>
    import scalaz.stream.<a href="tee.scala.html#scalaz.stream.tee" title="scalaz.stream.tee.type">tee</a>.<span class="delimiter">{</span>AwaitL, AwaitR, disconnectL, disconnectR, feedL, feedR<span class="delimiter">}</span>
    <a href="#scalaz.stream;Process.tee.t" title="scalaz.stream.Tee[O,O2,O3]">t</a>.<a href="#scalaz.stream;Process.suspendStep" title="=&gt; scalaz.stream.Process0[scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[O,O2]#T,O3]]">suspendStep</a> <a href="#scalaz.stream;Process.flatMap" title="(f: scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[O,O2]#T,O3] =&gt; scalaz.stream.Process[F2,O3])scalaz.stream.Process[F2,O3]">flatMap</a> <span class="delimiter">{</span> <a title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[O,O2]#T,O3]" id="scalaz.stream;Process.tee.$anonfun.ts">ts</a> =&gt;
      <a href="#scalaz.stream;Process.tee.$anonfun.ts" title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[O,O2]#T,O3]">ts</a> match <span class="delimiter">{</span>
        case <span title="scalaz.stream.Process.Step[scalaz.stream.Process.Env[O,O2]#T,O3]">s</span>@Step<span class="delimiter">(</span><a href="tee.scala.html#scalaz.stream.tee.AwaitL.unapply" title="(self: scalaz.stream.tee.TeeAwaitL[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Tee[I,I2,O]]">AwaitL</a><span class="delimiter">(</span>_<span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[O,O2]#T,O3]">contT</span><span class="delimiter">)</span> =&gt; this.<a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[F,O]">step</a> match <span class="delimiter">{</span>
          case Step<span class="delimiter">(</span><span title="scalaz.stream.Process.Await[F,Any,O]">awt</span>@Await<span class="delimiter">(</span><a title="F[Any]" id="scalaz.stream;Process.tee.$anonfun.rq">rq</a>, <a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]" id="scalaz.stream;Process.tee.$anonfun.rcv">rcv</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[F,O]">contL</span><span class="delimiter">)</span> =&gt; <span title="scalaz.stream.Process.Await[F,Any,O]">awt</span>.<a href="#scalaz.stream.Process;Await.extend" title="(f: scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[F2,O3])scalaz.stream.Process.Await[F2,Any,O3]">extend</a> <span class="delimiter">{</span> <a title="scalaz.stream.Process[F,O]" id="scalaz.stream;Process.tee.$anonfun.$anonfun.p">p</a> =&gt; <span class="delimiter">(</span><a href="#scalaz.stream;Process.tee.$anonfun.$anonfun.p" title="scalaz.stream.Process[F,O]">p</a>  <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[F,O]">contL</span><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.tee" title="(p2: scalaz.stream.Process[F2,O2])(t: scalaz.stream.Tee[O,O2,O3])scalaz.stream.Process[F2,O3]">tee</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.tee.p2" title="scalaz.stream.Process[F2,O2]">p2</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.stream.Process.Step[scalaz.stream.Process.Env[O,O2]#T,O3]">s</span>.<a href="#scalaz.stream.Process;Step.toProcess" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[O,O2]#T,O3]">toProcess</a><span class="delimiter">)</span> <span class="delimiter">}</span>
          case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream;Process.tee.$anonfun.os">os</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[F,O]">contL</span><span class="delimiter">)</span>           =&gt; <span title="scalaz.stream.Process.Cont[F,O]">contL</span>.<a href="#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[F,O]">continue</a>.<a href="#scalaz.stream;Process.tee" title="(p2: scalaz.stream.Process[F2,O2])(t: scalaz.stream.Tee[O,O2,O3])scalaz.stream.Process[F2,O3]">tee</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.tee.p2" title="scalaz.stream.Process[F2,O2]">p2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="tee.scala.html#scalaz.stream.tee.feedL" title="[I, I2, O](i: Seq[I])(p: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">feedL</a><span title="(i: Seq[O])(p: scalaz.stream.Tee[O,O2,O3])scalaz.stream.Tee[O,O2,O3]" class="delimiter">[</span><a href="#scalaz.stream;Process;O" title="O">O</a>, <a href="#scalaz.stream;Process.tee;O2" title="O2">O2</a>, <a href="#scalaz.stream;Process.tee;O3" title="O3">O3</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.tee.$anonfun.os" title="Seq[O]">os</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.stream.Process.Step[scalaz.stream.Process.Env[O,O2]#T,O3]">s</span>.<a href="#scalaz.stream.Process;Step.toProcess" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[O,O2]#T,O3]">toProcess</a><span class="delimiter">)</span><span class="delimiter">)</span>
          case <span title="scalaz.stream.Process.Halt">hlt</span>@Halt<span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span>              =&gt; <span title="scalaz.stream.Process.Halt">hlt</span>.<a href="#scalaz.stream;Process.tee" title="(p2: scalaz.stream.Process[F2,O2])(t: scalaz.stream.Tee[Nothing,O2,O3])scalaz.stream.Process[F2,O3]">tee</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.tee.p2" title="scalaz.stream.Process[F2,O2]">p2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="tee.scala.html#scalaz.stream.tee.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(tee: scalaz.stream.Tee[Nothing,O2,O3])scalaz.stream.Tee[Nothing,O2,O3]">disconnectL</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.stream.Process.Step[scalaz.stream.Process.Env[O,O2]#T,O3]">s</span>.<a href="#scalaz.stream.Process;Step.toProcess" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[O,O2]#T,O3]">toProcess</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.swallowKill" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Nothing,O2]#T,O3]">swallowKill</a><span class="delimiter">)</span>
          case <span title="scalaz.stream.Process.Halt">hlt</span>@Halt<span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">rsn</span>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a><span class="delimiter">)</span>  =&gt; <span title="scalaz.stream.Process.Halt">hlt</span>.<a href="#scalaz.stream;Process.tee" title="(p2: scalaz.stream.Process[F2,O2])(t: scalaz.stream.Tee[Nothing,O2,O3])scalaz.stream.Process[F2,O3]">tee</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.tee.p2" title="scalaz.stream.Process[F2,O2]">p2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="tee.scala.html#scalaz.stream.tee.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(tee: scalaz.stream.Tee[Nothing,O2,O3])scalaz.stream.Tee[Nothing,O2,O3]">disconnectL</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">rsn</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.stream.Process.Step[scalaz.stream.Process.Env[O,O2]#T,O3]">s</span>.<a href="#scalaz.stream.Process;Step.toProcess" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[O,O2]#T,O3]">toProcess</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        case <span title="scalaz.stream.Process.Step[scalaz.stream.Process.Env[O,O2]#T,O3]">s</span>@Step<span class="delimiter">(</span><a href="tee.scala.html#scalaz.stream.tee.AwaitR.unapply" title="(self: scalaz.stream.tee.TeeAwaitR[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Tee[I,I2,O]]">AwaitR</a><span class="delimiter">(</span>_<span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[O,O2]#T,O3]">contT</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.tee.p2" title="scalaz.stream.Process[F2,O2]">p2</a>.<a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[F2,O2]">step</a> match <span class="delimiter">{</span>
          case <a title="scalaz.stream.Process.Step[F2,O2] @unchecked" id="scalaz.stream;Process.tee.$anonfun.s2">s2</a>: Step<span class="delimiter">[</span>F2, O2<span class="delimiter">]</span>@<a href="#scalaz.stream.Process.Step.readResolve" title="scalaz.stream.Process.Step[F2,O2] @unchecked">unchecked</a> =&gt;
            <span title="(_1: scalaz.stream.Process.EmitOrAwait[F2,O2], _2: scalaz.stream.Process.Cont[F2,O2])(scalaz.stream.Process.EmitOrAwait[F2,O2], scalaz.stream.Process.Cont[F2,O2])" class="delimiter">(</span><a href="#scalaz.stream;Process.tee.$anonfun.s2" title="scalaz.stream.Process.Step[F2,O2] @unchecked">s2</a>.<a href="#scalaz.stream.Process;Step.head" title="=&gt; scalaz.stream.Process.EmitOrAwait[F2,O2]">head</a>, <a href="#scalaz.stream;Process.tee.$anonfun.s2" title="scalaz.stream.Process.Step[F2,O2] @unchecked">s2</a>.<a href="#scalaz.stream.Process;Step.next" title="=&gt; scalaz.stream.Process.Cont[F2,O2]">next</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
              case <span class="delimiter">(</span><span title="scalaz.stream.Process.Await[F2,Any,O2] @unchecked">awt</span>: Await<span class="delimiter">[</span>F2, Any, O2<span class="delimiter">]</span>@<a href="#scalaz.stream.Process.Await.readResolve" title="scalaz.stream.Process.Await[F2,Any,O2] @unchecked">unchecked</a>, <span title="scalaz.stream.Process.Cont[F2,O2]">contR</span><span class="delimiter">)</span> =&gt;
                <span title="scalaz.stream.Process.Await[F2,Any,O2] @unchecked">awt</span>.<a href="#scalaz.stream.Process;Await.extend" title="(f: scalaz.stream.Process[F2,O2] =&gt; scalaz.stream.Process[[x]F2[x],O3])scalaz.stream.Process.Await[[x]F2[x],Any,O3]">extend</a> <span class="delimiter">{</span> <span class="delimiter">(</span>p: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; this.<a href="#scalaz.stream;Process.tee" title="(p2: scalaz.stream.Process[F2,O2])(t: scalaz.stream.Tee[O,O2,O3])scalaz.stream.Process[F2,O3]">tee</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.tee.$anonfun.$anonfun.p" title="scalaz.stream.Process[F2,O2]">p</a> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]F2[x],O2])scalaz.stream.Process[[x]F2[x],O2]">+:</a> <span title="scalaz.stream.Process.Cont[F2,O2]">contR</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.stream.Process.Step[scalaz.stream.Process.Env[O,O2]#T,O3]">s</span>.<a href="#scalaz.stream.Process;Step.toProcess" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[O,O2]#T,O3]">toProcess</a><span class="delimiter">)</span> <span class="delimiter">}</span>
              case <span class="delimiter">(</span>Emit<span class="delimiter">(</span><a title="Seq[O2]" id="scalaz.stream;Process.tee.$anonfun.o2s">o2s</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[F2,O2]">contR</span><span class="delimiter">)</span> =&gt;
                this.<a href="#scalaz.stream;Process.tee" title="(p2: scalaz.stream.Process[F2,O2])(t: scalaz.stream.Tee[O,O2,O3])scalaz.stream.Process[F2,O3]">tee</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Cont[F2,O2]">contR</span>.<a href="#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[F2,O2]">continue</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scalaz.stream.Process[F2,O2]" class="delimiter">[</span><a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2,O2<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="tee.scala.html#scalaz.stream.tee.feedR" title="[I, I2, O](i: Seq[I2])(p: scalaz.stream.Tee[I,I2,O])scalaz.stream.Tee[I,I2,O]">feedR</a><span title="(i: Seq[O2])(p: scalaz.stream.Tee[O,O2,O3])scalaz.stream.Tee[O,O2,O3]" class="delimiter">[</span><a href="#scalaz.stream;Process;O" title="O">O</a>, <a href="#scalaz.stream;Process.tee;O2" title="O2">O2</a>, <a href="#scalaz.stream;Process.tee;O3" title="O3">O3</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.tee.$anonfun.o2s" title="Seq[O2]">o2s</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.stream.Process.Step[scalaz.stream.Process.Env[O,O2]#T,O3]">s</span>.<a href="#scalaz.stream.Process;Step.toProcess" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[O,O2]#T,O3]">toProcess</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          case <span title="scalaz.stream.Process.Halt">hlt</span>@Halt<span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span>              =&gt; this.<a href="#scalaz.stream;Process.tee" title="(p2: scalaz.stream.Process[[x]F[x],Nothing])(t: scalaz.stream.Tee[O,Nothing,O3])scalaz.stream.Process[[x]F[x],O3]">tee</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Halt">hlt</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="tee.scala.html#scalaz.stream.tee.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(tee: scalaz.stream.Tee[O,Nothing,O3])scalaz.stream.Tee[O,Nothing,O3]">disconnectR</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.stream.Process.Step[scalaz.stream.Process.Env[O,O2]#T,O3]">s</span>.<a href="#scalaz.stream.Process;Step.toProcess" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[O,O2]#T,O3]">toProcess</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.swallowKill" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[O,Nothing]#T,O3]">swallowKill</a><span class="delimiter">)</span>
          case <span title="scalaz.stream.Process.Halt">hlt</span>@Halt<span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">rsn</span> : <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a><span class="delimiter">)</span> =&gt; this.<a href="#scalaz.stream;Process.tee" title="(p2: scalaz.stream.Process[[x]F[x],Nothing])(t: scalaz.stream.Tee[O,Nothing,O3])scalaz.stream.Process[[x]F[x],O3]">tee</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Halt">hlt</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="tee.scala.html#scalaz.stream.tee.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(tee: scalaz.stream.Tee[O,Nothing,O3])scalaz.stream.Tee[O,Nothing,O3]">disconnectR</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">rsn</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.stream.Process.Step[scalaz.stream.Process.Env[O,O2]#T,O3]">s</span>.<a href="#scalaz.stream.Process;Step.toProcess" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[O,O2]#T,O3]">toProcess</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.Emit[O3]" id="scalaz.stream;Process.tee.$anonfun.emt">emt</a>@Emit<span class="delimiter">(</span><a title="Seq[O3]" id="scalaz.stream;Process.tee.$anonfun.o3s">o3s</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[O,O2]#T,O3]">contT</span><span class="delimiter">)</span> =&gt;
          <span class="comment">// When the process is killed from the outside it is killed at the beginning or after emit.</span>
          <span class="comment">// This ensures that Kill from the outside isn't swallowed.</span>
          <a href="#scalaz.stream;Process.tee.$anonfun.emt" title="scalaz.stream.Process.Emit[O3]">emt</a> <a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[F2,O3])scalaz.stream.Process[F2,O3]">onHalt</a> <a href="#scalaz.stream;Process.tee.$anonfun.$anonfun.x0$4" title="scalaz.stream.Process[F2,O3]" class="delimiter">{</a>
            case <a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a> =&gt; this.<a href="#scalaz.stream;Process.tee" title="(p2: scalaz.stream.Process[F2,O2])(t: scalaz.stream.Tee[O,O2,O3])scalaz.stream.Process[F2,O3]">tee</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.tee.p2" title="scalaz.stream.Process[F2,O2]">p2</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[O,O2]#T,O3]">contT</span>.<a href="#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[O,O2]#T,O3]">continue</a><span class="delimiter">)</span>
            case <a title="scalaz.stream.Cause" id="scalaz.stream;Process.tee.$anonfun.$anonfun.early">early</a> =&gt; this.<a href="#scalaz.stream;Process.tee" title="(p2: scalaz.stream.Process[F2,O2])(t: scalaz.stream.Tee[O,O2,O3])scalaz.stream.Process[F2,O3]">tee</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.tee.p2" title="scalaz.stream.Process[F2,O2]">p2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.tee.$anonfun.$anonfun.early" title="scalaz.stream.Cause">early</a><span class="delimiter">)</span> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[O,O2]#T[x],O3])scalaz.stream.Process[[x]scalaz.stream.Process.Env[O,O2]#T[x],O3]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[O,O2]#T,O3]">contT</span><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Process[F2,O3]">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.tee.$anonfun.$anonfun.early" title="scalaz.stream.Cause">early</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>

        case Halt<span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span><span class="delimiter">)</span>             =&gt; this.<a href="#scalaz.stream;Process.kill" title="=&gt; scalaz.stream.Process[F,Nothing]">kill</a> <a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[F2,Nothing])scalaz.stream.Process[F2,Nothing]">onHalt</a> <span class="delimiter">{</span> <a title="scalaz.stream.Cause" id="scalaz.stream;Process.tee.$anonfun.$anonfun.x$9">_</a> =&gt; <a href="#scalaz.stream;Process.tee.p2" title="scalaz.stream.Process[F2,O2]">p2</a>.<a href="#scalaz.stream;Process.kill" title="=&gt; scalaz.stream.Process[F2,Nothing]">kill</a> <a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[[x]F2[x],Nothing])scalaz.stream.Process[[x]F2[x],Nothing]">onHalt</a> <span class="delimiter">{</span> <a title="scalaz.stream.Cause" id="scalaz.stream;Process.tee.$anonfun.$anonfun.$anonfun.x$10">_</a> =&gt; <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span><span class="delimiter">)</span> <span class="delimiter">}</span> <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  <span class="comment">//////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="comment">//</span>
  <span class="comment">// Alphabetically, Other combinators</span>
  <span class="comment">//</span>
  <span class="comment">/////////////////////////////////////////////////////////////////////////////////////</span>

  <span class="comment">/**
   * Catch exceptions produced by this `Process`, not including termination by `Continue`, `End`, `Kill`
   * and uses `f` to decide whether to resume a second process.
   */</span>
  final def <a title="[F2[x] &gt;: F[x], O2](f: Throwable =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,scalaz.\/[O2,O]]" id="scalaz.stream;Process.attempt">attempt</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.attempt$default$1;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.attempt$default$1;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title="" id="scalaz.stream;Process.attempt$default$1;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span>
    <a title="Throwable =&gt; scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.attempt$default$1">f</a>: Throwable =&gt; Process<span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> = <span class="delimiter">(</span>t: <span title="Throwable">Throwable</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.emit" title="(o: Throwable)scalaz.stream.Process0[Throwable]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.attempt.f.$anonfun.t" title="Throwable">t</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,scalaz.\/[O2,O]]">Process</a><span class="delimiter">[</span>F2, O2 \/ O<span class="delimiter">]</span> =
    this.<a href="#scalaz.stream;Process.map" title="(f: O =&gt; scalaz.\/[Nothing,O])scalaz.stream.Process[F,scalaz.\/[Nothing,O]]">map</a><span class="delimiter">(</span><span title="O =&gt; scalaz.\/[Nothing,O]">right</span><span class="delimiter">)</span> <a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[F2,scalaz.\/[O2,O]])scalaz.stream.Process[F2,scalaz.\/[O2,O]]">onHalt</a> <a href="#scalaz.stream;Process.attempt.$anonfun.x0$5" title="scalaz.stream.Process[F2,scalaz.\/[O2,O]]" class="delimiter">{</a>
      case Error<span class="delimiter">(</span><a title="Throwable" id="scalaz.stream;Process.attempt.$anonfun.t">t</a><span class="delimiter">)</span> =&gt; <a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.attempt$default$1" title="(v1: Throwable)scalaz.stream.Process[F2,O2]">f</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.attempt.$anonfun.t" title="Throwable">t</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.map" title="(f: O2 =&gt; scalaz.\/[O2,Nothing])scalaz.stream.Process[F2,scalaz.\/[O2,Nothing]]">map</a><span class="delimiter">(</span><span title="O2 =&gt; scalaz.\/[O2,Nothing]">left</span><span class="delimiter">)</span>
      case <a title="scalaz.stream.Cause" id="scalaz.stream;Process.attempt.$anonfun.rsn">rsn</a>      =&gt; <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.attempt.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Attached `cause` when this Process terminates.  See `Cause.causedBy` for semantics.
   */</span>
  final def <a title="(cause: scalaz.stream.Cause)scalaz.stream.Process[F,O]" id="scalaz.stream;Process.causedBy">causedBy</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream;Process.causedBy.cause">cause</a>: <a href="Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> =
    <a href="#scalaz.stream;Process.causedBy.cause" title="scalaz.stream.Cause">cause</a>.<a href="Cause.scala.html#scalaz.stream;Cause.fold" title="(onEnd: =&gt; scalaz.stream.Process[F,O])(f: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">fold</a><span class="delimiter">(</span>this<span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream;Process.causedBy.$anonfun.ec">ec</a> =&gt; this.<a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">onHalt</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream;Process.causedBy.$anonfun.$anonfun.c">c</a> =&gt; <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.causedBy.$anonfun.$anonfun.c" title="scalaz.stream.Cause">c</a>.<a href="Cause.scala.html#scalaz.stream;Cause.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Cause">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.causedBy.$anonfun.ec" title="scalaz.stream.Cause.EarlyCause">ec</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Used when a `Process1`, `Tee`, or `Wye` is terminated by awaiting
   * on a branch that is in the halted state or was killed. Such a process
   * is given the opportunity to emit any final values. All Awaits are
   * converted to terminate with `cause`
   */</span>
  final def <a title="(cause: scalaz.stream.Cause.EarlyCause)scalaz.stream.Process0[O]" id="scalaz.stream;Process.disconnect">disconnect</a><span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream;Process.disconnect.cause">cause</a>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[O]">Process0</a><span class="delimiter">[</span>O<span class="delimiter">]</span> =
    this.<a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[F,O]">step</a> match <span class="delimiter">{</span>
      case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.Emit[O]" id="scalaz.stream;Process.disconnect.emt">emt</a>@Emit<span class="delimiter">(</span>_<span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span>     =&gt; <a href="#scalaz.stream;Process.disconnect.emt" title="scalaz.stream.Process.Emit[O]">emt</a> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[Nothing,O])scalaz.stream.Process[Nothing,O]">+:</a> <span title="scalaz.stream.Process.Cont[F,O]">cont</span>.<a href="#scalaz.stream.Process;Cont.extend" title="(f: scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[Nothing,O])scalaz.stream.Process.Cont[Nothing,O]">extend</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.disconnect.$anonfun.x$11" title="scalaz.stream.Process[F,O]">_</a>.<a href="#scalaz.stream;Process.disconnect" title="(cause: scalaz.stream.Cause.EarlyCause)scalaz.stream.Process0[O]">disconnect</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.disconnect.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.Await[F,Any,O]" id="scalaz.stream;Process.disconnect.awt">awt</a>@Await<span class="delimiter">(</span>_, <a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]" id="scalaz.stream;Process.disconnect.rcv">rcv</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.suspend" title="(p: =&gt; scalaz.stream.Process[Nothing,O])scalaz.stream.Process[Nothing,O]">suspend</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.disconnect.rcv" title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,Any])scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]">rcv</a><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.disconnect.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Process[F,O]],scalaz.Free.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process[F,O]">run</span><span class="delimiter">)</span> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.disconnect" title="(cause: scalaz.stream.Cause.EarlyCause)scalaz.stream.Process0[O]">disconnect</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.disconnect.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case <a title="scalaz.stream.Process.Halt" id="scalaz.stream;Process.disconnect.hlt">hlt</a>@Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream;Process.disconnect.rsn">rsn</a><span class="delimiter">)</span>           =&gt; <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.disconnect.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Ignore all outputs of this `Process`. */</span>
  final def <a title="=&gt; scalaz.stream.Process[F,Nothing]" id="scalaz.stream;Process.drain">drain</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,Nothing]">Process</a><span class="delimiter">[</span>F, Nothing<span class="delimiter">]</span> = <a href="#scalaz.stream;Process.flatMap" title="(f: O =&gt; scalaz.stream.Process[[x]F[x],Nothing])scalaz.stream.Process[[x]F[x],Nothing]">flatMap</a><span class="delimiter">(</span><a title="O" id="scalaz.stream;Process.drain.$anonfun.x$14">_</a> =&gt; <a href="#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Map over this `Process` to produce a stream of `F`-actions,
   * then evaluate these actions.
   */</span>
  def <a title="[F2[x] &gt;: F[x], O2](f: O =&gt; F2[O2])scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.evalMap">evalMap</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.evalMap;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.evalMap;F2;x">x</a><span class="delimiter">]</span>&gt;:F<span class="delimiter">[</span>x<span class="delimiter">]</span>,<a title="" id="scalaz.stream;Process.evalMap;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; F2[O2]" id="scalaz.stream;Process.evalMap.f">f</a>: O =&gt; F2<span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2,O2<span class="delimiter">]</span> =
    <a href="#scalaz.stream;Process.map" title="(f: O =&gt; F2[O2])scalaz.stream.Process[F,F2[O2]]">map</a><a href="#scalaz.stream.Process.EvalProcess(b6ed143934)" title="(self: scalaz.stream.Process[F2,F2[O2]])scalaz.stream.Process.EvalProcess[F2,O2]" class="delimiter">(</a><a href="#scalaz.stream;Process.evalMap.f" title="O =&gt; F2[O2]">f</a><span class="delimiter">)</span>.<a href="#scalaz.stream.Process;EvalProcess.eval" title="=&gt; scalaz.stream.Process[F2,O2]">eval</a>

  <span class="comment">/** Prepend a sequence of elements to the output of this `Process`. */</span>
  def <a title="[O2 &gt;: O](os: Seq[O2])scalaz.stream.Process[F,O2]" id="scalaz.stream;Process.prepend">prepend</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;Process.prepend;O2">O2</a>&gt;:O<span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[O2]" id="scalaz.stream;Process.prepend.os">os</a>:<span title="Seq[O2]">Seq</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O2]">Process</a><span class="delimiter">[</span>F,O2<span class="delimiter">]</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#scalaz.stream;Process.prepend.os" title="Seq[O2]">os</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#scalaz.stream.Process.emitAll" title="(os: Seq[O2])scalaz.stream.Process0[O2]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.prepend.os" title="Seq[O2]">os</a><span class="delimiter">)</span> <a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[F,O2])scalaz.stream.Process[F,O2]">onHalt</a> <a href="#scalaz.stream;Process.prepend.$anonfun.x0$6" title="scalaz.stream.Process[F,O2]" class="delimiter">{</a>
        case <a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a>               =&gt; this
        case <a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream;Process.prepend.$anonfun.cause">cause</a>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a> =&gt; this.<a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[F,O]">step</a> match <span class="delimiter">{</span>
          case Step<span class="delimiter">(</span>Await<span class="delimiter">(</span>_, <a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]" id="scalaz.stream;Process.prepend.$anonfun.rcv">rcv</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.prepend.$anonfun.rcv" title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,Any])scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]">rcv</a><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.prepend.$anonfun.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Process[F,O]],scalaz.Free.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process[F,O]">run</span><span class="delimiter">)</span> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[F,O]">cont</span>
          case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span>_<span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span>       =&gt; <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.prepend.$anonfun.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[F,O]">cont</span>
          case Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream;Process.prepend.$anonfun.rsn">rsn</a><span class="delimiter">)</span>             =&gt; <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.prepend.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a>.<a href="Cause.scala.html#scalaz.stream;Cause.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Cause">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.prepend.$anonfun.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> else this
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Map over this `Process` to produce a stream of `F`-actions,
   * then evaluate these actions in batches of `bufSize`, allowing
   * for nondeterminism in the evaluation order of each action in the
   * batch.
   */</span>
  def <a title="[F2[x] &gt;: F[x], O2](bufSize: Int)(f: O =&gt; F2[O2])(implicit F: scalaz.Nondeterminism[F2])scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.gatherMap">gatherMap</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.gatherMap;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.gatherMap;F2;x">x</a><span class="delimiter">]</span>&gt;:F<span class="delimiter">[</span>x<span class="delimiter">]</span>,<a title="" id="scalaz.stream;Process.gatherMap;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scalaz.stream;Process.gatherMap.bufSize">bufSize</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="O =&gt; F2[O2]" id="scalaz.stream;Process.gatherMap.f">f</a>: O =&gt; F2<span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>
    implicit <a title="scalaz.Nondeterminism[F2]" id="scalaz.stream;Process.gatherMap.F">F</a>: <span title="scalaz.Nondeterminism[F2]">Nondeterminism</span><span class="delimiter">[</span>F2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2,O2<span class="delimiter">]</span> =
     <a href="#scalaz.stream;Process.map" title="(f: O =&gt; F2[O2])scalaz.stream.Process[F,F2[O2]]">map</a><a href="#scalaz.stream.Process.EvalProcess(b6ed143934)" title="(self: scalaz.stream.Process[F2,F2[O2]])scalaz.stream.Process.EvalProcess[F2,O2]" class="delimiter">(</a><a href="#scalaz.stream;Process.gatherMap.f" title="O =&gt; F2[O2]">f</a><span class="delimiter">)</span>.<a href="#scalaz.stream.Process;EvalProcess.gather" title="(bufSize: Int)(implicit F: scalaz.Nondeterminism[F2])scalaz.stream.Process[F2,O2]">gather</a><a href="#scalaz.stream;Process.gatherMap.F" title="scalaz.Nondeterminism[F2]" class="delimiter">(</a><a href="#scalaz.stream;Process.gatherMap.bufSize" title="Int">bufSize</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Catch some of the exceptions generated by this `Process`, rethrowing any
   * not handled by the given `PartialFunction` and stripping out any values
   * emitted before the error.
   */</span>
  def <a title="[F2[x] &gt;: F[x], O2](f: PartialFunction[Throwable,scalaz.stream.Process[F2,O2]])(implicit F: scalaz.Catchable[F2])scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.handle">handle</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.handle;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.handle;F2;x">x</a><span class="delimiter">]</span>&gt;:F<span class="delimiter">[</span>x<span class="delimiter">]</span>,<a title="" id="scalaz.stream;Process.handle;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[Throwable,scalaz.stream.Process[F2,O2]]" id="scalaz.stream;Process.handle.f">f</a>: <span title="PartialFunction[Throwable,scalaz.stream.Process[F2,O2]]">PartialFunction</span><span class="delimiter">[</span>Throwable, Process<span class="delimiter">[</span>F2,O2<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Catchable[F2]" id="scalaz.stream;Process.handle.F">F</a>: <span title="scalaz.Catchable[F2]">Catchable</span><span class="delimiter">[</span>F2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> =
    <a href="#scalaz.stream;Process.attempt" title="(f: Throwable =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,scalaz.\/[O2,O]]">attempt</a><span class="delimiter">(</span><a title="Throwable" id="scalaz.stream;Process.handle.$anonfun.rsn">rsn</a> =&gt; <a href="#scalaz.stream;Process.handle.f" title="PartialFunction[Throwable,scalaz.stream.Process[F2,O2]]">f</a>.<span title="(v1: Throwable)Option[scalaz.stream.Process[F2,O2]]">lift</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.handle.$anonfun.rsn" title="Throwable">rsn</a><span class="delimiter">)</span>.<span title="(default: =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">getOrElse</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.fail" title="(rsn: Throwable)scalaz.stream.Process0[Nothing]">fail</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.handle.$anonfun.rsn" title="Throwable">rsn</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    .<a href="process1.scala.html#scalaz.stream;Process1Ops.dropWhile" title="(f: scalaz.\/[O2,O] =&gt; Boolean)scalaz.stream.Process[F2,scalaz.\/[O2,O]]">dropWhile</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.handle.$anonfun.x$17" title="scalaz.\/[O2,O]">_</a>.<span title="=&gt; Boolean">isRight</span><span class="delimiter">)</span>
    .<a href="#scalaz.stream;Process.map" title="(f: scalaz.\/[O2,O] =&gt; O2)scalaz.stream.Process[F2,O2]">map</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.handle.$anonfun.x$18" title="scalaz.\/[O2,O]">_</a>.<span title="(l: O2 =&gt; O2, r: O =&gt; O2)O2">fold</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.handle.$anonfun.$anonfun.x" title="(x: O2)O2">identity</a>, <a title="O" id="scalaz.stream;Process.handle.$anonfun.$anonfun.x$19">_</a> =&gt; sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;unpossible&quot;)" class="string">&quot;unpossible&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Returns true, if this process is halted */</span>
  final def <a title="=&gt; Boolean" id="scalaz.stream;Process.isHalt">isHalt</a>: <span title="Boolean">Boolean</span> = this match <span class="delimiter">{</span>
    case Halt<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; true
    case _ =&gt; false
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Skip the first part of the process and pretend that it ended with `early`.
   * The first part is the first `Halt` or the first `Emit` or request from the first `Await`.
   */</span>
  private<span class="delimiter">[</span>stream<span class="delimiter">]</span> final def <a title="(early: scalaz.stream.Cause.EarlyCause)scalaz.stream.Process[F,O]" id="scalaz.stream;Process.injectCause">injectCause</a><span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream;Process.injectCause.early">early</a>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> = <span class="delimiter">(</span>this match <span class="delimiter">{</span>
    <span class="comment">// Note: We cannot use `step` in the implementation since we want to inject `early` as soon as possible.</span>
    <span class="comment">// Eg. Let `q` be `halt ++ halt ++ ... ++ p`. `step` reduces `q` to `p` so if `injectCause` was implemented</span>
    <span class="comment">// by `step` then `q.injectCause` would be same as `p.injectCause`. But in our current implementation</span>
    <span class="comment">// `q.injectCause` behaves as `Halt(early) ++ halt ++ ... ++ p` which behaves as `Halt(early)`</span>
    <span class="comment">// (by the definition of `++` and the fact `early != End`).</span>
    case Halt<span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span>.<a href="Cause.scala.html#scalaz.stream;Cause.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Cause">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.injectCause.early" title="scalaz.stream.Cause.EarlyCause">early</a><span class="delimiter">)</span><span class="delimiter">)</span>
    case Emit<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.injectCause.early" title="scalaz.stream.Cause.EarlyCause">early</a><span class="delimiter">)</span>
    case Await<span class="delimiter">(</span>_, <span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]">rcv</span><span class="delimiter">)</span> =&gt; <a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">Try</a><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,Any])scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.injectCause.early" title="scalaz.stream.Cause.EarlyCause">early</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Process[F,O]],scalaz.Free.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process[F,O]">run</span><span class="delimiter">)</span>
    case Append<span class="delimiter">(</span>Halt<span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span><span class="delimiter">)</span>, <span title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Append.readResolve" title="(head: scalaz.stream.Process.HaltEmitOrAwait[F,O], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process.Append[F,O]">Append</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">rsn</span>.<a href="Cause.scala.html#scalaz.stream;Cause.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Cause">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.injectCause.early" title="scalaz.stream.Cause.EarlyCause">early</a><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</span><span class="delimiter">)</span>
    case Append<span class="delimiter">(</span>Emit<span class="delimiter">(</span>_<span class="delimiter">)</span>, <span title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Append.readResolve" title="(head: scalaz.stream.Process.HaltEmitOrAwait[F,O], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process.Append[F,O]">Append</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.injectCause.early" title="scalaz.stream.Cause.EarlyCause">early</a><span class="delimiter">)</span>, <span title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</span><span class="delimiter">)</span>
    case Append<span class="delimiter">(</span>Await<span class="delimiter">(</span>_, <span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]">rcv</span><span class="delimiter">)</span>, <span title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</span><span class="delimiter">)</span> =&gt; <a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">Try</a><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,Any])scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.injectCause.early" title="scalaz.stream.Cause.EarlyCause">early</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Process[F,O]],scalaz.Free.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process[F,O]">run</span><span class="delimiter">)</span> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">+:</a> <a href="#scalaz.stream.Process;Cont" title="(stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process.Cont[F,O]">Cont</a><span class="delimiter">(</span><span title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</span><span class="delimiter">)</span>
  <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Causes this process to be terminated immediately with `Kill` cause,
   * giving chance for any cleanup actions to be run
   */</span>
  final def <a title="=&gt; scalaz.stream.Process[F,Nothing]" id="scalaz.stream;Process.kill">kill</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,Nothing]">Process</a><span class="delimiter">[</span>F, Nothing<span class="delimiter">]</span> = <a href="#scalaz.stream;Process.injectCause" title="(early: scalaz.stream.Cause.EarlyCause)scalaz.stream.Process[F,O]">injectCause</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.drain" title="=&gt; scalaz.stream.Process[F,Nothing]">drain</a>.<a href="#scalaz.stream;Process.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Process[F,Nothing]">causedBy</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Run `p2` after this `Process` completes normally, or in the event of an error.
   * This behaves almost identically to `append`, except that `p1 append p2` will
   * not run `p2` if `p1` halts with an `Error` or is killed. Any errors raised by
   * `this` are reraised after `p2` completes.
   *
   * Note that `p2` is made into a finalizer using `asFinalizer`, so we
   * can be assured it is run even when this `Process` is being killed
   * by a downstream consumer.
   */</span>
  final def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](p2: =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.onComplete">onComplete</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.onComplete;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.onComplete;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream;Process.onComplete;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.onComplete.p2">p2</a>: =&gt; Process<span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> =
    this.<a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">onHalt</a> <span class="delimiter">{</span> <a title="scalaz.stream.Cause" id="scalaz.stream;Process.onComplete.$anonfun.cause">cause</a> =&gt; <a href="#scalaz.stream;Process.onComplete.p2" title="=&gt; scalaz.stream.Process[F2,O2]">p2</a>.<a href="#scalaz.stream;Process.asFinalizer" title="=&gt; scalaz.stream.Process[F2,O2]">asFinalizer</a>.<a href="#scalaz.stream;Process.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Process[F2,O2]">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.onComplete.$anonfun.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">/**
   * Mostly internal use function. Ensures this `Process` is run even
   * when being `kill`-ed. Used to ensure resource safety in various
   * combinators.
   */</span>
  final def <a title="=&gt; scalaz.stream.Process[F,O]" id="scalaz.stream;Process.asFinalizer">asFinalizer</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="[F[_], A, O](req: F[A])(rcv: scalaz.\/[scalaz.stream.Cause.EarlyCause,A] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]])scalaz.stream.Process.Await[F,A,O]" id="scalaz.stream;Process.asFinalizer.mkAwait">mkAwait</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream;Process.asFinalizer.mkAwait;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.asFinalizer.mkAwait;F;_">_</a><span class="delimiter">]</span>, <a title="" id="scalaz.stream;Process.asFinalizer.mkAwait;A">A</a>, <a title="" id="scalaz.stream;Process.asFinalizer.mkAwait;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="scalaz.stream;Process.asFinalizer.mkAwait.req">req</a>: <a href="#scalaz.stream;Process.asFinalizer.mkAwait;F" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,A] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]" id="scalaz.stream;Process.asFinalizer.mkAwait.rcv">rcv</a>: EarlyCause \/ A =&gt; Trampoline<span class="delimiter">[</span>Process<span class="delimiter">[</span>F, O<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#scalaz.stream.Process.Await.readResolve" title="(req: F[A], rcv: scalaz.\/[scalaz.stream.Cause.EarlyCause,A] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]])scalaz.stream.Process.Await[F,A,O]">Await</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.asFinalizer.mkAwait.req" title="F[A]">req</a>, <a href="#scalaz.stream;Process.asFinalizer.mkAwait.rcv" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,A] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]">rcv</a><span class="delimiter">)</span>
    <a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[F,O]">step</a> match <span class="delimiter">{</span>
      case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.Emit[O]" id="scalaz.stream;Process.asFinalizer.e">e</a>@Emit<span class="delimiter">(</span>_<span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.asFinalizer.e" title="scalaz.stream.Process.Emit[O]">e</a> <a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">onHalt</a> <a href="#scalaz.stream;Process.asFinalizer.$anonfun.x0$7" title="scalaz.stream.Process[F,O]" class="delimiter">{</a>
        case <a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a> =&gt; <span class="delimiter">(</span><a href="#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.asFinalizer" title="=&gt; scalaz.stream.Process[[x]F[x],O]">asFinalizer</a>.<a href="#scalaz.stream;Process.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Process[[x]F[x],O]">causedBy</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span>
        case <a title="scalaz.stream.Cause" id="scalaz.stream;Process.asFinalizer.$anonfun.cause">cause</a> =&gt; <span class="delimiter">(</span><a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.asFinalizer.$anonfun.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.asFinalizer" title="=&gt; scalaz.stream.Process[[x]F[x],O]">asFinalizer</a>
      <span class="delimiter">}</span>
      case Step<span class="delimiter">(</span>Await<span class="delimiter">(</span><a title="F[Any]" id="scalaz.stream;Process.asFinalizer.req">req</a>, <a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]" id="scalaz.stream;Process.asFinalizer.rcv">rcv</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.asFinalizer.mkAwait" title="(req: F[Any])(rcv: scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]])scalaz.stream.Process.Await[F,Any,O]">mkAwait</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.asFinalizer.req" title="F[Any]">req</a><span class="delimiter">)</span> <a href="#scalaz.stream;Process.asFinalizer.$anonfun.x0$8" title="scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]" class="delimiter">{</a>
        case -\/<span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Trampoline" title="=&gt; scalaz.Trampoline.type">Trampoline</a>.<span title="(a: =&gt; scalaz.stream.Process[F,O])scalaz.Free.Trampoline[scalaz.stream.Process[F,O]]">delay</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.Await.readResolve" title="(req: F[Any], rcv: scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]])scalaz.stream.Process.Await[F,Any,O]">Await</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.asFinalizer.req" title="F[Any]">req</a>, <a href="#scalaz.stream;Process.asFinalizer.rcv" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]">rcv</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.asFinalizer" title="=&gt; scalaz.stream.Process[F,O]">asFinalizer</a>.<a href="#scalaz.stream;Process.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Process[F,O]">causedBy</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case <a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any]" id="scalaz.stream;Process.asFinalizer.$anonfun.x">x</a> =&gt; <a href="#scalaz.stream;Process.asFinalizer.rcv" title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,Any])scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]">rcv</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.asFinalizer.$anonfun.x" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any]">x</a><span class="delimiter">)</span>.<span title="(f: scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[[x]F[x],O])scalaz.Free[Function0,scalaz.stream.Process[[x]F[x],O]]">map</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F,O]" id="scalaz.stream;Process.asFinalizer.$anonfun.$anonfun.p">p</a> =&gt; <span class="delimiter">(</span><a href="#scalaz.stream;Process.asFinalizer.$anonfun.$anonfun.p" title="scalaz.stream.Process[F,O]">p</a> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.asFinalizer" title="=&gt; scalaz.stream.Process[[x]F[x],O]">asFinalizer</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      case <a title="scalaz.stream.Process.Halt" id="scalaz.stream;Process.asFinalizer.hlt">hlt</a>@Halt<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.asFinalizer.hlt" title="scalaz.stream.Process.Halt">hlt</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * If this `Process` completes with an error, call `f` to produce
   * the next state. `f` is responsible for reraising the error if that
   * is the desired behavior. Since this function is often used for attaching
   * resource deallocation logic, the result of `f` is made into a finalizer
   * using `asFinalizer`, so we can be assured it is run even when this `Process`
   * is being killed by a downstream consumer.
   */</span>
  final def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](f: Throwable =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.onFailure">onFailure</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.onFailure;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.onFailure;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream;Process.onFailure;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="Throwable =&gt; scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.onFailure.f">f</a>: Throwable =&gt; Process<span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> =
    this.<a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">onHalt</a> <a href="#scalaz.stream;Process.onFailure.$anonfun.x0$9" title="scalaz.stream.Process[F2,O2]" class="delimiter">{</a>
      case <a title="scalaz.stream.Cause.Error" id="scalaz.stream;Process.onFailure.$anonfun.err">err</a>@Error<span class="delimiter">(</span><a title="Throwable" id="scalaz.stream;Process.onFailure.$anonfun.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.onFailure.f" title="(v1: Throwable)scalaz.stream.Process[F2,O2]">f</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.onFailure.$anonfun.rsn" title="Throwable">rsn</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.asFinalizer" title="=&gt; scalaz.stream.Process[F2,O2]">asFinalizer</a>
      case <a title="scalaz.stream.Cause" id="scalaz.stream;Process.onFailure.$anonfun.other">other</a> =&gt; <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.onFailure.$anonfun.other" title="scalaz.stream.Cause">other</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Attach supplied process only if process has been killed.
   * Since this function is often used for attaching resource
   * deallocation logic, the result of `f` is made into a finalizer
   * using `asFinalizer`, so we can be assured it is run even when
   * this `Process` is being killed by a downstream consumer.
   */</span>
  final def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](p: =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.onKill">onKill</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.onKill;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.onKill;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream;Process.onKill;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.stream.Process[F2,O2]" id="scalaz.stream;Process.onKill.p">p</a>: =&gt; Process<span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> =
    this.<a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">onHalt</a> <a href="#scalaz.stream;Process.onKill.$anonfun.x0$10" title="scalaz.stream.Process[F2,O2]" class="delimiter">{</a>
      case <a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a> =&gt; <a href="#scalaz.stream;Process.onKill.p" title="=&gt; scalaz.stream.Process[F2,O2]">p</a>.<a href="#scalaz.stream;Process.asFinalizer" title="=&gt; scalaz.stream.Process[F2,O2]">asFinalizer</a>
      case <a title="scalaz.stream.Cause" id="scalaz.stream;Process.onKill.$anonfun.other">other</a> =&gt; <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.onKill.$anonfun.other" title="scalaz.stream.Cause">other</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Like `attempt`, but accepts a partial function. Unhandled errors are rethrown.
   */</span>
  def <a title="[F2[x] &gt;: F[x], O2](f: PartialFunction[Throwable,scalaz.stream.Process[F2,O2]])(implicit F: scalaz.Catchable[F2])scalaz.stream.Process[F2,scalaz.\/[O2,O]]" id="scalaz.stream;Process.partialAttempt">partialAttempt</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.partialAttempt;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.partialAttempt;F2;x">x</a><span class="delimiter">]</span>&gt;:F<span class="delimiter">[</span>x<span class="delimiter">]</span>,<a title="" id="scalaz.stream;Process.partialAttempt;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[Throwable,scalaz.stream.Process[F2,O2]]" id="scalaz.stream;Process.partialAttempt.f">f</a>: <span title="PartialFunction[Throwable,scalaz.stream.Process[F2,O2]]">PartialFunction</span><span class="delimiter">[</span>Throwable, Process<span class="delimiter">[</span>F2,O2<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="delimiter">(</span>implicit <a title="scalaz.Catchable[F2]" id="scalaz.stream;Process.partialAttempt.F">F</a>: <span title="scalaz.Catchable[F2]">Catchable</span><span class="delimiter">[</span>F2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,scalaz.\/[O2,O]]">Process</a><span class="delimiter">[</span>F2, O2 \/ O<span class="delimiter">]</span> =
    <a href="#scalaz.stream;Process.attempt" title="(f: Throwable =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,scalaz.\/[O2,O]]">attempt</a><span class="delimiter">(</span><a title="Throwable" id="scalaz.stream;Process.partialAttempt.$anonfun.err">err</a> =&gt; <a href="#scalaz.stream;Process.partialAttempt.f" title="PartialFunction[Throwable,scalaz.stream.Process[F2,O2]]">f</a>.<span title="(v1: Throwable)Option[scalaz.stream.Process[F2,O2]]">lift</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.partialAttempt.$anonfun.err" title="Throwable">err</a><span class="delimiter">)</span>.<span title="(default: =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">getOrElse</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.fail" title="(rsn: Throwable)scalaz.stream.Process0[Nothing]">fail</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.partialAttempt.$anonfun.err" title="Throwable">err</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>


  <span class="comment">/**
   * Run this process until it halts, then run it again and again, as
   * long as no errors or `Kill` occur.
   */</span>
  final def <a title="=&gt; scalaz.stream.Process[F,O]" id="scalaz.stream;Process.repeat">repeat</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> = this.<a href="#scalaz.stream;Process.append" title="(p2: =&gt; scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">append</a><span class="delimiter">(</span>this.<a href="#scalaz.stream;Process.repeat" title="=&gt; scalaz.stream.Process[F,O]">repeat</a><span class="delimiter">)</span>

  <span class="comment">/**
   * For anly process terminating with `Kill`, this swallows the `Kill` and replaces it with `End` termination
   */</span>
  final def <a title="=&gt; scalaz.stream.Process[F,O]" id="scalaz.stream;Process.swallowKill">swallowKill</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this.<a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">onHalt</a> <a href="#scalaz.stream;Process.swallowKill.$anonfun.x0$11" title="scalaz.stream.Process[F,O]" class="delimiter">{</a>
      case <a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a> | <a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a> =&gt; <a href="#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>
      case <a title="scalaz.stream.Cause" id="scalaz.stream;Process.swallowKill.$anonfun.cause">cause</a> =&gt; <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.swallowKill.$anonfun.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Translate the request type from `F` to `G`, using the given polymorphic function. */</span>
  def <a title="[G[_]](f: scalaz.~&gt;[F,G])scalaz.stream.Process[G,O]" id="scalaz.stream;Process.translate">translate</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream;Process.translate;G">G</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.translate;G;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.~&gt;[F,G]" id="scalaz.stream;Process.translate.f">f</a>: F <span title="scalaz.~&gt;[F,G]">~&gt;</span> G<span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[G,O]">Process</a><span class="delimiter">[</span>G,O<span class="delimiter">]</span> =
    this.<a href="#scalaz.stream;Process.suspendStep" title="=&gt; scalaz.stream.Process0[scalaz.stream.Process.HaltOrStep[F,O]]">suspendStep</a>.<a href="#scalaz.stream;Process.flatMap" title="(f: scalaz.stream.Process.HaltOrStep[F,O] =&gt; scalaz.stream.Process[G,O])scalaz.stream.Process[G,O]">flatMap</a> <a href="#scalaz.stream;Process.translate.$anonfun.x0$12" title="scalaz.stream.Process[G,O]" class="delimiter">{</a>
      case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream;Process.translate.$anonfun.os">os</a><span class="delimiter">)</span>,<span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.emitAll" title="(os: Seq[O])scalaz.stream.Process0[O]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.translate.$anonfun.os" title="Seq[O]">os</a><span class="delimiter">)</span> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]G[x],O])scalaz.stream.Process[[x]G[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[F,O]">cont</span>.<a href="#scalaz.stream.Process;Cont.extend" title="(f: scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[G,O])scalaz.stream.Process.Cont[G,O]">extend</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.translate.$anonfun.$anonfun.x$24" title="scalaz.stream.Process[F,O]">_</a>.<a href="#scalaz.stream;Process.translate" title="(f: scalaz.~&gt;[F,G])scalaz.stream.Process[G,O]">translate</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.translate.f" title="scalaz.~&gt;[F,G]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case Step<span class="delimiter">(</span>Await<span class="delimiter">(</span><a title="F[Any]" id="scalaz.stream;Process.translate.$anonfun.req">req</a>,<a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]" id="scalaz.stream;Process.translate.$anonfun.rcv">rcv</a><span class="delimiter">)</span>,<span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.Process.Await.readResolve" title="[F[_], A, O](req: F[A], rcv: scalaz.\/[scalaz.stream.Cause.EarlyCause,A] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]])scalaz.stream.Process.Await[F,A,O]">Await</a><span title="(req: G[Any], rcv: scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[G,O]])scalaz.stream.Process.Await[G,Any,O]" class="delimiter">[</span><a href="#scalaz.stream;Process.translate;G" title="G">G</a>,<span title="Any">Any</span>,<a href="#scalaz.stream;Process;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.translate.f" title="(fa: F[Any])G[Any]">f</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.translate.$anonfun.req" title="F[Any]">req</a><span class="delimiter">)</span>, <a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any]" id="scalaz.stream;Process.translate.$anonfun.x$28.$anonfun.r">r</a> =&gt; <span class="delimiter">{</span>
          <a href="#scalaz.stream.Process.Trampoline" title="=&gt; scalaz.Trampoline.type">Trampoline</a>.<span title="(a: =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F,O]])scalaz.Free.Trampoline[scalaz.stream.Process[F,O]]">suspend</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.translate.$anonfun.rcv" title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,Any])scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]">rcv</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.translate.$anonfun.x$28.$anonfun.r" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any]">r</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(f: scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[G,O])scalaz.Free[Function0,scalaz.stream.Process[G,O]]">map</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.translate.$anonfun.x$28.$anonfun.$anonfun.x$26" title="scalaz.stream.Process[F,O]">_</a> <a href="#scalaz.stream;Process.translate" title="(f: scalaz.~&gt;[F,G])scalaz.stream.Process[G,O]">translate</a> <a href="#scalaz.stream;Process.translate.f" title="scalaz.~&gt;[F,G]">f</a><span class="delimiter">)</span>
        <span class="delimiter">}</span><span class="delimiter">)</span> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]G[x],O])scalaz.stream.Process[[x]G[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[F,O]">cont</span>.<a href="#scalaz.stream.Process;Cont.extend" title="(f: scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[G,O])scalaz.stream.Process.Cont[G,O]">extend</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.translate.$anonfun.$anonfun.x$27" title="scalaz.stream.Process[F,O]">_</a>.<a href="#scalaz.stream;Process.translate" title="(f: scalaz.~&gt;[F,G])scalaz.stream.Process[G,O]">translate</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.translate.f" title="scalaz.~&gt;[F,G]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case <a title="scalaz.stream.Process.Halt" id="scalaz.stream;Process.translate.$anonfun.hlt">hlt</a>@Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream;Process.translate.$anonfun.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.translate.$anonfun.hlt" title="scalaz.stream.Process.Halt">hlt</a>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Remove any leading emitted values from this `Process`.
   */</span>
  @tailrec
  final def <a title="=&gt; scalaz.stream.Process[F,O]" id="scalaz.stream;Process.trim">trim</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    this.<a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[F,O]">step</a> match <span class="delimiter">{</span>
      case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span>_<span class="delimiter">)</span>, <a title="scalaz.stream.Process.Cont[F,O]" id="scalaz.stream;Process.trim.cont">cont</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.trim.cont" title="scalaz.stream.Process.Cont[F,O]">cont</a>.<a href="#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[F,O]">continue</a>.<a href="#scalaz.stream;Process.trim" title="=&gt; scalaz.stream.Process[F,O]">trim</a>
      case _ =&gt; this
    <span class="delimiter">}</span>


  <span class="comment">/**
   * Removes all emitted elements from the front of this `Process`.
   * The second argument returned by this method is guaranteed to be
   * an `Await`, `Halt` or an `Append`-- if there are multiple `Emit'`s at the
   * front of this process, the sequences are concatenated together.
   *
   * If this `Process` does not begin with an `Emit`, returns the empty
   * sequence along with `this`.
   */</span>
  final def <a title="=&gt; (Seq[O], scalaz.stream.Process[F,O])" id="scalaz.stream;Process.unemit">unemit</a>:<span title="(Seq[O], scalaz.stream.Process[F,O])" class="delimiter">(</span>Seq<span class="delimiter">[</span>O<span class="delimiter">]</span>,Process<span class="delimiter">[</span>F,O<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(cur: scalaz.stream.Process[F,O], acc: Vector[O])(Seq[O], scalaz.stream.Process[F,O])" id="scalaz.stream;Process.unemit.go">go</a><span class="delimiter">(</span><a title="scalaz.stream.Process[F,O]" id="scalaz.stream;Process.unemit.go.cur">cur</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span>, <a title="Vector[O]" id="scalaz.stream;Process.unemit.go.acc">acc</a>: <span title="Vector[O]">Vector</span><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Seq[O], scalaz.stream.Process[F,O])" class="delimiter">(</span>Seq<span class="delimiter">[</span>O<span class="delimiter">]</span>, Process<span class="delimiter">[</span>F, O<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#scalaz.stream;Process.unemit.go.cur" title="scalaz.stream.Process[F,O]">cur</a>.<a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[F,O]">step</a> match <span class="delimiter">{</span>
        case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream;Process.unemit.go.os">os</a><span class="delimiter">)</span>,<span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.unemit.go" title="(cur: scalaz.stream.Process[F,O], acc: Vector[O])(Seq[O], scalaz.stream.Process[F,O])">go</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Cont[F,O]">cont</span>.<a href="#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[F,O]">continue</a>, <a href="Util.scala.html#scalaz.stream.Util.AppendSyntax(629eae9601)" title="(self: Vector[O])scalaz.stream.Util.AppendSyntax[O]">acc</a> <a href="Util.scala.html#scalaz.stream.Util;AppendSyntax.fast_++" title="(other: Seq[O])Vector[O]">fast_++</a> <a href="#scalaz.stream;Process.unemit.go.os" title="Seq[O]">os</a><span class="delimiter">)</span>
        case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.EmitOrAwait[F,O]" id="scalaz.stream;Process.unemit.go.awt">awt</a>, <span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span> =&gt; <span title="(_1: Vector[O], _2: scalaz.stream.Process[[x]F[x],O])(Vector[O], scalaz.stream.Process[[x]F[x],O])" class="delimiter">(</span><a href="#scalaz.stream;Process.unemit.go.acc" title="Vector[O]">acc</a>,<a href="#scalaz.stream;Process.unemit.go.awt" title="scalaz.stream.Process.EmitOrAwait[F,O]">awt</a> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[F,O]">cont</span><span class="delimiter">)</span>
        case Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream;Process.unemit.go.rsn">rsn</a><span class="delimiter">)</span> =&gt; <span title="(_1: Vector[O], _2: scalaz.stream.Process.Halt)(Vector[O], scalaz.stream.Process.Halt)" class="delimiter">(</span><a href="#scalaz.stream;Process.unemit.go.acc" title="Vector[O]">acc</a>,<a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.unemit.go.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#scalaz.stream;Process.unemit.go" title="(cur: scalaz.stream.Process[F,O], acc: Vector[O])(Seq[O], scalaz.stream.Process[F,O])">go</a><span class="delimiter">(</span>this, <span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="delimiter">}</span>




  <span class="comment">///////////////////////////////////////////</span>
  <span class="comment">//</span>
  <span class="comment">// Interpreters, runXXX</span>
  <span class="comment">//</span>
  <span class="comment">///////////////////////////////////////////</span>

  <span class="comment">/**
   * Collect the outputs of this `Process[F,O]` into a Monoid `B`, given a `Monad[F]` in
   * which we can catch exceptions. This function is not tail recursive and
   * relies on the `Monad[F]` to ensure stack safety.
   */</span>
  final def <a title="[F2[x] &gt;: F[x], B](f: O =&gt; B)(implicit F: scalaz.Monad[F2], implicit C: scalaz.Catchable[F2], implicit B: scalaz.Monoid[B])F2[B]" id="scalaz.stream;Process.runFoldMap">runFoldMap</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.runFoldMap;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.runFoldMap;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title="" id="scalaz.stream;Process.runFoldMap;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; B" id="scalaz.stream;Process.runFoldMap.f">f</a>: O =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Monad[F2]" id="scalaz.stream;Process.runFoldMap.F">F</a>: <span title="scalaz.Monad[F2]">Monad</span><span class="delimiter">[</span>F2<span class="delimiter">]</span>, <a title="scalaz.Catchable[F2]" id="scalaz.stream;Process.runFoldMap.C">C</a>: <span title="scalaz.Catchable[F2]">Catchable</span><span class="delimiter">[</span>F2<span class="delimiter">]</span>, <a title="scalaz.Monoid[B]" id="scalaz.stream;Process.runFoldMap.B">B</a>: <span title="scalaz.Monoid[B]">Monoid</span><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process.runFoldMap;F2" title="F2[B]">F2</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(cur: scalaz.stream.Process[F2,O], acc: B)F2[B]" id="scalaz.stream;Process.runFoldMap.go">go</a><span class="delimiter">(</span><a title="scalaz.stream.Process[F2,O]" id="scalaz.stream;Process.runFoldMap.go.cur">cur</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O]">Process</a><span class="delimiter">[</span>F2, O<span class="delimiter">]</span>, <a title="B" id="scalaz.stream;Process.runFoldMap.go.acc">acc</a>: <a href="#scalaz.stream;Process.runFoldMap;B" title="B">B</a><span class="delimiter">)</span>: <a href="#scalaz.stream;Process.runFoldMap;F2" title="F2[B]">F2</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#scalaz.stream;Process.runFoldMap.go.cur" title="scalaz.stream.Process[F2,O]">cur</a>.<a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[F2,O]">step</a> match <span class="delimiter">{</span>
        case <a title="scalaz.stream.Process.Step[F2,O] @unchecked" id="scalaz.stream;Process.runFoldMap.go.s">s</a>: Step<span class="delimiter">[</span>F2,O<span class="delimiter">]</span>@<a href="#scalaz.stream.Process.Step.readResolve" title="scalaz.stream.Process.Step[F2,O] @unchecked">unchecked</a> =&gt;
          <span title="(_1: scalaz.stream.Process.EmitOrAwait[F2,O], _2: scalaz.stream.Process.Cont[F2,O])(scalaz.stream.Process.EmitOrAwait[F2,O], scalaz.stream.Process.Cont[F2,O])" class="delimiter">(</span><a href="#scalaz.stream;Process.runFoldMap.go.s" title="scalaz.stream.Process.Step[F2,O] @unchecked">s</a>.<a href="#scalaz.stream.Process;Step.head" title="=&gt; scalaz.stream.Process.EmitOrAwait[F2,O]">head</a>, <a href="#scalaz.stream;Process.runFoldMap.go.s" title="scalaz.stream.Process.Step[F2,O] @unchecked">s</a>.<a href="#scalaz.stream.Process;Step.next" title="=&gt; scalaz.stream.Process.Cont[F2,O]">next</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
            case <span class="delimiter">(</span>Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream;Process.runFoldMap.go.os">os</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[F2,O]">cont</span><span class="delimiter">)</span> =&gt;
              <a href="#scalaz.stream;Process.runFoldMap.F" title="scalaz.Monad[F2]">F</a>.<span title="(fa: F2[B])(f: B =&gt; F2[B])F2[B]">bind</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.runFoldMap.F" title="scalaz.Monad[F2]">F</a>.<span title="(a: =&gt; B)F2[B]">point</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.runFoldMap.go.os" title="Seq[O]">os</a>.<span title="(z: B)(op: (B, O) =&gt; B)B">foldLeft</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.runFoldMap.go.acc" title="B">acc</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="B" id="scalaz.stream;Process.runFoldMap.go.$anonfun.b">b</a>, <a title="O" id="scalaz.stream;Process.runFoldMap.go.$anonfun.o">o</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.runFoldMap.B" title="scalaz.Monoid[B]">B</a>.<span title="(f1: B, f2: =&gt; B)B">append</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.runFoldMap.go.$anonfun.b" title="B">b</a>, <a href="#scalaz.stream;Process.runFoldMap.f" title="(v1: O)B">f</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.runFoldMap.go.$anonfun.o" title="O">o</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="B" id="scalaz.stream;Process.runFoldMap.go.$anonfun.nacc">nacc</a> =&gt;
                <a href="#scalaz.stream;Process.runFoldMap.go" title="(cur: scalaz.stream.Process[F2,O], acc: B)F2[B]">go</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Cont[F2,O]">cont</span>.<a href="#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[F2,O]">continue</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scalaz.stream.Process[F2,O]" class="delimiter">[</span><a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O]">Process</a><span class="delimiter">[</span>F2,O<span class="delimiter">]</span><span class="delimiter">]</span>, <a href="#scalaz.stream;Process.runFoldMap.go.$anonfun.nacc" title="B">nacc</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            case <span class="delimiter">(</span><a title="scalaz.stream.Process.Await[F2,Any,O] @unchecked" id="scalaz.stream;Process.runFoldMap.go.awt">awt</a>:Await<span class="delimiter">[</span>F2,Any,O<span class="delimiter">]</span>@<a href="#scalaz.stream.Process.Await.readResolve" title="scalaz.stream.Process.Await[F2,Any,O] @unchecked">unchecked</a>, <span title="scalaz.stream.Process.Cont[F2,O]">cont</span><span class="delimiter">)</span> =&gt;
              <a href="#scalaz.stream;Process.runFoldMap.F" title="scalaz.Monad[F2]">F</a>.<span title="(fa: F2[scalaz.\/[Throwable,Any]])(f: scalaz.\/[Throwable,Any] =&gt; F2[B])F2[B]">bind</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.runFoldMap.C" title="scalaz.Catchable[F2]">C</a>.<span title="(f: F2[Any])F2[scalaz.\/[Throwable,Any]]">attempt</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.runFoldMap.go.awt" title="scalaz.stream.Process.Await[F2,Any,O] @unchecked">awt</a>.<a href="#scalaz.stream.Process;Await.req" title="=&gt; F2[Any]">req</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="scalaz.\/[Throwable,Any]" id="scalaz.stream;Process.runFoldMap.go.$anonfun.r">r</a> =&gt;
                <a href="#scalaz.stream;Process.runFoldMap.go" title="(cur: scalaz.stream.Process[F2,O], acc: B)F2[B]">go</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[F2,O])scalaz.stream.Process[F2,O]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.runFoldMap.go.awt" title="scalaz.stream.Process.Await[F2,Any,O] @unchecked">awt</a>.<a href="#scalaz.stream.Process;Await.rcv" title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,Any])scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O]]">rcv</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.EarlyCause" title="scalaz.stream.Cause.EarlyCause.type">EarlyCause</a>.<a href="Cause.scala.html#scalaz.stream.Cause.EarlyCause.fromTaskResult" title="(r: scalaz.\/[Throwable,Any])scalaz.\/[scalaz.stream.Cause.EarlyCause,Any]">fromTaskResult</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.runFoldMap.go.$anonfun.r" title="scalaz.\/[Throwable,Any]">r</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Process[F2,O]],scalaz.Free.Trampoline[scalaz.stream.Process[F2,O]]])scalaz.stream.Process[F2,O]">run</span><span class="delimiter">)</span> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]F2[x],O])scalaz.stream.Process[[x]F2[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[F2,O]">cont</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scalaz.stream.Process[F2,O]" class="delimiter">[</span><a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O]">Process</a><span class="delimiter">[</span>F2,O<span class="delimiter">]</span><span class="delimiter">]</span>
                  , <a href="#scalaz.stream;Process.runFoldMap.go.acc" title="B">acc</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        case Halt<span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.runFoldMap.F" title="scalaz.Monad[F2]">F</a>.<span title="(a: =&gt; B)F2[B]">point</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.runFoldMap.go.acc" title="B">acc</a><span class="delimiter">)</span>
        case Halt<span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.runFoldMap.F" title="scalaz.Monad[F2]">F</a>.<span title="(a: =&gt; B)F2[B]">point</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.runFoldMap.go.acc" title="B">acc</a><span class="delimiter">)</span>
        case Halt<span class="delimiter">(</span>Error<span class="delimiter">(</span><a title="Throwable" id="scalaz.stream;Process.runFoldMap.go.rsn">rsn</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream;Process.runFoldMap.C" title="scalaz.Catchable[F2]">C</a>.<span title="(err: Throwable)F2[B]">fail</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.runFoldMap.go.rsn" title="Throwable">rsn</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="#scalaz.stream;Process.runFoldMap.go" title="(cur: scalaz.stream.Process[F2,O], acc: B)F2[B]">go</a><span class="delimiter">(</span>this, <a href="#scalaz.stream;Process.runFoldMap.B" title="scalaz.Monoid[B]">B</a>.<span title="=&gt; B">zero</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>


  <span class="comment">/**
   * Collect the outputs of this `Process[F,O]`, given a `Monad[F]` in
   * which we can catch exceptions. This function is not tail recursive and
   * relies on the `Monad[F]` to ensure stack safety.
   */</span>
  final def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](implicit F: scalaz.Monad[F2], implicit C: scalaz.Catchable[F2])F2[IndexedSeq[O2]]" id="scalaz.stream;Process.runLog">runLog</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.runLog;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.runLog;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream;Process.runLog;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Monad[F2]" id="scalaz.stream;Process.runLog.F">F</a>: <span title="scalaz.Monad[F2]">Monad</span><span class="delimiter">[</span>F2<span class="delimiter">]</span>, <a title="scalaz.Catchable[F2]" id="scalaz.stream;Process.runLog.C">C</a>: <span title="scalaz.Catchable[F2]">Catchable</span><span class="delimiter">[</span>F2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process.runLog;F2" title="F2[IndexedSeq[O2]]">F2</a><span class="delimiter">[</span>IndexedSeq<span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#scalaz.stream;Process.runLog.F" title="scalaz.Monad[F2]">F</a>.<span title="(fa: F2[Vector[O2]])(f: Vector[O2] =&gt; IndexedSeq[O2])F2[IndexedSeq[O2]]">map</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.runFoldMap" title="[F2[x] &gt;: F[x], B](f: O =&gt; B)(implicit F: scalaz.Monad[F2], implicit C: scalaz.Catchable[F2], implicit B: scalaz.Monoid[B])F2[B]">runFoldMap</a><span title="(f: O =&gt; Vector[O2])(implicit F: scalaz.Monad[F2], implicit C: scalaz.Catchable[F2], implicit B: scalaz.Monoid[Vector[O2]])F2[Vector[O2]]" class="delimiter">[</span><a href="#scalaz.stream;Process.runLog;F2" title="F2">F2</a>, <span title="Vector[O2]">Vector</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="(elems: O*)scala.collection.immutable.Vector[O]">Vector</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.runLog.$anonfun.x$31" title="O">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
      <a href="#scalaz.stream;Process.runLog.F" title="scalaz.Monad[F2]">F</a>, <a href="#scalaz.stream;Process.runLog.C" title="scalaz.Catchable[F2]">C</a>,
      <span class="comment">// workaround for performance bug in Vector ++</span>
      <span title="scalaz.Monoid.type">Monoid</span>.<span title="[A](f: (A, =&gt; A) =&gt; A, z: A)scalaz.Monoid[A]">instance</span><span title="(f: (Vector[O2], =&gt; Vector[O2]) =&gt; Vector[O2], z: Vector[O2])scalaz.Monoid[Vector[O2]]" class="delimiter">[</span><span title="Vector[O2]">Vector</span><span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Vector[O2]" id="scalaz.stream;Process.runLog.$anonfun.a">a</a>, <a title="=&gt; Vector[O2]" id="scalaz.stream;Process.runLog.$anonfun.b">b</a><span class="delimiter">)</span> =&gt; <a href="Util.scala.html#scalaz.stream.Util.AppendSyntax(629eae9601)" title="(self: Vector[O2])scalaz.stream.Util.AppendSyntax[O2]">a</a> <a href="Util.scala.html#scalaz.stream.Util;AppendSyntax.fast_++" title="(other: Seq[O2])Vector[O2]">fast_++</a> <a href="#scalaz.stream;Process.runLog.$anonfun.b" title="=&gt; Vector[O2]">b</a>, <span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.runLog.$anonfun.x$32" title="Vector[O2]">_</a>.<span title="=&gt; scala.collection.immutable.IndexedSeq[O2]">toIndexedSeq</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Run this `Process` solely for its final emitted value, if one exists. */</span>
  final def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](implicit F: scalaz.Monad[F2], implicit C: scalaz.Catchable[F2])F2[Option[O2]]" id="scalaz.stream;Process.runLast">runLast</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.runLast;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.runLast;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream;Process.runLast;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Monad[F2]" id="scalaz.stream;Process.runLast.F">F</a>: <span title="scalaz.Monad[F2]">Monad</span><span class="delimiter">[</span>F2<span class="delimiter">]</span>, <a title="scalaz.Catchable[F2]" id="scalaz.stream;Process.runLast.C">C</a>: <span title="scalaz.Catchable[F2]">Catchable</span><span class="delimiter">[</span>F2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process.runLast;F2" title="F2[Option[O2]]">F2</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>O2<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#scalaz.stream;Process.runLast.F" title="scalaz.Monad[F2]">F</a>.<span title="(fa: F2[IndexedSeq[O2]])(f: IndexedSeq[O2] =&gt; Option[O2])F2[Option[O2]]">map</span><span class="delimiter">(</span>this.<a href="process1.scala.html#scalaz.stream;Process1Ops.last" title="=&gt; scalaz.stream.Process[F,O]">last</a>.<a href="#scalaz.stream;Process.runLog" title="[F2[x] &gt;: F[x], O2 &gt;: O](implicit F: scalaz.Monad[F2], implicit C: scalaz.Catchable[F2])F2[IndexedSeq[O2]]">runLog</a><a href="#scalaz.stream;Process.runLast.F" title="(implicit F: scalaz.Monad[F2], implicit C: scalaz.Catchable[F2])F2[IndexedSeq[O2]]" class="delimiter">[</a><a href="#scalaz.stream;Process.runLast;F2" title="F2">F2</a>,<a href="#scalaz.stream;Process.runLast;O2" title="O2">O2</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.runLast.$anonfun.x$33" title="IndexedSeq[O2]">_</a>.<span title="=&gt; Option[O2]">lastOption</span><span class="delimiter">)</span>

  <span class="comment">/** Run this `Process` solely for its final emitted value, if one exists, using `o2` otherwise. */</span>
  final def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](o2: =&gt; O2)(implicit F: scalaz.Monad[F2], implicit C: scalaz.Catchable[F2])F2[O2]" id="scalaz.stream;Process.runLastOr">runLastOr</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.runLastOr;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.runLastOr;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream;Process.runLastOr;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; O2" id="scalaz.stream;Process.runLastOr.o2">o2</a>: =&gt; O2<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Monad[F2]" id="scalaz.stream;Process.runLastOr.F">F</a>: <span title="scalaz.Monad[F2]">Monad</span><span class="delimiter">[</span>F2<span class="delimiter">]</span>, <a title="scalaz.Catchable[F2]" id="scalaz.stream;Process.runLastOr.C">C</a>: <span title="scalaz.Catchable[F2]">Catchable</span><span class="delimiter">[</span>F2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process.runLastOr;F2" title="F2[O2]">F2</a><span class="delimiter">[</span>O2<span class="delimiter">]</span> =
    <a href="#scalaz.stream;Process.runLastOr.F" title="scalaz.Monad[F2]">F</a>.<span title="(fa: F2[IndexedSeq[O2]])(f: IndexedSeq[O2] =&gt; O2)F2[O2]">map</span><span class="delimiter">(</span>this.<a href="process1.scala.html#scalaz.stream;Process1Ops.last" title="=&gt; scalaz.stream.Process[F,O]">last</a>.<a href="#scalaz.stream;Process.runLog" title="[F2[x] &gt;: F[x], O2 &gt;: O](implicit F: scalaz.Monad[F2], implicit C: scalaz.Catchable[F2])F2[IndexedSeq[O2]]">runLog</a><a href="#scalaz.stream;Process.runLastOr.F" title="(implicit F: scalaz.Monad[F2], implicit C: scalaz.Catchable[F2])F2[IndexedSeq[O2]]" class="delimiter">[</a><a href="#scalaz.stream;Process.runLastOr;F2" title="F2">F2</a>,<a href="#scalaz.stream;Process.runLastOr;O2" title="O2">O2</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.runLastOr.$anonfun.x$34" title="IndexedSeq[O2]">_</a>.<span title="=&gt; Option[O2]">lastOption</span>.<span title="(default: =&gt; O2)O2">getOrElse</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.runLastOr.o2" title="=&gt; O2">o2</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Run this `Process`, purely for its effects. */</span>
  final def <a title="[F2[x] &gt;: F[x]](implicit F: scalaz.Monad[F2], implicit C: scalaz.Catchable[F2])F2[Unit]" id="scalaz.stream;Process.run">run</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream;Process.run;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream;Process.run;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scalaz.Monad[F2]" id="scalaz.stream;Process.run.F">F</a>: <span title="scalaz.Monad[F2]">Monad</span><span class="delimiter">[</span>F2<span class="delimiter">]</span>, <a title="scalaz.Catchable[F2]" id="scalaz.stream;Process.run.C">C</a>: <span title="scalaz.Catchable[F2]">Catchable</span><span class="delimiter">[</span>F2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process.run;F2" title="F2[Unit]">F2</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> =
    <a href="#scalaz.stream;Process.run.F" title="scalaz.Monad[F2]">F</a>.<span title="(fa: F2[IndexedSeq[Nothing]])F2[Unit]">void</span><span class="delimiter">(</span><a href="#scalaz.stream;Process.drain" title="=&gt; scalaz.stream.Process[F,Nothing]">drain</a>.<a href="#scalaz.stream;Process.runLog" title="(implicit F: scalaz.Monad[F2], implicit C: scalaz.Catchable[F2])F2[IndexedSeq[Nothing]]">runLog</a><span class="delimiter">(</span><a href="#scalaz.stream;Process.run.F" title="scalaz.Monad[F2]">F</a>, <a href="#scalaz.stream;Process.run.C" title="scalaz.Catchable[F2]">C</a><span class="delimiter">)</span><span class="delimiter">)</span>

<span class="delimiter">}</span>


object <a title="scalaz.stream.Process.type" id="scalaz.stream.Process">Process</a> extends <a href="ProcessInstances.scala.html#scalaz.stream;ProcessInstances" title="scalaz.stream.ProcessInstances">ProcessInstances</a> <span class="delimiter">{</span>


  import scalaz.stream.<a href="Util.scala.html#scalaz.stream.Util" title="scalaz.stream.Util.type">Util</a>._

  <span class="comment">//////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="comment">//</span>
  <span class="comment">// Algebra</span>
  <span class="comment">//</span>
  <span class="comment">/////////////////////////////////////////////////////////////////////////////////////</span>

  type <a title="[+A]scalaz.Free.Trampoline[A] @scala.annotation.unchecked.uncheckedVariance" id="scalaz.stream.Process;Trampoline">Trampoline</a><span class="delimiter">[</span>+<a title="" id="scalaz.stream.Process;Trampoline;A">A</a><span class="delimiter">]</span> = scalaz.Free.Trampoline<span class="delimiter">[</span>A<span class="delimiter">]</span> @<span title="scalaz.Free.Trampoline[A] @scala.annotation.unchecked.uncheckedVariance">uncheckedVariance</span>
  val <a title="scalaz.Trampoline.type" id="scalaz.stream.Process.Trampoline">Trampoline</a> = scalaz.<span title="scalaz.Trampoline.type">Trampoline</span>

  <span class="comment">/**
   * Tags a state of process that has no appended tail, tha means can be Halt, Emit or Await
   */</span>
  sealed trait <a title="trait HaltEmitOrAwait[+F[_], +O] extends AnyRef with scalaz.stream.Process[F,O]" id="scalaz.stream.Process;HaltEmitOrAwait">HaltEmitOrAwait</a><span class="delimiter">[</span>+<a title="[_]" id="scalaz.stream.Process;HaltEmitOrAwait;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;HaltEmitOrAwait;F;_">_</a><span class="delimiter">]</span>, +<a title="" id="scalaz.stream.Process;HaltEmitOrAwait;O">O</a><span class="delimiter">]</span> extends <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span>

  object <a title="scalaz.stream.Process.HaltEmitOrAwait.type" id="scalaz.stream.Process.HaltEmitOrAwait">HaltEmitOrAwait</a> <a href="#scalaz.stream.Process.HaltEmitOrAwait" title="scalaz.stream.Process.HaltEmitOrAwait.type" class="delimiter">{</a>

    def <a title="[F[_], O](p: scalaz.stream.Process[F,O])Option[scalaz.stream.Process.HaltEmitOrAwait[F,O]]" id="scalaz.stream.Process.HaltEmitOrAwait.unapply">unapply</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.HaltEmitOrAwait.unapply;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.HaltEmitOrAwait.unapply;F;_">_</a><span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process.HaltEmitOrAwait.unapply;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F,O]" id="scalaz.stream.Process.HaltEmitOrAwait.unapply.p">p</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[scalaz.stream.Process.HaltEmitOrAwait[F,O]]">Option</span><span class="delimiter">[</span>HaltEmitOrAwait<span class="delimiter">[</span>F, O<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scalaz.stream.Process.HaltEmitOrAwait.unapply.p" title="scalaz.stream.Process[F,O]">p</a> match <span class="delimiter">{</span>
      case <a title="scalaz.stream.Process.Emit[O @unchecked]" id="scalaz.stream.Process.HaltEmitOrAwait.unapply.emit">emit</a>: <a href="#scalaz.stream.Process.Emit.readResolve" title="scalaz.stream.Process.Emit[O @unchecked]">Emit</a><span class="delimiter">[</span>O@unchecked<span class="delimiter">]</span> =&gt; <span title="(x: scalaz.stream.Process.Emit[O @unchecked])Some[scalaz.stream.Process.Emit[O @unchecked]]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.HaltEmitOrAwait.unapply.emit" title="scalaz.stream.Process.Emit[O @unchecked]">emit</a><span class="delimiter">)</span>
      case <a title="scalaz.stream.Process.Halt" id="scalaz.stream.Process.HaltEmitOrAwait.unapply.halt">halt</a>: <a href="#scalaz.stream.Process.Halt.readResolve" title="scalaz.stream.Process.Halt">Halt</a> =&gt; <span title="(x: scalaz.stream.Process.Halt)Some[scalaz.stream.Process.Halt]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.HaltEmitOrAwait.unapply.halt" title="scalaz.stream.Process.Halt">halt</a><span class="delimiter">)</span>
      case <a title="scalaz.stream.Process.Await[F @unchecked,_,O @unchecked]" id="scalaz.stream.Process.HaltEmitOrAwait.unapply.aw">aw</a>: <a href="#scalaz.stream.Process.Await.readResolve" title="scalaz.stream.Process.Await[F @unchecked,_,O @unchecked]">Await</a><span class="delimiter">[</span>F@unchecked, _, O@unchecked<span class="delimiter">]</span> =&gt; <span title="(x: scalaz.stream.Process.Await[F @unchecked,_,O @unchecked])Some[scalaz.stream.Process.Await[F @unchecked,_,O @unchecked]]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.HaltEmitOrAwait.unapply.aw" title="scalaz.stream.Process.Await[F @unchecked,_,O @unchecked]">aw</a><span class="delimiter">)</span>
      case _ =&gt; <span title="None.type">None</span>
    <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  <span class="comment">/**
   * Marker trait representing process in Emit or Await state.
   * Is useful for more type safety.
   */</span>
  sealed trait <a title="trait EmitOrAwait[+F[_], +O] extends AnyRef with scalaz.stream.Process[F,O]" id="scalaz.stream.Process;EmitOrAwait">EmitOrAwait</a><span class="delimiter">[</span>+<a title="[_]" id="scalaz.stream.Process;EmitOrAwait;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;EmitOrAwait;F;_">_</a><span class="delimiter">]</span>, +<a title="" id="scalaz.stream.Process;EmitOrAwait;O">O</a><span class="delimiter">]</span> extends <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span>


  <span class="comment">/**
   * The `Halt` constructor instructs the driver
   * that the last evaluation of Process completed with
   * supplied cause.
   */</span>
  case class <a title="class Halt extends AnyRef with scalaz.stream.Process.HaltEmitOrAwait[Nothing,Nothing] with scalaz.stream.Process.HaltOrStep[Nothing,Nothing] with Product with Serializable" id="scalaz.stream.Process.Halt.readResolve">Halt</a><span title="Product" class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.Process;Halt.cause">cause</a>: <a href="Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a><span class="delimiter">)</span> extends <a href="#scalaz.stream.Process;HaltEmitOrAwait" title="scalaz.stream.Process.HaltEmitOrAwait[Nothing,Nothing]">HaltEmitOrAwait</a><span class="delimiter">[</span>Nothing, Nothing<span class="delimiter">]</span> with <a href="#scalaz.stream.Process;HaltOrStep" title="scalaz.stream.Process.HaltOrStep[Nothing,Nothing]">HaltOrStep</a><span class="delimiter">[</span>Nothing, Nothing<span class="delimiter">]</span>


  <span class="comment">/**
   * The `Emit` constructor instructs the driver to emit
   * the given sequence of values to the output
   * and then halt execution with supplied reason.
   *
   * Instead calling this constructor directly, please use one
   * of the following helpers:
   *
   * Process.emit
   * Process.emitAll
   */</span>
  case class <a href="#scalaz.stream.Process;Emit.productElement.x$1" title="class Emit[+O] extends AnyRef with scalaz.stream.Process.HaltEmitOrAwait[Nothing,O] with scalaz.stream.Process.EmitOrAwait[Nothing,O] with Product with Serializable" id="scalaz.stream.Process.Emit.readResolve">Emit</a><span class="delimiter">[</span>+<a title="" id="scalaz.stream.Process;Emit;O">O</a><span class="delimiter">]</span><span title="Product" class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.Process;Emit.seq">seq</a>: <span title="Seq[O]">Seq</span><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scalaz.stream.Process;HaltEmitOrAwait" title="scalaz.stream.Process.HaltEmitOrAwait[Nothing,O]">HaltEmitOrAwait</a><span class="delimiter">[</span>Nothing, O<span class="delimiter">]</span> with <a href="#scalaz.stream.Process;EmitOrAwait" title="scalaz.stream.Process.EmitOrAwait[Nothing,O]">EmitOrAwait</a><span class="delimiter">[</span>Nothing, O<span class="delimiter">]</span>

  <span class="comment">/**
   * The `Await` constructor instructs the driver to evaluate
   * `req`. If it returns successfully, `recv` is called with result on right side
   * to transition to the next state.
   *
   * In case the req terminates with failure the `Error(failure)` is passed on left side
   * giving chance for any fallback action.
   *
   * In case the process was killed before the request is evaluated `Kill` is passed on left side.
   * `Kill` is passed on left side as well as when the request is already in progress, but process was killed.
   *
   * Note that
   *
   * Instead of this constructor directly, please use:
   *
   * Process.await
   *
   */</span>
  case class <a href="#scalaz.stream.Process;Await.productElement.x$1" title="class Await[+F[_], A, +O] extends AnyRef with scalaz.stream.Process.HaltEmitOrAwait[F,O] with scalaz.stream.Process.EmitOrAwait[F,O] with Product with Serializable" id="scalaz.stream.Process.Await.readResolve">Await</a><span class="delimiter">[</span>+<a title="[_]" id="scalaz.stream.Process;Await;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Await;F;_">_</a><span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process;Await;A">A</a>, +<a title="" id="scalaz.stream.Process;Await;O">O</a><span class="delimiter">]</span><span title="Product" class="delimiter">(</span>
    <a title="F[A]" id="scalaz.stream.Process;Await.req">req</a>: <a href="#scalaz.stream.Process;Await;F" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
    , <a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,A] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]" id="scalaz.stream.Process;Await.rcv">rcv</a>: <span class="delimiter">(</span>EarlyCause \/ A<span class="delimiter">)</span> =&gt; Trampoline<span class="delimiter">[</span>Process<span class="delimiter">[</span>F, O<span class="delimiter">]</span><span class="delimiter">]</span> @uncheckedVariance
    <span class="delimiter">)</span> extends <a href="#scalaz.stream.Process;HaltEmitOrAwait" title="scalaz.stream.Process.HaltEmitOrAwait[F,O]">HaltEmitOrAwait</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> with <a href="#scalaz.stream.Process;EmitOrAwait" title="scalaz.stream.Process.EmitOrAwait[F,O]">EmitOrAwait</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="comment">/**
     * Helper to modify the result of `rcv` parameter of await stack-safely on trampoline.
     */</span>
    def <a title="[F2[x] &gt;: F[x], O2](f: scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process.Await[F2,A,O2]" id="scalaz.stream.Process;Await.extend">extend</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream.Process;Await.extend;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Await.extend;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process;Await.extend;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[F2,O2]" id="scalaz.stream.Process;Await.extend.f">f</a>: Process<span class="delimiter">[</span>F, O<span class="delimiter">]</span> =&gt; Process<span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream.Process.Await.readResolve" title="scalaz.stream.Process.Await[F2,A,O2]">Await</a><span class="delimiter">[</span>F2, A, O2<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.Await.readResolve" title="[F[_], A, O](req: F[A], rcv: scalaz.\/[scalaz.stream.Cause.EarlyCause,A] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]])scalaz.stream.Process.Await[F,A,O]">Await</a><span title="(req: F2[A], rcv: scalaz.\/[scalaz.stream.Cause.EarlyCause,A] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]])scalaz.stream.Process.Await[F2,A,O2]" class="delimiter">[</span><a href="#scalaz.stream.Process;Await.extend;F2" title="F2">F2</a>, <a href="#scalaz.stream.Process;Await;A" title="A">A</a>, <a href="#scalaz.stream.Process;Await.extend;O2" title="O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;Await.req" title="=&gt; F[A]">req</a>, <a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,A]" id="scalaz.stream.Process;Await.extend.$anonfun.r">r</a> =&gt; <a href="#scalaz.stream.Process.Trampoline" title="=&gt; scalaz.Trampoline.type">Trampoline</a>.<span title="(a: =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F,O]])scalaz.Free.Trampoline[scalaz.stream.Process[F,O]]">suspend</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;Await.rcv" title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,A])scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]">rcv</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;Await.extend.$anonfun.r" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,A]">r</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(f: scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[F2,O2])scalaz.Free[Function0,scalaz.stream.Process[F2,O2]]">map</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;Await.extend.f" title="scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[F2,O2]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>


  <span class="comment">/**
   * The `Append` constructor instructs the driver to continue with
   * evaluation of first step found in tail Vector.
   *
   * Instead of this constructor please use:
   *
   * Process.append
   */</span>
  case class <a href="#scalaz.stream.Process;Append.productElement.x$1" title="class Append[+F[_], +O] extends AnyRef with scalaz.stream.Process[F,O] with Product with Serializable" id="scalaz.stream.Process.Append.readResolve">Append</a><span class="delimiter">[</span>+<a title="[_]" id="scalaz.stream.Process;Append;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Append;F;_">_</a><span class="delimiter">]</span>, +<a title="" id="scalaz.stream.Process;Append;O">O</a><span class="delimiter">]</span><span title="Product" class="delimiter">(</span>
    <a title="scalaz.stream.Process.HaltEmitOrAwait[F,O]" id="scalaz.stream.Process;Append.head">head</a>: <a href="#scalaz.stream.Process;HaltEmitOrAwait" title="scalaz.stream.Process.HaltEmitOrAwait[F,O]">HaltEmitOrAwait</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span>
    , <a title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]" id="scalaz.stream.Process;Append.stack">stack</a>: Vector<span class="delimiter">[</span>Cause =&gt; Trampoline<span class="delimiter">[</span>Process<span class="delimiter">[</span>F, O<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> @<span title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]] @scala.annotation.unchecked.uncheckedVariance">uncheckedVariance</span>
    <span class="delimiter">)</span> extends <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * Helper to modify the head and appended processes
     */</span>
    def <a title="[F2[x] &gt;: F[x], O2](f: scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]" id="scalaz.stream.Process;Append.extend">extend</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream.Process;Append.extend;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Append.extend;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process;Append.extend;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[F2,O2]" id="scalaz.stream.Process;Append.extend.f">f</a>: Process<span class="delimiter">[</span>F, O<span class="delimiter">]</span> =&gt; Process<span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> = <span class="delimiter">{</span>
      val <a title="scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.Free[Function0,scalaz.stream.Process[F2,O2]]]" id="scalaz.stream.Process;Append.extend.ms">ms</a> = <a href="#scalaz.stream.Process;Append.stack" title="=&gt; Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a>.<span title="(f: (scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]) =&gt; (scalaz.stream.Cause =&gt; scalaz.Free[Function0,scalaz.stream.Process[F2,O2]]))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]],scalaz.stream.Cause =&gt; scalaz.Free[Function0,scalaz.stream.Process[F2,O2]],scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.Free[Function0,scalaz.stream.Process[F2,O2]]]])scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.Free[Function0,scalaz.stream.Process[F2,O2]]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector.Coll,scalaz.stream.Cause =&gt; scalaz.Free[Function0,scalaz.stream.Process[F2,O2]],scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.Free[Function0,scalaz.stream.Process[F2,O2]]]]" class="delimiter">(</span><a title="scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]" id="scalaz.stream.Process;Append.extend.ms.$anonfun.n">n</a> =&gt; <span class="delimiter">(</span>cause: <a href="Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Trampoline" title="=&gt; scalaz.Trampoline.type">Trampoline</a>.<span title="(a: =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F,O]])scalaz.Free.Trampoline[scalaz.stream.Process[F,O]]">suspend</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;Append.extend.ms.$anonfun.n" title="(v1: scalaz.stream.Cause)scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]">n</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;Append.extend.ms.$anonfun.$anonfun.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(f: scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[F2,O2])scalaz.Free[Function0,scalaz.stream.Process[F2,O2]]">map</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;Append.extend.f" title="scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[F2,O2]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="#scalaz.stream.Process;Append.extend.f" title="(v1: scalaz.stream.Process[F,O])scalaz.stream.Process[F2,O2]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;Append.head" title="=&gt; scalaz.stream.Process.HaltEmitOrAwait[F,O]">head</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case <a href="#scalaz.stream.Process.HaltEmitOrAwait.unapply" title="(p: scalaz.stream.Process[F2,O2])Option[scalaz.stream.Process.HaltEmitOrAwait[F2,O2]]">HaltEmitOrAwait</a><span class="delimiter">(</span><a title="scalaz.stream.Process.HaltEmitOrAwait[F2,O2]" id="scalaz.stream.Process;Append.extend.p">p</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Append.readResolve" title="(head: scalaz.stream.Process.HaltEmitOrAwait[F2,O2], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]])scalaz.stream.Process.Append[F2,O2]">Append</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;Append.extend.p" title="scalaz.stream.Process.HaltEmitOrAwait[F2,O2]">p</a>, <a href="#scalaz.stream.Process;Append.extend.ms" title="scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.Free[Function0,scalaz.stream.Process[F2,O2]]]">ms</a><span class="delimiter">)</span>
        case <a title="scalaz.stream.Process.Append[F2 @unchecked,O2 @unchecked]" id="scalaz.stream.Process;Append.extend.app">app</a>: <a href="#scalaz.stream.Process.Append.readResolve" title="scalaz.stream.Process.Append[F2 @unchecked,O2 @unchecked]">Append</a><span class="delimiter">[</span>F2@unchecked, O2@unchecked<span class="delimiter">]</span> =&gt; <a href="#scalaz.stream.Process.Append.readResolve" title="(head: scalaz.stream.Process.HaltEmitOrAwait[F2,O2], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]])scalaz.stream.Process.Append[F2,O2]">Append</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;Append.extend.app" title="scalaz.stream.Process.Append[F2 @unchecked,O2 @unchecked]">app</a>.<a href="#scalaz.stream.Process;Append.head" title="=&gt; scalaz.stream.Process.HaltEmitOrAwait[F2 @unchecked,O2 @unchecked]">head</a>, <a href="#scalaz.stream.Process;Append.extend.app" title="scalaz.stream.Process.Append[F2 @unchecked,O2 @unchecked]">app</a>.<a href="Util.scala.html#scalaz.stream.Util.AppendSyntax(629eae9601)" title="(self: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2 @unchecked,O2 @unchecked]]])scalaz.stream.Util.AppendSyntax[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2 @unchecked,O2 @unchecked]]]">stack</a> <a href="Util.scala.html#scalaz.stream.Util;AppendSyntax.fast_++" title="(other: Seq[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]])Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]]">fast_++</a> <a href="#scalaz.stream.Process;Append.extend.ms" title="scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.Free[Function0,scalaz.stream.Process[F2,O2]]]">ms</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  <span class="comment">/**
   * Marker trait representing next step of process or terminated process in `Halt`
   */</span>
  sealed trait <a title="trait HaltOrStep[+F[_], +O] extends AnyRef" id="scalaz.stream.Process;HaltOrStep">HaltOrStep</a><span class="delimiter">[</span>+<a title="[_]" id="scalaz.stream.Process;HaltOrStep;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;HaltOrStep;F;_">_</a><span class="delimiter">]</span>, +<a title="" id="scalaz.stream.Process;HaltOrStep;O">O</a><span class="delimiter">]</span>

  <span class="comment">/**
   * Intermediate step of process.
   * Used to step within the process to define complex combinators.
   */</span>
  case class <a href="#scalaz.stream.Process;Step.productElement.x$1" title="class Step[+F[_], +O] extends AnyRef with scalaz.stream.Process.HaltOrStep[F,O] with Product with Serializable" id="scalaz.stream.Process.Step.readResolve">Step</a><span class="delimiter">[</span>+<a title="[_]" id="scalaz.stream.Process;Step;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Step;F;_">_</a><span class="delimiter">]</span>, +<a title="" id="scalaz.stream.Process;Step;O">O</a><span class="delimiter">]</span><span title="Product" class="delimiter">(</span><a title="scalaz.stream.Process.EmitOrAwait[F,O]" id="scalaz.stream.Process;Step.head">head</a>: <a href="#scalaz.stream.Process;EmitOrAwait" title="scalaz.stream.Process.EmitOrAwait[F,O]">EmitOrAwait</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span>, <a title="scalaz.stream.Process.Cont[F,O]" id="scalaz.stream.Process;Step.next">next</a>: <a href="#scalaz.stream.Process;Cont" title="scalaz.stream.Process.Cont[F,O]">Cont</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scalaz.stream.Process;HaltOrStep" title="scalaz.stream.Process.HaltOrStep[F,O]">HaltOrStep</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="=&gt; scalaz.stream.Process[F,O]" id="scalaz.stream.Process;Step.toProcess">toProcess</a> : <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> = <a href="#scalaz.stream.Process.Append.readResolve" title="(head: scalaz.stream.Process.HaltEmitOrAwait[F,O], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process.Append[F,O]">Append</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;Step.head" title="=&gt; scalaz.stream.Process.EmitOrAwait[F,O]">head</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scalaz.stream.Process.HaltEmitOrAwait[F,O]" class="delimiter">[</span><a href="#scalaz.stream.Process;HaltEmitOrAwait" title="scalaz.stream.Process.HaltEmitOrAwait[F,O]">HaltEmitOrAwait</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span><span class="delimiter">]</span>,<a href="#scalaz.stream.Process;Step.next" title="=&gt; scalaz.stream.Process.Cont[F,O]">next</a>.<a href="#scalaz.stream.Process;Cont.stack" title="=&gt; Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Continuation of the process. Represents process _stack_. Used in conjunction with `Step`.
   */</span>
  case class <a href="#scalaz.stream.Process;Cont.productElement.x$1" title="class Cont[+F[_], +O] extends AnyRef with Product with Serializable" id="scalaz.stream.Process;Cont">Cont</a><span class="delimiter">[</span>+<a title="[_]" id="scalaz.stream.Process;Cont;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Cont;F;_">_</a><span class="delimiter">]</span>, +<a title="" id="scalaz.stream.Process;Cont;O">O</a><span class="delimiter">]</span><a href="#scalaz.stream.Process;Cont" title="Product" class="delimiter">(</a><a title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]" id="scalaz.stream.Process;Cont.stack">stack</a>: Vector<span class="delimiter">[</span>Cause =&gt; Trampoline<span class="delimiter">[</span>Process<span class="delimiter">[</span>F, O<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> @<span title="Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]] @scala.annotation.unchecked.uncheckedVariance">uncheckedVariance</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * Prepends supplied process to this stack
     */</span>
    def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](p: scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]" id="scalaz.stream.Process;Cont.+:">+:</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream.Process;Cont.+:;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Cont.+:;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream.Process;Cont.+:;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F2,O2]" id="scalaz.stream.Process;Cont.+:.p">p</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> = <a href="#scalaz.stream.Process;Cont.prepend" title="(p: scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]">prepend</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;Cont.+:.p" title="scalaz.stream.Process[F2,O2]">p</a><span class="delimiter">)</span>

    <span class="comment">/** alias for +: */</span>
    def <a title="[F2[x] &gt;: F[x], O2 &gt;: O](p: scalaz.stream.Process[F2,O2])scalaz.stream.Process[F2,O2]" id="scalaz.stream.Process;Cont.prepend">prepend</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream.Process;Cont.prepend;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Cont.prepend;F2;x">x</a><span class="delimiter">]</span> &gt;: F<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title=" &gt;: O" id="scalaz.stream.Process;Cont.prepend;O2">O2</a> &gt;: O<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F2,O2]" id="scalaz.stream.Process;Cont.prepend.p">p</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scalaz.stream.Process;Cont.stack" title="=&gt; Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#scalaz.stream.Process;Cont.prepend.p" title="scalaz.stream.Process[F2,O2]">p</a>
      else <a href="#scalaz.stream.Process;Cont.prepend.p" title="scalaz.stream.Process[F2,O2]">p</a> match <span class="delimiter">{</span>
        case <a title="scalaz.stream.Process.Append[F2 @unchecked,O2 @unchecked]" id="scalaz.stream.Process;Cont.prepend.app">app</a>: <a href="#scalaz.stream.Process.Append.readResolve" title="scalaz.stream.Process.Append[F2 @unchecked,O2 @unchecked]">Append</a><span class="delimiter">[</span>F2@unchecked, O2@unchecked<span class="delimiter">]</span> =&gt; <a href="#scalaz.stream.Process.Append.readResolve" title="[F[_], O](head: scalaz.stream.Process.HaltEmitOrAwait[F,O], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process.Append[F,O]">Append</a><span title="(head: scalaz.stream.Process.HaltEmitOrAwait[F2,O2], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]])scalaz.stream.Process.Append[F2,O2]" class="delimiter">[</span><a href="#scalaz.stream.Process;Cont.prepend;F2" title="F2">F2</a>, <a href="#scalaz.stream.Process;Cont.prepend;O2" title="O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;Cont.prepend.app" title="scalaz.stream.Process.Append[F2 @unchecked,O2 @unchecked]">app</a>.<a href="#scalaz.stream.Process;Append.head" title="=&gt; scalaz.stream.Process.HaltEmitOrAwait[F2 @unchecked,O2 @unchecked]">head</a>, <a href="#scalaz.stream.Process;Cont.prepend.app" title="scalaz.stream.Process.Append[F2 @unchecked,O2 @unchecked]">app</a>.<a href="Util.scala.html#scalaz.stream.Util.AppendSyntax(629eae9601)" title="(self: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2 @unchecked,O2 @unchecked]]])scalaz.stream.Util.AppendSyntax[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2 @unchecked,O2 @unchecked]]]">stack</a> <a href="Util.scala.html#scalaz.stream.Util;AppendSyntax.fast_++" title="(other: Seq[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]])Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]]">fast_++</a> <a href="#scalaz.stream.Process;Cont.stack" title="=&gt; Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a><span class="delimiter">)</span>
        case <a title="scalaz.stream.Process.Emit[O2 @unchecked]" id="scalaz.stream.Process;Cont.prepend.emt">emt</a>: <a href="#scalaz.stream.Process.Emit.readResolve" title="scalaz.stream.Process.Emit[O2 @unchecked]">Emit</a><span class="delimiter">[</span>O2@unchecked<span class="delimiter">]</span> =&gt; <a href="#scalaz.stream.Process.Append.readResolve" title="(head: scalaz.stream.Process.HaltEmitOrAwait[F,O2], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O2]]])scalaz.stream.Process.Append[F,O2]">Append</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;Cont.prepend.emt" title="scalaz.stream.Process.Emit[O2 @unchecked]">emt</a>, <a href="#scalaz.stream.Process;Cont.stack" title="=&gt; Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a><span class="delimiter">)</span>
        case <a title="scalaz.stream.Process.Await[F2 @unchecked,_,O2 @unchecked]" id="scalaz.stream.Process;Cont.prepend.awt">awt</a>: <a href="#scalaz.stream.Process.Await.readResolve" title="scalaz.stream.Process.Await[F2 @unchecked,_,O2 @unchecked]">Await</a><span class="delimiter">[</span>F2@unchecked, _, O2@unchecked<span class="delimiter">]</span> =&gt; <a href="#scalaz.stream.Process.Append.readResolve" title="(head: scalaz.stream.Process.HaltEmitOrAwait[F2,O2], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]])scalaz.stream.Process.Append[F2,O2]">Append</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;Cont.prepend.awt" title="scalaz.stream.Process.Await[F2 @unchecked,_,O2 @unchecked]">awt</a>, <a href="#scalaz.stream.Process;Cont.stack" title="=&gt; Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a><span class="delimiter">)</span>
        case <a title="scalaz.stream.Process.Halt" id="scalaz.stream.Process;Cont.prepend.hlt">hlt</a>@Halt<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Append.readResolve" title="(head: scalaz.stream.Process.HaltEmitOrAwait[F,O], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process.Append[F,O]">Append</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;Cont.prepend.hlt" title="scalaz.stream.Process.Halt">hlt</a>, <a href="#scalaz.stream.Process;Cont.stack" title="=&gt; Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Converts this stack to process, that is used
     * when following process with normal termination.
     */</span>
    def <a title="=&gt; scalaz.stream.Process[F,O]" id="scalaz.stream.Process;Cont.continue">continue</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> = <a href="#scalaz.stream.Process;Cont.prepend" title="(p: scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">prepend</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Applies transformation function `f` to all frames of this stack.
     */</span>
    def <a title="[F2[_], O2](f: scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[F2,O2])scalaz.stream.Process.Cont[F2,O2]" id="scalaz.stream.Process;Cont.extend">extend</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process;Cont.extend;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Cont.extend;F2;_">_</a><span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process;Cont.extend;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[F2,O2]" id="scalaz.stream.Process;Cont.extend.f">f</a>: Process<span class="delimiter">[</span>F, O<span class="delimiter">]</span> =&gt; Process<span class="delimiter">[</span>F2, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream.Process;Cont" title="scalaz.stream.Process.Cont[F2,O2]">Cont</a><span class="delimiter">[</span>F2, O2<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process;Cont" title="(stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]])scalaz.stream.Process.Cont[F2,O2]">Cont</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;Cont.stack" title="=&gt; Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a>.<span title="(f: (scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]) =&gt; (scalaz.stream.Cause =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]]))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]],scalaz.stream.Cause =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]],Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]]])Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F2,O2]]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector.Coll,scalaz.stream.Cause =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]],scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]]]]" class="delimiter">(</span><a title="scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]" id="scalaz.stream.Process;Cont.extend.$anonfun.tf">tf</a> =&gt; <span class="delimiter">(</span>cause: <a href="Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Trampoline" title="=&gt; scalaz.Trampoline.type">Trampoline</a>.<span title="(a: =&gt; scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]])scalaz.Free.Trampoline[scalaz.stream.Process[F2,O2]]">suspend</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;Cont.extend.$anonfun.tf" title="(v1: scalaz.stream.Cause)scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]">tf</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;Cont.extend.$anonfun.$anonfun.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span>.<span title="(f: scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[F2,O2])scalaz.Free[Function0,scalaz.stream.Process[F2,O2]]">map</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;Cont.extend.f" title="scalaz.stream.Process[F,O] =&gt; scalaz.stream.Process[F2,O2]">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>


    <span class="comment">/**
     * Returns true, when this continuation is empty, i.e. no more appends to process
     */</span>
    def <a title="=&gt; Boolean" id="scalaz.stream.Process;Cont.isEmpty">isEmpty</a> : <span title="Boolean">Boolean</span> = <a href="#scalaz.stream.Process;Cont.stack" title="=&gt; Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">stack</a>.<span title="=&gt; Boolean">isEmpty</span>

  <span class="delimiter">}</span>

  object <a title="scalaz.stream.Process.Cont.type" id="scalaz.stream.Process.Cont.readResolve">Cont</a> <a href="#scalaz.stream.Process.Cont.readResolve" title="scalaz.stream.Process.Cont.type" class="delimiter">{</a>
    <span class="comment">/** empty continuation, that means evaluation is at end **/</span>
    val <a title="scalaz.stream.Process.Cont[Nothing,Nothing]" id="scalaz.stream.Process.Cont.empty">empty</a>:<a href="#scalaz.stream.Process;Cont" title="scalaz.stream.Process.Cont[Nothing,Nothing]">Cont</a><span class="delimiter">[</span>Nothing,Nothing<span class="delimiter">]</span> = <a href="#scalaz.stream.Process;Cont" title="(stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[Nothing,Nothing]]])scalaz.stream.Process.Cont[Nothing,Nothing]">Cont</a><span class="delimiter">(</span><span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>


  <span class="comment">///////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="comment">//</span>
  <span class="comment">// CONSTRUCTORS</span>
  <span class="comment">//</span>
  <span class="comment">//////////////////////////////////////////////////////////////////////////////////////</span>

  <span class="comment">/** Alias for emitAll */</span>
  def <a title="[O](o: O*)scalaz.stream.Process0[O]" id="scalaz.stream.Process.apply">apply</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.apply;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="O*" id="scalaz.stream.Process.apply.o">o</a>: <span title="O*">O</span>*<span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[O]">Process0</a><span class="delimiter">[</span>O<span class="delimiter">]</span> = <a href="#scalaz.stream.Process.emitAll" title="(os: Seq[O])scalaz.stream.Process0[O]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.apply.o" title="O*">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Await the given `F` request and use its result.
   * If you need to specify fallback, use `awaitOr`
   */</span>
  def <a title="[F[_], A, O](req: F[A])(rcv: A =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]" id="scalaz.stream.Process.await">await</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.await;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.await;F;_">_</a><span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process.await;A">A</a>, <a title="" id="scalaz.stream.Process.await;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="scalaz.stream.Process.await.req">req</a>: <a href="#scalaz.stream.Process.await;F" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.stream.Process[F,O]" id="scalaz.stream.Process.await.rcv">rcv</a>: A =&gt; Process<span class="delimiter">[</span>F, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.awaitOr" title="(req: F[A])(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[F,O])(rcv: A =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">awaitOr</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.await.req" title="F[A]">req</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.Halt.readResolve" title="scalaz.stream.Process.Halt.type">Halt</a>.<a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">apply</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.await.rcv" title="A =&gt; scalaz.stream.Process[F,O]">rcv</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Await a request, and if it fails, use `fb` to determine the next state.
   * Otherwise, use `rcv` to determine the next state.
   */</span>
  def <a title="[F[_], A, O](req: F[A])(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[F,O])(rcv: A =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]" id="scalaz.stream.Process.awaitOr">awaitOr</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.awaitOr;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.awaitOr;F;_">_</a><span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process.awaitOr;A">A</a>, <a title="" id="scalaz.stream.Process.awaitOr;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="scalaz.stream.Process.awaitOr.req">req</a>: <a href="#scalaz.stream.Process.awaitOr;F" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>
    <a title="scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[F,O]" id="scalaz.stream.Process.awaitOr.fb">fb</a>: EarlyCause =&gt; Process<span class="delimiter">[</span>F, O<span class="delimiter">]</span>
    <span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.stream.Process[F,O]" id="scalaz.stream.Process.awaitOr.rcv">rcv</a>: A =&gt; Process<span class="delimiter">[</span>F, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#scalaz.stream.Process.Await.readResolve" title="(req: F[A], rcv: scalaz.\/[scalaz.stream.Cause.EarlyCause,A] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]])scalaz.stream.Process.Await[F,A,O]">Await</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.awaitOr.req" title="F[A]">req</a>, <span class="delimiter">(</span>r: EarlyCause <span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,A]">\/</span> A<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Trampoline" title="=&gt; scalaz.Trampoline.type">Trampoline</a>.<span title="(a: =&gt; scalaz.stream.Process[F,O])scalaz.Free.Trampoline[scalaz.stream.Process[F,O]]">delay</span><span class="delimiter">(</span><a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.awaitOr.$anonfun.r" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,A]">r</a>.<span title="(l: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[F,O], r: A =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">fold</span><span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.Process.awaitOr.$anonfun.$anonfun.ec">ec</a> =&gt; <a href="#scalaz.stream.Process.awaitOr.fb" title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.stream.Process[F,O]">fb</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.awaitOr.$anonfun.$anonfun.ec" title="scalaz.stream.Cause.EarlyCause">ec</a><span class="delimiter">)</span>, <a title="A" id="scalaz.stream.Process.awaitOr.$anonfun.$anonfun.a">a</a> =&gt; <a href="#scalaz.stream.Process.awaitOr.rcv" title="(v1: A)scalaz.stream.Process[F,O]">rcv</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.awaitOr.$anonfun.$anonfun.a" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The `Process1` which awaits a single input, emits it, then halts normally. */</span>
  def <a title="[I]=&gt; scalaz.stream.Process1[I,I]" id="scalaz.stream.Process.await1">await1</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.await1;I">I</a><span class="delimiter">]</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.receive1" title="(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]">receive1</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">)</span>

  <span class="comment">/** `Writer` based version of `await1`. */</span>
  def <a title="[A]=&gt; scalaz.stream.Writer1[Nothing,A,A]" id="scalaz.stream.Process.await1W">await1W</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.await1W;A">A</a><span class="delimiter">]</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Writer1[Nothing,A,A]">Writer1</a><span class="delimiter">[</span>Nothing, A, A<span class="delimiter">]</span> =
    <a href="writer.scala.html#scalaz.stream.writer" title="scalaz.stream.writer.type">writer</a>.<a href="writer.scala.html#scalaz.stream.writer.liftO" title="(p: scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Is,A])scalaz.stream.Writer[scalaz.stream.Process.Env[A,Any]#Is,Nothing,A]">liftO</a><span class="delimiter">(</span><a href="#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="#scalaz.stream.Process.await1" title="[I]=&gt; scalaz.stream.Process1[I,I]">await1</a><span title="scalaz.stream.Process1[A,A]" class="delimiter">[</span><a href="#scalaz.stream.Process.await1W;A" title="A">A</a><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="comment">/** Like `await1`, but consults `fb` when await fails to receive an `I` */</span>
  def <a title="[I](fb: =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]" id="scalaz.stream.Process.await1Or">await1Or</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.await1Or;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.stream.Process1[I,I]" id="scalaz.stream.Process.await1Or.fb">fb</a>: =&gt; Process1<span class="delimiter">[</span>I, I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[I,I]">Process1</a><span class="delimiter">[</span>I, I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.receive1Or" title="(fb: =&gt; scalaz.stream.Process1[I,I])(rcv: I =&gt; scalaz.stream.Process1[I,I])scalaz.stream.Process1[I,I]">receive1Or</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.await1Or.fb" title="=&gt; scalaz.stream.Process1[I,I]">fb</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">)</span>

  <span class="comment">/** The `Wye` which request from both branches concurrently. */</span>
  def <a title="[I, I2]=&gt; scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]" id="scalaz.stream.Process.awaitBoth">awaitBoth</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.awaitBoth;I">I</a>, <a title="" id="scalaz.stream.Process.awaitBoth;I2">I2</a><span class="delimiter">]</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]">Wye</a><span class="delimiter">[</span>I, I2, ReceiveY<span class="delimiter">[</span>I, I2<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.await" title="(req: scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]])(rcv: scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.ReceiveY[I,I2]])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.ReceiveY[I,I2]]">await</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.Both" title="[I, I2]=&gt; scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]">Both</a><span title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]" class="delimiter">[</span><a href="#scalaz.stream.Process.awaitBoth;I" title="I">I</a>, <a href="#scalaz.stream.Process.awaitBoth;I2" title="I2">I2</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.emit" title="(o: scalaz.stream.ReceiveY[I,I2])scalaz.stream.Process0[scalaz.stream.ReceiveY[I,I2]]">emit</a><span class="delimiter">)</span>

  <span class="comment">/** `Writer` based version of `awaitBoth`. */</span>
  def <a title="[I, I2]=&gt; scalaz.stream.WyeW[Nothing,I,I2,scalaz.stream.ReceiveY[I,I2]]" id="scalaz.stream.Process.awaitBothW">awaitBothW</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.awaitBothW;I">I</a>, <a title="" id="scalaz.stream.Process.awaitBothW;I2">I2</a><span class="delimiter">]</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.WyeW[Nothing,I,I2,scalaz.stream.ReceiveY[I,I2]]">WyeW</a><span class="delimiter">[</span>Nothing, I, I2, ReceiveY<span class="delimiter">[</span>I, I2<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="writer.scala.html#scalaz.stream.writer" title="scalaz.stream.writer.type">writer</a>.<a href="writer.scala.html#scalaz.stream.writer.liftO" title="(p: scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.ReceiveY[I,I2]])scalaz.stream.Writer[scalaz.stream.Process.Env[I,I2]#Y,Nothing,scalaz.stream.ReceiveY[I,I2]]">liftO</a><span class="delimiter">(</span><a href="#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="#scalaz.stream.Process.awaitBoth" title="[I, I2]=&gt; scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]">awaitBoth</a><span title="scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]" class="delimiter">[</span><a href="#scalaz.stream.Process.awaitBothW;I" title="I">I</a>, <a href="#scalaz.stream.Process.awaitBothW;I2" title="I2">I2</a><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="comment">/** The `Tee` which requests from the left branch, emits this value, then halts. */</span>
  def <a title="[I]=&gt; scalaz.stream.Tee[I,Any,I]" id="scalaz.stream.Process.awaitL">awaitL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.awaitL;I">I</a><span class="delimiter">]</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Tee[I,Any,I]">Tee</a><span class="delimiter">[</span>I, Any, I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.await" title="(req: scalaz.stream.Process.Env[I,Any]#Is[I])(rcv: I =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,I]">await</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.L" title="[I]=&gt; scalaz.stream.Process.Env[I,Any]#Is[I]">L</a><span title="scalaz.stream.Process.Env[I,Any]#Is[I]" class="delimiter">[</span><a href="#scalaz.stream.Process.awaitL;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">)</span>

  <span class="comment">/** `Writer` based version of `awaitL`. */</span>
  def <a title="[I]=&gt; scalaz.stream.TeeW[Nothing,I,Any,I]" id="scalaz.stream.Process.awaitLW">awaitLW</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.awaitLW;I">I</a><span class="delimiter">]</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.TeeW[Nothing,I,Any,I]">TeeW</a><span class="delimiter">[</span>Nothing, I, Any, I<span class="delimiter">]</span> =
    <a href="writer.scala.html#scalaz.stream.writer" title="scalaz.stream.writer.type">writer</a>.<a href="writer.scala.html#scalaz.stream.writer.liftO" title="(p: scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#T,I])scalaz.stream.Writer[scalaz.stream.Process.Env[I,Any]#T,Nothing,I]">liftO</a><span class="delimiter">(</span><a href="#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="#scalaz.stream.Process.awaitL" title="[I]=&gt; scalaz.stream.Tee[I,Any,I]">awaitL</a><span title="scalaz.stream.Tee[I,Any,I]" class="delimiter">[</span><a href="#scalaz.stream.Process.awaitLW;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="comment">/** The `Tee` which requests from the right branch, emits this value, then halts. */</span>
  def <a title="[I2]=&gt; scalaz.stream.Tee[Any,I2,I2]" id="scalaz.stream.Process.awaitR">awaitR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.awaitR;I2">I2</a><span class="delimiter">]</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Tee[Any,I2,I2]">Tee</a><span class="delimiter">[</span>Any, I2, I2<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.await" title="(req: scalaz.stream.Process.Env[Any,I2]#T[I2])(rcv: I2 =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Any,I2]#T,I2])scalaz.stream.Process[scalaz.stream.Process.Env[Any,I2]#T,I2]">await</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.R" title="[I2]=&gt; scalaz.stream.Process.Env[Any,I2]#T[I2]">R</a><span title="scalaz.stream.Process.Env[Any,I2]#T[I2]" class="delimiter">[</span><a href="#scalaz.stream.Process.awaitR;I2" title="I2">I2</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.emit" title="(o: I2)scalaz.stream.Process0[I2]">emit</a><span class="delimiter">)</span>

  <span class="comment">/** `Writer` based version of `awaitR`. */</span>
  def <a title="[I2]=&gt; scalaz.stream.TeeW[Nothing,Any,I2,I2]" id="scalaz.stream.Process.awaitRW">awaitRW</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.awaitRW;I2">I2</a><span class="delimiter">]</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.TeeW[Nothing,Any,I2,I2]">TeeW</a><span class="delimiter">[</span>Nothing, Any, I2, I2<span class="delimiter">]</span> =
    <a href="writer.scala.html#scalaz.stream.writer" title="scalaz.stream.writer.type">writer</a>.<a href="writer.scala.html#scalaz.stream.writer.liftO" title="(p: scalaz.stream.Process[scalaz.stream.Process.Env[Any,I2]#T,I2])scalaz.stream.Writer[scalaz.stream.Process.Env[Any,I2]#T,Nothing,I2]">liftO</a><span class="delimiter">(</span><a href="#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="#scalaz.stream.Process.awaitR" title="[I2]=&gt; scalaz.stream.Tee[Any,I2,I2]">awaitR</a><span title="scalaz.stream.Tee[Any,I2,I2]" class="delimiter">[</span><a href="#scalaz.stream.Process.awaitRW;I2" title="I2">I2</a><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="comment">/**
   * The infinite `Process`, always emits `a`.
   * If for performance reasons it is good to emit `a` in chunks,
   * specify size of chunk by `chunkSize` parameter
   */</span>
  def <a title="[A](a: A, chunkSize: Int)scalaz.stream.Process0[A]" id="scalaz.stream.Process.constant">constant</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.constant$default$2;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="scalaz.stream.Process.constant.a">a</a>: <a href="#scalaz.stream.Process.constant$default$2;A" title="A">A</a>, <a title="Int" id="scalaz.stream.Process.constant$default$2">chunkSize</a>: <span title="Int">Int</span> = <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[A]">Process0</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    lazy val <a title="scalaz.stream.Process0[A]" id="scalaz.stream.Process.constant.go">go</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[A]">Process0</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#scalaz.stream.Process.constant$default$2" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">chunkSize</a>.<span title="(that: Int)Int">max</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#scalaz.stream.Process.emit" title="(o: A)scalaz.stream.Process0[A]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.constant.a" title="A">a</a><span class="delimiter">)</span> <a href="#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[Nothing,A])scalaz.stream.Process[Nothing,A]">++</a> <a href="#scalaz.stream.Process.constant.go" title="=&gt; scalaz.stream.Process0[A]">go</a>
      else <a href="#scalaz.stream.Process.emitAll" title="(os: Seq[A])scalaz.stream.Process0[A]">emitAll</a><span class="delimiter">(</span><span title="scala.collection.immutable.List.type">List</span>.<span title="(n: Int)(elem: =&gt; A)List[A]">fill</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.constant$default$2" title="Int">chunkSize</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.constant.a" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[Nothing,A])scalaz.stream.Process[Nothing,A]">++</a> <a href="#scalaz.stream.Process.constant.go" title="=&gt; scalaz.stream.Process0[A]">go</a>
    <a href="#scalaz.stream.Process.constant.go" title="=&gt; scalaz.stream.Process0[A]">go</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The `Process` which emits the single value given, then halts. */</span>
  def <a title="[O](o: O)scalaz.stream.Process0[O]" id="scalaz.stream.Process.emit">emit</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.emit;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="O" id="scalaz.stream.Process.emit.o">o</a>: <a href="#scalaz.stream.Process.emit;O" title="O">O</a><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[O]">Process0</a><span class="delimiter">[</span>O<span class="delimiter">]</span> = <a href="#scalaz.stream.Process.Emit.readResolve" title="(seq: Seq[O])scalaz.stream.Process.Emit[O]">Emit</a><span class="delimiter">(</span><span title="(elems: O*)scala.collection.immutable.Vector[O]">Vector</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.emit.o" title="O">o</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** The `Process` which emits the given sequence of values, then halts. */</span>
  def <a title="[O](os: Seq[O])scalaz.stream.Process0[O]" id="scalaz.stream.Process.emitAll">emitAll</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.emitAll;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.Process.emitAll.os">os</a>: <span title="Seq[O]">Seq</span><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[O]">Process0</a><span class="delimiter">[</span>O<span class="delimiter">]</span> = <a href="#scalaz.stream.Process.Emit.readResolve" title="(seq: Seq[O])scalaz.stream.Process.Emit[O]">Emit</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.emitAll.os" title="Seq[O]">os</a><span class="delimiter">)</span>

  <span class="comment">/** A `Writer` which emits one value to the output. */</span>
  def <a title="[O](o: O)scalaz.stream.Process0[scalaz.\/[Nothing,O]]" id="scalaz.stream.Process.emitO">emitO</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.emitO;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="O" id="scalaz.stream.Process.emitO.o">o</a>: <a href="#scalaz.stream.Process.emitO;O" title="O">O</a><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[scalaz.\/[Nothing,O]]">Process0</a><span class="delimiter">[</span>Nothing \/ O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.emit" title="(o: scalaz.\/[Nothing,O])scalaz.stream.Process0[scalaz.\/[Nothing,O]]">emit</a><span class="delimiter">(</span><span title="(v1: O)scalaz.\/[Nothing,O]">right</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.emitO.o" title="O">o</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A `Writer` which writes the given value. */</span>
  def <a title="[W](s: W)scalaz.stream.Process0[scalaz.\/[W,Nothing]]" id="scalaz.stream.Process.emitW">emitW</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.emitW;W">W</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="W" id="scalaz.stream.Process.emitW.s">s</a>: <a href="#scalaz.stream.Process.emitW;W" title="W">W</a><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[scalaz.\/[W,Nothing]]">Process0</a><span class="delimiter">[</span>W \/ Nothing<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.emit" title="(o: scalaz.\/[W,Nothing])scalaz.stream.Process0[scalaz.\/[W,Nothing]]">emit</a><span class="delimiter">(</span><span title="(v1: W)scalaz.\/[W,Nothing]">left</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.emitW.s" title="W">s</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** The `Process` which emits no values and halts immediately with the given exception. */</span>
  def <a title="(rsn: Throwable)scalaz.stream.Process0[Nothing]" id="scalaz.stream.Process.fail">fail</a><span class="delimiter">(</span><a title="Throwable" id="scalaz.stream.Process.fail.rsn">rsn</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[Nothing]">Process0</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> = <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause;Error" title="(rsn: Throwable)scalaz.stream.Cause.Error">Error</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.fail.rsn" title="Throwable">rsn</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A `Process` which emits `n` repetitions of `a`. */</span>
  def <a title="[A](n: Int)(a: A, chunkSize: Int)scalaz.stream.Process0[A]" id="scalaz.stream.Process.fill">fill</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.fill$default$3;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scalaz.stream.Process.fill$default$3.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A" id="scalaz.stream.Process.fill.a">a</a>: <a href="#scalaz.stream.Process.fill$default$3;A" title="A">A</a>, <a title="Int" id="scalaz.stream.Process.fill$default$3">chunkSize</a>: <span title="Int">Int</span> = <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[A]">Process0</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val chunkN = <a href="#scalaz.stream.Process.fill$default$3" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">chunkSize</a> <a title="Int" id="scalaz.stream.Process.fill.chunkN">max</a> <span title="Int(1)" class="int">1</span>
    val <a title="scalaz.stream.Process0[A]" id="scalaz.stream.Process.fill.chunk">chunk</a> = <a href="#scalaz.stream.Process.emitAll" title="(os: Seq[A])scalaz.stream.Process0[A]">emitAll</a><span class="delimiter">(</span><span title="scala.collection.immutable.List.type">List</span>.<span title="(n: Int)(elem: =&gt; A)List[A]">fill</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.fill.chunkN" title="Int">chunkN</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.fill.a" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// we can reuse this for each step</span>
    def <a title="(m: Int)scalaz.stream.Process0[A]" id="scalaz.stream.Process.fill.go">go</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream.Process.fill.go.m">m</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[A]">Process0</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#scalaz.stream.Process.fill.go.m" title="Int">m</a> <span title="(x: Int)Boolean">&gt;=</span> <a href="#scalaz.stream.Process.fill.chunkN" title="Int">chunkN</a><span class="delimiter">)</span> <a href="#scalaz.stream.Process.fill.chunk" title="scalaz.stream.Process0[A]">chunk</a> <a href="#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[Nothing,A])scalaz.stream.Process[Nothing,A]">++</a> <a href="#scalaz.stream.Process.fill.go" title="(m: Int)scalaz.stream.Process0[A]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.fill.go.m" title="Int">m</a> <span title="(x: Int)Int">-</span> <a href="#scalaz.stream.Process.fill.chunkN" title="Int">chunkN</a><span class="delimiter">)</span>
      else if <span class="delimiter">(</span><a href="#scalaz.stream.Process.fill.go.m" title="Int">m</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>
      else <a href="#scalaz.stream.Process.emitAll" title="(os: Seq[A])scalaz.stream.Process0[A]">emitAll</a><span class="delimiter">(</span><span title="scala.collection.immutable.List.type">List</span>.<span title="(n: Int)(elem: =&gt; A)List[A]">fill</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.fill.go.m" title="Int">m</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.fill.a" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#scalaz.stream.Process.fill.go" title="(m: Int)scalaz.stream.Process0[A]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.fill$default$3.n" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">n</a> <span title="(that: Int)Int">max</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Produce a continuous stream from a discrete stream by using the
   * most recent value.
   */</span>
  def <a title="[A](p: scalaz.stream.Process[scalaz.concurrent.Task,A])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,A]" id="scalaz.stream.Process.forwardFill">forwardFill</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.forwardFill;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.concurrent.Task,A]" id="scalaz.stream.Process.forwardFill.p">p</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,A]">Process</a><span class="delimiter">[</span>Task, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream.Process.forwardFill.S">S</a>: <span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,A]">Process</a><span class="delimiter">[</span>Task, A<span class="delimiter">]</span> =
    async.<a href="async/package.scala.html#scalaz.stream.async.package.toSignal" title="(source: scalaz.stream.Process[scalaz.concurrent.Task,A], haltOnSource: Boolean)(implicit S: scalaz.concurrent.Strategy)scalaz.stream.async.mutable.Signal[A]">toSignal</a><a href="#scalaz.stream.Process.forwardFill.S" title="scalaz.concurrent.Strategy" class="delimiter">(</a><a href="#scalaz.stream.Process.forwardFill.p" title="scalaz.stream.Process[scalaz.concurrent.Task,A]">p</a><span class="delimiter">)</span>.<a href="async/immutable/Signal.scala.html#scalaz.stream.async.immutable;Signal.continuous" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,A]">continuous</a>

  <span class="comment">/** `halt` but with precise type. */</span>
  private<span class="delimiter">[</span>stream<span class="delimiter">]</span> val <a title="scalaz.stream.Process.Halt" id="scalaz.stream.Process.halt0">halt0</a>: <a href="#scalaz.stream.Process.Halt.readResolve" title="scalaz.stream.Process.Halt">Halt</a> = <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span>

  <span class="comment">/** The `Process` which emits no values and signals normal termination. */</span>
  val <a title="scalaz.stream.Process0[Nothing]" id="scalaz.stream.Process.halt">halt</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[Nothing]">Process0</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> = <a href="#scalaz.stream.Process.halt0" title="=&gt; scalaz.stream.Process.Halt">halt0</a>

  <span class="comment">/** Alias for `halt`. */</span>
  def <a title="[F[_], O]=&gt; scalaz.stream.Process[F,O]" id="scalaz.stream.Process.empty">empty</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.empty;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.empty;F;_">_</a><span class="delimiter">]</span>,<a title="" id="scalaz.stream.Process.empty;O">O</a><span class="delimiter">]</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> = <a href="#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>

  <span class="comment">/**
   * An infinite `Process` that repeatedly applies a given function
   * to a start value. `start` is the first value emitted, followed
   * by `f(start)`, then `f(f(start))`, and so on.
   */</span>
  def <a title="[A](start: A)(f: A =&gt; A)scalaz.stream.Process0[A]" id="scalaz.stream.Process.iterate">iterate</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.iterate;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="scalaz.stream.Process.iterate.start">start</a>: <a href="#scalaz.stream.Process.iterate;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; A" id="scalaz.stream.Process.iterate.f">f</a>: A =&gt; A<span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[A]">Process0</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.emit" title="(o: A)scalaz.stream.Process0[A]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.iterate.start" title="A">start</a><span class="delimiter">)</span> <a href="#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[Nothing,A])scalaz.stream.Process[Nothing,A]">++</a> <a href="#scalaz.stream.Process.iterate" title="(start: A)(f: A =&gt; A)scalaz.stream.Process0[A]">iterate</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.iterate.f" title="(v1: A)A">f</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.iterate.start" title="A">start</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.iterate.f" title="A =&gt; A">f</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Like [[iterate]], but takes an effectful function for producing
   * the next state. `start` is the first value emitted.
   */</span>
  def <a title="[F[_], A](start: A)(f: A =&gt; F[A])scalaz.stream.Process[F,A]" id="scalaz.stream.Process.iterateEval">iterateEval</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.iterateEval;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.iterateEval;F;_">_</a><span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process.iterateEval;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="scalaz.stream.Process.iterateEval.start">start</a>: <a href="#scalaz.stream.Process.iterateEval;A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; F[A]" id="scalaz.stream.Process.iterateEval.f">f</a>: A =&gt; F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,A]">Process</a><span class="delimiter">[</span>F, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.emit" title="(o: A)scalaz.stream.Process0[A]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.iterateEval.start" title="A">start</a><span class="delimiter">)</span> <a href="#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[F,A])scalaz.stream.Process[F,A]">++</a> <a href="#scalaz.stream.Process.await" title="(req: F[A])(rcv: A =&gt; scalaz.stream.Process[F,A])scalaz.stream.Process[F,A]">await</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.iterateEval.f" title="(v1: A)F[A]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.iterateEval.start" title="A">start</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.iterateEval" title="(start: A)(f: A =&gt; F[A])scalaz.stream.Process[F,A]">iterateEval</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.iterateEval.$anonfun.x$35" title="A">_</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.iterateEval.f" title="A =&gt; F[A]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Lazily produce the range `[start, stopExclusive)`. If you want to produce the sequence in one chunk, instead of lazily, use `emitAll(start until stopExclusive)`.  */</span>
  def <a title="(start: Int, stopExclusive: Int, by: Int)scalaz.stream.Process0[Int]" id="scalaz.stream.Process.range">range</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream.Process.range.start">start</a>: <span title="Int">Int</span>, <a title="Int" id="scalaz.stream.Process.range.stopExclusive">stopExclusive</a>: <span title="Int">Int</span>, <a title="Int" id="scalaz.stream.Process.range$default$3">by</a>: <span title="Int">Int</span> = <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[Int]">Process0</a><span class="delimiter">[</span>Int<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.unfold" title="(s0: Int)(f: Int =&gt; Option[(Int, Int)])scalaz.stream.Process0[Int]">unfold</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.range.start" title="Int">start</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Int" id="scalaz.stream.Process.range.$anonfun.i">i</a> =&gt; if <span class="delimiter">(</span><a href="#scalaz.stream.Process.range.$anonfun.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#scalaz.stream.Process.range.stopExclusive" title="Int">stopExclusive</a><span class="delimiter">)</span> <span title="(x: (Int, Int))Some[(Int, Int)]">Some</span><span class="delimiter">(</span><span title="(_1: Int, _2: Int)(Int, Int)" class="delimiter">(</span><a href="#scalaz.stream.Process.range.$anonfun.i" title="Int">i</a>, <a href="#scalaz.stream.Process.range.$anonfun.i" title="Int">i</a> <span title="(x: Int)Int">+</span> <a href="#scalaz.stream.Process.range$default$3" title="Int">by</a><span class="delimiter">)</span><span class="delimiter">)</span> else <span title="None.type">None</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Lazily produce a sequence of nonoverlapping ranges, where each range
   * contains `size` integers, assuming the upper bound is exclusive.
   * Example: `ranges(0, 1000, 10)` results in the pairs
   * `(0, 10), (10, 20), (20, 30) ... (990, 1000)`
   *
   * Note: The last emitted range may be truncated at `stopExclusive`. For
   * instance, `ranges(0,5,4)` results in `(0,4), (4,5)`.
   *
   * @throws IllegalArgumentException if `size` &lt;= 0
   */</span>
  def <a title="(start: Int, stopExclusive: Int, size: Int)scalaz.stream.Process0[(Int, Int)]" id="scalaz.stream.Process.ranges">ranges</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream.Process.ranges.start">start</a>: <span title="Int">Int</span>, <a title="Int" id="scalaz.stream.Process.ranges.stopExclusive">stopExclusive</a>: <span title="Int">Int</span>, <a title="Int" id="scalaz.stream.Process.ranges.size">size</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[(Int, Int)]">Process0</a><span class="delimiter">[</span><span class="delimiter">(</span>Int, Int<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.ranges.size" title="Int">size</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span>, <span title="String(&quot;size must be &gt; 0, was: &quot;)" class="string">&quot;size must be &gt; 0, was: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scalaz.stream.Process.ranges.size" title="Int">size</a><span class="delimiter">)</span>
    <a href="#scalaz.stream.Process.unfold" title="(s0: Int)(f: Int =&gt; Option[((Int, Int), Int)])scalaz.stream.Process0[(Int, Int)]">unfold</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.ranges.start" title="Int">start</a><span class="delimiter">)</span><span class="delimiter">{</span>
      <a title="Int" id="scalaz.stream.Process.ranges.$anonfun.lower">lower</a> =&gt;
        if <span class="delimiter">(</span><a href="#scalaz.stream.Process.ranges.$anonfun.lower" title="Int">lower</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#scalaz.stream.Process.ranges.stopExclusive" title="Int">stopExclusive</a><span class="delimiter">)</span>
          <span title="(x: ((Int, Int), Int))Some[((Int, Int), Int)]">Some</span><span class="delimiter">(</span><span title="(_1: (Int, Int), _2: Int)((Int, Int), Int)" class="delimiter">(</span><a href="#scalaz.stream.Process.ranges.$anonfun.lower" title="(self: Int)ArrowAssoc[Int]">lower</a> <span title="(y: Int)(Int, Int)">-&gt;</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.ranges.$anonfun.lower" title="Int">lower</a><span title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">+</span><a href="#scalaz.stream.Process.ranges.size" title="Int">size</a><span class="delimiter">)</span> <span title="(that: Int)Int">min</span> <a href="#scalaz.stream.Process.ranges.stopExclusive" title="Int">stopExclusive</a><span class="delimiter">)</span>, <a href="#scalaz.stream.Process.ranges.$anonfun.lower" title="Int">lower</a><span title="(x: Int)Int">+</span><a href="#scalaz.stream.Process.ranges.size" title="Int">size</a><span class="delimiter">)</span><span class="delimiter">)</span>
        else
          <span title="None.type">None</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * The `Process1` which awaits a single input and passes it to `rcv` to
   * determine the next state.
   */</span>
  def <a title="[I, O](rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]" id="scalaz.stream.Process.receive1">receive1</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.receive1;I">I</a>, <a title="" id="scalaz.stream.Process.receive1;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; scalaz.stream.Process1[I,O]" id="scalaz.stream.Process.receive1.rcv">rcv</a>: I =&gt; Process1<span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[I,O]">Process1</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.await" title="(req: scalaz.stream.Process.Env[I,Any]#Is[I])(rcv: I =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O]">await</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.Get" title="[I]=&gt; scalaz.stream.Process.Env[I,Any]#Is[I]">Get</a><span title="scalaz.stream.Process.Env[I,Any]#Is[I]" class="delimiter">[</span><a href="#scalaz.stream.Process.receive1;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.receive1.rcv" title="I =&gt; scalaz.stream.Process1[I,O]">rcv</a><span class="delimiter">)</span>

  <span class="comment">/** Like `receive1`, but consults `fb` when it fails to receive an input. */</span>
  def <a title="[I, O](fb: =&gt; scalaz.stream.Process1[I,O])(rcv: I =&gt; scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]" id="scalaz.stream.Process.receive1Or">receive1Or</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.receive1Or;I">I</a>, <a title="" id="scalaz.stream.Process.receive1Or;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.stream.Process1[I,O]" id="scalaz.stream.Process.receive1Or.fb">fb</a>: =&gt; Process1<span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="I =&gt; scalaz.stream.Process1[I,O]" id="scalaz.stream.Process.receive1Or.rcv">rcv</a>: I =&gt; Process1<span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[I,O]">Process1</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.awaitOr" title="(req: scalaz.stream.Process.Env[I,Any]#Is[I])(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O])(rcv: I =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O]">awaitOr</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.Get" title="[I]=&gt; scalaz.stream.Process.Env[I,Any]#Is[I]">Get</a><span title="scalaz.stream.Process.Env[I,Any]#Is[I]" class="delimiter">[</span><a href="#scalaz.stream.Process.receive1Or;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span>rsn: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.receive1Or.fb" title="=&gt; scalaz.stream.Process1[I,O]">fb</a>.<a href="#scalaz.stream;Process.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#Is,O]">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.receive1Or.$anonfun.rsn" title="scalaz.stream.Cause.EarlyCause">rsn</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.receive1Or.rcv" title="I =&gt; scalaz.stream.Process1[I,O]">rcv</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Delay running `p` until `awaken` becomes true for the first time.
   * The `awaken` process may be discrete.
   */</span>
  def <a title="[F[_], A](awaken: scalaz.stream.Process[F,Boolean])(p: scalaz.stream.Process[F,A])scalaz.stream.Process[F,A]" id="scalaz.stream.Process.sleepUntil">sleepUntil</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.sleepUntil;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.sleepUntil;F;_">_</a><span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process.sleepUntil;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F,Boolean]" id="scalaz.stream.Process.sleepUntil.awaken">awaken</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,Boolean]">Process</a><span class="delimiter">[</span>F, Boolean<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F,A]" id="scalaz.stream.Process.sleepUntil.p">p</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,A]">Process</a><span class="delimiter">[</span>F, A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,A]">Process</a><span class="delimiter">[</span>F, A<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.sleepUntil.awaken" title="scalaz.stream.Process[F,Boolean]">awaken</a>.<a href="process1.scala.html#scalaz.stream;Process1Ops.dropWhile" title="(f: Boolean =&gt; Boolean)scalaz.stream.Process[F,Boolean]">dropWhile</a><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#scalaz.stream.Process.sleepUntil.$anonfun.x$36" title="Boolean">_</a><span class="delimiter">)</span>.<a href="process1.scala.html#scalaz.stream;Process1Ops.once" title="=&gt; scalaz.stream.Process[F,Boolean]">once</a>.<a href="#scalaz.stream;Process.flatMap" title="(f: Boolean =&gt; scalaz.stream.Process[[x]F[x],A])scalaz.stream.Process[[x]F[x],A]">flatMap</a><span class="delimiter">(</span><a title="Boolean" id="scalaz.stream.Process.sleepUntil.$anonfun.x$37">_</a> =&gt; <a href="#scalaz.stream.Process.sleepUntil.p" title="scalaz.stream.Process[F,A]">p</a><span class="delimiter">)</span>

  <span class="comment">/**
   * A supply of `Long` values, starting with `initial`.
   * Each read is guaranteed to return a value which is unique
   * across all threads reading from this `supply`.
   */</span>
  def <a title="(initial: Long)scalaz.stream.Process[scalaz.concurrent.Task,Long]" id="scalaz.stream.Process.supply">supply</a><span class="delimiter">(</span><a title="Long" id="scalaz.stream.Process.supply.initial">initial</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,Long]">Process</a><span class="delimiter">[</span>Task, Long<span class="delimiter">]</span> = <span class="delimiter">{</span>
    import java.util.concurrent.atomic.AtomicLong
    val <a title="java.util.concurrent.atomic.AtomicLong" id="scalaz.stream.Process.supply.l">l</a> = new <span title="java.util.concurrent.atomic.AtomicLong">AtomicLong</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.supply.initial" title="Long">initial</a><span class="delimiter">)</span>
    <a href="#scalaz.stream.Process.repeatEval" title="(f: scalaz.concurrent.Task[Long])scalaz.stream.Process[scalaz.concurrent.Task,Long]">repeatEval</a> <span class="delimiter">{</span> <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; Long)scalaz.concurrent.Task[Long]">delay</span> <span class="delimiter">{</span> <a href="#scalaz.stream.Process.supply.l" title="java.util.concurrent.atomic.AtomicLong">l</a>.<span title="()Long">getAndIncrement</span> <span class="delimiter">}</span><span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A `Writer` which writes the given value; alias for `emitW`. */</span>
  def <a title="[S](s: S)scalaz.stream.Process0[scalaz.\/[S,Nothing]]" id="scalaz.stream.Process.tell">tell</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.tell;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="scalaz.stream.Process.tell.s">s</a>: <a href="#scalaz.stream.Process.tell;S" title="S">S</a><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[scalaz.\/[S,Nothing]]">Process0</a><span class="delimiter">[</span>S \/ Nothing<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.emitW" title="(s: S)scalaz.stream.Process0[scalaz.\/[S,Nothing]]">emitW</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.tell.s" title="S">s</a><span class="delimiter">)</span>

  <span class="comment">/** Produce a (potentially infinite) source from an unfold. */</span>
  def <a title="[S, A](s0: S)(f: S =&gt; Option[(A, S)])scalaz.stream.Process0[A]" id="scalaz.stream.Process.unfold">unfold</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.unfold;S">S</a>, <a title="" id="scalaz.stream.Process.unfold;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="scalaz.stream.Process.unfold.s0">s0</a>: <a href="#scalaz.stream.Process.unfold;S" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="S =&gt; Option[(A, S)]" id="scalaz.stream.Process.unfold.f">f</a>: S =&gt; Option<span class="delimiter">[</span><span class="delimiter">(</span>A, S<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[A]">Process0</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(s: S)scalaz.stream.Process0[A]" id="scalaz.stream.Process.unfold.go">go</a><span class="delimiter">(</span><a title="S" id="scalaz.stream.Process.unfold.go.s">s</a>: <a href="#scalaz.stream.Process.unfold;S" title="S">S</a><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[A]">Process0</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.unfold.f" title="(v1: S)Option[(A, S)]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.unfold.go.s" title="S">s</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case Some<span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="scalaz.stream.Process.unfold.go.a">a</a>, <a title="S" id="scalaz.stream.Process.unfold.go.sn">sn</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.emit" title="(o: A)scalaz.stream.Process0[A]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.unfold.go.a" title="A">a</a><span class="delimiter">)</span> <a href="#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[Nothing,A])scalaz.stream.Process[Nothing,A]">++</a> <a href="#scalaz.stream.Process.unfold.go" title="(s: S)scalaz.stream.Process0[A]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.unfold.go.sn" title="S">sn</a><span class="delimiter">)</span>
        case <span title="None.type">None</span> =&gt; <a href="#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>
      <span class="delimiter">}</span>
    <a href="#scalaz.stream.Process.suspend" title="(p: =&gt; scalaz.stream.Process[Nothing,A])scalaz.stream.Process[Nothing,A]">suspend</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.unfold.go" title="(s: S)scalaz.stream.Process0[A]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.unfold.s0" title="S">s0</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Like [[unfold]], but takes an effectful function. */</span>
  def <a title="[F[_], S, A](s0: S)(f: S =&gt; F[Option[(A, S)]])scalaz.stream.Process[F,A]" id="scalaz.stream.Process.unfoldEval">unfoldEval</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.unfoldEval;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.unfoldEval;F;_">_</a><span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process.unfoldEval;S">S</a>, <a title="" id="scalaz.stream.Process.unfoldEval;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="scalaz.stream.Process.unfoldEval.s0">s0</a>: <a href="#scalaz.stream.Process.unfoldEval;S" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="S =&gt; F[Option[(A, S)]]" id="scalaz.stream.Process.unfoldEval.f">f</a>: S =&gt; F<span class="delimiter">[</span>Option<span class="delimiter">[</span><span class="delimiter">(</span>A, S<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,A]">Process</a><span class="delimiter">[</span>F, A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(s: S)scalaz.stream.Process[F,A]" id="scalaz.stream.Process.unfoldEval.go">go</a><span class="delimiter">(</span><a title="S" id="scalaz.stream.Process.unfoldEval.go.s">s</a>: <a href="#scalaz.stream.Process.unfoldEval;S" title="S">S</a><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,A]">Process</a><span class="delimiter">[</span>F, A<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.await" title="(req: F[Option[(A, S)]])(rcv: Option[(A, S)] =&gt; scalaz.stream.Process[F,A])scalaz.stream.Process[F,A]">await</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.unfoldEval.f" title="(v1: S)F[Option[(A, S)]]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.unfoldEval.go.s" title="S">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scalaz.stream.Process.unfoldEval.go.$anonfun.x0$13" title="scalaz.stream.Process[F,A]" class="delimiter">{</a>
        case Some<span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="scalaz.stream.Process.unfoldEval.go.$anonfun.a">a</a>, <a title="S" id="scalaz.stream.Process.unfoldEval.go.$anonfun.sn">sn</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.emit" title="(o: A)scalaz.stream.Process0[A]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.unfoldEval.go.$anonfun.a" title="A">a</a><span class="delimiter">)</span> <a href="#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[F,A])scalaz.stream.Process[F,A]">++</a> <a href="#scalaz.stream.Process.unfoldEval.go" title="(s: S)scalaz.stream.Process[F,A]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.unfoldEval.go.$anonfun.sn" title="S">sn</a><span class="delimiter">)</span>
        case <span title="None.type">None</span> =&gt; <a href="#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>
      <span class="delimiter">}</span>
    <a href="#scalaz.stream.Process.suspend" title="(p: =&gt; scalaz.stream.Process[F,A])scalaz.stream.Process[F,A]">suspend</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.unfoldEval.go" title="(s: S)scalaz.stream.Process[F,A]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.unfoldEval.s0" title="S">s0</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">//////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="comment">//</span>
  <span class="comment">// ENV, Tee, Wye et All</span>
  <span class="comment">//</span>
  <span class="comment">/////////////////////////////////////////////////////////////////////////////////////</span>


  case class <a href="#scalaz.stream.Process;Env.productElement.x$1" title="class Env[-I, -I2] extends AnyRef with Product with Serializable" id="scalaz.stream.Process.Env.readResolve">Env</a><span class="delimiter">[</span>-<a title="" id="scalaz.stream.Process;Env;I">I</a>, -<a title="" id="scalaz.stream.Process;Env;I2">I2</a><span class="delimiter">]</span><a href="#scalaz.stream.Process.Env.readResolve" title="Product" class="delimiter">(</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    sealed trait <a title="trait Y[-X] extends AnyRef" id="scalaz.stream.Process;Env;Y">Y</a><span class="delimiter">[</span>-<a title="" id="scalaz.stream.Process;Env;Y;X">X</a><span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="=&gt; Int" id="scalaz.stream.Process;Env;Y.tag">tag</a>: <span title="Int">Int</span>
      def <a title="[R](l: =&gt; R, r: =&gt; R, both: =&gt; R)R" id="scalaz.stream.Process;Env;Y.fold">fold</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Env;Y.fold;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; R" id="scalaz.stream.Process;Env;Y.fold.l">l</a>: =&gt; R, <a title="=&gt; R" id="scalaz.stream.Process;Env;Y.fold.r">r</a>: =&gt; R, <a title="=&gt; R" id="scalaz.stream.Process;Env;Y.fold.both">both</a>: =&gt; R<span class="delimiter">)</span>: <a href="#scalaz.stream.Process;Env;Y.fold;R" title="R">R</a>
    <span class="delimiter">}</span>
    sealed trait <a title="trait T[-X] extends AnyRef with Env.this.Y[X]" id="scalaz.stream.Process;Env;T">T</a><span class="delimiter">[</span>-<a title="" id="scalaz.stream.Process;Env;T;X">X</a><span class="delimiter">]</span> extends <a href="#scalaz.stream.Process;Env;Y" title="Env.this.Y[X]">Y</a><span class="delimiter">[</span>X<span class="delimiter">]</span>
    sealed trait <a title="trait Is[-X] extends AnyRef with Env.this.T[X]" id="scalaz.stream.Process;Env;Is">Is</a><span class="delimiter">[</span>-<a title="" id="scalaz.stream.Process;Env;Is;X">X</a><span class="delimiter">]</span> extends <a href="#scalaz.stream.Process;Env;T" title="Env.this.T[X]">T</a><span class="delimiter">[</span>X<span class="delimiter">]</span>
    case object <a href="#scalaz.stream.Process;Env.Left.productElement.x$1" title="Env.this.Left.type" id="scalaz.stream.Process;Env.Left.readResolve">Left</a> extends <a href="#scalaz.stream.Process;Env;Is" title="Env.this.Is[I]">Is</a><span class="delimiter">[</span>I<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="=&gt; Int" id="scalaz.stream.Process;Env.Left.tag">tag</a> = <span title="Int(0)" class="int">0</span>
      def <a title="[R](l: =&gt; R, r: =&gt; R, both: =&gt; R)R" id="scalaz.stream.Process;Env.Left.fold">fold</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Env.Left.fold;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; R" id="scalaz.stream.Process;Env.Left.fold.l">l</a>: =&gt; R, <a title="=&gt; R" id="scalaz.stream.Process;Env.Left.fold.r">r</a>: =&gt; R, <a title="=&gt; R" id="scalaz.stream.Process;Env.Left.fold.both">both</a>: =&gt; R<span class="delimiter">)</span>: <a href="#scalaz.stream.Process;Env.Left.fold;R" title="R">R</a> = <a href="#scalaz.stream.Process;Env.Left.fold.l" title="=&gt; R">l</a>
    <span class="delimiter">}</span>
    case object <a href="#scalaz.stream.Process;Env.Right.productElement.x$1" title="Env.this.Right.type" id="scalaz.stream.Process;Env.Right.readResolve">Right</a> extends <a href="#scalaz.stream.Process;Env;T" title="Env.this.T[I2]">T</a><span class="delimiter">[</span>I2<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="=&gt; Int" id="scalaz.stream.Process;Env.Right.tag">tag</a> = <span title="Int(1)" class="int">1</span>
      def <a title="[R](l: =&gt; R, r: =&gt; R, both: =&gt; R)R" id="scalaz.stream.Process;Env.Right.fold">fold</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Env.Right.fold;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; R" id="scalaz.stream.Process;Env.Right.fold.l">l</a>: =&gt; R, <a title="=&gt; R" id="scalaz.stream.Process;Env.Right.fold.r">r</a>: =&gt; R, <a title="=&gt; R" id="scalaz.stream.Process;Env.Right.fold.both">both</a>: =&gt; R<span class="delimiter">)</span>: <a href="#scalaz.stream.Process;Env.Right.fold;R" title="R">R</a> = <a href="#scalaz.stream.Process;Env.Right.fold.r" title="=&gt; R">r</a>
    <span class="delimiter">}</span>
    case object <a href="#scalaz.stream.Process;Env.Both.productElement.x$1" title="Env.this.Both.type" id="scalaz.stream.Process;Env.Both.readResolve">Both</a> extends <a href="#scalaz.stream.Process;Env;Y" title="Env.this.Y[scalaz.stream.ReceiveY[I,I2]]">Y</a><span class="delimiter">[</span>ReceiveY<span class="delimiter">[</span>I, I2<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="=&gt; Int" id="scalaz.stream.Process;Env.Both.tag">tag</a> = <span title="Int(2)" class="int">2</span>
      def <a title="[R](l: =&gt; R, r: =&gt; R, both: =&gt; R)R" id="scalaz.stream.Process;Env.Both.fold">fold</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Env.Both.fold;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; R" id="scalaz.stream.Process;Env.Both.fold.l">l</a>: =&gt; R, <a title="=&gt; R" id="scalaz.stream.Process;Env.Both.fold.r">r</a>: =&gt; R, <a title="=&gt; R" id="scalaz.stream.Process;Env.Both.fold.both">both</a>: =&gt; R<span class="delimiter">)</span>: <a href="#scalaz.stream.Process;Env.Both.fold;R" title="R">R</a> = <a href="#scalaz.stream.Process;Env.Both.fold.both" title="=&gt; R">both</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  private val <a title="scalaz.stream.Process.Env[Any,Any]#Left.type" id="scalaz.stream.Process.Left_">Left_</a>  = <a href="#scalaz.stream.Process.Env.readResolve" title="[I, I2]()scalaz.stream.Process.Env[I,I2]">Env</a><span title="()scalaz.stream.Process.Env[Any,Any]" class="delimiter">[</span><span title="Any">Any</span>, <span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="#scalaz.stream.Process;Env.Left.readResolve" title="scalaz.stream.Process.Env[Any,Any]#Left.type">Left</a>
  private val <a title="scalaz.stream.Process.Env[Any,Any]#Right.type" id="scalaz.stream.Process.Right_">Right_</a> = <a href="#scalaz.stream.Process.Env.readResolve" title="[I, I2]()scalaz.stream.Process.Env[I,I2]">Env</a><span title="()scalaz.stream.Process.Env[Any,Any]" class="delimiter">[</span><span title="Any">Any</span>, <span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="#scalaz.stream.Process;Env.Right.readResolve" title="scalaz.stream.Process.Env[Any,Any]#Right.type">Right</a>
  private val <a title="scalaz.stream.Process.Env[Any,Any]#Both.type" id="scalaz.stream.Process.Both_">Both_</a>  = <a href="#scalaz.stream.Process.Env.readResolve" title="[I, I2]()scalaz.stream.Process.Env[I,I2]">Env</a><span title="()scalaz.stream.Process.Env[Any,Any]" class="delimiter">[</span><span title="Any">Any</span>, <span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="#scalaz.stream.Process;Env.Both.readResolve" title="scalaz.stream.Process.Env[Any,Any]#Both.type">Both</a>

  def <a title="[I]=&gt; scalaz.stream.Process.Env[I,Any]#Is[I]" id="scalaz.stream.Process.Get">Get</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.Get;I">I</a><span class="delimiter">]</span>: Env<span class="delimiter">[</span>I, Any<span class="delimiter">]</span>#<a href="#scalaz.stream.Process;Env;Is" title="scalaz.stream.Process.Env[I,Any]#Is[I]">Is</a><span class="delimiter">[</span>I<span class="delimiter">]</span> = <a href="#scalaz.stream.Process.Left_" title="=&gt; scalaz.stream.Process.Env[Any,Any]#Left.type">Left_</a>
  def <a title="[I]=&gt; scalaz.stream.Process.Env[I,Any]#Is[I]" id="scalaz.stream.Process.L">L</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.L;I">I</a><span class="delimiter">]</span>: Env<span class="delimiter">[</span>I, Any<span class="delimiter">]</span>#<a href="#scalaz.stream.Process;Env;Is" title="scalaz.stream.Process.Env[I,Any]#Is[I]">Is</a><span class="delimiter">[</span>I<span class="delimiter">]</span> = <a href="#scalaz.stream.Process.Left_" title="=&gt; scalaz.stream.Process.Env[Any,Any]#Left.type">Left_</a>
  def <a title="[I2]=&gt; scalaz.stream.Process.Env[Any,I2]#T[I2]" id="scalaz.stream.Process.R">R</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.R;I2">I2</a><span class="delimiter">]</span>: Env<span class="delimiter">[</span>Any, I2<span class="delimiter">]</span>#<a href="#scalaz.stream.Process;Env;T" title="scalaz.stream.Process.Env[Any,I2]#T[I2]">T</a><span class="delimiter">[</span>I2<span class="delimiter">]</span> = <a href="#scalaz.stream.Process.Right_" title="=&gt; scalaz.stream.Process.Env[Any,Any]#Right.type">Right_</a>
  def <a title="[I, I2]=&gt; scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]" id="scalaz.stream.Process.Both">Both</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.Both;I">I</a>, <a title="" id="scalaz.stream.Process.Both;I2">I2</a><span class="delimiter">]</span>: Env<span class="delimiter">[</span>I, I2<span class="delimiter">]</span>#<a href="#scalaz.stream.Process;Env;Y" title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]">Y</a><span class="delimiter">[</span>ReceiveY<span class="delimiter">[</span>I, I2<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scalaz.stream.Process.Both_" title="=&gt; scalaz.stream.Process.Env[Any,Any]#Both.type">Both_</a>


  <span class="comment">//////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="comment">//</span>
  <span class="comment">// SYNTAX</span>
  <span class="comment">//</span>
  <span class="comment">/////////////////////////////////////////////////////////////////////////////////////</span>

  <span class="comment">/** Adds syntax for `Channel`. */</span>
  implicit class <a href="#scalaz.stream.Process.ChannelSyntax(f213a79260).self" title="class ChannelSyntax[F[_], I, O] extends AnyVal" id="scalaz.stream.Process.ChannelSyntax(f213a79260)">ChannelSyntax</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.ChannelSyntax(f213a79260);F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.ChannelSyntax(f213a79260);F;_">_</a><span class="delimiter">]</span>,<a title="" id="scalaz.stream.Process.ChannelSyntax(f213a79260);I">I</a>,<a title="" id="scalaz.stream.Process.ChannelSyntax(f213a79260);O">O</a><span class="delimiter">]</span><a href="#scalaz.stream.Process.ChannelSyntax(f213a79260)" title="scalaz.stream.Process.ChannelSyntax[F,I,O]" class="delimiter">(</a>val <a title="scalaz.stream.Channel[F,I,O]" id="scalaz.stream.Process.ChannelSyntax(f213a79260).self">self</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Channel[F,I,O]">Channel</a><span class="delimiter">[</span>F,I,O<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scalaz.stream.Process.ChannelSyntax(f213a79260)" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
    <span class="comment">/** Transform the input of this `Channel`. */</span>
    def <a title="[I0](f: I0 =&gt; I)scalaz.stream.Channel[F,I0,O]" id="scalaz.stream.Process;ChannelSyntax.contramap">contramap</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;ChannelSyntax.contramap;I0">I0</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I0 =&gt; I" id="scalaz.stream.Process;ChannelSyntax.contramap.f">f</a>: I0 =&gt; I<span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Channel[F,I0,O]">Channel</a><span class="delimiter">[</span>F,I0,O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.ChannelSyntax(f213a79260).self" title="=&gt; scalaz.stream.Channel[F,I,O]">self</a>.<a href="#scalaz.stream;Process.map" title="(f: (I =&gt; F[O]) =&gt; (I0 =&gt; F[O]))scalaz.stream.Process[F,I0 =&gt; F[O]]">map</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;ChannelSyntax.contramap.f" title="I0 =&gt; I">f</a> <span title="(g: I =&gt; F[O])I0 =&gt; F[O]">andThen</span> <a href="#scalaz.stream.Process;ChannelSyntax.contramap.$anonfun.x$38" title="I =&gt; F[O]">_</a><span class="delimiter">)</span>

    <span class="comment">/** Transform the output of this `Channel` */</span>
    def <a title="[O2](f: O =&gt; O2)(implicit F: scalaz.Functor[F])scalaz.stream.Channel[F,I,O2]" id="scalaz.stream.Process;ChannelSyntax.mapOut">mapOut</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;ChannelSyntax.mapOut;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; O2" id="scalaz.stream.Process;ChannelSyntax.mapOut.f">f</a>: O =&gt; O2<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Functor[F]" id="scalaz.stream.Process;ChannelSyntax.mapOut.F">F</a>: <span title="scalaz.Functor[F]">Functor</span><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Channel[F,I,O2]">Channel</a><span class="delimiter">[</span>F,I,O2<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.ChannelSyntax(f213a79260).self" title="=&gt; scalaz.stream.Channel[F,I,O]">self</a>.<a href="#scalaz.stream;Process.map" title="(f: (I =&gt; F[O]) =&gt; (I =&gt; F[O2]))scalaz.stream.Process[F,I =&gt; F[O2]]">map</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;ChannelSyntax.mapOut.$anonfun.x$39" title="I =&gt; F[O]">_</a> <span title="(g: F[O] =&gt; F[O2])I =&gt; F[O2]">andThen</span> <a href="#scalaz.stream.Process;ChannelSyntax.mapOut.F" title="scalaz.Functor[F]">F</a>.<span title="(f: O =&gt; O2)F[O] =&gt; F[O2]">lift</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;ChannelSyntax.mapOut.f" title="O =&gt; O2">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Adds syntax for `Sink`. */</span>
  implicit class <a href="#scalaz.stream.Process.SinkSyntax(b90e16a096).self" title="class SinkSyntax[F[_], I] extends AnyVal" id="scalaz.stream.Process.SinkSyntax(b90e16a096)">SinkSyntax</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.SinkSyntax(b90e16a096);F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.SinkSyntax(b90e16a096);F;_">_</a><span class="delimiter">]</span>,<a title="" id="scalaz.stream.Process.SinkSyntax(b90e16a096);I">I</a><span class="delimiter">]</span><a href="#scalaz.stream.Process.SinkSyntax(b90e16a096)" title="scalaz.stream.Process.SinkSyntax[F,I]" class="delimiter">(</a>val <a title="scalaz.stream.Sink[F,I]" id="scalaz.stream.Process.SinkSyntax(b90e16a096).self">self</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Sink[F,I]">Sink</a><span class="delimiter">[</span>F,I<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scalaz.stream.Process.SinkSyntax(b90e16a096)" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
    <span class="comment">/** Converts `Sink` to `Channel`, that will perform the side effect and echo its input. */</span>
    def <a title="(implicit F: scalaz.Functor[F])scalaz.stream.Channel[F,I,I]" id="scalaz.stream.Process;SinkSyntax.toChannel">toChannel</a><span class="delimiter">(</span>implicit <a title="scalaz.Functor[F]" id="scalaz.stream.Process;SinkSyntax.toChannel.F">F</a>: <span title="scalaz.Functor[F]">Functor</span><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Channel[F,I,I]">Channel</a><span class="delimiter">[</span>F,I,I<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.SinkSyntax(b90e16a096).self" title="=&gt; scalaz.stream.Sink[F,I]">self</a>.<a href="#scalaz.stream;Process.map" title="(f: (I =&gt; F[Unit]) =&gt; (I =&gt; F[I]))scalaz.stream.Process[F,I =&gt; F[I]]">map</a><span class="delimiter">(</span><a title="I =&gt; F[Unit]" id="scalaz.stream.Process;SinkSyntax.toChannel.$anonfun.f">f</a> =&gt; <span class="delimiter">(</span>i: <a href="#scalaz.stream.Process.SinkSyntax(b90e16a096);I" title="I">I</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;SinkSyntax.toChannel.F" title="scalaz.Functor[F]">F</a>.<span title="(fa: F[Unit])(f: Unit =&gt; I)F[I]">map</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;SinkSyntax.toChannel.$anonfun.f" title="(v1: I)F[Unit]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SinkSyntax.toChannel.$anonfun.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Unit" id="scalaz.stream.Process;SinkSyntax.toChannel.$anonfun.$anonfun.$anonfun.x$40">_</a> =&gt; <a href="#scalaz.stream.Process;SinkSyntax.toChannel.$anonfun.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  implicit class <a href="#scalaz.stream.Process.ProcessSyntax(90c98207c6).self" title="class ProcessSyntax[F[_], O] extends AnyVal" id="scalaz.stream.Process.ProcessSyntax(90c98207c6)">ProcessSyntax</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.ProcessSyntax(90c98207c6);F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.ProcessSyntax(90c98207c6);F;_">_</a><span class="delimiter">]</span>,<a title="" id="scalaz.stream.Process.ProcessSyntax(90c98207c6);O">O</a><span class="delimiter">]</span><a href="#scalaz.stream.Process.ProcessSyntax(90c98207c6)" title="scalaz.stream.Process.ProcessSyntax[F,O]" class="delimiter">(</a>val <a title="scalaz.stream.Process[F,O]" id="scalaz.stream.Process.ProcessSyntax(90c98207c6).self">self</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scalaz.stream.Process.ProcessSyntax(90c98207c6)" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
    <span class="comment">/** Feed this `Process` through the given effectful `Channel`. */</span>
    def <a title="[F2[x] &gt;: F[x], O2](f: scalaz.stream.Channel[F2,O,O2])scalaz.stream.Process[F2,O2]" id="scalaz.stream.Process;ProcessSyntax.through">through</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream.Process;ProcessSyntax.through;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;ProcessSyntax.through;F2;x">x</a><span class="delimiter">]</span>&gt;:F<span class="delimiter">[</span>x<span class="delimiter">]</span>,<a title="" id="scalaz.stream.Process;ProcessSyntax.through;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Channel[F2,O,O2]" id="scalaz.stream.Process;ProcessSyntax.through.f">f</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Channel[F2,O,O2]">Channel</a><span class="delimiter">[</span>F2,O,O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2,O2<span class="delimiter">]</span> =
        <a href="#scalaz.stream.Process.ProcessSyntax(90c98207c6).self" title="=&gt; scalaz.stream.Process[F,O]">self</a>.<a href="tee.scala.html#scalaz.stream;TeeOps.zipWith" title="(p2: scalaz.stream.Process[F2,O =&gt; F2[O2]])(f: (O, O =&gt; F2[O2]) =&gt; F2[O2])scalaz.stream.Process[F2,F2[O2]]">zipWith</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;ProcessSyntax.through.f" title="scalaz.stream.Channel[F2,O,O2]">f</a><span class="delimiter">)</span><a href="#scalaz.stream.Process.EvalProcess(b6ed143934)" title="(self: scalaz.stream.Process[F2,F2[O2]])scalaz.stream.Process.EvalProcess[F2,O2]" class="delimiter">(</a><span class="delimiter">(</span><a title="O" id="scalaz.stream.Process;ProcessSyntax.through.$anonfun.o">o</a>,<a title="O =&gt; F2[O2]" id="scalaz.stream.Process;ProcessSyntax.through.$anonfun.f">f</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;ProcessSyntax.through.$anonfun.f" title="(v1: O)F2[O2]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;ProcessSyntax.through.$anonfun.o" title="O">o</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#scalaz.stream.Process;EvalProcess.eval" title="=&gt; scalaz.stream.Process[F2,O2]">eval</a>

    <span class="comment">/**
     * Feed this `Process` through the given effectful `Channel`, signaling
     * termination to `f` via `None`. Useful to allow `f` to flush any
     * buffered values to the output when it detects termination, see
     * [[scalaz.stream.io.bufferedChannel]] combinator.
     */</span>
    def <a title="[F2[x] &gt;: F[x], O2](f: scalaz.stream.Channel[F2,Option[O],O2])scalaz.stream.Process[F2,O2]" id="scalaz.stream.Process;ProcessSyntax.throughOption">throughOption</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream.Process;ProcessSyntax.throughOption;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;ProcessSyntax.throughOption;F2;x">x</a><span class="delimiter">]</span>&gt;:F<span class="delimiter">[</span>x<span class="delimiter">]</span>,<a title="" id="scalaz.stream.Process;ProcessSyntax.throughOption;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Channel[F2,Option[O],O2]" id="scalaz.stream.Process;ProcessSyntax.throughOption.f">f</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Channel[F2,Option[O],O2]">Channel</a><span class="delimiter">[</span>F2,Option<span class="delimiter">[</span>O<span class="delimiter">]</span>,O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O2]">Process</a><span class="delimiter">[</span>F2,O2<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.ProcessSyntax(90c98207c6).self" title="=&gt; scalaz.stream.Process[F,O]">self</a>.<a href="#scalaz.stream.Process.ProcessSyntax(90c98207c6)" title="(self: scalaz.stream.Process[F,Option[O]])scalaz.stream.Process.ProcessSyntax[F,Option[O]]">terminated</a>.<a href="#scalaz.stream.Process;ProcessSyntax.through" title="(f: scalaz.stream.Channel[F2,Option[O],O2])scalaz.stream.Process[F2,O2]">through</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;ProcessSyntax.throughOption.f" title="scalaz.stream.Channel[F2,Option[O],O2]">f</a><span class="delimiter">)</span>

    <span class="comment">/** Attaches `Sink` to this  `Process`  */</span>
    def <a title="[F2[x] &gt;: F[x]](f: scalaz.stream.Sink[F2,O])scalaz.stream.Process[F2,Unit]" id="scalaz.stream.Process;ProcessSyntax.to">to</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream.Process;ProcessSyntax.to;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;ProcessSyntax.to;F2;x">x</a><span class="delimiter">]</span>&gt;:F<span class="delimiter">[</span>x<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Sink[F2,O]" id="scalaz.stream.Process;ProcessSyntax.to.f">f</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Sink[F2,O]">Sink</a><span class="delimiter">[</span>F2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,Unit]">Process</a><span class="delimiter">[</span>F2,Unit<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process;ProcessSyntax.through" title="(f: scalaz.stream.Channel[F2,O,Unit])scalaz.stream.Process[F2,Unit]">through</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;ProcessSyntax.to.f" title="scalaz.stream.Sink[F2,O]">f</a><span class="delimiter">)</span>

    <span class="comment">/** Attach a `Sink` to the output of this `Process` but echo the original. */</span>
    def <a title="[F2[x] &gt;: F[x]](f: scalaz.stream.Sink[F2,O])scalaz.stream.Process[F2,O]" id="scalaz.stream.Process;ProcessSyntax.observe">observe</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream.Process;ProcessSyntax.observe;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;ProcessSyntax.observe;F2;x">x</a><span class="delimiter">]</span>&gt;:F<span class="delimiter">[</span>x<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Sink[F2,O]" id="scalaz.stream.Process;ProcessSyntax.observe.f">f</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Sink[F2,O]">Sink</a><span class="delimiter">[</span>F2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F2,O]">Process</a><span class="delimiter">[</span>F2,O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.ProcessSyntax(90c98207c6).self" title="=&gt; scalaz.stream.Process[F,O]">self</a>.<a href="tee.scala.html#scalaz.stream;TeeOps.zipWith" title="(p2: scalaz.stream.Process[F2,O =&gt; F2[Unit]])(f: (O, O =&gt; F2[Unit]) =&gt; (O, F2[Unit]))scalaz.stream.Process[F2,(O, F2[Unit])]">zipWith</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;ProcessSyntax.observe.f" title="scalaz.stream.Sink[F2,O]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="O" id="scalaz.stream.Process;ProcessSyntax.observe.$anonfun.o">o</a>,<a title="O =&gt; F2[Unit]" id="scalaz.stream.Process;ProcessSyntax.observe.$anonfun.f">f</a><span class="delimiter">)</span> =&gt; <span title="(_1: O, _2: F2[Unit])(O, F2[Unit])" class="delimiter">(</span><a href="#scalaz.stream.Process;ProcessSyntax.observe.$anonfun.o" title="O">o</a>,<a href="#scalaz.stream.Process;ProcessSyntax.observe.$anonfun.f" title="(v1: O)F2[Unit]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;ProcessSyntax.observe.$anonfun.o" title="O">o</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.flatMap" title="(f: ((O, F2[Unit])) =&gt; scalaz.stream.Process[[x]F2[x],O])scalaz.stream.Process[[x]F2[x],O]">flatMap</a> <a href="#scalaz.stream.Process;ProcessSyntax.observe.$anonfun.x0$14" title="scalaz.stream.Process[F2,O]" class="delimiter">{</a> case <span class="delimiter">(</span><a title="O" id="scalaz.stream.Process;ProcessSyntax.observe.$anonfun.orig">orig</a>,<a title="F2[Unit]" id="scalaz.stream.Process;ProcessSyntax.observe.$anonfun.action">action</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.emit" title="(o: F2[Unit])scalaz.stream.Process0[F2[Unit]]">emit</a><a href="#scalaz.stream.Process.EvalProcess(b6ed143934)" title="(self: scalaz.stream.Process[F2,F2[Unit]])scalaz.stream.Process.EvalProcess[F2,Unit]" class="delimiter">(</a><a href="#scalaz.stream.Process;ProcessSyntax.observe.$anonfun.action" title="F2[Unit]">action</a><span class="delimiter">)</span>.<a href="#scalaz.stream.Process;EvalProcess.eval" title="=&gt; scalaz.stream.Process[F2,Unit]">eval</a>.<a href="#scalaz.stream;Process.drain" title="=&gt; scalaz.stream.Process[F2,Nothing]">drain</a> <a href="#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[[x]F2[x],O])scalaz.stream.Process[[x]F2[x],O]">++</a> <a href="#scalaz.stream.Process.emit" title="(o: O)scalaz.stream.Process0[O]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;ProcessSyntax.observe.$anonfun.orig" title="O">orig</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides infix syntax for `eval: Process[F,F[O]] =&gt; Process[F,O]`
   */</span>
  implicit class <a href="#scalaz.stream.Process.EvalProcess(b6ed143934).self" title="class EvalProcess[F[_], O] extends AnyVal" id="scalaz.stream.Process.EvalProcess(b6ed143934)">EvalProcess</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.EvalProcess(b6ed143934);F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.EvalProcess(b6ed143934);F;_">_</a><span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process.EvalProcess(b6ed143934);O">O</a><span class="delimiter">]</span><a href="#scalaz.stream.Process.EvalProcess(b6ed143934)" title="scalaz.stream.Process.EvalProcess[F,O]" class="delimiter">(</a>val <a title="scalaz.stream.Process[F,F[O]]" id="scalaz.stream.Process.EvalProcess(b6ed143934).self">self</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,F[O]]">Process</a><span class="delimiter">[</span>F, F<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scalaz.stream.Process.EvalProcess(b6ed143934)" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>

    <span class="comment">/**
     * Evaluate the stream of `F` actions produced by this `Process`.
     * This sequences `F` actions strictly--the first `F` action will
     * be evaluated before work begins on producing the next `F`
     * action. To allow for concurrent evaluation, use `sequence`
     * or `gather`.
     *
     * If evaluation of `F` results to `Terminated(cause)`
     * the evaluation of the stream is terminated with `cause`
     */</span>
    def <a title="=&gt; scalaz.stream.Process[F,O]" id="scalaz.stream.Process;EvalProcess.eval">eval</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#scalaz.stream.Process.EvalProcess(b6ed143934).self" title="=&gt; scalaz.stream.Process[F,F[O]]">self</a>.<a href="#scalaz.stream;Process.flatMap" title="(f: F[O] =&gt; scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">flatMap</a><span class="delimiter">(</span><a title="F[O]" id="scalaz.stream.Process;EvalProcess.eval.$anonfun.f">f</a>=&gt; <a href="#scalaz.stream.Process.await" title="(req: F[O])(rcv: O =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">await</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;EvalProcess.eval.$anonfun.f" title="F[O]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.emit" title="(o: O)scalaz.stream.Process0[O]">emit</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">onHalt</a> <a href="#scalaz.stream.Process;EvalProcess.eval.$anonfun.x0$15" title="scalaz.stream.Process[F,O]" class="delimiter">{</a>
        case Error<span class="delimiter">(</span>Terminated<span class="delimiter">(</span><span title="scalaz.stream.Cause">cause</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">cause</span><span class="delimiter">)</span>
        case <span title="scalaz.stream.Cause">cause</span> =&gt; <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">cause</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Read chunks of `bufSize` from input, then use `Nondeterminism.gatherUnordered`
     * to run all these actions to completion.
     */</span>
    def <a title="(bufSize: Int)(implicit F: scalaz.Nondeterminism[F])scalaz.stream.Process[F,O]" id="scalaz.stream.Process;EvalProcess.gather">gather</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream.Process;EvalProcess.gather.bufSize">bufSize</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Nondeterminism[F]" id="scalaz.stream.Process;EvalProcess.gather.F">F</a>: <span title="scalaz.Nondeterminism[F]">Nondeterminism</span><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.EvalProcess(b6ed143934).self" title="=&gt; scalaz.stream.Process[F,F[O]]">self</a>.<a href="#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[F[O],Vector[F[O]]])scalaz.stream.Process[F,Vector[F[O]]]">pipe</a><span class="delimiter">(</span><a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="process1.scala.html#scalaz.stream.process1.chunk" title="(n: Int)scalaz.stream.Process1[F[O],Vector[F[O]]]">chunk</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;EvalProcess.gather.bufSize" title="Int">bufSize</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.map" title="(f: Vector[F[O]] =&gt; F[List[O]])scalaz.stream.Process[F,F[List[O]]]">map</a><a href="#scalaz.stream.Process.EvalProcess(b6ed143934)" title="(self: scalaz.stream.Process[F,F[List[O]]])scalaz.stream.Process.EvalProcess[F,List[O]]" class="delimiter">(</a><a href="#scalaz.stream.Process;EvalProcess.gather.F" title="scalaz.Nondeterminism[F]">F</a>.<a href="#scalaz.stream.Process;EvalProcess.gather.$anonfun.fs" title="(fs: Seq[F[O]])F[List[O]]">gatherUnordered</a><span class="delimiter">)</span>.<a href="#scalaz.stream.Process;EvalProcess.eval" title="=&gt; scalaz.stream.Process[F,List[O]]">eval</a>.<a href="#scalaz.stream;Process.flatMap" title="(f: List[O] =&gt; scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">flatMap</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.emitAll" title="(os: Seq[O])scalaz.stream.Process0[O]">emitAll</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Read chunks of `bufSize` from input, then use `Nondeterminism.gather`
     * to run all these actions to completion and return elements in order.
     */</span>
    def <a title="(bufSize: Int)(implicit F: scalaz.Nondeterminism[F])scalaz.stream.Process[F,O]" id="scalaz.stream.Process;EvalProcess.sequence">sequence</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream.Process;EvalProcess.sequence.bufSize">bufSize</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.Nondeterminism[F]" id="scalaz.stream.Process;EvalProcess.sequence.F">F</a>: <span title="scalaz.Nondeterminism[F]">Nondeterminism</span><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.EvalProcess(b6ed143934).self" title="=&gt; scalaz.stream.Process[F,F[O]]">self</a>.<a href="#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[F[O],Vector[F[O]]])scalaz.stream.Process[F,Vector[F[O]]]">pipe</a><span class="delimiter">(</span><a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="process1.scala.html#scalaz.stream.process1.chunk" title="(n: Int)scalaz.stream.Process1[F[O],Vector[F[O]]]">chunk</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;EvalProcess.sequence.bufSize" title="Int">bufSize</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.map" title="(f: Vector[F[O]] =&gt; F[List[O]])scalaz.stream.Process[F,F[List[O]]]">map</a><a href="#scalaz.stream.Process.EvalProcess(b6ed143934)" title="(self: scalaz.stream.Process[F,F[List[O]]])scalaz.stream.Process.EvalProcess[F,List[O]]" class="delimiter">(</a><a href="#scalaz.stream.Process;EvalProcess.sequence.F" title="scalaz.Nondeterminism[F]">F</a>.<a href="#scalaz.stream.Process;EvalProcess.sequence.$anonfun.fs" title="(fs: Seq[F[O]])F[List[O]]">gather</a><span class="delimiter">)</span>.<a href="#scalaz.stream.Process;EvalProcess.eval" title="=&gt; scalaz.stream.Process[F,List[O]]">eval</a>.<a href="#scalaz.stream;Process.flatMap" title="(f: List[O] =&gt; scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">flatMap</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.emitAll" title="(os: Seq[O])scalaz.stream.Process0[O]">emitAll</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class provides infix syntax specific to `Process0`.
   */</span>
  implicit class <a href="#scalaz.stream.Process.Process0Syntax(0cbdd80600).self" title="class Process0Syntax[O] extends AnyVal" id="scalaz.stream.Process.Process0Syntax(0cbdd80600)">Process0Syntax</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.Process0Syntax(0cbdd80600);O">O</a><span class="delimiter">]</span><a href="#scalaz.stream.Process.Process0Syntax(0cbdd80600)" title="scalaz.stream.Process.Process0Syntax[O]" class="delimiter">(</a>val <a title="scalaz.stream.Process0[O]" id="scalaz.stream.Process.Process0Syntax(0cbdd80600).self">self</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[O]">Process0</a><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scalaz.stream.Process.Process0Syntax(0cbdd80600)" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>

    <span class="comment">/** Converts this `Process0` to a `Vector`. */</span>
    def <a title="=&gt; Vector[O]" id="scalaz.stream.Process;Process0Syntax.toVector">toVector</a>: <span title="Vector[O]">Vector</span><span class="delimiter">[</span>O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.Process0Syntax(0cbdd80600).self" title="=&gt; scalaz.stream.Process0[O]">self</a>.<a href="#scalaz.stream;Process.unemit" title="=&gt; (Seq[O], scalaz.stream.Process[Nothing,O])">unemit</a> match <span class="delimiter">{</span>
        case <span class="delimiter">(</span>_, Halt<span class="delimiter">(</span>Error<span class="delimiter">(</span><a title="Throwable" id="scalaz.stream.Process;Process0Syntax.toVector.rsn">rsn</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; throw <a href="#scalaz.stream.Process;Process0Syntax.toVector.rsn" title="Throwable">rsn</a>
        case <span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.Process;Process0Syntax.toVector.os">os</a>, _<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;Process0Syntax.toVector.os" title="Seq[O]">os</a>.<span title="=&gt; Vector[O]">toVector</span>
      <span class="delimiter">}</span>

    <span class="comment">/** Converts this `Process0` to an `IndexedSeq`. */</span>
    def <a title="=&gt; IndexedSeq[O]" id="scalaz.stream.Process;Process0Syntax.toIndexedSeq">toIndexedSeq</a>: <span title="IndexedSeq[O]">IndexedSeq</span><span class="delimiter">[</span>O<span class="delimiter">]</span> = <a href="#scalaz.stream.Process;Process0Syntax.toVector" title="=&gt; Vector[O]">toVector</a>

    <span class="comment">/** Converts this `Process0` to a `List`. */</span>
    def <a title="=&gt; List[O]" id="scalaz.stream.Process;Process0Syntax.toList">toList</a>: <span title="List[O]">List</span><span class="delimiter">[</span>O<span class="delimiter">]</span> = <a href="#scalaz.stream.Process;Process0Syntax.toVector" title="=&gt; Vector[O]">toVector</a>.<span title="=&gt; List[O]">toList</span>

    <span class="comment">/** Converts this `Process0` to a `Seq`. */</span>
    def <a title="=&gt; Seq[O]" id="scalaz.stream.Process;Process0Syntax.toSeq">toSeq</a>: <span title="Seq[O]">Seq</span><span class="delimiter">[</span>O<span class="delimiter">]</span> = <a href="#scalaz.stream.Process;Process0Syntax.toVector" title="=&gt; Vector[O]">toVector</a>

    <span class="comment">/** Converts this `Process0` to a `Stream`. */</span>
    def <a title="=&gt; Stream[O]" id="scalaz.stream.Process;Process0Syntax.toStream">toStream</a>: <span title="Stream[O]">Stream</span><span class="delimiter">[</span>O<span class="delimiter">]</span> = <span class="delimiter">{</span>
      def <a title="(p: scalaz.stream.Process0[O])Stream[O]" id="scalaz.stream.Process;Process0Syntax.toStream.go">go</a><span class="delimiter">(</span><a title="scalaz.stream.Process0[O]" id="scalaz.stream.Process;Process0Syntax.toStream.go.p">p</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process0[O]">Process0</a><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Stream[O]">Stream</span><span class="delimiter">[</span>O<span class="delimiter">]</span> =
        <a href="#scalaz.stream.Process;Process0Syntax.toStream.go.p" title="scalaz.stream.Process0[O]">p</a>.<a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[Nothing,O]">step</a> match <span class="delimiter">{</span>
          case <a title="scalaz.stream.Process.Step[Nothing,O]" id="scalaz.stream.Process;Process0Syntax.toStream.go.s">s</a>: <a href="#scalaz.stream.Process.Step.readResolve" title="scalaz.stream.Process.Step[Nothing,O]">Step</a><span class="delimiter">[</span>Nothing, O<span class="delimiter">]</span> =&gt;
            <a href="#scalaz.stream.Process;Process0Syntax.toStream.go.s" title="scalaz.stream.Process.Step[Nothing,O]">s</a>.<a href="#scalaz.stream.Process;Step.head" title="=&gt; scalaz.stream.Process.EmitOrAwait[Nothing,O]">head</a> match <span class="delimiter">{</span>
              case Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.Process;Process0Syntax.toStream.go.os">os</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;Process0Syntax.toStream.go.os" title="Seq[O]">os</a>.<span title="=&gt; scala.collection.immutable.Stream[O]">toStream</span> <a href="#scalaz.stream.Process;Process0Syntax.toStream.go.x$41" title="(prefix: scala.collection.immutable.Stream[O])scala.collection.immutable.Stream[O]">#:::</a> <a href="#scalaz.stream.Process;Process0Syntax.toStream.go" title="(p: scalaz.stream.Process0[O])Stream[O]">go</a><span title="(stream: =&gt; scala.collection.immutable.Stream[O])scala.collection.immutable.Stream.ConsWrapper[O]" class="delimiter">(</span><a href="#scalaz.stream.Process;Process0Syntax.toStream.go.s" title="scalaz.stream.Process.Step[Nothing,O]">s</a>.<a href="#scalaz.stream.Process;Step.next" title="=&gt; scalaz.stream.Process.Cont[Nothing,O]">next</a>.<a href="#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[Nothing,O]">continue</a><span class="delimiter">)</span>
              case _ =&gt; sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;impossible&quot;)" class="string">&quot;impossible&quot;</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          case Halt<span class="delimiter">(</span>Error<span class="delimiter">(</span><a title="Throwable" id="scalaz.stream.Process;Process0Syntax.toStream.go.rsn">rsn</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; throw <a href="#scalaz.stream.Process;Process0Syntax.toStream.go.rsn" title="Throwable">rsn</a>
          case Halt<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <span title="=&gt; collection.immutable.Stream.type">Stream</span>.<span title="scala.collection.immutable.Stream[Nothing]">empty</span>
        <span class="delimiter">}</span>
      <a href="#scalaz.stream.Process;Process0Syntax.toStream.go" title="(p: scalaz.stream.Process0[O])Stream[O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.Process0Syntax(0cbdd80600).self" title="=&gt; scalaz.stream.Process0[O]">self</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Converts this `Process0` to a `Map`. */</span>
    def <a title="[K, V](implicit isKV: &lt;:&lt;[O,(K, V)])Map[K,V]" id="scalaz.stream.Process;Process0Syntax.toMap">toMap</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Process0Syntax.toMap;K">K</a>, <a title="" id="scalaz.stream.Process;Process0Syntax.toMap;V">V</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="&lt;:&lt;[O,(K, V)]" id="scalaz.stream.Process;Process0Syntax.toMap.isKV">isKV</a>: O <span title="&lt;:&lt;[O,(K, V)]">&lt;:&lt;</span> <span class="delimiter">(</span>K, V<span class="delimiter">)</span><span class="delimiter">)</span>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <a href="#scalaz.stream.Process;Process0Syntax.toVector" title="=&gt; Vector[O]">toVector</a>.<span title="(implicit ev: &lt;:&lt;[O,(K, V)])scala.collection.immutable.Map[K,V]">toMap</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;Process0Syntax.toMap.isKV" title="&lt;:&lt;[O,(K, V)]">isKV</a><span class="delimiter">)</span>

    <span class="comment">/** Converts this `Process0` to a `SortedMap`. */</span>
    def <a title="[K, V](implicit isKV: &lt;:&lt;[O,(K, V)], implicit ord: Ordering[K])scala.collection.SortedMap[K,V]" id="scalaz.stream.Process;Process0Syntax.toSortedMap">toSortedMap</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Process0Syntax.toSortedMap;K">K</a>, <a title="" id="scalaz.stream.Process;Process0Syntax.toSortedMap;V">V</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="&lt;:&lt;[O,(K, V)]" id="scalaz.stream.Process;Process0Syntax.toSortedMap.isKV">isKV</a>: O <span title="&lt;:&lt;[O,(K, V)]">&lt;:&lt;</span> <span class="delimiter">(</span>K, V<span class="delimiter">)</span>, <a title="Ordering[K]" id="scalaz.stream.Process;Process0Syntax.toSortedMap.ord">ord</a>: <span title="Ordering[K]">Ordering</span><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scala.collection.SortedMap[K,V]">SortedMap</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span> =
      <span title="(elems: (K, V)*)(implicit ord: Ordering[K])scala.collection.SortedMap[K,V]">SortedMap</span><a href="#scalaz.stream.Process;Process0Syntax.toSortedMap.ord" title="Ordering[K]" class="delimiter">(</a><a href="#scalaz.stream.Process;Process0Syntax.toVector" title="=&gt; Vector[O]">toVector</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Seq[(K, V)]" class="delimiter">[</span><span title="Seq[(K, V)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>K, V<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span>: _*<span class="delimiter">)</span>

    def <a title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,O]" id="scalaz.stream.Process;Process0Syntax.toSource">toSource</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,O]">Process</a><span class="delimiter">[</span>Task, O<span class="delimiter">]</span> = <a href="#scalaz.stream.Process.Process0Syntax(0cbdd80600).self" title="=&gt; scalaz.stream.Process0[O]">self</a>

    @deprecated<span class="delimiter">(</span><span class="string">&quot;liftIO is deprecated in favor of toSource. It will be removed in a future release.&quot;</span>, <span class="string">&quot;0.7&quot;</span><span class="delimiter">)</span>
    def <a title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,O]" id="scalaz.stream.Process;Process0Syntax.liftIO">liftIO</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,O]">Process</a><span class="delimiter">[</span>Task, O<span class="delimiter">]</span> = <a href="#scalaz.stream.Process.Process0Syntax(0cbdd80600).self" title="=&gt; scalaz.stream.Process0[O]">self</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Syntax for Sink, that is specialized for Task */</span>
  implicit class <a href="#scalaz.stream.Process.SinkTaskSyntax(c45ec1498d).self" title="class SinkTaskSyntax[I] extends AnyVal" id="scalaz.stream.Process.SinkTaskSyntax(c45ec1498d)">SinkTaskSyntax</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.SinkTaskSyntax(c45ec1498d);I">I</a><span class="delimiter">]</span><a href="#scalaz.stream.Process.SinkTaskSyntax(c45ec1498d)" title="scalaz.stream.Process.SinkTaskSyntax[I]" class="delimiter">(</a>val <a title="scalaz.stream.Sink[scalaz.concurrent.Task,I]" id="scalaz.stream.Process.SinkTaskSyntax(c45ec1498d).self">self</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Sink[scalaz.concurrent.Task,I]">Sink</a><span class="delimiter">[</span>Task,I<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scalaz.stream.Process.SinkTaskSyntax(c45ec1498d)" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>
    <span class="comment">/** converts sink to sink that first pipes received `I0` to supplied p1 */</span>
    def <a title="[I0](p1: scalaz.stream.Process1[I0,I])scalaz.stream.Sink[scalaz.concurrent.Task,I0]" id="scalaz.stream.Process;SinkTaskSyntax.pipeIn">pipeIn</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;SinkTaskSyntax.pipeIn;I0">I0</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[I0,I]" id="scalaz.stream.Process;SinkTaskSyntax.pipeIn.p1">p1</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[I0,I]">Process1</a><span class="delimiter">[</span>I0, I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Sink[scalaz.concurrent.Task,I0]">Sink</a><span class="delimiter">[</span>Task, I0<span class="delimiter">]</span> = <a href="#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="#scalaz.stream.Process.suspend" title="(p: =&gt; scalaz.stream.Process[scalaz.concurrent.Task,I0 =&gt; scalaz.concurrent.Task[Unit]])scalaz.stream.Process[scalaz.concurrent.Task,I0 =&gt; scalaz.concurrent.Task[Unit]]">suspend</a> <span class="delimiter">{</span>
      import scalaz.<span title="scalaz.Scalaz.type">Scalaz</span>._
      <span class="comment">// Note: Function `f` from sink `self` may be used for more than 1 element emitted by `p1`.</span>
      @volatile var <a title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I0,Any]#Is,I]" id="scalaz.stream.Process;SinkTaskSyntax.pipeIn.cur">cur</a> = <a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.p1" title="scalaz.stream.Process1[I0,I]">p1</a>.<a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I0,Any]#Is,I]">step</a>
      @volatile var <a title="Option[I =&gt; scalaz.concurrent.Task[Unit]]" id="scalaz.stream.Process;SinkTaskSyntax.pipeIn.lastF">lastF</a>: <span title="Option[I =&gt; scalaz.concurrent.Task[Unit]]">Option</span><span class="delimiter">[</span>I =&gt; Task<span class="delimiter">[</span>Unit<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="None.type">None</span>
      <a href="#scalaz.stream.Process.SinkTaskSyntax(c45ec1498d).self" title="=&gt; scalaz.stream.Sink[scalaz.concurrent.Task,I]">self</a>.<a href="process1.scala.html#scalaz.stream;Process1Ops.takeWhile" title="(f: (I =&gt; scalaz.concurrent.Task[Unit]) =&gt; Boolean)scalaz.stream.Process[scalaz.concurrent.Task,I =&gt; scalaz.concurrent.Task[Unit]]">takeWhile</a> <span class="delimiter">{</span> <a title="I =&gt; scalaz.concurrent.Task[Unit]" id="scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.x$42">_</a> =&gt;
        <a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.cur" title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I0,Any]#Is,I]">cur</a> match <span class="delimiter">{</span>
          case Halt<span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>.<a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span> =&gt; false
          case Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.cause">cause</a><span class="delimiter">)</span>     =&gt; throw new <a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>.<a href="Cause.scala.html#scalaz.stream.Cause;Terminated" title="scalaz.stream.Cause.Terminated">Terminated</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span>
          case _               =&gt; true
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> <a href="#scalaz.stream;Process.map" title="(f: (I =&gt; scalaz.concurrent.Task[Unit]) =&gt; (I0 =&gt; scalaz.concurrent.Task[Unit]))scalaz.stream.Process[scalaz.concurrent.Task,I0 =&gt; scalaz.concurrent.Task[Unit]]">map</a> <span class="delimiter">{</span> <span class="delimiter">(</span>f: I =&gt; Task<span class="delimiter">[</span>Unit<span class="delimiter">]</span><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.lastF" title="Option[I =&gt; scalaz.concurrent.Task[Unit]]">lastF</a> = <a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.f" title="(a: I =&gt; scalaz.concurrent.Task[Unit])scalaz.syntax.std.OptionIdOps[I =&gt; scalaz.concurrent.Task[Unit]]">f</a>.<span title="=&gt; Option[I =&gt; scalaz.concurrent.Task[Unit]]">some</span>
        <span class="delimiter">(</span>i0: <a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn;I0" title="I0">I0</a><span class="delimiter">)</span> =&gt; <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; scalaz.concurrent.Task[Unit])scalaz.concurrent.Task[Unit]">suspend</span> <span class="delimiter">{</span>
          <a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.cur" title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I0,Any]#Is,I]">cur</a> match <span class="delimiter">{</span>
            case Halt<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;Impossible&quot;)" class="string">&quot;Impossible&quot;</span><span class="delimiter">)</span>
            case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><span title="Seq[I]">piped</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I0,Any]#Is,I]">cont</span><span class="delimiter">)</span> =&gt;
              <a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.cur" title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I0,Any]#Is,I]">cur</a> = <a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="process1.scala.html#scalaz.stream.process1.feed1" title="(i: I0)(p: scalaz.stream.Process1[I0,I])scalaz.stream.Process1[I0,I]">feed1</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.$anonfun.i0" title="I0">i0</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I0,Any]#Is,I]">cont</span>.<a href="#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I0,Any]#Is,I]">continue</a> <span class="delimiter">}</span>.<a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I0,Any]#Is,I]">step</a>
              <span title="Seq[I]">piped</span>.<span title="(v: List[I])(implicit F0: scalaz.Foldable[List])scalaz.syntax.FoldableOps[List,I]">toList</span>.<span title="(f: I =&gt; scalaz.concurrent.Task[Unit])(implicit evidence$11: scalaz.Applicative[scalaz.concurrent.Task])scalaz.concurrent.Task[Unit]">traverse_</span><span title="=&gt; scalaz.Nondeterminism[scalaz.concurrent.Task] with scalaz.Catchable[scalaz.concurrent.Task] with scalaz.MonadError[[α, β]scalaz.concurrent.Task[β],Throwable]" class="delimiter">(</span><a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.f" title="I =&gt; scalaz.concurrent.Task[Unit]">f</a><span class="delimiter">)</span>
            case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.EmitOrAwait[scalaz.stream.Process.Env[I0,Any]#Is,I]" id="scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.$anonfun.hd">hd</a>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I0,Any]#Is,I]">cont</span><span class="delimiter">)</span> =&gt;
              val <a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.$anonfun.x$44.piped" title="(Seq[I], scalaz.stream.Process[scalaz.stream.Process.Env[I0,Any]#Is,I])" class="delimiter">(</a><a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.$anonfun.x$44" title="Seq[I]" id="scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.$anonfun.x$44.piped">piped</a>, <a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.$anonfun.x$44" title="scalaz.stream.Process[scalaz.stream.Process.Env[I0,Any]#Is,I]" id="scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.$anonfun.tl">tl</a><span class="delimiter">)</span> = <a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="process1.scala.html#scalaz.stream.process1.feed1" title="(i: I0)(p: scalaz.stream.Process1[I0,I])scalaz.stream.Process1[I0,I]">feed1</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.$anonfun.i0" title="I0">i0</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.$anonfun.hd" title="scalaz.stream.Process.EmitOrAwait[scalaz.stream.Process.Env[I0,Any]#Is,I]">hd</a> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I0,Any]#Is[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I0,Any]#Is[x],I]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I0,Any]#Is,I]">cont</span><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.unemit" title="=&gt; (Seq[I], scalaz.stream.Process[scalaz.stream.Process.Env[I0,Any]#Is,I])">unemit</a>
              <a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.cur" title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I0,Any]#Is,I]">cur</a> = <a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.$anonfun.tl" title="scalaz.stream.Process[scalaz.stream.Process.Env[I0,Any]#Is,I]">tl</a>.<a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I0,Any]#Is,I]">step</a>
              <span title="Seq[I]">piped</span>.<span title="(v: List[I])(implicit F0: scalaz.Foldable[List])scalaz.syntax.FoldableOps[List,I]">toList</span>.<span title="(f: I =&gt; scalaz.concurrent.Task[Unit])(implicit evidence$11: scalaz.Applicative[scalaz.concurrent.Task])scalaz.concurrent.Task[Unit]">traverse_</span><span title="=&gt; scalaz.Nondeterminism[scalaz.concurrent.Task] with scalaz.Catchable[scalaz.concurrent.Task] with scalaz.MonadError[[α, β]scalaz.concurrent.Task[β],Throwable]" class="delimiter">(</span><a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.f" title="I =&gt; scalaz.concurrent.Task[Unit]">f</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> <a href="#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],I0 =&gt; scalaz.concurrent.Task[Unit]])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],I0 =&gt; scalaz.concurrent.Task[Unit]]">onHalt</a> <a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.x0$16" title="scalaz.stream.Process[scalaz.concurrent.Task,I0 =&gt; scalaz.concurrent.Task[Unit]]" class="delimiter">{</a>
        case <a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>.<a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a> =&gt;
          <a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.lastF" title="Option[I =&gt; scalaz.concurrent.Task[Unit]]">lastF</a> <span title="(f: (I =&gt; scalaz.concurrent.Task[Unit]) =&gt; scalaz.stream.Process[scalaz.concurrent.Task,Nothing])Option[scalaz.stream.Process[scalaz.concurrent.Task,Nothing]]">map</span> <span class="delimiter">{</span> <a title="I =&gt; scalaz.concurrent.Task[Unit]" id="scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.$anonfun.f">f</a> =&gt;
            <a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.cur" title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I0,Any]#Is,I]">cur</a> match <span class="delimiter">{</span>
              case Halt<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;Impossible (2)&quot;)" class="string">&quot;Impossible (2)&quot;</span><span class="delimiter">)</span>
              case <a title="scalaz.stream.Process.Step[scalaz.stream.Process.Env[I0,Any]#Is,I]" id="scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.$anonfun.s">s</a>@Step<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
                <a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.$anonfun.s" title="scalaz.stream.Process.Step[scalaz.stream.Process.Env[I0,Any]#Is,I]">s</a>.<a href="#scalaz.stream.Process;Step.toProcess" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I0,Any]#Is,I]">toProcess</a>.<a href="#scalaz.stream;Process.disconnect" title="(cause: scalaz.stream.Cause.EarlyCause)scalaz.stream.Process0[I]">disconnect</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>.<a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.evalMap" title="(f: I =&gt; scalaz.concurrent.Task[Unit])scalaz.stream.Process[scalaz.concurrent.Task,Unit]">evalMap</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.$anonfun.f" title="I =&gt; scalaz.concurrent.Task[Unit]">f</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.drain" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,Nothing]">drain</a>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span> <span title="(default: =&gt; scalaz.stream.Process[scalaz.concurrent.Task,Nothing])scalaz.stream.Process[scalaz.concurrent.Task,Nothing]">getOrElse</span> <a href="#scalaz.stream.Process.Halt.readResolve" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>.<a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span>
        case <a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>.<a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a>  =&gt; <a href="#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>
        case <a title="scalaz.stream.Cause.Error" id="scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.c">c</a>@Cause.Error<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>.<a href="#scalaz.stream;Process.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Process[Nothing,Nothing]">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SinkTaskSyntax.pipeIn.$anonfun.c" title="scalaz.stream.Cause.Error">c</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  implicit class <a href="#scalaz.stream.Process.WriterTaskSyntax(452f18ab47).self" title="class WriterTaskSyntax[W, O] extends AnyVal" id="scalaz.stream.Process.WriterTaskSyntax(452f18ab47)">WriterTaskSyntax</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.WriterTaskSyntax(452f18ab47);W">W</a>, <a title="" id="scalaz.stream.Process.WriterTaskSyntax(452f18ab47);O">O</a><span class="delimiter">]</span><a href="#scalaz.stream.Process.WriterTaskSyntax(452f18ab47)" title="scalaz.stream.Process.WriterTaskSyntax[W,O]" class="delimiter">(</a>val <a title="scalaz.stream.Writer[scalaz.concurrent.Task,W,O]" id="scalaz.stream.Process.WriterTaskSyntax(452f18ab47).self">self</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Writer[scalaz.concurrent.Task,W,O]">Writer</a><span class="delimiter">[</span>Task, W, O<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scalaz.stream.Process.WriterTaskSyntax(452f18ab47)" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>

    <span class="comment">/**
     * Returns result of channel evaluation on `O` side tupled with
     * original output value passed to channel.
     */</span>
    def <a title="[O2](ch: scalaz.stream.Channel[scalaz.concurrent.Task,O,O2])scalaz.stream.Writer[scalaz.concurrent.Task,W,(O, O2)]" id="scalaz.stream.Process;WriterTaskSyntax.observeOThrough">observeOThrough</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WriterTaskSyntax.observeOThrough;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Channel[scalaz.concurrent.Task,O,O2]" id="scalaz.stream.Process;WriterTaskSyntax.observeOThrough.ch">ch</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Channel[scalaz.concurrent.Task,O,O2]">Channel</a><span class="delimiter">[</span>Task, O, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Writer[scalaz.concurrent.Task,W,(O, O2)]">Writer</a><span class="delimiter">[</span>Task, W, <span class="delimiter">(</span>O, O2<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      val observerCh = <a href="#scalaz.stream.Process;WriterTaskSyntax.observeOThrough.ch" title="scalaz.stream.Channel[scalaz.concurrent.Task,O,O2]">ch</a> <a href="#scalaz.stream;Process.map" title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[W,O] =&gt; scalaz.concurrent.Task[scalaz.\/[W,(O, O2)]]]" id="scalaz.stream.Process;WriterTaskSyntax.observeOThrough.observerCh">map</a> <span class="delimiter">{</span> <a title="O =&gt; scalaz.concurrent.Task[O2]" id="scalaz.stream.Process;WriterTaskSyntax.observeOThrough.observerCh.$anonfun.f">f</a> =&gt;
        in: <span class="delimiter">(</span>W <span title="scalaz.\/[W,O]">\/</span> O<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;WriterTaskSyntax.observeOThrough.observerCh.$anonfun.$anonfun.in" title="scalaz.\/[W,O]">in</a>.<span title="(l: W =&gt; scalaz.concurrent.Task[scalaz.\/[W,(O, O2)]], r: O =&gt; scalaz.concurrent.Task[scalaz.\/[W,(O, O2)]])scalaz.concurrent.Task[scalaz.\/[W,(O, O2)]]">fold</span><span class="delimiter">(</span><a title="W" id="scalaz.stream.Process;WriterTaskSyntax.observeOThrough.observerCh.$anonfun.$anonfun.$anonfun.w">w</a> =&gt; <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: scalaz.-\/[W])scalaz.concurrent.Task[scalaz.-\/[W]]">now</span><span class="delimiter">(</span><span title="(a: W)scalaz.-\/[W]">-\/</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterTaskSyntax.observeOThrough.observerCh.$anonfun.$anonfun.$anonfun.w" title="W">w</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a title="O" id="scalaz.stream.Process;WriterTaskSyntax.observeOThrough.observerCh.$anonfun.$anonfun.$anonfun.o">o</a> =&gt; <a href="#scalaz.stream.Process;WriterTaskSyntax.observeOThrough.observerCh.$anonfun.f" title="(v1: O)scalaz.concurrent.Task[O2]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterTaskSyntax.observeOThrough.observerCh.$anonfun.$anonfun.$anonfun.o" title="O">o</a><span class="delimiter">)</span>.<span title="(f: O2 =&gt; scalaz.\/-[(O, O2)])scalaz.concurrent.Task[scalaz.\/-[(O, O2)]]">map</span><span class="delimiter">(</span><a title="O2" id="scalaz.stream.Process;WriterTaskSyntax.observeOThrough.observerCh.$anonfun.$anonfun.$anonfun.$anonfun.o2">o2</a> =&gt; <span title="(b: (O, O2))scalaz.\/-[(O, O2)]">\/-</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterTaskSyntax.observeOThrough.observerCh.$anonfun.$anonfun.$anonfun.o" title="(self: O)ArrowAssoc[O]">o</a> <span title="(y: O2)(O, O2)">-&gt;</span> <a href="#scalaz.stream.Process;WriterTaskSyntax.observeOThrough.observerCh.$anonfun.$anonfun.$anonfun.$anonfun.o2" title="O2">o2</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#scalaz.stream.Process.ProcessSyntax(90c98207c6)" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[W,O]])scalaz.stream.Process.ProcessSyntax[scalaz.concurrent.Task,scalaz.\/[W,O]]">self</a> <a href="#scalaz.stream.Process;ProcessSyntax.through" title="(f: scalaz.stream.Channel[[x]scalaz.concurrent.Task[x],scalaz.\/[W,O],scalaz.\/[W,(O, O2)]])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],scalaz.\/[W,(O, O2)]]">through</a> <a href="#scalaz.stream.Process;WriterTaskSyntax.observeOThrough.observerCh" title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[W,O] =&gt; scalaz.concurrent.Task[scalaz.\/[W,(O, O2)]]]">observerCh</a>
    <span class="delimiter">}</span>

    <span class="comment">/** Returns result of channel evaluation on `W` side tupled with
     * original write value passed to channel.
     */</span>
    def <a title="[W2](ch: scalaz.stream.Channel[scalaz.concurrent.Task,W,W2])scalaz.stream.Writer[scalaz.concurrent.Task,(W, W2),O]" id="scalaz.stream.Process;WriterTaskSyntax.observeWThrough">observeWThrough</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WriterTaskSyntax.observeWThrough;W2">W2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Channel[scalaz.concurrent.Task,W,W2]" id="scalaz.stream.Process;WriterTaskSyntax.observeWThrough.ch">ch</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Channel[scalaz.concurrent.Task,W,W2]">Channel</a><span class="delimiter">[</span>Task, W, W2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Writer[scalaz.concurrent.Task,(W, W2),O]">Writer</a><span class="delimiter">[</span>Task, <span class="delimiter">(</span>W, W2<span class="delimiter">)</span>, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
      val observerCh = <a href="#scalaz.stream.Process;WriterTaskSyntax.observeWThrough.ch" title="scalaz.stream.Channel[scalaz.concurrent.Task,W,W2]">ch</a> <a href="#scalaz.stream;Process.map" title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[W,O] =&gt; scalaz.concurrent.Task[scalaz.\/[(W, W2),O]]]" id="scalaz.stream.Process;WriterTaskSyntax.observeWThrough.observerCh">map</a> <span class="delimiter">{</span> <a title="W =&gt; scalaz.concurrent.Task[W2]" id="scalaz.stream.Process;WriterTaskSyntax.observeWThrough.observerCh.$anonfun.f">f</a> =&gt;
        in: <span class="delimiter">(</span>W <span title="scalaz.\/[W,O]">\/</span> O<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;WriterTaskSyntax.observeWThrough.observerCh.$anonfun.$anonfun.in" title="scalaz.\/[W,O]">in</a>.<span title="(l: W =&gt; scalaz.concurrent.Task[scalaz.\/[(W, W2),O]], r: O =&gt; scalaz.concurrent.Task[scalaz.\/[(W, W2),O]])scalaz.concurrent.Task[scalaz.\/[(W, W2),O]]">fold</span><span class="delimiter">(</span><a title="W" id="scalaz.stream.Process;WriterTaskSyntax.observeWThrough.observerCh.$anonfun.$anonfun.$anonfun.w">w</a> =&gt; <a href="#scalaz.stream.Process;WriterTaskSyntax.observeWThrough.observerCh.$anonfun.f" title="(v1: W)scalaz.concurrent.Task[W2]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterTaskSyntax.observeWThrough.observerCh.$anonfun.$anonfun.$anonfun.w" title="W">w</a><span class="delimiter">)</span>.<span title="(f: W2 =&gt; scalaz.-\/[(W, W2)])scalaz.concurrent.Task[scalaz.-\/[(W, W2)]]">map</span><span class="delimiter">(</span><a title="W2" id="scalaz.stream.Process;WriterTaskSyntax.observeWThrough.observerCh.$anonfun.$anonfun.$anonfun.$anonfun.w2">w2</a> =&gt; <span title="(a: (W, W2))scalaz.-\/[(W, W2)]">-\/</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterTaskSyntax.observeWThrough.observerCh.$anonfun.$anonfun.$anonfun.w" title="(self: W)ArrowAssoc[W]">w</a> <span title="(y: W2)(W, W2)">-&gt;</span> <a href="#scalaz.stream.Process;WriterTaskSyntax.observeWThrough.observerCh.$anonfun.$anonfun.$anonfun.$anonfun.w2" title="W2">w2</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a title="O" id="scalaz.stream.Process;WriterTaskSyntax.observeWThrough.observerCh.$anonfun.$anonfun.$anonfun.o">o</a> =&gt; <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: scalaz.\/-[O])scalaz.concurrent.Task[scalaz.\/-[O]]">now</span><span class="delimiter">(</span><span title="(b: O)scalaz.\/-[O]">\/-</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterTaskSyntax.observeWThrough.observerCh.$anonfun.$anonfun.$anonfun.o" title="O">o</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#scalaz.stream.Process.ProcessSyntax(90c98207c6)" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[W,O]])scalaz.stream.Process.ProcessSyntax[scalaz.concurrent.Task,scalaz.\/[W,O]]">self</a> <a href="#scalaz.stream.Process;ProcessSyntax.through" title="(f: scalaz.stream.Channel[[x]scalaz.concurrent.Task[x],scalaz.\/[W,O],scalaz.\/[(W, W2),O]])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],scalaz.\/[(W, W2),O]]">through</a> <a href="#scalaz.stream.Process;WriterTaskSyntax.observeWThrough.observerCh" title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[W,O] =&gt; scalaz.concurrent.Task[scalaz.\/[(W, W2),O]]]">observerCh</a>
    <span class="delimiter">}</span>

    <span class="comment">/** Feed this `Writer`'s output through the provided effectful `Channel`. */</span>
    def <a title="[O2](ch: scalaz.stream.Channel[scalaz.concurrent.Task,O,O2])scalaz.stream.Writer[scalaz.concurrent.Task,W,O2]" id="scalaz.stream.Process;WriterTaskSyntax.throughO">throughO</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WriterTaskSyntax.throughO;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Channel[scalaz.concurrent.Task,O,O2]" id="scalaz.stream.Process;WriterTaskSyntax.throughO.ch">ch</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Channel[scalaz.concurrent.Task,O,O2]">Channel</a><span class="delimiter">[</span>Task, O, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Writer[scalaz.concurrent.Task,W,O2]">Writer</a><span class="delimiter">[</span>Task, W, O2<span class="delimiter">]</span> = <span class="delimiter">{</span>
      val ch2 = <a href="#scalaz.stream.Process;WriterTaskSyntax.throughO.ch" title="scalaz.stream.Channel[scalaz.concurrent.Task,O,O2]">ch</a> <a href="#scalaz.stream;Process.map" title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[W,O] =&gt; scalaz.concurrent.Task[scalaz.\/[W,O2]]]" id="scalaz.stream.Process;WriterTaskSyntax.throughO.ch2">map</a> <span class="delimiter">{</span> <a title="O =&gt; scalaz.concurrent.Task[O2]" id="scalaz.stream.Process;WriterTaskSyntax.throughO.ch2.$anonfun.f">f</a> =&gt;
        in: <span class="delimiter">(</span>W <span title="scalaz.\/[W,O]">\/</span> O<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;WriterTaskSyntax.throughO.ch2.$anonfun.$anonfun.in" title="scalaz.\/[W,O]">in</a>.<span title="(l: W =&gt; scalaz.concurrent.Task[scalaz.\/[W,O2]], r: O =&gt; scalaz.concurrent.Task[scalaz.\/[W,O2]])scalaz.concurrent.Task[scalaz.\/[W,O2]]">fold</span><span class="delimiter">(</span><a title="W" id="scalaz.stream.Process;WriterTaskSyntax.throughO.ch2.$anonfun.$anonfun.$anonfun.w">w</a> =&gt; <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: scalaz.\/[W,Nothing])scalaz.concurrent.Task[scalaz.\/[W,Nothing]]">now</span><span class="delimiter">(</span><span title="(v1: W)scalaz.\/[W,Nothing]">left</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterTaskSyntax.throughO.ch2.$anonfun.$anonfun.$anonfun.w" title="W">w</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a title="O" id="scalaz.stream.Process;WriterTaskSyntax.throughO.ch2.$anonfun.$anonfun.$anonfun.o">o</a> =&gt; <a href="#scalaz.stream.Process;WriterTaskSyntax.throughO.ch2.$anonfun.f" title="(v1: O)scalaz.concurrent.Task[O2]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterTaskSyntax.throughO.ch2.$anonfun.$anonfun.$anonfun.o" title="O">o</a><span class="delimiter">)</span>.<span title="(f: O2 =&gt; scalaz.\/[Nothing,O2])scalaz.concurrent.Task[scalaz.\/[Nothing,O2]]">map</span><span class="delimiter">(</span><span title="O2 =&gt; scalaz.\/[Nothing,O2]">right</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#scalaz.stream.Process.ProcessSyntax(90c98207c6)" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[W,O]])scalaz.stream.Process.ProcessSyntax[scalaz.concurrent.Task,scalaz.\/[W,O]]">self</a> <a href="#scalaz.stream.Process;ProcessSyntax.through" title="(f: scalaz.stream.Channel[[x]scalaz.concurrent.Task[x],scalaz.\/[W,O],scalaz.\/[W,O2]])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],scalaz.\/[W,O2]]">through</a> <a href="#scalaz.stream.Process;WriterTaskSyntax.throughO.ch2" title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[W,O] =&gt; scalaz.concurrent.Task[scalaz.\/[W,O2]]]">ch2</a>
    <span class="delimiter">}</span>

    <span class="comment">/** Feed this `Writer`'s writes through the provided effectful `Channel`. */</span>
    def <a title="[W2](ch: scalaz.stream.Channel[scalaz.concurrent.Task,W,W2])scalaz.stream.Writer[scalaz.concurrent.Task,W2,O]" id="scalaz.stream.Process;WriterTaskSyntax.throughW">throughW</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WriterTaskSyntax.throughW;W2">W2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Channel[scalaz.concurrent.Task,W,W2]" id="scalaz.stream.Process;WriterTaskSyntax.throughW.ch">ch</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Channel[scalaz.concurrent.Task,W,W2]">Channel</a><span class="delimiter">[</span>Task, W, W2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Writer[scalaz.concurrent.Task,W2,O]">Writer</a><span class="delimiter">[</span>Task, W2, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
      val ch2 = <a href="#scalaz.stream.Process;WriterTaskSyntax.throughW.ch" title="scalaz.stream.Channel[scalaz.concurrent.Task,W,W2]">ch</a> <a href="#scalaz.stream;Process.map" title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[W,O] =&gt; scalaz.concurrent.Task[scalaz.\/[W2,O]]]" id="scalaz.stream.Process;WriterTaskSyntax.throughW.ch2">map</a> <span class="delimiter">{</span> <a title="W =&gt; scalaz.concurrent.Task[W2]" id="scalaz.stream.Process;WriterTaskSyntax.throughW.ch2.$anonfun.f">f</a> =&gt;
        in: <span class="delimiter">(</span>W <span title="scalaz.\/[W,O]">\/</span> O<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;WriterTaskSyntax.throughW.ch2.$anonfun.$anonfun.in" title="scalaz.\/[W,O]">in</a>.<span title="(l: W =&gt; scalaz.concurrent.Task[scalaz.\/[W2,O]], r: O =&gt; scalaz.concurrent.Task[scalaz.\/[W2,O]])scalaz.concurrent.Task[scalaz.\/[W2,O]]">fold</span><span class="delimiter">(</span><a title="W" id="scalaz.stream.Process;WriterTaskSyntax.throughW.ch2.$anonfun.$anonfun.$anonfun.w">w</a> =&gt; <a href="#scalaz.stream.Process;WriterTaskSyntax.throughW.ch2.$anonfun.f" title="(v1: W)scalaz.concurrent.Task[W2]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterTaskSyntax.throughW.ch2.$anonfun.$anonfun.$anonfun.w" title="W">w</a><span class="delimiter">)</span>.<span title="(f: W2 =&gt; scalaz.\/[W2,Nothing])scalaz.concurrent.Task[scalaz.\/[W2,Nothing]]">map</span><span class="delimiter">(</span><span title="W2 =&gt; scalaz.\/[W2,Nothing]">left</span><span class="delimiter">)</span>, <a title="O" id="scalaz.stream.Process;WriterTaskSyntax.throughW.ch2.$anonfun.$anonfun.$anonfun.o">o</a> =&gt; <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: scalaz.\/[Nothing,O])scalaz.concurrent.Task[scalaz.\/[Nothing,O]]">now</span><span class="delimiter">(</span><span title="(v1: O)scalaz.\/[Nothing,O]">right</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterTaskSyntax.throughW.ch2.$anonfun.$anonfun.$anonfun.o" title="O">o</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#scalaz.stream.Process.ProcessSyntax(90c98207c6)" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[W,O]])scalaz.stream.Process.ProcessSyntax[scalaz.concurrent.Task,scalaz.\/[W,O]]">self</a> <a href="#scalaz.stream.Process;ProcessSyntax.through" title="(f: scalaz.stream.Channel[[x]scalaz.concurrent.Task[x],scalaz.\/[W,O],scalaz.\/[W2,O]])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],scalaz.\/[W2,O]]">through</a> <a href="#scalaz.stream.Process;WriterTaskSyntax.throughW.ch2" title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[W,O] =&gt; scalaz.concurrent.Task[scalaz.\/[W2,O]]]">ch2</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  <span class="comment">/**
   * This class provides infix syntax specific to `Process1`.
   */</span>
  implicit class <a href="#scalaz.stream.Process.Process1Syntax(ed4aae368f).self" title="class Process1Syntax[I, O] extends AnyVal" id="scalaz.stream.Process.Process1Syntax(ed4aae368f)">Process1Syntax</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.Process1Syntax(ed4aae368f);I">I</a>,<a title="" id="scalaz.stream.Process.Process1Syntax(ed4aae368f);O">O</a><span class="delimiter">]</span><a href="#scalaz.stream.Process.Process1Syntax(ed4aae368f)" title="scalaz.stream.Process.Process1Syntax[I,O]" class="delimiter">(</a>val <a title="scalaz.stream.Process1[I,O]" id="scalaz.stream.Process.Process1Syntax(ed4aae368f).self">self</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[I,O]">Process1</a><span class="delimiter">[</span>I,O<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scalaz.stream.Process.Process1Syntax(ed4aae368f)" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>

    <span class="comment">/** Apply this `Process` to an `Iterable`. */</span>
    def <a title="(input: Iterable[I])IndexedSeq[O]" id="scalaz.stream.Process;Process1Syntax.apply">apply</a><span class="delimiter">(</span><a title="Iterable[I]" id="scalaz.stream.Process;Process1Syntax.apply.input">input</a>: <span title="Iterable[I]">Iterable</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="IndexedSeq[O]">IndexedSeq</span><span class="delimiter">[</span>O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.apply" title="(o: I*)scalaz.stream.Process0[I]">Process</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;Process1Syntax.apply.input" title="Iterable[I]">input</a>.<span title="=&gt; Seq[I]">toSeq</span>: _*<span class="delimiter">)</span>.<a href="#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[I,O])scalaz.stream.Process[Nothing,O]">pipe</a><a href="#scalaz.stream.Process.Process0Syntax(0cbdd80600)" title="(self: scalaz.stream.Process0[O])scalaz.stream.Process.Process0Syntax[O]" class="delimiter">(</a><a href="#scalaz.stream.Process.Process1Syntax(ed4aae368f).self" title="=&gt; scalaz.stream.Process1[I,O]">self</a><span class="delimiter">)</span>.<a href="#scalaz.stream.Process;Process0Syntax.toIndexedSeq" title="=&gt; IndexedSeq[O]">toIndexedSeq</a>

    <span class="comment">/**
     * Transform `self` to operate on the left hand side of an `\/`, passing
     * through any values it receives on the right. Note that this halts
     * whenever `self` halts.
     */</span>
    def <a title="[I2]=&gt; scalaz.stream.Process1[scalaz.\/[I,I2],scalaz.\/[O,I2]]" id="scalaz.stream.Process;Process1Syntax.liftL">liftL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Process1Syntax.liftL;I2">I2</a><span class="delimiter">]</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[scalaz.\/[I,I2],scalaz.\/[O,I2]]">Process1</a><span class="delimiter">[</span>I \/ I2, O \/ I2<span class="delimiter">]</span> =
      <a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="process1.scala.html#scalaz.stream.process1.liftL" title="(p: scalaz.stream.Process1[I,O])scalaz.stream.Process1[scalaz.\/[I,I2],scalaz.\/[O,I2]]">liftL</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.Process1Syntax(ed4aae368f).self" title="=&gt; scalaz.stream.Process1[I,O]">self</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Transform `self` to operate on the right hand side of an `\/`, passing
     * through any values it receives on the left. Note that this halts
     * whenever `self` halts.
     */</span>
    def <a title="[I0]=&gt; scalaz.stream.Process1[scalaz.\/[I0,I],scalaz.\/[I0,O]]" id="scalaz.stream.Process;Process1Syntax.liftR">liftR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Process1Syntax.liftR;I0">I0</a><span class="delimiter">]</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[scalaz.\/[I0,I],scalaz.\/[I0,O]]">Process1</a><span class="delimiter">[</span>I0 \/ I, I0 \/ O<span class="delimiter">]</span> =
      <a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="process1.scala.html#scalaz.stream.process1.liftR" title="(p: scalaz.stream.Process1[I,O])scalaz.stream.Process1[scalaz.\/[I0,I],scalaz.\/[I0,O]]">liftR</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.Process1Syntax(ed4aae368f).self" title="=&gt; scalaz.stream.Process1[I,O]">self</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Feed a single input to this `Process1`.
     */</span>
    def <a title="(i: I)scalaz.stream.Process1[I,O]" id="scalaz.stream.Process;Process1Syntax.feed1">feed1</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.Process;Process1Syntax.feed1.i">i</a>: <a href="#scalaz.stream.Process.Process1Syntax(ed4aae368f);I" title="I">I</a><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[I,O]">Process1</a><span class="delimiter">[</span>I,O<span class="delimiter">]</span> =
      <a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="process1.scala.html#scalaz.stream.process1.feed1" title="(i: I)(p: scalaz.stream.Process1[I,O])scalaz.stream.Process1[I,O]">feed1</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;Process1Syntax.feed1.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.Process1Syntax(ed4aae368f).self" title="=&gt; scalaz.stream.Process1[I,O]">self</a><span class="delimiter">)</span>

    <span class="comment">/** Transform the input of this `Process1`. */</span>
    def <a title="[I2](f: I2 =&gt; I)scalaz.stream.Process1[I2,O]" id="scalaz.stream.Process;Process1Syntax.contramap">contramap</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;Process1Syntax.contramap;I2">I2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I2 =&gt; I" id="scalaz.stream.Process;Process1Syntax.contramap.f">f</a>: I2 =&gt; I<span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[I2,O]">Process1</a><span class="delimiter">[</span>I2,O<span class="delimiter">]</span> =
      <a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="process1.scala.html#scalaz.stream.process1.lift" title="(f: I2 =&gt; I)scalaz.stream.Process1[I2,I]">lift</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;Process1Syntax.contramap.f" title="I2 =&gt; I">f</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[I,O])scalaz.stream.Process[scalaz.stream.Process.Env[I2,Any]#Is,O]">pipe</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.Process1Syntax(ed4aae368f).self" title="=&gt; scalaz.stream.Process1[I,O]">self</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>


  <span class="comment">/**
   * Syntax for processes that have its effects wrapped in Task
   */</span>
  implicit class <a href="#scalaz.stream.Process.SourceSyntax.self" title="class SourceSyntax[O] extends AnyRef with scalaz.stream.WyeOps[O]" id="scalaz.stream.Process.SourceSyntax">SourceSyntax</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.SourceSyntax;O">O</a><span class="delimiter">]</span><a href="#scalaz.stream.Process.SourceSyntax" title="scalaz.stream.Process.SourceSyntax[O]" class="delimiter">(</a>val <a title="scalaz.stream.Process[scalaz.concurrent.Task,O]" id="scalaz.stream.Process.SourceSyntax.self">self</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,O]">Process</a><span class="delimiter">[</span>Task, O<span class="delimiter">]</span><span class="delimiter">)</span>   extends <a href="wye.scala.html#scalaz.stream;WyeOps" title="scalaz.stream.WyeOps[O]">WyeOps</a><span class="delimiter">[</span>O<span class="delimiter">]</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * Produce a continuous stream from a discrete stream by using the
     * most recent value.
     */</span>
    def <a title="(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,O]" id="scalaz.stream.Process;SourceSyntax.forwardFill">forwardFill</a><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream.Process;SourceSyntax.forwardFill.S">S</a>: <span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,O]">Process</a><span class="delimiter">[</span>Task, O<span class="delimiter">]</span> =
      async.<a href="async/package.scala.html#scalaz.stream.async.package.toSignal" title="(source: scalaz.stream.Process[scalaz.concurrent.Task,O], haltOnSource: Boolean)(implicit S: scalaz.concurrent.Strategy)scalaz.stream.async.mutable.Signal[O]">toSignal</a><a href="#scalaz.stream.Process;SourceSyntax.forwardFill.S" title="scalaz.concurrent.Strategy" class="delimiter">(</a><a href="#scalaz.stream.Process.SourceSyntax.self" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,O]">self</a><span class="delimiter">)</span>.<a href="async/immutable/Signal.scala.html#scalaz.stream.async.immutable;Signal.continuous" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,O]">continuous</a>

    <span class="comment">/**
     * Returns result of channel evaluation tupled with
     * original value passed to channel.
     **/</span>
    def <a title="[O2](ch: scalaz.stream.Channel[scalaz.concurrent.Task,O,O2])scalaz.stream.Process[scalaz.concurrent.Task,(O, O2)]" id="scalaz.stream.Process;SourceSyntax.observeThrough">observeThrough</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;SourceSyntax.observeThrough;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Channel[scalaz.concurrent.Task,O,O2]" id="scalaz.stream.Process;SourceSyntax.observeThrough.ch">ch</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Channel[scalaz.concurrent.Task,O,O2]">Channel</a><span class="delimiter">[</span>Task, O, O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,(O, O2)]">Process</a><span class="delimiter">[</span>Task, <span class="delimiter">(</span>O, O2<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      val observerCh = <a href="#scalaz.stream.Process;SourceSyntax.observeThrough.ch" title="scalaz.stream.Channel[scalaz.concurrent.Task,O,O2]">ch</a> <a href="#scalaz.stream;Process.map" title="scalaz.stream.Process[scalaz.concurrent.Task,O =&gt; scalaz.concurrent.Task[(O, O2)]]" id="scalaz.stream.Process;SourceSyntax.observeThrough.observerCh">map</a> <span class="delimiter">{</span> <a title="O =&gt; scalaz.concurrent.Task[O2]" id="scalaz.stream.Process;SourceSyntax.observeThrough.observerCh.$anonfun.f">f</a> =&gt;
        o: <a href="#scalaz.stream.Process.SourceSyntax;O" title="O">O</a> =&gt; <a href="#scalaz.stream.Process;SourceSyntax.observeThrough.observerCh.$anonfun.f" title="(v1: O)scalaz.concurrent.Task[O2]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.observeThrough.observerCh.$anonfun.$anonfun.o" title="O">o</a><span class="delimiter">)</span> <span title="(f: O2 =&gt; (O, O2))scalaz.concurrent.Task[(O, O2)]">map</span> <span class="delimiter">{</span> <a title="O2" id="scalaz.stream.Process;SourceSyntax.observeThrough.observerCh.$anonfun.$anonfun.$anonfun.o2">o2</a> =&gt; <a href="#scalaz.stream.Process;SourceSyntax.observeThrough.observerCh.$anonfun.$anonfun.o" title="(self: O)ArrowAssoc[O]">o</a> <span title="(y: O2)(O, O2)">-&gt;</span> <a href="#scalaz.stream.Process;SourceSyntax.observeThrough.observerCh.$anonfun.$anonfun.$anonfun.o2" title="O2">o2</a> <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#scalaz.stream.Process.ProcessSyntax(90c98207c6)" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,O])scalaz.stream.Process.ProcessSyntax[scalaz.concurrent.Task,O]">self</a> <a href="#scalaz.stream.Process;ProcessSyntax.through" title="(f: scalaz.stream.Channel[[x]scalaz.concurrent.Task[x],O,(O, O2)])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],(O, O2)]">through</a> <a href="#scalaz.stream.Process;SourceSyntax.observeThrough.observerCh" title="scalaz.stream.Process[scalaz.concurrent.Task,O =&gt; scalaz.concurrent.Task[(O, O2)]]">observerCh</a>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Asynchronous stepping of this Process. Note that this method is not resource safe unless
     * callback is called with _left_ side completed. In that case it is guaranteed that all cleanups
     * has been successfully completed.
     * User of this method is responsible for any cleanup actions to be performed by running the
     * next Process obtained on right side of callback.
     *
     * This method returns a function, that when applied, causes the running computation to be interrupted.
     * That is useful of process contains any asynchronous code, that may be left with incomplete callbacks.
     * If the evaluation of the process is interrupted, then the interruption is only active if the callback
     * was not completed before, otherwise interruption is no-op.
     *
     * There is chance, that cleanup code of intermediate `Await` will get called twice on interrupt, but
     * always at least once. The second cleanup invocation in that case may run on different thread, asynchronously.
     *
     * Please note that this method is *not* intended for external use!  It is the `Await` analogue of `step`, which
     * is also an internal-use function.
     *
     * @param cb  result of the asynchronous evaluation of the process. Note that, the callback is never called
     *            on the right side, if the sequence is empty.
     * @param S  Strategy to use when evaluating the process. Note that `Strategy.Sequential` may cause SOE.
     * @return   Function to interrupt the evaluation
     */</span>
    protected<span class="delimiter">[</span>stream<span class="delimiter">]</span> final def <a title="(cb: scalaz.\/[scalaz.stream.Cause,(Seq[O], scalaz.stream.Process.Cont[scalaz.concurrent.Task,O])] =&gt; Unit)(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Cause.EarlyCause =&gt; Unit" id="scalaz.stream.Process;SourceSyntax.stepAsync">stepAsync</a><span class="delimiter">(</span><a title="scalaz.\/[scalaz.stream.Cause,(Seq[O], scalaz.stream.Process.Cont[scalaz.concurrent.Task,O])] =&gt; Unit" id="scalaz.stream.Process;SourceSyntax.stepAsync.cb">cb</a>: Cause \/ <span class="delimiter">(</span>Seq<span class="delimiter">[</span>O<span class="delimiter">]</span>, Cont<span class="delimiter">[</span>Task,O<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream.Process;SourceSyntax.stepAsync.S">S</a>: <span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: EarlyCause =&gt; Unit = <span class="delimiter">{</span>
      val allSteps = <span title="scalaz.concurrent.Task.type">Task</span> <a title="scalaz.concurrent.Task[scalaz.stream.Process[scalaz.concurrent.Task,O] =&gt; scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps">delay</a> <span class="delimiter">{</span>
        <span class="comment">/*
         * Represents the running state of the computation.  If we're running, then the interrupt
         * function *for our current step* will be on the left.  If we have been interrupted, then
         * the cause for that interrupt will be on the right.  These state transitions are made
         * atomically, such that it is *impossible* for a task to be running, never interrupted and
         * to have this value be a right.  If the value is a right, then either no task is running
         * or the running task has received an interrupt.
         */</span>
        val <a title="java.util.concurrent.atomic.AtomicReference[scalaz.\/[() =&gt; Unit,scalaz.stream.Cause.EarlyCause]]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.interrupted">interrupted</a> = new <span title="java.util.concurrent.atomic.AtomicReference[scalaz.\/[() =&gt; Unit,scalaz.stream.Cause.EarlyCause]]">AtomicReference</span><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">)</span> \/ EarlyCause<span class="delimiter">]</span><span class="delimiter">(</span><span title="(a: () =&gt; Unit)scalaz.-\/[() =&gt; Unit]">-\/</span><span class="delimiter">(</span><span class="delimiter">{</span> <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>

        <span class="comment">/*
         * Produces the evaluation for a single step.  Generally, this function will be
         * invoked only once and return immediately.  In the case of an `Await`, we must
         * descend recursively into the resultant child.  Generally speaking, the recursion
         * should be extremely shallow, since it is uncommon to have a chain of nested
         * awaits of any significant length (usually they are punctuated by an `Emit`).
         */</span>
        def <a title="(p: scalaz.stream.Process[scalaz.concurrent.Task,O])scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go">go</a><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.concurrent.Task,O]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.p">p</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,O]">Process</a><span class="delimiter">[</span>Task, O<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]">Task</span><span class="delimiter">[</span>EarlyCause =&gt; Unit<span class="delimiter">]</span> = <span title="scalaz.concurrent.Task.type">Task</span> <span title="(v: scalaz.concurrent.Task[scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]])(implicit F0: scalaz.Bind[scalaz.concurrent.Task])scalaz.syntax.BindOps[scalaz.concurrent.Task,scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]]">delay</span> <span class="delimiter">{</span>
          <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.p" title="scalaz.stream.Process[scalaz.concurrent.Task,O]">p</a>.<a href="#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.concurrent.Task,O]">step</a> match <span class="delimiter">{</span>
            case Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.cause">cause</a><span class="delimiter">)</span> =&gt;
              <span class="delimiter">(</span><span title="scalaz.concurrent.Task.type">Task</span> <span title="(v: scalaz.concurrent.Task[() =&gt; Unit])(implicit F0: scalaz.Bind[scalaz.concurrent.Task])scalaz.syntax.BindOps[scalaz.concurrent.Task,() =&gt; Unit]">delay</span> <span class="delimiter">{</span> <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a> <span class="delimiter">{</span> <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.cb" title="(v1: scalaz.\/[scalaz.stream.Cause,(Seq[O], scalaz.stream.Process.Cont[scalaz.concurrent.Task,O])])Unit">cb</a><span class="delimiter">(</span><span title="(a: scalaz.stream.Cause)scalaz.-\/[scalaz.stream.Cause]">-\/</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span> <span class="delimiter">}</span><span class="delimiter">)</span> <span title="(b: =&gt; scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit])scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]">&gt;&gt;</span> <span class="delimiter">(</span><span title="scalaz.concurrent.Task.type">Task</span> <span title="(a: scalaz.stream.Cause.EarlyCause =&gt; Unit)scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]">now</span> <span class="delimiter">{</span> _: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>

            case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.os">os</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,O]">cont</span><span class="delimiter">)</span> =&gt;
              <span class="delimiter">(</span><span title="scalaz.concurrent.Task.type">Task</span> <span title="(v: scalaz.concurrent.Task[() =&gt; Unit])(implicit F0: scalaz.Bind[scalaz.concurrent.Task])scalaz.syntax.BindOps[scalaz.concurrent.Task,() =&gt; Unit]">delay</span> <span class="delimiter">{</span> <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a> <span class="delimiter">{</span> <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.cb" title="(v1: scalaz.\/[scalaz.stream.Cause,(Seq[O], scalaz.stream.Process.Cont[scalaz.concurrent.Task,O])])Unit">cb</a><span class="delimiter">(</span><span title="(b: (Seq[O], scalaz.stream.Process.Cont[scalaz.concurrent.Task,O]))scalaz.\/-[(Seq[O], scalaz.stream.Process.Cont[scalaz.concurrent.Task,O])]">\/-</span><span class="delimiter">(</span><span title="(_1: Seq[O], _2: scalaz.stream.Process.Cont[scalaz.concurrent.Task,O])(Seq[O], scalaz.stream.Process.Cont[scalaz.concurrent.Task,O])" class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.os" title="Seq[O]">os</a>, <span title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span> <span class="delimiter">}</span><span class="delimiter">)</span> <span title="(b: =&gt; scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit])scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]">&gt;&gt;</span> <span class="delimiter">(</span><span title="scalaz.concurrent.Task.type">Task</span> <span title="(a: scalaz.stream.Cause.EarlyCause =&gt; Unit)scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]">now</span> <span class="delimiter">{</span> _: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>

            case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.Await[scalaz.concurrent.Task,a,O]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.awt">awt</a>: <a href="#scalaz.stream.Process.Await.readResolve" title="scalaz.stream.Process.Await[scalaz.concurrent.Task,a,O]">Await</a><span class="delimiter">[</span>Task, a, O<span class="delimiter">]</span>, <span title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,O]">cont</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
              val Await<a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.req" title="(scalaz.concurrent.Task[a], scalaz.\/[scalaz.stream.Cause.EarlyCause,a] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,O]])" class="delimiter">(</a><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.x$47" title="scalaz.concurrent.Task[a]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.req">req</a>, <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.x$47" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,a] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,O]]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.rcv">rcv</a><span class="delimiter">)</span> = <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.awt" title="scalaz.stream.Process.Await[scalaz.concurrent.Task,a,O]">awt</a>

              case class <a title="class PreStepAbort extends RuntimeException with Product with Serializable" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go;PreStepAbort.readResolve">PreStepAbort</a><span title="Product" class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go;PreStepAbort.c">c</a>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a><span class="delimiter">)</span> extends <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go;PreStepAbort.readResolve" title="RuntimeException">RuntimeException</a>

              def <a title="(msg: Option[scalaz.\/[Throwable,a]])Option[scalaz.stream.Process[scalaz.concurrent.Task,O]]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.unpack">unpack</a><span class="delimiter">(</span><a title="Option[scalaz.\/[Throwable,a]]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.unpack.msg">msg</a>: <span title="Option[scalaz.\/[Throwable,a]]">Option</span><span class="delimiter">[</span>Throwable \/ a<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[scalaz.stream.Process[scalaz.concurrent.Task,O]]">Option</span><span class="delimiter">[</span>Process<span class="delimiter">[</span>Task, O<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.unpack.msg" title="Option[scalaz.\/[Throwable,a]]">msg</a> <span title="(f: scalaz.\/[Throwable,a] =&gt; scalaz.stream.Process[scalaz.concurrent.Task,O])Option[scalaz.stream.Process[scalaz.concurrent.Task,O]]">map</span> <span class="delimiter">{</span> <a title="scalaz.\/[Throwable,a]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.unpack.$anonfun.r">r</a> =&gt; <a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[scalaz.concurrent.Task,O])scalaz.stream.Process[scalaz.concurrent.Task,O]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.rcv" title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,a])scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,O]]">rcv</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.EarlyCause" title="scalaz.stream.Cause.EarlyCause.type">EarlyCause</a> <a href="Cause.scala.html#scalaz.stream.Cause.EarlyCause.fromTaskResult" title="(r: scalaz.\/[Throwable,a])scalaz.\/[scalaz.stream.Cause.EarlyCause,a]">fromTaskResult</a> <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.unpack.$anonfun.r" title="scalaz.\/[Throwable,a]">r</a><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Process[scalaz.concurrent.Task,O]],scalaz.Free.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,O]]])scalaz.stream.Process[scalaz.concurrent.Task,O]">run</span><span class="delimiter">)</span> <span class="delimiter">}</span>

              <span class="comment">// throws an exception if we're already interrupted (caught in preStep check)</span>
              def <a title="(int: =&gt; () =&gt; Unit)scalaz.concurrent.Task[Unit]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.checkInterrupt">checkInterrupt</a><span class="delimiter">(</span><a title="=&gt; () =&gt; Unit" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.checkInterrupt.int">int</a>: =&gt; <span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">)</span><span class="delimiter">)</span>: <span title="scalaz.concurrent.Task[Unit]">Task</span><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <span title="scalaz.concurrent.Task.type">Task</span> <span title="(v: scalaz.concurrent.Task[scalaz.concurrent.Task[Unit]])(implicit F0: scalaz.Bind[scalaz.concurrent.Task])scalaz.syntax.BindOps[scalaz.concurrent.Task,scalaz.concurrent.Task[Unit]]">delay</span> <span class="delimiter">{</span>
                <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.interrupted" title="java.util.concurrent.atomic.AtomicReference[scalaz.\/[() =&gt; Unit,scalaz.stream.Cause.EarlyCause]]">interrupted</a>.<span title="()scalaz.\/[() =&gt; Unit,scalaz.stream.Cause.EarlyCause]">get</span><span class="delimiter">(</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
                  case <a title="scalaz.-\/[() =&gt; Unit]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.checkInterrupt.ptr">ptr</a> @ -\/<span class="delimiter">(</span><a title="() =&gt; Unit" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.checkInterrupt.int2">int2</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
                    if <span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.interrupted" title="java.util.concurrent.atomic.AtomicReference[scalaz.\/[() =&gt; Unit,scalaz.stream.Cause.EarlyCause]]">interrupted</a>.<span title="(x$1: scalaz.\/[() =&gt; Unit,scalaz.stream.Cause.EarlyCause], x$2: scalaz.\/[() =&gt; Unit,scalaz.stream.Cause.EarlyCause])Boolean">compareAndSet</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.checkInterrupt.ptr" title="scalaz.-\/[() =&gt; Unit]">ptr</a>, <span title="(a: () =&gt; Unit)scalaz.-\/[() =&gt; Unit]">-\/</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.checkInterrupt.int" title="=&gt; () =&gt; Unit">int</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                      <span title="scalaz.concurrent.Task.type">Task</span> <span title="(a: Unit)scalaz.concurrent.Task[Unit]">now</span> <span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
                    else
                      <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.checkInterrupt" title="(int: =&gt; () =&gt; Unit)scalaz.concurrent.Task[Unit]">checkInterrupt</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.checkInterrupt.int" title="=&gt; () =&gt; Unit">int</a><span class="delimiter">)</span>
                  <span class="delimiter">}</span>

                  case \/-<span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.checkInterrupt.c">c</a><span class="delimiter">)</span> =&gt; <span title="scalaz.concurrent.Task.type">Task</span> <span title="(e: Throwable)scalaz.concurrent.Task[Nothing]">fail</span> <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go;PreStepAbort.readResolve" title="(c: scalaz.stream.Cause.EarlyCause)PreStepAbort">PreStepAbort</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.checkInterrupt.c" title="scalaz.stream.Cause.EarlyCause">c</a><span class="delimiter">)</span>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span> <span title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.concurrent.Task[Unit],scalaz.concurrent.Task[Unit]])scalaz.concurrent.Task[Unit]">join</span>

              <span title="scalaz.concurrent.Task.type">Task</span> <span title="(a: =&gt; scalaz.stream.Cause.EarlyCause =&gt; Unit)scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]">delay</span> <span class="delimiter">{</span>
                <span class="comment">// will be true when we have &quot;committed&quot; to either a mid-step OR exceptional/completed</span>
                val <a title="java.util.concurrent.atomic.AtomicBoolean" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.barrier">barrier</a> = new <span title="java.util.concurrent.atomic.AtomicBoolean">AtomicBoolean</span><span class="delimiter">(</span>false<span class="delimiter">)</span>

                <span class="comment">// detects what completion/interrupt case we're in and factors out race conditions</span>
                def <a title="(preStep: scalaz.stream.Cause.EarlyCause =&gt; Unit, midStep: scalaz.stream.Cause.EarlyCause =&gt; Unit, postStep: (scalaz.stream.Process[scalaz.concurrent.Task,O], scalaz.stream.Cause.EarlyCause) =&gt; Unit, exceptional: Throwable =&gt; Unit, completed: scalaz.stream.Process[scalaz.concurrent.Task,O] =&gt; Unit)(result: Option[scalaz.\/[Throwable,a]])Unit" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle">handle</a><span class="delimiter">(</span>
                    <span class="comment">// interrupted before the task started running; task never ran!</span>
                    <a title="scalaz.stream.Cause.EarlyCause =&gt; Unit" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.preStep">preStep</a>: EarlyCause =&gt; Unit,
                    <span class="comment">// interrupted *during* the task run; task is probably still running</span>
                    <a title="scalaz.stream.Cause.EarlyCause =&gt; Unit" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.midStep">midStep</a>: EarlyCause =&gt; Unit,
                    <span class="comment">// task finished running, but we were *previously* interrupted</span>
                    <a title="(scalaz.stream.Process[scalaz.concurrent.Task,O], scalaz.stream.Cause.EarlyCause) =&gt; Unit" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.postStep">postStep</a>: <span class="delimiter">(</span>Process<span class="delimiter">[</span>Task, O<span class="delimiter">]</span>, EarlyCause<span class="delimiter">)</span> =&gt; Unit,
                    <span class="comment">// task finished with an error, but was not interrupted</span>
                    <a title="Throwable =&gt; Unit" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.exceptional">exceptional</a>: Throwable =&gt; Unit,
                    <span class="comment">// task finished with a value, no errors, no interrupts</span>
                    <a title="scalaz.stream.Process[scalaz.concurrent.Task,O] =&gt; Unit" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.completed">completed</a>: Process<span class="delimiter">[</span>Task, O<span class="delimiter">]</span> =&gt; Unit<span class="delimiter">)</span><span class="delimiter">(</span><span title="Option[scalaz.\/[Throwable,a]]">result</span>: <span title="Option[scalaz.\/[Throwable,a]]">Option</span><span class="delimiter">[</span>Throwable \/ a<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span title="Option[scalaz.\/[Throwable,a]]">result</span> match <span class="delimiter">{</span>

                  <span class="comment">// interrupted via the `Task.fail` defined in `checkInterrupt`</span>
                  case Some<span class="delimiter">(</span>-\/<span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go;PreStepAbort.readResolve" title="(x$0: PreStepAbort)Option[scalaz.stream.Cause.EarlyCause]">PreStepAbort</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">cause</span>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.preStep" title="(v1: scalaz.stream.Cause.EarlyCause)Unit">preStep</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">cause</span><span class="delimiter">)</span>

                  case <span title="Option[scalaz.\/[Throwable,a]]">result</span> =&gt; <span class="delimiter">{</span>
                    val <a title="Option[scalaz.stream.Cause.EarlyCause]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.inter">inter</a> = <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.interrupted" title="java.util.concurrent.atomic.AtomicReference[scalaz.\/[() =&gt; Unit,scalaz.stream.Cause.EarlyCause]]">interrupted</a>.<span title="()scalaz.\/[() =&gt; Unit,scalaz.stream.Cause.EarlyCause]">get</span><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="=&gt; Option[scalaz.stream.Cause.EarlyCause]">toOption</span>

                    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.inter" title="Option[scalaz.stream.Cause.EarlyCause]">inter</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <span title="Option[scalaz.\/[Throwable,a]]">result</span>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span>

                    <span class="comment">// interrupted via the callback mechanism, checked in `completeInterruptibly`</span>
                    <span class="comment">// always matches to a `None` (we don't have a value yet)</span>
                    <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.inter" title="Option[scalaz.stream.Cause.EarlyCause]">inter</a> <span title="(p: scalaz.stream.Cause.EarlyCause =&gt; Boolean)Option[scalaz.stream.Cause.EarlyCause]">filter</span> <span class="delimiter">{</span> <a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.$anonfun.x$48">_</a> =&gt; <span title="=&gt; Boolean">!</span><span title="Option[scalaz.\/[Throwable,a]]">result</span>.<span title="=&gt; Boolean">isDefined</span> <span class="delimiter">}</span> match <span class="delimiter">{</span>
                      case Some<span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">cause</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
                        if <span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.barrier" title="java.util.concurrent.atomic.AtomicBoolean">barrier</a>.<span title="(x$1: Boolean, x$2: Boolean)Boolean">compareAndSet</span><span class="delimiter">(</span>false, true<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                          <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.midStep" title="(v1: scalaz.stream.Cause.EarlyCause)Unit">midStep</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">cause</span><span class="delimiter">)</span>
                        <span class="delimiter">}</span> else <span class="delimiter">{</span>
                          <span class="comment">// task already completed *successfully*, pretend we weren't interrupted at all</span>
                          <span class="comment">// our *next* step (which is already running) will get a pre-step interrupt</span>
                          <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
                        <span class="delimiter">}</span>
                      <span class="delimiter">}</span>

                      case <span title="None.type">None</span> =&gt; <span class="delimiter">{</span>
                        <span class="comment">// completed the task, `interrupted.get()` is defined, and so we were interrupted post-completion</span>
                        <span class="comment">// always matches to a `Some` (we always have value)</span>
                        val <a title="Option[Unit]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.pc">pc</a> = for <span class="delimiter">{</span>
                          <a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.pc.$anonfun.cause">cause</a> &lt;- <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.inter" title="(f: scalaz.stream.Cause.EarlyCause =&gt; Option[Unit])Option[Unit]">inter</a>
                          <a title="scalaz.stream.Process[scalaz.concurrent.Task,O]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.pc.$anonfun.$anonfun.continuation">continuation</a> &lt;- <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.unpack" title="(msg: Option[scalaz.\/[Throwable,a]])Option[scalaz.stream.Process[scalaz.concurrent.Task,O]]">unpack</a><span title="(f: scalaz.stream.Process[scalaz.concurrent.Task,O] =&gt; Unit)Option[Unit]" class="delimiter">(</span><span title="Option[scalaz.\/[Throwable,a]]">result</span><span class="delimiter">)</span>
                        <span class="delimiter">}</span> yield <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.postStep" title="(v1: scalaz.stream.Process[scalaz.concurrent.Task,O], v2: scalaz.stream.Cause.EarlyCause)Unit">postStep</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.pc.$anonfun.$anonfun.continuation" title="scalaz.stream.Process[scalaz.concurrent.Task,O]">continuation</a>, <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.pc.$anonfun.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span>

                        <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.pc" title="Option[Unit]">pc</a> match <span class="delimiter">{</span>
                          case Some<span class="delimiter">(</span><a title="Unit" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.back">back</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.back" title="Unit">back</a>

                          case <span title="None.type">None</span> =&gt; <span class="delimiter">{</span>
                            if <span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.barrier" title="java.util.concurrent.atomic.AtomicBoolean">barrier</a>.<span title="(x$1: Boolean, x$2: Boolean)Boolean">compareAndSet</span><span class="delimiter">(</span>false, true<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                              <span title="Option[scalaz.\/[Throwable,a]]">result</span> match <span class="delimiter">{</span>
                                <span class="comment">// nominally completed the task, but with an exception</span>
                                case Some<span class="delimiter">(</span>-\/<span class="delimiter">(</span><a title="Throwable" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.t">t</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.exceptional" title="(v1: Throwable)Unit">exceptional</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.t" title="Throwable">t</a><span class="delimiter">)</span>

                                case <span title="Option[scalaz.\/[Throwable,a]]">result</span> =&gt; <span class="delimiter">{</span>
                                  <span class="comment">// completed the task, no interrupts, no exceptions, good to go!</span>
                                  <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.unpack" title="(msg: Option[scalaz.\/[Throwable,a]])Option[scalaz.stream.Process[scalaz.concurrent.Task,O]]">unpack</a><span class="delimiter">(</span><span title="Option[scalaz.\/[Throwable,a]]">result</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
                                    case Some<span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.concurrent.Task,O]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.head">head</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.completed" title="(v1: scalaz.stream.Process[scalaz.concurrent.Task,O])Unit">completed</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.head" title="scalaz.stream.Process[scalaz.concurrent.Task,O]">head</a> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.concurrent.Task[x],O])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,O]">cont</span><span class="delimiter">)</span>

                                    case <span title="None.type">None</span> =&gt; <span title="=&gt; Nothing">???</span>      <span class="comment">// didn't match any condition; fail! (probably a double-None bug in completeInterruptibly)</span>
                                  <span class="delimiter">}</span>
                                <span class="delimiter">}</span>
                              <span class="delimiter">}</span>
                            <span class="delimiter">}</span> else <span class="delimiter">{</span>
                              <span title="Option[scalaz.\/[Throwable,a]]">result</span> match <span class="delimiter">{</span>
                                case Some<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
                                  <span class="comment">// we detected mid-step interrupt; this needs to transmute to post-step; loop back to the top!</span>
                                  <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle" title="(preStep: scalaz.stream.Cause.EarlyCause =&gt; Unit, midStep: scalaz.stream.Cause.EarlyCause =&gt; Unit, postStep: (scalaz.stream.Process[scalaz.concurrent.Task,O], scalaz.stream.Cause.EarlyCause) =&gt; Unit, exceptional: Throwable =&gt; Unit, completed: scalaz.stream.Process[scalaz.concurrent.Task,O] =&gt; Unit)(result: Option[scalaz.\/[Throwable,a]])Unit">handle</a><span class="delimiter">(</span>preStep = <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.preStep" title="scalaz.stream.Cause.EarlyCause =&gt; Unit">preStep</a>, midStep = <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.midStep" title="scalaz.stream.Cause.EarlyCause =&gt; Unit">midStep</a>, postStep = <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.postStep" title="(scalaz.stream.Process[scalaz.concurrent.Task,O], scalaz.stream.Cause.EarlyCause) =&gt; Unit">postStep</a>, exceptional = <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.exceptional" title="Throwable =&gt; Unit">exceptional</a>, completed = <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle.completed" title="scalaz.stream.Process[scalaz.concurrent.Task,O] =&gt; Unit">completed</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="Option[scalaz.\/[Throwable,a]]">result</span><span class="delimiter">)</span>

                                case <span title="None.type">None</span> =&gt; <span title="=&gt; Nothing">???</span>        <span class="comment">// wtf?! (apparently we were called twice with None; bug in completeInterruptibly)</span>
                              <span class="delimiter">}</span>
                            <span class="delimiter">}</span>
                          <span class="delimiter">}</span>
                        <span class="delimiter">}</span>
                      <span class="delimiter">}</span>
                    <span class="delimiter">}</span>
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span>

                <span class="comment">/*
                 * Start the task. per the `completeInterruptibly` invariants, the callback will be invoked exactly once
                 * unless interrupted in the final computation step, in which case it will be invoked twice: once with
                 * the interrupt signal and once with the final computed result (this case is detected by the `PostStep`)
                 * extractor.  Under all other circumstances, including interrupts, exceptions and natural completion, the
                 * callback will be invoked exactly once.
                 */</span>
                lazy val <a title="() =&gt; Unit" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.interrupt">interrupt</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Unit = <a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly" title="(f: scalaz.concurrent.Future[scalaz.\/[Throwable,a]])(cb: Option[scalaz.\/[Throwable,a]] =&gt; Unit)(implicit S: scalaz.concurrent.Strategy)() =&gt; Unit">completeInterruptibly</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.checkInterrupt" title="(int: =&gt; () =&gt; Unit)scalaz.concurrent.Task[Unit]">checkInterrupt</a><span title="(v: scalaz.concurrent.Task[Unit])(implicit F0: scalaz.Bind[scalaz.concurrent.Task])scalaz.syntax.BindOps[scalaz.concurrent.Task,Unit]" class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.interrupt" title="=&gt; () =&gt; Unit">interrupt</a><span class="delimiter">)</span> <span title="(b: =&gt; scalaz.concurrent.Task[a])scalaz.concurrent.Task[a]">&gt;&gt;</span> <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.req" title="scalaz.concurrent.Task[a]">req</a><span class="delimiter">)</span>.<span title="=&gt; scalaz.concurrent.Future[scalaz.\/[Throwable,a]]">get</span><span class="delimiter">)</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.S" title="scalaz.concurrent.Strategy" class="delimiter">(</a><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.handle" title="(preStep: scalaz.stream.Cause.EarlyCause =&gt; Unit, midStep: scalaz.stream.Cause.EarlyCause =&gt; Unit, postStep: (scalaz.stream.Process[scalaz.concurrent.Task,O], scalaz.stream.Cause.EarlyCause) =&gt; Unit, exceptional: Throwable =&gt; Unit, completed: scalaz.stream.Process[scalaz.concurrent.Task,O] =&gt; Unit)(result: Option[scalaz.\/[Throwable,a]])Unit">handle</a><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.interrupt.$anonfun.result" title="Option[scalaz.\/[Throwable,a]]" class="delimiter">(</a>
                  preStep = <span class="delimiter">{</span> <span title="scalaz.stream.Cause.EarlyCause">cause</span> =&gt;
                    <span class="comment">// interrupted; now drain</span>
                    <span class="delimiter">(</span><a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[scalaz.concurrent.Task,O])scalaz.stream.Process[scalaz.concurrent.Task,O]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.rcv" title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,a])scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,O]]">rcv</a><span class="delimiter">(</span><span title="(a: scalaz.stream.Cause.EarlyCause)scalaz.-\/[scalaz.stream.Cause.EarlyCause]">-\/</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">cause</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Process[scalaz.concurrent.Task,O]],scalaz.Free.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,O]]])scalaz.stream.Process[scalaz.concurrent.Task,O]">run</span><span class="delimiter">)</span> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.concurrent.Task[x],O])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,O]">cont</span><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.drain" title="=&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],Nothing]">drain</a>.<a href="#scalaz.stream;Process.run" title="(implicit F: scalaz.Monad[[x]scalaz.concurrent.Task[x]], implicit C: scalaz.Catchable[[x]scalaz.concurrent.Task[x]])scalaz.concurrent.Task[Unit]">run</a> <span title="(f: scalaz.\/[Throwable,Unit] =&gt; Unit)Unit">runAsync</span> <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.interrupt.$anonfun.$anonfun.x0$17" title="Unit" class="delimiter">{</a>
                      case -\/<span class="delimiter">(</span><span title="Throwable">t</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a> <span title="Unit" class="delimiter">{</span> <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.cb" title="(v1: scalaz.\/[scalaz.stream.Cause,(Seq[O], scalaz.stream.Process.Cont[scalaz.concurrent.Task,O])])Unit">cb</a><span class="delimiter">(</span><span title="(a: scalaz.stream.Cause)scalaz.-\/[scalaz.stream.Cause]">-\/</span><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause;Error" title="(rsn: Throwable)scalaz.stream.Cause.Error">Error</a><span class="delimiter">(</span><span title="Throwable">t</span><span class="delimiter">)</span> <a href="Cause.scala.html#scalaz.stream;Cause.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Cause">causedBy</a> <span title="scalaz.stream.Cause.EarlyCause">cause</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
                      case \/-<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a> <span title="Unit" class="delimiter">{</span> <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.cb" title="(v1: scalaz.\/[scalaz.stream.Cause,(Seq[O], scalaz.stream.Process.Cont[scalaz.concurrent.Task,O])])Unit">cb</a><span class="delimiter">(</span><span title="(a: scalaz.stream.Cause.EarlyCause)scalaz.-\/[scalaz.stream.Cause.EarlyCause]">-\/</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">cause</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
                    <span class="delimiter">}</span>
                  <span class="delimiter">}</span>,

                  midStep = <span class="delimiter">{</span> <span title="scalaz.stream.Cause.EarlyCause">cause</span> =&gt;
                    <span class="comment">// interrupted; now drain</span>
                    <span class="delimiter">(</span><a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[scalaz.concurrent.Task,O])scalaz.stream.Process[scalaz.concurrent.Task,O]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.rcv" title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,a])scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,O]]">rcv</a><span class="delimiter">(</span><span title="(a: scalaz.stream.Cause.EarlyCause)scalaz.-\/[scalaz.stream.Cause.EarlyCause]">-\/</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">cause</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Process[scalaz.concurrent.Task,O]],scalaz.Free.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,O]]])scalaz.stream.Process[scalaz.concurrent.Task,O]">run</span><span class="delimiter">)</span> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.concurrent.Task[x],O])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,O]">cont</span><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.drain" title="=&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],Nothing]">drain</a>.<a href="#scalaz.stream;Process.run" title="(implicit F: scalaz.Monad[[x]scalaz.concurrent.Task[x]], implicit C: scalaz.Catchable[[x]scalaz.concurrent.Task[x]])scalaz.concurrent.Task[Unit]">run</a> <span title="(f: scalaz.\/[Throwable,Unit] =&gt; Unit)Unit">runAsync</span> <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.interrupt.$anonfun.$anonfun.x0$18" title="Unit" class="delimiter">{</a>
                      case -\/<span class="delimiter">(</span><span title="Throwable">t</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a> <span title="Unit" class="delimiter">{</span> <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.cb" title="(v1: scalaz.\/[scalaz.stream.Cause,(Seq[O], scalaz.stream.Process.Cont[scalaz.concurrent.Task,O])])Unit">cb</a><span class="delimiter">(</span><span title="(a: scalaz.stream.Cause)scalaz.-\/[scalaz.stream.Cause]">-\/</span><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause;Error" title="(rsn: Throwable)scalaz.stream.Cause.Error">Error</a><span class="delimiter">(</span><span title="Throwable">t</span><span class="delimiter">)</span> <a href="Cause.scala.html#scalaz.stream;Cause.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Cause">causedBy</a> <span title="scalaz.stream.Cause.EarlyCause">cause</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
                      case \/-<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a> <span title="Unit" class="delimiter">{</span> <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.cb" title="(v1: scalaz.\/[scalaz.stream.Cause,(Seq[O], scalaz.stream.Process.Cont[scalaz.concurrent.Task,O])])Unit">cb</a><span class="delimiter">(</span><span title="(a: scalaz.stream.Cause.EarlyCause)scalaz.-\/[scalaz.stream.Cause.EarlyCause]">-\/</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">cause</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
                    <span class="delimiter">}</span>
                  <span class="delimiter">}</span>,

                  postStep = <span class="delimiter">{</span> <span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.concurrent.Task,O]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.interrupt.$anonfun.inner">inner</a>, <span title="scalaz.stream.Cause.EarlyCause">cause</span><span class="delimiter">)</span> =&gt;
                    <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.interrupt.$anonfun.inner" title="scalaz.stream.Process[scalaz.concurrent.Task,O]">inner</a>.<a href="#scalaz.stream;Process.kill" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,Nothing]">kill</a>.<a href="#scalaz.stream;Process.run" title="(implicit F: scalaz.Monad[[x]scalaz.concurrent.Task[x]], implicit C: scalaz.Catchable[[x]scalaz.concurrent.Task[x]])scalaz.concurrent.Task[Unit]">run</a> <span title="(f: scalaz.\/[Throwable,Unit] =&gt; Unit)Unit">runAsync</span> <span class="delimiter">{</span> <a title="scalaz.\/[Throwable,Unit]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.interrupt.$anonfun.$anonfun.x$52">_</a> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>
                  <span class="delimiter">}</span>,

                  exceptional = <span class="delimiter">{</span> <a title="Throwable" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.interrupt.$anonfun.t">t</a> =&gt;
                    <span class="comment">// we got an exception (not an interrupt!) and we need to drain everything</span>
                    <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go" title="(p: scalaz.stream.Process[scalaz.concurrent.Task,O])scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]">go</a><span class="delimiter">(</span><a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[scalaz.concurrent.Task,O])scalaz.stream.Process[scalaz.concurrent.Task,O]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.rcv" title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,a])scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,O]]">rcv</a><span class="delimiter">(</span><span title="(a: scalaz.stream.Cause.Error)scalaz.-\/[scalaz.stream.Cause.Error]">-\/</span><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause;Error" title="(rsn: Throwable)scalaz.stream.Cause.Error">Error</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.interrupt.$anonfun.t" title="Throwable">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Process[scalaz.concurrent.Task,O]],scalaz.Free.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,O]]])scalaz.stream.Process[scalaz.concurrent.Task,O]">run</span><span class="delimiter">)</span> <a href="#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.concurrent.Task[x],O])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,O]">cont</span><span class="delimiter">)</span> <span title="(f: scalaz.\/[Throwable,scalaz.stream.Cause.EarlyCause =&gt; Unit] =&gt; Unit)Unit">runAsync</span> <span class="delimiter">{</span> <a title="scalaz.\/[Throwable,scalaz.stream.Cause.EarlyCause =&gt; Unit]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.interrupt.$anonfun.$anonfun.x$54">_</a> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>
                  <span class="delimiter">}</span>,

                  completed = <span class="delimiter">{</span> <a title="scalaz.stream.Process[scalaz.concurrent.Task,O]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.interrupt.$anonfun.continuation">continuation</a> =&gt;
                    <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go" title="(p: scalaz.stream.Process[scalaz.concurrent.Task,O])scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.interrupt.$anonfun.continuation" title="scalaz.stream.Process[scalaz.concurrent.Task,O]">continuation</a><span class="delimiter">)</span> <span title="(f: scalaz.\/[Throwable,scalaz.stream.Cause.EarlyCause =&gt; Unit] =&gt; Unit)Unit">runAsync</span> <span class="delimiter">{</span> <a title="scalaz.\/[Throwable,scalaz.stream.Cause.EarlyCause =&gt; Unit]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.interrupt.$anonfun.$anonfun.x$55">_</a> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>
                  <span class="delimiter">}</span>
                <span class="delimiter">)</span><span class="delimiter">)</span>

                <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.interrupt" title="=&gt; () =&gt; Unit">interrupt</a>     <span class="comment">// please don't delete this!  highly mutable code within</span>

                <span class="comment">// interrupts the current step (may be a recursive child!) and sets `interrupted`</span>
                def <a title="(cause: scalaz.stream.Cause.EarlyCause)Unit" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.referencedInterrupt">referencedInterrupt</a><span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.referencedInterrupt.cause">cause</a>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
                  <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.interrupted" title="java.util.concurrent.atomic.AtomicReference[scalaz.\/[() =&gt; Unit,scalaz.stream.Cause.EarlyCause]]">interrupted</a>.<span title="()scalaz.\/[() =&gt; Unit,scalaz.stream.Cause.EarlyCause]">get</span><span class="delimiter">(</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
                    case <a title="scalaz.-\/[() =&gt; Unit]" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.referencedInterrupt.ptr">ptr</a> @ -\/<span class="delimiter">(</span><a title="() =&gt; Unit" id="scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.referencedInterrupt.int">int</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
                      if <span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.interrupted" title="java.util.concurrent.atomic.AtomicReference[scalaz.\/[() =&gt; Unit,scalaz.stream.Cause.EarlyCause]]">interrupted</a>.<span title="(x$1: scalaz.\/[() =&gt; Unit,scalaz.stream.Cause.EarlyCause], x$2: scalaz.\/[() =&gt; Unit,scalaz.stream.Cause.EarlyCause])Boolean">compareAndSet</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.referencedInterrupt.ptr" title="scalaz.-\/[() =&gt; Unit]">ptr</a>, <span title="(b: scalaz.stream.Cause.EarlyCause)scalaz.\/-[scalaz.stream.Cause.EarlyCause]">\/-</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.referencedInterrupt.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                        <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.referencedInterrupt.int" title="()Unit">int</a><span class="delimiter">(</span><span class="delimiter">)</span>
                      <span class="delimiter">}</span> else <span class="delimiter">{</span>
                        <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.referencedInterrupt" title="(cause: scalaz.stream.Cause.EarlyCause)Unit">referencedInterrupt</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.referencedInterrupt.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span>
                      <span class="delimiter">}</span>
                    <span class="delimiter">}</span>

                    case \/-<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>    <span class="comment">// interrupted a second (or more) time; discard later causes and keep the first one</span>
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span>

                <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go.referencedInterrupt" title="(cause: scalaz.stream.Cause.EarlyCause)Unit">referencedInterrupt</a> _
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span> <span title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit],scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]])scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]">join</span>

        <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps.go" title="(p: scalaz.stream.Process[scalaz.concurrent.Task,O])scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]">go</a> _
      <span class="delimiter">}</span>

      <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.allSteps" title="scalaz.concurrent.Task[scalaz.stream.Process[scalaz.concurrent.Task,O] =&gt; scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]]">allSteps</a> <span title="(f: (scalaz.stream.Process[scalaz.concurrent.Task,O] =&gt; scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]) =&gt; scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit])scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]">flatMap</span> <span class="delimiter">{</span> <a href="#scalaz.stream.Process;SourceSyntax.stepAsync.$anonfun.x$56" title="(v1: scalaz.stream.Process[scalaz.concurrent.Task,O])scalaz.concurrent.Task[scalaz.stream.Cause.EarlyCause =&gt; Unit]">_</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.SourceSyntax.self" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,O]">self</a><span class="delimiter">)</span> <span class="delimiter">}</span> <span title="=&gt; scalaz.stream.Cause.EarlyCause =&gt; Unit">run</span>   <span class="comment">// hey, we could totally return something sane here! what up?</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Analogous to Future#listenInterruptibly, but guarantees listener notification provided that the
     * body of any given computation step does not block indefinitely.  When the interrupt function is
     * invoked, the callback will be immediately invoked, either with an available completion value or
     * with None.  If the current step of the task ultimately completes with its *final* value (i.e.
     * the final step of the task is an Async and it starts before the interrupt and completes *afterwards*),
     * that value will be passed to the callback as a second return.  Thus, the callback will always be
     * invoked at least once, and may be invoked twice.  If it is invoked twice, the first callback
     * will always be None while the second will be Some.
     *
     *
     */</span>
    private def <a title="[A](f: scalaz.concurrent.Future[A])(cb: Option[A] =&gt; Unit)(implicit S: scalaz.concurrent.Strategy)() =&gt; Unit" id="scalaz.stream.Process;SourceSyntax.completeInterruptibly">completeInterruptibly</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;SourceSyntax.completeInterruptibly;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.concurrent.Future[A]" id="scalaz.stream.Process;SourceSyntax.completeInterruptibly.f">f</a>: <span title="scalaz.concurrent.Future[A]">Future</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Option[A] =&gt; Unit" id="scalaz.stream.Process;SourceSyntax.completeInterruptibly.cb">cb</a>: Option<span class="delimiter">[</span>A<span class="delimiter">]</span> =&gt; Unit<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream.Process;SourceSyntax.completeInterruptibly.S">S</a>: <span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Unit = <span class="delimiter">{</span>
      import <span title="scalaz.concurrent.Future.type">Future</span>._

      val <a title="java.util.concurrent.atomic.AtomicBoolean" id="scalaz.stream.Process;SourceSyntax.completeInterruptibly.cancel">cancel</a> = new <span title="java.util.concurrent.atomic.AtomicBoolean">AtomicBoolean</span><span class="delimiter">(</span>false<span class="delimiter">)</span>

      <span class="comment">// `cb` is run exactly once or twice</span>
      <span class="comment">// Case A) `cb` is run with `None` followed by `Some` if we were cancelled but still obtained a value.</span>
      <span class="comment">// Case B) `cb` is run with just `Some` if it's never cancelled.</span>
      <span class="comment">// Case C) `cb` is run with just `None` if it's cancelled before a value is even attempted.</span>
      <span class="comment">// Case D) the same as case A, but in the opposite order, only in very rare cases</span>
      lazy val <a title="scalaz.concurrent.Actor[Option[scalaz.concurrent.Future[A]]]" id="scalaz.stream.Process;SourceSyntax.completeInterruptibly.actor">actor</a>: <span title="scalaz.concurrent.Actor[Option[scalaz.concurrent.Future[A]]]">Actor</span><span class="delimiter">[</span>Option<span class="delimiter">[</span>Future<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = new <span title="scalaz.concurrent.Actor[Option[scalaz.concurrent.Future[A]]]">Actor</span><span class="delimiter">[</span>Option<span class="delimiter">[</span>Future<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.actor.$anonfun.x0$19" title="Unit" class="delimiter">{</a>
        <span class="comment">// pure cases</span>
        case Some<span class="delimiter">(</span>Suspend<span class="delimiter">(</span><span title="() =&gt; scalaz.concurrent.Future[A]">thunk</span><span class="delimiter">)</span><span class="delimiter">)</span> if <span title="=&gt; Boolean">!</span><a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.cancel" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a>.<span title="()Boolean">get</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.actor" title="=&gt; scalaz.concurrent.Actor[Option[scalaz.concurrent.Future[A]]]">actor</a> <span title="(a: Option[scalaz.concurrent.Future[A]])Unit">!</span> <span title="(x: scalaz.concurrent.Future[A])Some[scalaz.concurrent.Future[A]]">Some</span><span class="delimiter">(</span><span title="()scalaz.concurrent.Future[A]">thunk</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

        case Some<span class="delimiter">(</span>BindSuspend<span class="delimiter">(</span><span title="() =&gt; scalaz.concurrent.Future[Any]">thunk</span>, <span title="Any =&gt; scalaz.concurrent.Future[A]">g</span><span class="delimiter">)</span><span class="delimiter">)</span> if <span title="=&gt; Boolean">!</span><a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.cancel" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a>.<span title="()Boolean">get</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.actor" title="=&gt; scalaz.concurrent.Actor[Option[scalaz.concurrent.Future[A]]]">actor</a> <span title="(a: Option[scalaz.concurrent.Future[A]])Unit">!</span> <span title="(x: scalaz.concurrent.Future[A])Some[scalaz.concurrent.Future[A]]">Some</span><span class="delimiter">(</span><span title="()scalaz.concurrent.Future[Any]">thunk</span><span class="delimiter">(</span><span class="delimiter">)</span> <span title="(f: Any =&gt; scalaz.concurrent.Future[A])scalaz.concurrent.Future[A]">flatMap</span> <span title="Any =&gt; scalaz.concurrent.Future[A]">g</span><span class="delimiter">)</span>

        case Some<span class="delimiter">(</span>Now<span class="delimiter">(</span><a title="A" id="scalaz.stream.Process;SourceSyntax.completeInterruptibly.actor.$anonfun.a">a</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a> <span title="Unit" class="delimiter">{</span> <a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.cb" title="(v1: Option[A])Unit">cb</a><span class="delimiter">(</span><span title="(x: A)Some[A]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.actor.$anonfun.a" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>

        case Some<span class="delimiter">(</span>Async<span class="delimiter">(</span><span title="(A =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit">onFinish</span><span class="delimiter">)</span><span class="delimiter">)</span> if <span title="=&gt; Boolean">!</span><a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.cancel" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a>.<span title="()Boolean">get</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
          <span title="(v1: A =&gt; scalaz.Free.Trampoline[Unit])Unit">onFinish</span> <span class="delimiter">{</span> <span title="A">a</span> =&gt;
            <a href="#scalaz.stream.Process.Trampoline" title="=&gt; scalaz.Trampoline.type">Trampoline</a> <span title="(a: =&gt; Unit)scalaz.Free.Trampoline[Unit]">delay</span> <span class="delimiter">{</span> <a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a> <span title="Unit" class="delimiter">{</span> <a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.cb" title="(v1: Option[A])Unit">cb</a><span class="delimiter">(</span><span title="(x: A)Some[A]">Some</span><span class="delimiter">(</span><span title="A">a</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span> <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        case Some<span class="delimiter">(</span>BindAsync<span class="delimiter">(</span><span title="(Any =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit">onFinish</span>, <span title="Any =&gt; scalaz.concurrent.Future[A]">g</span><span class="delimiter">)</span><span class="delimiter">)</span> if <span title="=&gt; Boolean">!</span><a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.cancel" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a>.<span title="()Boolean">get</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
          <span title="(v1: Any =&gt; scalaz.Free.Trampoline[Unit])Unit">onFinish</span> <span class="delimiter">{</span> <span title="Any">a</span> =&gt;
            if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.cancel" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a>.<span title="()Boolean">get</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#scalaz.stream.Process.Trampoline" title="=&gt; scalaz.Trampoline.type">Trampoline</a> <span title="(a: =&gt; scalaz.concurrent.Future[A])scalaz.Free.Trampoline[scalaz.concurrent.Future[A]]">delay</span> <span class="delimiter">{</span> <span title="(v1: Any)scalaz.concurrent.Future[A]">g</span><span class="delimiter">(</span><span title="Any">a</span><span class="delimiter">)</span> <span class="delimiter">}</span> <span title="(f: scalaz.concurrent.Future[A] =&gt; Unit)scalaz.Free[Function0,Unit]">map</span> <span class="delimiter">{</span> <a title="scalaz.concurrent.Future[A]" id="scalaz.stream.Process;SourceSyntax.completeInterruptibly.actor.$anonfun.$anonfun.$anonfun.r">r</a> =&gt; <a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.actor" title="=&gt; scalaz.concurrent.Actor[Option[scalaz.concurrent.Future[A]]]">actor</a> <span title="(a: Option[scalaz.concurrent.Future[A]])Unit">!</span> <span title="(x: scalaz.concurrent.Future[A])Some[scalaz.concurrent.Future[A]]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.actor.$anonfun.$anonfun.$anonfun.r" title="scalaz.concurrent.Future[A]">r</a><span class="delimiter">)</span> <span class="delimiter">}</span>
            <span class="delimiter">}</span> else <span class="delimiter">{</span>
              <span class="comment">// here we drop `a` on the floor</span>
              <a href="#scalaz.stream.Process.Trampoline" title="=&gt; scalaz.Trampoline.type">Trampoline</a> <span title="(a: Unit)scalaz.Free.Trampoline[Unit]">done</span> <span class="delimiter">{</span> <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>  <span class="comment">// `cb` already run with `None`</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        <span class="comment">// fallthrough case where cancel.get() == true</span>
        case Some<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>  <span class="comment">// `cb` already run with `None`</span>

        case <span title="None.type">None</span> =&gt; <span class="delimiter">{</span>
          <a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.cancel" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a>.<span title="(x$1: Boolean)Unit">set</span><span class="delimiter">(</span>true<span class="delimiter">)</span>  <span class="comment">// the only place where `cancel` is set to `true`</span>
          <a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a> <span title="Unit" class="delimiter">{</span> <a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.cb" title="(v1: Option[A])Unit">cb</a><span class="delimiter">(</span><span title="None.type">None</span><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>

      <a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a> <span class="delimiter">{</span> <a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.actor" title="=&gt; scalaz.concurrent.Actor[Option[scalaz.concurrent.Future[A]]]">actor</a> <span title="(a: Option[scalaz.concurrent.Future[A]])Unit">!</span> <span title="(x: scalaz.concurrent.Future[A])Some[scalaz.concurrent.Future[A]]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.f" title="scalaz.concurrent.Future[A]">f</a><span class="delimiter">)</span> <span class="delimiter">}</span>

      <span class="delimiter">{</span> <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process;SourceSyntax.completeInterruptibly.actor" title="=&gt; scalaz.concurrent.Actor[Option[scalaz.concurrent.Future[A]]]">actor</a> <span title="(a: Option[scalaz.concurrent.Future[A]])Unit">!</span> <span title="None.type">None</span> <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class provides infix syntax specific to `Tee`. We put these here
   * rather than trying to cram them into `Process` itself using implicit
   * equality witnesses. This doesn't work out so well due to variance
   * issues.
   */</span>
  implicit class <a href="#scalaz.stream.Process.TeeSyntax(a723a9ee6d).self" title="class TeeSyntax[I, I2, O] extends AnyVal" id="scalaz.stream.Process.TeeSyntax(a723a9ee6d)">TeeSyntax</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.TeeSyntax(a723a9ee6d);I">I</a>,<a title="" id="scalaz.stream.Process.TeeSyntax(a723a9ee6d);I2">I2</a>,<a title="" id="scalaz.stream.Process.TeeSyntax(a723a9ee6d);O">O</a><span class="delimiter">]</span><a href="#scalaz.stream.Process.TeeSyntax(a723a9ee6d)" title="scalaz.stream.Process.TeeSyntax[I,I2,O]" class="delimiter">(</a>val <a title="scalaz.stream.Tee[I,I2,O]" id="scalaz.stream.Process.TeeSyntax(a723a9ee6d).self">self</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Tee[I,I2,O]">Tee</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scalaz.stream.Process.TeeSyntax(a723a9ee6d)" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>

    <span class="comment">/** Transform the left input to a `Tee`. */</span>
    def <a title="[I0](f: I0 =&gt; I)scalaz.stream.Tee[I0,I2,O]" id="scalaz.stream.Process;TeeSyntax.contramapL">contramapL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;TeeSyntax.contramapL;I0">I0</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I0 =&gt; I" id="scalaz.stream.Process;TeeSyntax.contramapL.f">f</a>: I0 =&gt; I<span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Tee[I0,I2,O]">Tee</a><span class="delimiter">[</span>I0,I2,O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.WyeSyntax(7c0aa99697)" title="(self: scalaz.stream.Wye[I,I2,O])scalaz.stream.Process.WyeSyntax[I,I2,O]">self</a>.<a href="#scalaz.stream.Process;WyeSyntax.contramapL_" title="(f: I0 =&gt; I)scalaz.stream.Wye[I0,I2,O]">contramapL_</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;TeeSyntax.contramapL.f" title="I0 =&gt; I">f</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scalaz.stream.Tee[I0,I2,O]" class="delimiter">[</span><a href="#scalaz.stream;Process" title="scalaz.stream.Tee[I0,I2,O]">Tee</a><span class="delimiter">[</span>I0,I2,O<span class="delimiter">]</span><span class="delimiter">]</span>

    <span class="comment">/** Transform the right input to a `Tee`. */</span>
    def <a title="[I3](f: I3 =&gt; I2)scalaz.stream.Tee[I,I3,O]" id="scalaz.stream.Process;TeeSyntax.contramapR">contramapR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;TeeSyntax.contramapR;I3">I3</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I3 =&gt; I2" id="scalaz.stream.Process;TeeSyntax.contramapR.f">f</a>: I3 =&gt; I2<span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Tee[I,I3,O]">Tee</a><span class="delimiter">[</span>I,I3,O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.WyeSyntax(7c0aa99697)" title="(self: scalaz.stream.Wye[I,I2,O])scalaz.stream.Process.WyeSyntax[I,I2,O]">self</a>.<a href="#scalaz.stream.Process;WyeSyntax.contramapR_" title="(f: I3 =&gt; I2)scalaz.stream.Wye[I,I3,O]">contramapR_</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;TeeSyntax.contramapR.f" title="I3 =&gt; I2">f</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scalaz.stream.Tee[I,I3,O]" class="delimiter">[</span><a href="#scalaz.stream;Process" title="scalaz.stream.Tee[I,I3,O]">Tee</a><span class="delimiter">[</span>I,I3,O<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>


  <span class="comment">/**
   * Infix syntax for working with `Writer[F,W,O]`. We call
   * the `W` parameter the 'write' side of the `Writer` and
   * `O` the 'output' side. Many method in this class end
   * with either `W` or `O`, depending on what side they
   * operate on.
   */</span>
  implicit class <a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5).self" title="class WriterSyntax[F[_], W, O] extends AnyVal" id="scalaz.stream.Process.WriterSyntax(9eeb057ad5)">WriterSyntax</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.WriterSyntax(9eeb057ad5);F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.WriterSyntax(9eeb057ad5);F;_">_</a><span class="delimiter">]</span>,<a title="" id="scalaz.stream.Process.WriterSyntax(9eeb057ad5);W">W</a>,<a title="" id="scalaz.stream.Process.WriterSyntax(9eeb057ad5);O">O</a><span class="delimiter">]</span><a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5)" title="scalaz.stream.Process.WriterSyntax[F,W,O]" class="delimiter">(</a>val <a title="scalaz.stream.Writer[F,W,O]" id="scalaz.stream.Process.WriterSyntax(9eeb057ad5).self">self</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Writer[F,W,O]">Writer</a><span class="delimiter">[</span>F,W,O<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5)" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>

    <span class="comment">/**
     * Observe the output side of this Writer` using the
     * given `Sink`, then discard it. Also see `observeW`.
     */</span>
    def <a title="(snk: scalaz.stream.Sink[F,O])scalaz.stream.Process[F,W]" id="scalaz.stream.Process;WriterSyntax.drainO">drainO</a><span class="delimiter">(</span><a title="scalaz.stream.Sink[F,O]" id="scalaz.stream.Process;WriterSyntax.drainO.snk">snk</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Sink[F,O]">Sink</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,W]">Process</a><span class="delimiter">[</span>F,W<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process;WriterSyntax.observeO" title="(snk: scalaz.stream.Sink[F,O])scalaz.stream.Writer[F,W,O]">observeO</a><a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5)" title="(self: scalaz.stream.Writer[F,W,O])scalaz.stream.Process.WriterSyntax[F,W,O]" class="delimiter">(</a><a href="#scalaz.stream.Process;WriterSyntax.drainO.snk" title="scalaz.stream.Sink[F,O]">snk</a><span class="delimiter">)</span>.<a href="#scalaz.stream.Process;WriterSyntax.stripO" title="=&gt; scalaz.stream.Process[F,W]">stripO</a>

    <span class="comment">/**
     * Observe the write side of this `Writer` using the
     * given `Sink`, then discard it. Also see `observeW`.
     */</span>
    def <a title="(snk: scalaz.stream.Sink[F,W])scalaz.stream.Process[F,O]" id="scalaz.stream.Process;WriterSyntax.drainW">drainW</a><span class="delimiter">(</span><a title="scalaz.stream.Sink[F,W]" id="scalaz.stream.Process;WriterSyntax.drainW.snk">snk</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Sink[F,W]">Sink</a><span class="delimiter">[</span>F,W<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process;WriterSyntax.observeW" title="(snk: scalaz.stream.Sink[F,W])scalaz.stream.Writer[F,W,O]">observeW</a><a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5)" title="(self: scalaz.stream.Writer[F,W,O])scalaz.stream.Process.WriterSyntax[F,W,O]" class="delimiter">(</a><a href="#scalaz.stream.Process;WriterSyntax.drainW.snk" title="scalaz.stream.Sink[F,W]">snk</a><span class="delimiter">)</span>.<a href="#scalaz.stream.Process;WriterSyntax.stripW" title="=&gt; scalaz.stream.Process[F,O]">stripW</a>

    def <a title="[F2[x] &gt;: F[x], W2 &gt;: W, B](f: O =&gt; scalaz.stream.Writer[F2,W2,B])scalaz.stream.Writer[F2,W2,B]" id="scalaz.stream.Process;WriterSyntax.flatMapO">flatMapO</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream.Process;WriterSyntax.flatMapO;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WriterSyntax.flatMapO;F2;x">x</a><span class="delimiter">]</span>&gt;:F<span class="delimiter">[</span>x<span class="delimiter">]</span>,<a title=" &gt;: W" id="scalaz.stream.Process;WriterSyntax.flatMapO;W2">W2</a>&gt;:W,<a title="" id="scalaz.stream.Process;WriterSyntax.flatMapO;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; scalaz.stream.Writer[F2,W2,B]" id="scalaz.stream.Process;WriterSyntax.flatMapO.f">f</a>: O =&gt; Writer<span class="delimiter">[</span>F2,W2,B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Writer[F2,W2,B]">Writer</a><span class="delimiter">[</span>F2,W2,B<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5).self" title="=&gt; scalaz.stream.Writer[F,W,O]">self</a>.<a href="#scalaz.stream;Process.flatMap" title="(f: scalaz.\/[W,O] =&gt; scalaz.stream.Process[F2,scalaz.\/[W2,B]])scalaz.stream.Process[F2,scalaz.\/[W2,B]]">flatMap</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.flatMapO.$anonfun.x$57" title="scalaz.\/[W,O]">_</a>.<span title="(l: W =&gt; scalaz.stream.Writer[F2,W2,B], r: O =&gt; scalaz.stream.Writer[F2,W2,B])scalaz.stream.Writer[F2,W2,B]">fold</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.emitW" title="(s: W)scalaz.stream.Process0[scalaz.\/[W,Nothing]]">emitW</a>, <a href="#scalaz.stream.Process;WriterSyntax.flatMapO.f" title="O =&gt; scalaz.stream.Writer[F2,W2,B]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">/** Transform the write side of this `Writer`. */</span>
    def <a title="[F2[x] &gt;: F[x], W2, O2 &gt;: O](f: W =&gt; scalaz.stream.Writer[F2,W2,O2])scalaz.stream.Writer[F2,W2,O2]" id="scalaz.stream.Process;WriterSyntax.flatMapW">flatMapW</a><span class="delimiter">[</span><a title="[x] &gt;: F[x]" id="scalaz.stream.Process;WriterSyntax.flatMapW;F2">F2</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WriterSyntax.flatMapW;F2;x">x</a><span class="delimiter">]</span>&gt;:F<span class="delimiter">[</span>x<span class="delimiter">]</span>,<a title="" id="scalaz.stream.Process;WriterSyntax.flatMapW;W2">W2</a>,<a title=" &gt;: O" id="scalaz.stream.Process;WriterSyntax.flatMapW;O2">O2</a>&gt;:O<span class="delimiter">]</span><span class="delimiter">(</span><a title="W =&gt; scalaz.stream.Writer[F2,W2,O2]" id="scalaz.stream.Process;WriterSyntax.flatMapW.f">f</a>: W =&gt; Writer<span class="delimiter">[</span>F2,W2,O2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Writer[F2,W2,O2]">Writer</a><span class="delimiter">[</span>F2,W2,O2<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5).self" title="=&gt; scalaz.stream.Writer[F,W,O]">self</a>.<a href="#scalaz.stream;Process.flatMap" title="(f: scalaz.\/[W,O] =&gt; scalaz.stream.Process[F2,scalaz.\/[W2,O2]])scalaz.stream.Process[F2,scalaz.\/[W2,O2]]">flatMap</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.flatMapW.$anonfun.x$58" title="scalaz.\/[W,O]">_</a>.<span title="(l: W =&gt; scalaz.stream.Writer[F2,W2,O2], r: O =&gt; scalaz.stream.Writer[F2,W2,O2])scalaz.stream.Writer[F2,W2,O2]">fold</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.flatMapW.f" title="W =&gt; scalaz.stream.Writer[F2,W2,O2]">f</a>, <a href="#scalaz.stream.Process.emitO" title="(o: O)scalaz.stream.Process0[scalaz.\/[Nothing,O]]">emitO</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">/** Map over the output side of this `Writer`. */</span>
    def <a title="[B](f: O =&gt; B)scalaz.stream.Writer[F,W,B]" id="scalaz.stream.Process;WriterSyntax.mapO">mapO</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WriterSyntax.mapO;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="O =&gt; B" id="scalaz.stream.Process;WriterSyntax.mapO.f">f</a>: O =&gt; B<span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Writer[F,W,B]">Writer</a><span class="delimiter">[</span>F,W,B<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5).self" title="=&gt; scalaz.stream.Writer[F,W,O]">self</a>.<a href="#scalaz.stream;Process.map" title="(f: scalaz.\/[W,O] =&gt; scalaz.\/[W,B])scalaz.stream.Process[F,scalaz.\/[W,B]]">map</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.mapO.$anonfun.x$59" title="scalaz.\/[W,O]">_</a>.<span title="(g: O =&gt; B)scalaz.\/[W,B]">map</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.mapO.f" title="O =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">/** Map over the write side of this `Writer`. */</span>
    def <a title="[W2](f: W =&gt; W2)scalaz.stream.Writer[F,W2,O]" id="scalaz.stream.Process;WriterSyntax.mapW">mapW</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WriterSyntax.mapW;W2">W2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="W =&gt; W2" id="scalaz.stream.Process;WriterSyntax.mapW.f">f</a>: W =&gt; W2<span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Writer[F,W2,O]">Writer</a><span class="delimiter">[</span>F,W2,O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5).self" title="=&gt; scalaz.stream.Writer[F,W,O]">self</a>.<a href="#scalaz.stream;Process.map" title="(f: scalaz.\/[W,O] =&gt; scalaz.\/[W2,O])scalaz.stream.Process[F,scalaz.\/[W2,O]]">map</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.mapW.$anonfun.x$60" title="scalaz.\/[W,O]">_</a>.<span title="(f: W =&gt; W2)scalaz.\/[W2,O]">leftMap</span><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.mapW.f" title="W =&gt; W2">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">/**
     * Observe the output side of this `Writer` using the
     * given `Sink`, keeping it available for subsequent
     * processing. Also see `drainO`.
     */</span>
    def <a title="(snk: scalaz.stream.Sink[F,O])scalaz.stream.Writer[F,W,O]" id="scalaz.stream.Process;WriterSyntax.observeO">observeO</a><span class="delimiter">(</span><a title="scalaz.stream.Sink[F,O]" id="scalaz.stream.Process;WriterSyntax.observeO.snk">snk</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Sink[F,O]">Sink</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Writer[F,W,O]">Writer</a><span class="delimiter">[</span>F,W,O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5).self" title="=&gt; scalaz.stream.Writer[F,W,O]">self</a>.<a href="#scalaz.stream;Process.map" title="(f: scalaz.\/[W,O] =&gt; scalaz.\/[O,W])scalaz.stream.Process[F,scalaz.\/[O,W]]">map</a><a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5)" title="(self: scalaz.stream.Writer[F,O,W])scalaz.stream.Process.WriterSyntax[F,O,W]" class="delimiter">(</a><a href="#scalaz.stream.Process;WriterSyntax.observeO.$anonfun.x$61" title="scalaz.\/[W,O]">_</a>.<span title="=&gt; scalaz.\/[O,W]">swap</span><span class="delimiter">)</span>.<a href="#scalaz.stream.Process;WriterSyntax.observeW" title="(snk: scalaz.stream.Sink[F,O])scalaz.stream.Writer[F,O,W]">observeW</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.observeO.snk" title="scalaz.stream.Sink[F,O]">snk</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.map" title="(f: scalaz.\/[O,W] =&gt; scalaz.\/[W,O])scalaz.stream.Process[F,scalaz.\/[W,O]]">map</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.observeO.$anonfun.x$62" title="scalaz.\/[O,W]">_</a>.<span title="=&gt; scalaz.\/[W,O]">swap</span><span class="delimiter">)</span>

    <span class="comment">/**
     * Observe the write side of this `Writer` using the
     * given `Sink`, keeping it available for subsequent
     * processing. Also see `drainW`.
     */</span>
    def <a title="(snk: scalaz.stream.Sink[F,W])scalaz.stream.Writer[F,W,O]" id="scalaz.stream.Process;WriterSyntax.observeW">observeW</a><span class="delimiter">(</span><a title="scalaz.stream.Sink[F,W]" id="scalaz.stream.Process;WriterSyntax.observeW.snk">snk</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Sink[F,W]">Sink</a><span class="delimiter">[</span>F,W<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Writer[F,W,O]">Writer</a><span class="delimiter">[</span>F,W,O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5).self" title="=&gt; scalaz.stream.Writer[F,W,O]">self</a>.<a href="tee.scala.html#scalaz.stream;TeeOps.zipWith" title="(p2: scalaz.stream.Process[[x]F[x],W =&gt; F[Unit]])(f: (scalaz.\/[W,O], W =&gt; F[Unit]) =&gt; scalaz.stream.Process[[x]F[x],scalaz.\/[W,O]])scalaz.stream.Process[[x]F[x],scalaz.stream.Process[[x]F[x],scalaz.\/[W,O]]]">zipWith</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.observeW.snk" title="scalaz.stream.Sink[F,W]">snk</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="scalaz.\/[W,O]" id="scalaz.stream.Process;WriterSyntax.observeW.$anonfun.a">a</a>,<a title="W =&gt; F[Unit]" id="scalaz.stream.Process;WriterSyntax.observeW.$anonfun.f">f</a><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.Process;WriterSyntax.observeW.$anonfun.a" title="scalaz.\/[W,O]">a</a>.<span title="(l: W =&gt; scalaz.stream.Process[[x]F[x],scalaz.\/[W,O]], r: O =&gt; scalaz.stream.Process[[x]F[x],scalaz.\/[W,O]])scalaz.stream.Process[[x]F[x],scalaz.\/[W,O]]">fold</span><span class="delimiter">(</span>
          <span class="delimiter">(</span>s: <a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5);W" title="W">W</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process.eval_" title="(f: F[Unit])scalaz.stream.Process[F,Nothing]">eval_</a> <span class="delimiter">{</span> <a href="#scalaz.stream.Process;WriterSyntax.observeW.$anonfun.f" title="(v1: W)F[Unit]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.observeW.$anonfun.$anonfun.s" title="W">s</a><span class="delimiter">)</span> <span class="delimiter">}</span> <a href="#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[[x]F[x],scalaz.\/[W,Nothing]])scalaz.stream.Process[[x]F[x],scalaz.\/[W,Nothing]]">++</a> <a href="#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="#scalaz.stream.Process.emitW" title="(s: W)scalaz.stream.Process0[scalaz.\/[W,Nothing]]">emitW</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.observeW.$anonfun.$anonfun.s" title="W">s</a><span class="delimiter">)</span>,
          <span class="delimiter">(</span>a: <a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5);O" title="O">O</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="#scalaz.stream.Process.emitO" title="(o: O)scalaz.stream.Process0[scalaz.\/[Nothing,O]]">emitO</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.observeW.$anonfun.$anonfun.a" title="O">a</a><span class="delimiter">)</span>
        <span class="delimiter">)</span>
      <span class="delimiter">)</span>.<a href="#scalaz.stream;Process.flatMap" title="(f: scalaz.stream.Process[[x]F[x],scalaz.\/[W,O]] =&gt; scalaz.stream.Process[[x]F[x],scalaz.\/[W,O]])scalaz.stream.Process[[x]F[x],scalaz.\/[W,O]]">flatMap</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.observeW.$anonfun.x" title="(x: scalaz.stream.Process[[x]F[x],scalaz.\/[W,O]])scalaz.stream.Process[[x]F[x],scalaz.\/[W,O]]">identity</a><span class="delimiter">)</span>

    <span class="comment">/** Pipe output side of this `Writer`  */</span>
    def <a title="[B](f: scalaz.stream.Process1[O,B])scalaz.stream.Writer[F,W,B]" id="scalaz.stream.Process;WriterSyntax.pipeO">pipeO</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WriterSyntax.pipeO;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[O,B]" id="scalaz.stream.Process;WriterSyntax.pipeO.f">f</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[O,B]">Process1</a><span class="delimiter">[</span>O,B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Writer[F,W,B]">Writer</a><span class="delimiter">[</span>F,W,B<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5).self" title="=&gt; scalaz.stream.Writer[F,W,O]">self</a>.<a href="#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[scalaz.\/[W,O],scalaz.\/[W,B]])scalaz.stream.Process[F,scalaz.\/[W,B]]">pipe</a><span class="delimiter">(</span><a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="process1.scala.html#scalaz.stream.process1.liftR" title="(p: scalaz.stream.Process1[O,B])scalaz.stream.Process1[scalaz.\/[W,O],scalaz.\/[W,B]]">liftR</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.pipeO.f" title="scalaz.stream.Process1[O,B]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">/** Pipe write side of this `Writer`  */</span>
    def <a title="[B](f: scalaz.stream.Process1[W,B])scalaz.stream.Writer[F,B,O]" id="scalaz.stream.Process;WriterSyntax.pipeW">pipeW</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WriterSyntax.pipeW;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[W,B]" id="scalaz.stream.Process;WriterSyntax.pipeW.f">f</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[W,B]">Process1</a><span class="delimiter">[</span>W,B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Writer[F,B,O]">Writer</a><span class="delimiter">[</span>F,B,O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5).self" title="=&gt; scalaz.stream.Writer[F,W,O]">self</a>.<a href="#scalaz.stream;Process.pipe" title="(p1: scalaz.stream.Process1[scalaz.\/[W,O],scalaz.\/[B,O]])scalaz.stream.Process[F,scalaz.\/[B,O]]">pipe</a><span class="delimiter">(</span><a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="process1.scala.html#scalaz.stream.process1.liftL" title="(p: scalaz.stream.Process1[W,B])scalaz.stream.Process1[scalaz.\/[W,O],scalaz.\/[B,O]]">liftL</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.pipeW.f" title="scalaz.stream.Process1[W,B]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">/** Remove the output side of this `Writer`. */</span>
    def <a title="=&gt; scalaz.stream.Process[F,W]" id="scalaz.stream.Process;WriterSyntax.stripO">stripO</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,W]">Process</a><span class="delimiter">[</span>F,W<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5).self" title="=&gt; scalaz.stream.Writer[F,W,O]">self</a>.<a href="#scalaz.stream;Process.flatMap" title="(f: scalaz.\/[W,O] =&gt; scalaz.stream.Process[[x]F[x],W])scalaz.stream.Process[[x]F[x],W]">flatMap</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.stripO.$anonfun.x$63" title="scalaz.\/[W,O]">_</a>.<span title="(l: W =&gt; scalaz.stream.Process0[W], r: O =&gt; scalaz.stream.Process0[W])scalaz.stream.Process0[W]">fold</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.emit" title="(o: W)scalaz.stream.Process0[W]">emit</a>, <a title="O" id="scalaz.stream.Process;WriterSyntax.stripO.$anonfun.$anonfun.x$64">_</a> =&gt; <a href="#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">/** Remove the write side of this `Writer`. */</span>
    def <a title="=&gt; scalaz.stream.Process[F,O]" id="scalaz.stream.Process;WriterSyntax.stripW">stripW</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.WriterSyntax(9eeb057ad5).self" title="=&gt; scalaz.stream.Writer[F,W,O]">self</a>.<a href="#scalaz.stream;Process.flatMap" title="(f: scalaz.\/[W,O] =&gt; scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">flatMap</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WriterSyntax.stripW.$anonfun.x$65" title="scalaz.\/[W,O]">_</a>.<span title="(l: W =&gt; scalaz.stream.Process0[O], r: O =&gt; scalaz.stream.Process0[O])scalaz.stream.Process0[O]">fold</span><span class="delimiter">(</span><a title="W" id="scalaz.stream.Process;WriterSyntax.stripW.$anonfun.$anonfun.x$66">_</a> =&gt; <a href="#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>, <a href="#scalaz.stream.Process.emit" title="(o: O)scalaz.stream.Process0[O]">emit</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>


  <span class="comment">/**
   * This class provides infix syntax specific to `Wye`. We put these here
   * rather than trying to cram them into `Process` itself using implicit
   * equality witnesses. This doesn't work out so well due to variance
   * issues.
   */</span>
  implicit class <a href="#scalaz.stream.Process.WyeSyntax(7c0aa99697).self" title="class WyeSyntax[I, I2, O] extends AnyVal" id="scalaz.stream.Process.WyeSyntax(7c0aa99697)">WyeSyntax</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.WyeSyntax(7c0aa99697);I">I</a>,<a title="" id="scalaz.stream.Process.WyeSyntax(7c0aa99697);I2">I2</a>,<a title="" id="scalaz.stream.Process.WyeSyntax(7c0aa99697);O">O</a><span class="delimiter">]</span><a href="#scalaz.stream.Process.WyeSyntax(7c0aa99697)" title="scalaz.stream.Process.WyeSyntax[I,I2,O]" class="delimiter">(</a>val <a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.Process.WyeSyntax(7c0aa99697).self">self</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scalaz.stream.Process.WyeSyntax(7c0aa99697)" title="AnyVal">AnyVal</a> <span class="delimiter">{</span>

    <span class="comment">/**
     * Apply a `Wye` to two `Iterable` inputs.
     */</span>
    def <a title="(input: Iterable[I], input2: Iterable[I2])IndexedSeq[O]" id="scalaz.stream.Process;WyeSyntax.apply">apply</a><span class="delimiter">(</span><a title="Iterable[I]" id="scalaz.stream.Process;WyeSyntax.apply.input">input</a>: <span title="Iterable[I]">Iterable</span><span class="delimiter">[</span>I<span class="delimiter">]</span>, <a title="Iterable[I2]" id="scalaz.stream.Process;WyeSyntax.apply.input2">input2</a>: <span title="Iterable[I2]">Iterable</span><span class="delimiter">[</span>I2<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="IndexedSeq[O]">IndexedSeq</span><span class="delimiter">[</span>O<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="comment">// this is probably rather slow</span>
      val <a title="scalaz.stream.Process[scalaz.concurrent.Task,I]" id="scalaz.stream.Process;WyeSyntax.apply.src1">src1</a> = <a href="#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="#scalaz.stream.Process.emitAll" title="(os: Seq[I])scalaz.stream.Process0[I]">emitAll</a><a href="#scalaz.stream.Process.Process0Syntax(0cbdd80600)" title="(self: scalaz.stream.Process0[I])scalaz.stream.Process.Process0Syntax[I]" class="delimiter">(</a><a href="#scalaz.stream.Process;WyeSyntax.apply.input" title="Iterable[I]">input</a>.<span title="=&gt; Seq[I]">toSeq</span><span class="delimiter">)</span>.<a href="#scalaz.stream.Process;Process0Syntax.toSource" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,I]">toSource</a>
      val <a title="scalaz.stream.Process[scalaz.concurrent.Task,I2]" id="scalaz.stream.Process;WyeSyntax.apply.src2">src2</a> = <a href="#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="#scalaz.stream.Process.emitAll" title="(os: Seq[I2])scalaz.stream.Process0[I2]">emitAll</a><a href="#scalaz.stream.Process.Process0Syntax(0cbdd80600)" title="(self: scalaz.stream.Process0[I2])scalaz.stream.Process.Process0Syntax[I2]" class="delimiter">(</a><a href="#scalaz.stream.Process;WyeSyntax.apply.input2" title="Iterable[I2]">input2</a>.<span title="=&gt; Seq[I2]">toSeq</span><span class="delimiter">)</span>.<a href="#scalaz.stream.Process;Process0Syntax.toSource" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,I2]">toSource</a>
      <a href="#scalaz.stream.Process.SourceSyntax" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,I])scalaz.stream.Process.SourceSyntax[I]">src1</a>.<a href="wye.scala.html#scalaz.stream;WyeOps.wye" title="(p2: scalaz.stream.Process[scalaz.concurrent.Task,I2])(y: scalaz.stream.Wye[I,I2,O])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,O]">wye</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WyeSyntax.apply.src2" title="scalaz.stream.Process[scalaz.concurrent.Task,I2]">src2</a><span class="delimiter">)</span><span title="=&gt; scalaz.concurrent.Strategy" class="delimiter">(</span><a href="#scalaz.stream.Process.WyeSyntax(7c0aa99697).self" title="=&gt; scalaz.stream.Wye[I,I2,O]">self</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.runLog" title="(implicit F: scalaz.Monad[[x]scalaz.concurrent.Task[x]], implicit C: scalaz.Catchable[[x]scalaz.concurrent.Task[x]])scalaz.concurrent.Task[IndexedSeq[O]]">runLog</a>.<span title="=&gt; IndexedSeq[O]">run</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Transform the left input of the given `Wye` using a `Process1`.
     */</span>
    def <a title="[I0](f: scalaz.stream.Process1[I0,I])scalaz.stream.Wye[I0,I2,O]" id="scalaz.stream.Process;WyeSyntax.attachL">attachL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WyeSyntax.attachL;I0">I0</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[I0,I]" id="scalaz.stream.Process;WyeSyntax.attachL.f">f</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[I0,I]">Process1</a><span class="delimiter">[</span>I0,I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Wye[I0,I2,O]">Wye</a><span class="delimiter">[</span>I0, I2, O<span class="delimiter">]</span> =
      scalaz.stream.<a href="wye.scala.html#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="wye.scala.html#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[I0,I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I0,I2,O]">attachL</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WyeSyntax.attachL.f" title="scalaz.stream.Process1[I0,I]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.WyeSyntax(7c0aa99697).self" title="=&gt; scalaz.stream.Wye[I,I2,O]">self</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Transform the right input of the given `Wye` using a `Process1`.
     */</span>
    def <a title="[I1](f: scalaz.stream.Process1[I1,I2])scalaz.stream.Wye[I,I1,O]" id="scalaz.stream.Process;WyeSyntax.attachR">attachR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WyeSyntax.attachR;I1">I1</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[I1,I2]" id="scalaz.stream.Process;WyeSyntax.attachR.f">f</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process1[I1,I2]">Process1</a><span class="delimiter">[</span>I1,I2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Wye[I,I1,O]">Wye</a><span class="delimiter">[</span>I, I1, O<span class="delimiter">]</span> =
     scalaz.stream.<a href="wye.scala.html#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="wye.scala.html#scalaz.stream.wye.attachR" title="(p: scalaz.stream.Process1[I1,I2])(w: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I1,O]">attachR</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WyeSyntax.attachR.f" title="scalaz.stream.Process1[I1,I2]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.WyeSyntax(7c0aa99697).self" title="=&gt; scalaz.stream.Wye[I,I2,O]">self</a><span class="delimiter">)</span>

    <span class="comment">/** Transform the left input to a `Wye`. */</span>
    def <a title="[I0](f: I0 =&gt; I)scalaz.stream.Wye[I0,I2,O]" id="scalaz.stream.Process;WyeSyntax.contramapL">contramapL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WyeSyntax.contramapL;I0">I0</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I0 =&gt; I" id="scalaz.stream.Process;WyeSyntax.contramapL.f">f</a>: I0 =&gt; I<span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Wye[I0,I2,O]">Wye</a><span class="delimiter">[</span>I0, I2, O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process;WyeSyntax.contramapL_" title="(f: I0 =&gt; I)scalaz.stream.Wye[I0,I2,O]">contramapL_</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WyeSyntax.contramapL.f" title="I0 =&gt; I">f</a><span class="delimiter">)</span>

    <span class="comment">/** Transform the right input to a `Wye`. */</span>
    def <a title="[I3](f: I3 =&gt; I2)scalaz.stream.Wye[I,I3,O]" id="scalaz.stream.Process;WyeSyntax.contramapR">contramapR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WyeSyntax.contramapR;I3">I3</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I3 =&gt; I2" id="scalaz.stream.Process;WyeSyntax.contramapR.f">f</a>: I3 =&gt; I2<span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Wye[I,I3,O]">Wye</a><span class="delimiter">[</span>I, I3, O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process;WyeSyntax.contramapR_" title="(f: I3 =&gt; I2)scalaz.stream.Wye[I,I3,O]">contramapR_</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WyeSyntax.contramapR.f" title="I3 =&gt; I2">f</a><span class="delimiter">)</span>

    private<span class="delimiter">[</span>stream<span class="delimiter">]</span> def <a title="[I0](f: I0 =&gt; I)scalaz.stream.Wye[I0,I2,O]" id="scalaz.stream.Process;WyeSyntax.contramapL_">contramapL_</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WyeSyntax.contramapL_;I0">I0</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I0 =&gt; I" id="scalaz.stream.Process;WyeSyntax.contramapL_.f">f</a>: I0 =&gt; I<span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Wye[I0,I2,O]">Wye</a><span class="delimiter">[</span>I0, I2, O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.WyeSyntax(7c0aa99697)" title="(self: scalaz.stream.Wye[I,I2,O])scalaz.stream.Process.WyeSyntax[I,I2,O]">self</a>.<a href="#scalaz.stream.Process;WyeSyntax.attachL" title="(f: scalaz.stream.Process1[I0,I])scalaz.stream.Wye[I0,I2,O]">attachL</a><span class="delimiter">(</span><a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="process1.scala.html#scalaz.stream.process1.lift" title="(f: I0 =&gt; I)scalaz.stream.Process1[I0,I]">lift</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WyeSyntax.contramapL_.f" title="I0 =&gt; I">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

    private<span class="delimiter">[</span>stream<span class="delimiter">]</span> def <a title="[I3](f: I3 =&gt; I2)scalaz.stream.Wye[I,I3,O]" id="scalaz.stream.Process;WyeSyntax.contramapR_">contramapR_</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process;WyeSyntax.contramapR_;I3">I3</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I3 =&gt; I2" id="scalaz.stream.Process;WyeSyntax.contramapR_.f">f</a>: I3 =&gt; I2<span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Wye[I,I3,O]">Wye</a><span class="delimiter">[</span>I, I3, O<span class="delimiter">]</span> =
      <a href="#scalaz.stream.Process.WyeSyntax(7c0aa99697)" title="(self: scalaz.stream.Wye[I,I2,O])scalaz.stream.Process.WyeSyntax[I,I2,O]">self</a>.<a href="#scalaz.stream.Process;WyeSyntax.attachR" title="(f: scalaz.stream.Process1[I3,I2])scalaz.stream.Wye[I,I3,O]">attachR</a><span class="delimiter">(</span><a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.<a href="process1.scala.html#scalaz.stream.process1.lift" title="(f: I3 =&gt; I2)scalaz.stream.Process1[I3,I2]">lift</a><span class="delimiter">(</span><a href="#scalaz.stream.Process;WyeSyntax.contramapR_.f" title="I3 =&gt; I2">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">/**
     * Converting requests for the left input into normal termination.
     * Note that `Both` requests are rewritten to fetch from the only input.
     */</span>
    def <a title="=&gt; scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.Process;WyeSyntax.detach1L">detach1L</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> =   scalaz.stream.<a href="wye.scala.html#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="wye.scala.html#scalaz.stream.wye.detach1L" title="(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">detach1L</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.WyeSyntax(7c0aa99697).self" title="=&gt; scalaz.stream.Wye[I,I2,O]">self</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Converting requests for the left input into normal termination.
     * Note that `Both` requests are rewritten to fetch from the only input.
     */</span>
    def <a title="=&gt; scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.Process;WyeSyntax.detach1R">detach1R</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> = scalaz.stream.<a href="wye.scala.html#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="wye.scala.html#scalaz.stream.wye.detach1R" title="(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">detach1R</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.WyeSyntax(7c0aa99697).self" title="=&gt; scalaz.stream.Wye[I,I2,O]">self</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">//////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="comment">//</span>
  <span class="comment">// SYNTAX Functions</span>
  <span class="comment">//</span>
  <span class="comment">/////////////////////////////////////////////////////////////////////////////////////</span>

  <span class="comment">/**
   * Evaluate an arbitrary effect in a `Process`. The resulting
   * `Process` emits a single value. To evaluate repeatedly, use
   * `repeatEval(t)`.
   * Do not use `eval.repeat` or  `repeat(eval)` as that may cause infinite loop in certain situations.
   */</span>
  def <a title="[F[_], O](f: F[O])scalaz.stream.Process[F,O]" id="scalaz.stream.Process.eval">eval</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.eval;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.eval;F;_">_</a><span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process.eval;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[O]" id="scalaz.stream.Process.eval.f">f</a>: <a href="#scalaz.stream.Process.eval;F" title="F[O]">F</a><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.awaitOr" title="(req: F[O])(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[F,O])(rcv: O =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">awaitOr</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.eval.f" title="F[O]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.eval.$anonfun.x$67" title="scalaz.stream.Cause.EarlyCause">_</a>.<a href="Cause.scala.html#scalaz.stream;Cause.asHalt" title="=&gt; scalaz.stream.Process.Halt">asHalt</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.emit" title="(o: O)scalaz.stream.Process0[O]">emit</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Evaluate an arbitrary effect once, purely for its effects,
   * ignoring its return value. This `Process` emits no values.
   */</span>
  def <a title="[F[_], O](f: F[O])scalaz.stream.Process[F,Nothing]" id="scalaz.stream.Process.eval_">eval_</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.eval_;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.eval_;F;_">_</a><span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process.eval_;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[O]" id="scalaz.stream.Process.eval_.f">f</a>: <a href="#scalaz.stream.Process.eval_;F" title="F[O]">F</a><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,Nothing]">Process</a><span class="delimiter">[</span>F, Nothing<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.eval" title="(f: F[O])scalaz.stream.Process[F,O]">eval</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.eval_.f" title="F[O]">f</a><span class="delimiter">)</span>.<a href="#scalaz.stream;Process.drain" title="=&gt; scalaz.stream.Process[F,Nothing]">drain</a>

  <span class="comment">/** Prefix syntax for `p.repeat`. */</span>
  def <a title="[F[_], O](p: scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]" id="scalaz.stream.Process.repeat">repeat</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.repeat;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.repeat;F;_">_</a><span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process.repeat;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[F,O]" id="scalaz.stream.Process.repeat.p">p</a>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> = <a href="#scalaz.stream.Process.repeat.p" title="scalaz.stream.Process[F,O]">p</a>.<a href="#scalaz.stream;Process.repeat" title="=&gt; scalaz.stream.Process[F,O]">repeat</a>


  <span class="comment">/**
   * Evaluate an arbitrary effect in a `Process`. The resulting `Process` will emit values
   * until evaluation of `f` signals termination with `End` or an error occurs.
   *
   * Note that if `f` results to failure of type `Terminated` the repeatEval will convert cause
   * to respective process cause termination, and will halt with that cause.
   *
   */</span>
  def <a title="[F[_], O](f: F[O])scalaz.stream.Process[F,O]" id="scalaz.stream.Process.repeatEval">repeatEval</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.repeatEval;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.repeatEval;F;_">_</a><span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process.repeatEval;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[O]" id="scalaz.stream.Process.repeatEval.f">f</a>: <a href="#scalaz.stream.Process.repeatEval;F" title="F[O]">F</a><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.awaitOr" title="(req: F[O])(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[F,O])(rcv: O =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">awaitOr</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.repeatEval.f" title="F[O]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.repeatEval.$anonfun.x$68" title="scalaz.stream.Cause.EarlyCause">_</a>.<a href="Cause.scala.html#scalaz.stream;Cause.asHalt" title="=&gt; scalaz.stream.Process.Halt">asHalt</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="O" id="scalaz.stream.Process.repeatEval.$anonfun.o">o</a> =&gt; <a href="#scalaz.stream.Process.emit" title="(o: O)scalaz.stream.Process0[O]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.repeatEval.$anonfun.o" title="O">o</a><span class="delimiter">)</span> <a href="#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]">++</a> <a href="#scalaz.stream.Process.repeatEval" title="(f: F[O])scalaz.stream.Process[F,O]">repeatEval</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.repeatEval.f" title="F[O]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Produce `p` lazily. Useful if producing the process involves allocation of
   * some local mutable resource we want to ensure is freshly allocated
   * for each consumer of `p`.
   *
   * Note that this implementation assures that:
   * {{{
   *    suspend(p).kill === suspend(p.kill)
   *    suspend(p).kill === p.kill
   *
   *    suspend(p).repeat === suspend(p.repeat)
   *    suspend(p).repeat ===  p.repeat
   *
   *    suspend(p).eval === suspend(p.eval)
   *    suspend(p).eval === p.eval
   *
   *    Halt(cause) ++ suspend(p) === Halt(cause) ++ p
   * }}}
   *
   */</span>
  def <a title="[F[_], O](p: =&gt; scalaz.stream.Process[F,O])scalaz.stream.Process[F,O]" id="scalaz.stream.Process.suspend">suspend</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.Process.suspend;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.Process.suspend;F;_">_</a><span class="delimiter">]</span>, <a title="" id="scalaz.stream.Process.suspend;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.stream.Process[F,O]" id="scalaz.stream.Process.suspend.p">p</a>: =&gt; Process<span class="delimiter">[</span>F, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F, O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.Process.Append.readResolve" title="(head: scalaz.stream.Process.HaltEmitOrAwait[F,O], stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]])scalaz.stream.Process.Append[F,O]">Append</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.halt0" title="=&gt; scalaz.stream.Process.Halt">halt0</a>,<span title="(elems: scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]*)scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]]">Vector</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.suspend.$anonfun.x0$20" title="scalaz.stream.Process.Trampoline[scalaz.stream.Process[F,O]]" class="delimiter">{</a>
      case <a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a> =&gt; <a href="#scalaz.stream.Process.Trampoline" title="=&gt; scalaz.Trampoline.type">Trampoline</a>.<span title="(a: scalaz.stream.Process[F,O])scalaz.Free.Trampoline[scalaz.stream.Process[F,O]]">done</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.suspend.p" title="=&gt; scalaz.stream.Process[F,O]">p</a><span class="delimiter">)</span>
      case <a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.Process.suspend.$anonfun.early">early</a>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a> =&gt; <a href="#scalaz.stream.Process.Trampoline" title="=&gt; scalaz.Trampoline.type">Trampoline</a>.<span title="(a: scalaz.stream.Process[F,O])scalaz.Free.Trampoline[scalaz.stream.Process[F,O]]">done</span><span class="delimiter">(</span><a href="#scalaz.stream.Process.suspend.p" title="=&gt; scalaz.stream.Process[F,O]">p</a>.<a href="#scalaz.stream;Process.injectCause" title="(early: scalaz.stream.Cause.EarlyCause)scalaz.stream.Process[F,O]">injectCause</a><span class="delimiter">(</span><a href="#scalaz.stream.Process.suspend.$anonfun.early" title="scalaz.stream.Cause.EarlyCause">early</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>
