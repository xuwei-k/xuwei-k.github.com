<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scalaz-stream/scalaz/stream/wye.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scalaz.stream

import <a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>._
import scala.annotation.tailrec
import scala.concurrent.duration.Duration
import scalaz.<span title="scalaz.\/.type">\/</span>._
import scalaz.concurrent.<span class="delimiter">{</span>Actor, Strategy, Task<span class="delimiter">}</span>
import scalaz.stream.<a href="Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>._
import scalaz.stream.<a href="ReceiveY.scala.html#scalaz.stream.ReceiveY" title="scalaz.stream.ReceiveY.type">ReceiveY</a>._
import scalaz.stream.<a href="Util.scala.html#scalaz.stream.Util" title="scalaz.stream.Util.type">Util</a>._
import scalaz.stream.<a href="process1.scala.html#scalaz.stream.process1" title="scalaz.stream.process1.type">process1</a>.Await1
import scalaz.<span class="delimiter">{</span>-\/, Either3, Left3, Middle3, Right3, \/, \/-<span class="delimiter">}</span>


object <a title="scalaz.stream.wye.type" id="scalaz.stream.wye">wye</a> <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type" class="delimiter">{</a>

  <span class="comment">/**
   * A `Wye` which emits values from its right branch, but allows up to `n`
   * elements from the left branch to enqueue unanswered before blocking
   * on the right branch.
   */</span>
  def <a title="[I](n: Int)scalaz.stream.Wye[Any,I,I]" id="scalaz.stream.wye.boundedQueue">boundedQueue</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.boundedQueue;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scalaz.stream.wye.boundedQueue.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[Any,I,I]">Wye</a><span class="delimiter">[</span>Any,I,I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.yipWithL" title="[I, O, O2](n: Int)(f: (I, O) =&gt; O2)scalaz.stream.Wye[I,O,O2]">yipWithL</a><span title="(n: Int)(f: (Any, I) =&gt; I)scalaz.stream.Wye[Any,I,I]" class="delimiter">[</span><span title="Any">Any</span>,<a href="#scalaz.stream.wye.boundedQueue;I" title="I">I</a>,<a href="#scalaz.stream.wye.boundedQueue;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.boundedQueue.n" title="Int">n</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Any" id="scalaz.stream.wye.boundedQueue.$anonfun.i">i</a>,<a title="I" id="scalaz.stream.wye.boundedQueue.$anonfun.i2">i2</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.wye.boundedQueue.$anonfun.i2" title="I">i2</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[Any,I]#Y[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[Any,I]#Y[x],I]">++</a> <a href="tee.scala.html#scalaz.stream.tee" title="scalaz.stream.tee.type">tee</a>.<a href="tee.scala.html#scalaz.stream.tee.passR" title="scalaz.stream.Tee[Any,I,I]">passR</a>

  <span class="comment">/**
   * After each input, dynamically determine whether to read from the left, right, or both,
   * for the subsequent input, using the provided functions `f` and `g`. The returned
   * `Wye` begins by reading from the left side and is left-biased--if a read of both branches
   * returns a `These(x,y)`, it uses the signal generated by `f` for its next step.
   */</span>
  def <a title="[I, I2](f: I =&gt; scalaz.stream.wye.Request, g: I2 =&gt; scalaz.stream.wye.Request)scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]" id="scalaz.stream.wye.dynamic">dynamic</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.dynamic;I">I</a>,<a title="" id="scalaz.stream.wye.dynamic;I2">I2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; scalaz.stream.wye.Request" id="scalaz.stream.wye.dynamic.f">f</a>: I =&gt; wye.Request, <a title="I2 =&gt; scalaz.stream.wye.Request" id="scalaz.stream.wye.dynamic.g">g</a>: I2 =&gt; wye.Request<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]">Wye</a><span class="delimiter">[</span>I,I2,ReceiveY<span class="delimiter">[</span>I,I2<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    import scalaz.stream.<a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.Request" title="scalaz.stream.wye.Request.type">Request</a>._
    def <a title="(signal: scalaz.stream.wye.Request)scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]" id="scalaz.stream.wye.dynamic.go">go</a><span class="delimiter">(</span><a title="scalaz.stream.wye.Request" id="scalaz.stream.wye.dynamic.go.signal">signal</a>: wye.<a href="#scalaz.stream.wye;Request" title="scalaz.stream.wye.Request">Request</a><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]">Wye</a><span class="delimiter">[</span>I,I2,ReceiveY<span class="delimiter">[</span>I,I2<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scalaz.stream.wye.dynamic.go.signal" title="scalaz.stream.wye.Request">signal</a> match <span class="delimiter">{</span>
      case <a href="#scalaz.stream.wye.Request.L.readResolve" title="scalaz.stream.wye.Request.L.type">L</a> =&gt; <a href="#scalaz.stream.wye.receiveL" title="(rcv: I =&gt; scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]])scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]">receiveL</a> <span class="delimiter">{</span> <span title="I">i</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: scalaz.stream.ReceiveY.ReceiveL[I])scalaz.stream.Process0[scalaz.stream.ReceiveY.ReceiveL[I]]">emit</a><span class="delimiter">(</span><a href="ReceiveY.scala.html#scalaz.stream.ReceiveY;ReceiveL" title="(get: I)scalaz.stream.ReceiveY.ReceiveL[I]">ReceiveL</a><span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.ReceiveY[I,I2]])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.ReceiveY[I,I2]]">++</a> <a href="#scalaz.stream.wye.dynamic.go" title="(signal: scalaz.stream.wye.Request)scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.dynamic.f" title="(v1: I)scalaz.stream.wye.Request">f</a><span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      case <a href="#scalaz.stream.wye.Request.R.readResolve" title="scalaz.stream.wye.Request.R.type">R</a> =&gt; <a href="#scalaz.stream.wye.receiveR" title="(rcv: I2 =&gt; scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]])scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]">receiveR</a> <span class="delimiter">{</span> <span title="I2">i2</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: scalaz.stream.ReceiveY.ReceiveR[I2])scalaz.stream.Process0[scalaz.stream.ReceiveY.ReceiveR[I2]]">emit</a><span class="delimiter">(</span><a href="ReceiveY.scala.html#scalaz.stream.ReceiveY;ReceiveR" title="(get: I2)scalaz.stream.ReceiveY.ReceiveR[I2]">ReceiveR</a><span class="delimiter">(</span><span title="I2">i2</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.ReceiveY[I,I2]])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.ReceiveY[I,I2]]">++</a> <a href="#scalaz.stream.wye.dynamic.go" title="(signal: scalaz.stream.wye.Request)scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.dynamic.g" title="(v1: I2)scalaz.stream.wye.Request">g</a><span class="delimiter">(</span><span title="I2">i2</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      case <a href="#scalaz.stream.wye.Request.Both.readResolve" title="scalaz.stream.wye.Request.Both.type">Both</a> =&gt; <a href="#scalaz.stream.wye.receiveBoth" title="(rcv: scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]])scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]">receiveBoth</a> <a href="#scalaz.stream.wye.dynamic.go.$anonfun.x0$1" title="scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]" class="delimiter">{</a>
        case <span title="scalaz.stream.ReceiveY.ReceiveL[I]">t</span>@ReceiveL<span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: scalaz.stream.ReceiveY.ReceiveL[I])scalaz.stream.Process0[scalaz.stream.ReceiveY.ReceiveL[I]]">emit</a><span class="delimiter">(</span><span title="scalaz.stream.ReceiveY.ReceiveL[I]">t</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.ReceiveY[I,I2]])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.ReceiveY[I,I2]]">++</a> <a href="#scalaz.stream.wye.dynamic.go" title="(signal: scalaz.stream.wye.Request)scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.dynamic.f" title="(v1: I)scalaz.stream.wye.Request">f</a><span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case <span title="scalaz.stream.ReceiveY.ReceiveR[I2]">t</span>@ReceiveR<span class="delimiter">(</span><span title="I2">i2</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: scalaz.stream.ReceiveY.ReceiveR[I2])scalaz.stream.Process0[scalaz.stream.ReceiveY.ReceiveR[I2]]">emit</a><span class="delimiter">(</span><span title="scalaz.stream.ReceiveY.ReceiveR[I2]">t</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.ReceiveY[I,I2]])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.ReceiveY[I,I2]]">++</a> <a href="#scalaz.stream.wye.dynamic.go" title="(signal: scalaz.stream.wye.Request)scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.dynamic.g" title="(v1: I2)scalaz.stream.wye.Request">g</a><span class="delimiter">(</span><span title="I2">i2</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case <a href="ReceiveY.scala.html#scalaz.stream.ReceiveY.HaltOne.unapply" title="(ry: scalaz.stream.ReceiveY[Any,Any])Option[scalaz.stream.Cause]">HaltOne</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.dynamic.go.$anonfun.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.dynamic.go.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#scalaz.stream.wye.dynamic.go" title="(signal: scalaz.stream.wye.Request)scalaz.stream.Wye[I,I2,scalaz.stream.ReceiveY[I,I2]]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.Request.L.readResolve" title="scalaz.stream.wye.Request.L.type">L</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Invokes `dynamic` with `I == I2`, and produces a single `I` output. Output is
   * left-biased: if a `These(i1,i2)` is emitted, this is translated to an
   * `emitSeq(List(i1,i2))`.
   */</span>
  def <a title="[I](f: I =&gt; scalaz.stream.wye.Request)scalaz.stream.Wye[I,I,I]" id="scalaz.stream.wye.dynamic1">dynamic1</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.dynamic1;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; scalaz.stream.wye.Request" id="scalaz.stream.wye.dynamic1.f">f</a>: I =&gt; wye.Request<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I,I]">Wye</a><span class="delimiter">[</span>I,I,I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.dynamic" title="(f: I =&gt; scalaz.stream.wye.Request, g: I =&gt; scalaz.stream.wye.Request)scalaz.stream.Wye[I,I,scalaz.stream.ReceiveY[I,I]]">dynamic</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.dynamic1.f" title="I =&gt; scalaz.stream.wye.Request">f</a>, <a href="#scalaz.stream.wye.dynamic1.f" title="I =&gt; scalaz.stream.wye.Request">f</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: scalaz.stream.ReceiveY[I,I] =&gt; scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I]#Y[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I]#Y[x],I]">flatMap</a> <a href="#scalaz.stream.wye.dynamic1.$anonfun.x0$2" title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I]#Y,I]" class="delimiter">{</a>
      case ReceiveL<span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span>
      case ReceiveR<span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span>
      case <a href="ReceiveY.scala.html#scalaz.stream.ReceiveY.HaltOne.unapply" title="(ry: scalaz.stream.ReceiveY[Any,Any])Option[scalaz.stream.Cause]">HaltOne</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.dynamic1.$anonfun.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.dynamic1.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Nondeterminstic interleave of both inputs. Emits values whenever either
   * of the inputs is available.
   */</span>
  def <a title="[I, I2]=&gt; scalaz.stream.Wye[I,I2,scalaz.\/[I,I2]]" id="scalaz.stream.wye.either">either</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.either;I">I</a>,<a title="" id="scalaz.stream.wye.either;I2">I2</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,scalaz.\/[I,I2]]">Wye</a><span class="delimiter">[</span>I,I2,I \/ I2<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.receiveBoth" title="(rcv: scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,scalaz.\/[I,I2]])scalaz.stream.Wye[I,I2,scalaz.\/[I,I2]]">receiveBoth</a> <a href="#scalaz.stream.wye.either.$anonfun.x0$3" title="scalaz.stream.Wye[I,I2,scalaz.\/[I,I2]]" class="delimiter">{</a>
      case ReceiveL<span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: scalaz.\/[I,Nothing])scalaz.stream.Process0[scalaz.\/[I,Nothing]]">emit</a><span class="delimiter">(</span><span title="(v1: I)scalaz.\/[I,Nothing]">left</span><span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,scalaz.\/[I,I2]])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,scalaz.\/[I,I2]]">++</a> <a href="#scalaz.stream.wye.either" title="scalaz.stream.Wye[I,I2,scalaz.\/[I,I2]]">either</a>
      case ReceiveR<span class="delimiter">(</span><span title="I2">i</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: scalaz.\/[Nothing,I2])scalaz.stream.Process0[scalaz.\/[Nothing,I2]]">emit</a><span class="delimiter">(</span><span title="(v1: I2)scalaz.\/[Nothing,I2]">right</span><span class="delimiter">(</span><span title="I2">i</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,scalaz.\/[I,I2]])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,scalaz.\/[I,I2]]">++</a> <a href="#scalaz.stream.wye.either" title="scalaz.stream.Wye[I,I2,scalaz.\/[I,I2]]">either</a>
      case HaltL<span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span>     =&gt; <a href="Process.scala.html#scalaz.stream.Process.awaitR" title="[I2]=&gt; scalaz.stream.Tee[Any,I2,I2]">awaitR</a><span title="scalaz.stream.Tee[Any,I2,I2]" class="delimiter">[</span><a href="#scalaz.stream.wye.either;I2" title="I2">I2</a><span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream;Process.map" title="(f: I2 =&gt; scalaz.\/[Nothing,I2])scalaz.stream.Process[scalaz.stream.Process.Env[Any,I2]#T,scalaz.\/[Nothing,I2]]">map</a><span class="delimiter">(</span><span title="I2 =&gt; scalaz.\/[Nothing,I2]">right</span><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.repeat" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Any,I2]#T,scalaz.\/[Nothing,I2]]">repeat</a>
      case HaltR<span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span>     =&gt; <a href="Process.scala.html#scalaz.stream.Process.awaitL" title="[I]=&gt; scalaz.stream.Tee[I,Any,I]">awaitL</a><span title="scalaz.stream.Tee[I,Any,I]" class="delimiter">[</span><a href="#scalaz.stream.wye.either;I" title="I">I</a><span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream;Process.map" title="(f: I =&gt; scalaz.\/[I,Nothing])scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#T,scalaz.\/[I,Nothing]]">map</a><span class="delimiter">(</span><span title="I =&gt; scalaz.\/[I,Nothing]">left</span><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.repeat" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#T,scalaz.\/[I,Nothing]]">repeat</a>
      case <a title="scalaz.stream.ReceiveY[I,I2]" id="scalaz.stream.wye.either.$anonfun.h">h</a>@<a href="ReceiveY.scala.html#scalaz.stream.ReceiveY.HaltOne.unapply" title="(ry: scalaz.stream.ReceiveY[Any,Any])Option[scalaz.stream.Cause]">HaltOne</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.either.$anonfun.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.either.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Continuous wye, that first reads from Left to get `A`,
   * Then when `A` is not available it reads from R echoing any `A` that was received from Left
   * Will halt once any of the sides halt
   */</span>
  def <a title="[A]=&gt; scalaz.stream.Wye[A,Any,A]" id="scalaz.stream.wye.echoLeft">echoLeft</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.echoLeft;A">A</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[A,Any,A]">Wye</a><span class="delimiter">[</span>A, Any, A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(a: A)scalaz.stream.Wye[A,Any,A]" id="scalaz.stream.wye.echoLeft.go">go</a><span class="delimiter">(</span><a title="A" id="scalaz.stream.wye.echoLeft.go.a">a</a>: <a href="#scalaz.stream.wye.echoLeft;A" title="A">A</a><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[A,Any,A]">Wye</a><span class="delimiter">[</span>A, Any, A<span class="delimiter">]</span> =
      <a href="#scalaz.stream.wye.receiveBoth" title="(rcv: scalaz.stream.ReceiveY[A,Any] =&gt; scalaz.stream.Wye[A,Any,A])scalaz.stream.Wye[A,Any,A]">receiveBoth</a> <a href="#scalaz.stream.wye.echoLeft.go.$anonfun.x0$4" title="scalaz.stream.Wye[A,Any,A]" class="delimiter">{</a>
        case ReceiveL<span class="delimiter">(</span><a title="A" id="scalaz.stream.wye.echoLeft.go.$anonfun.l">l</a><span class="delimiter">)</span>  =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: A)scalaz.stream.Process0[A]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.echoLeft.go.$anonfun.l" title="A">l</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Y,A])scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Y,A]">++</a> <a href="#scalaz.stream.wye.echoLeft.go" title="(a: A)scalaz.stream.Wye[A,Any,A]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.echoLeft.go.$anonfun.l" title="A">l</a><span class="delimiter">)</span>
        case ReceiveR<span class="delimiter">(</span>_<span class="delimiter">)</span>  =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: A)scalaz.stream.Process0[A]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.echoLeft.go.a" title="A">a</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Y,A])scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Y,A]">++</a> <a href="#scalaz.stream.wye.echoLeft.go" title="(a: A)scalaz.stream.Wye[A,Any,A]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.echoLeft.go.a" title="A">a</a><span class="delimiter">)</span>
        case <a href="ReceiveY.scala.html#scalaz.stream.ReceiveY.HaltOne.unapply" title="(ry: scalaz.stream.ReceiveY[Any,Any])Option[scalaz.stream.Cause]">HaltOne</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.echoLeft.go.$anonfun.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.echoLeft.go.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#scalaz.stream.wye.receiveL" title="(rcv: A =&gt; scalaz.stream.Wye[A,Any,A])scalaz.stream.Wye[A,Any,A]">receiveL</a><span class="delimiter">(</span><a title="A" id="scalaz.stream.wye.echoLeft.$anonfun.s">s</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: A)scalaz.stream.Process0[A]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.echoLeft.$anonfun.s" title="A">s</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Y,A])scalaz.stream.Process[scalaz.stream.Process.Env[A,Any]#Y,A]">++</a> <a href="#scalaz.stream.wye.echoLeft.go" title="(a: A)scalaz.stream.Wye[A,Any,A]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.echoLeft.$anonfun.s" title="A">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Let through the right branch as long as the left branch is `false`,
   * listening asynchronously for the left branch to become `true`.
   * This halts as soon as the right or left branch halts.
   */</span>
  def <a title="[I]=&gt; scalaz.stream.Wye[Boolean,I,I]" id="scalaz.stream.wye.interrupt">interrupt</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.interrupt;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[Boolean,I,I]">Wye</a><span class="delimiter">[</span>Boolean, I, I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.receiveBoth" title="(rcv: scalaz.stream.ReceiveY[Boolean,I] =&gt; scalaz.stream.Wye[Boolean,I,I])scalaz.stream.Wye[Boolean,I,I]">receiveBoth</a> <a href="#scalaz.stream.wye.interrupt.$anonfun.x0$5" title="scalaz.stream.Wye[Boolean,I,I]" class="delimiter">{</a>
      case ReceiveR<span class="delimiter">(</span><a title="I" id="scalaz.stream.wye.interrupt.$anonfun.i">i</a><span class="delimiter">)</span>    =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.interrupt.$anonfun.i" title="I">i</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Boolean,I]#Y,I])scalaz.stream.Process[scalaz.stream.Process.Env[Boolean,I]#Y,I]">++</a> <a href="#scalaz.stream.wye.interrupt" title="scalaz.stream.Wye[Boolean,I,I]">interrupt</a>
      case ReceiveL<span class="delimiter">(</span><a title="Boolean" id="scalaz.stream.wye.interrupt.$anonfun.kill">kill</a><span class="delimiter">)</span> =&gt; if <span class="delimiter">(</span><a href="#scalaz.stream.wye.interrupt.$anonfun.kill" title="Boolean">kill</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a> else <a href="#scalaz.stream.wye.interrupt" title="scalaz.stream.Wye[Boolean,I,I]">interrupt</a>
      case <a href="ReceiveY.scala.html#scalaz.stream.ReceiveY.HaltOne.unapply" title="(ry: scalaz.stream.ReceiveY[Any,Any])Option[scalaz.stream.Cause]">HaltOne</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.interrupt.$anonfun.e">e</a><span class="delimiter">)</span>     =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.interrupt.$anonfun.e" title="scalaz.stream.Cause">e</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Non-deterministic interleave of both inputs. Emits values whenever either
   * of the inputs is available.
   *
   * Will terminate once both sides terminate.
   */</span>
  def <a title="[I]=&gt; scalaz.stream.Wye[I,I,I]" id="scalaz.stream.wye.merge">merge</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.merge;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I,I]">Wye</a><span class="delimiter">[</span>I,I,I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.receiveBoth" title="(rcv: scalaz.stream.ReceiveY[I,I] =&gt; scalaz.stream.Wye[I,I,I])scalaz.stream.Wye[I,I,I]">receiveBoth</a> <a href="#scalaz.stream.wye.merge.$anonfun.x0$6" title="scalaz.stream.Wye[I,I,I]" class="delimiter">{</a>
      case ReceiveL<span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I]#Y,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I]#Y,I]">++</a> <a href="#scalaz.stream.wye.merge" title="scalaz.stream.Wye[I,I,I]">merge</a>
      case ReceiveR<span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I]#Y,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I]#Y,I]">++</a> <a href="#scalaz.stream.wye.merge" title="scalaz.stream.Wye[I,I,I]">merge</a>
      case HaltL<span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span>   =&gt; <a href="Process.scala.html#scalaz.stream.Process.awaitR" title="scalaz.stream.Tee[Any,I,I]">awaitR</a>.<a href="Process.scala.html#scalaz.stream;Process.repeat" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Any,I]#T,I]">repeat</a>
      case HaltR<span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span>   =&gt; <a href="Process.scala.html#scalaz.stream.Process.awaitL" title="scalaz.stream.Tee[I,Any,I]">awaitL</a>.<a href="Process.scala.html#scalaz.stream;Process.repeat" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#T,I]">repeat</a>
      case <a href="ReceiveY.scala.html#scalaz.stream.ReceiveY.HaltOne.unapply" title="(ry: scalaz.stream.ReceiveY[Any,Any])Option[scalaz.stream.Cause]">HaltOne</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.merge.$anonfun.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.merge.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Like `merge`, but terminates whenever one side terminate.
   */</span>
  def <a title="[I]=&gt; scalaz.stream.Wye[I,I,I]" id="scalaz.stream.wye.mergeHaltBoth">mergeHaltBoth</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.mergeHaltBoth;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I,I]">Wye</a><span class="delimiter">[</span>I,I,I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.receiveBoth" title="(rcv: scalaz.stream.ReceiveY[I,I] =&gt; scalaz.stream.Wye[I,I,I])scalaz.stream.Wye[I,I,I]">receiveBoth</a> <a href="#scalaz.stream.wye.mergeHaltBoth.$anonfun.x0$7" title="scalaz.stream.Wye[I,I,I]" class="delimiter">{</a>
      case ReceiveL<span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I]#Y,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I]#Y,I]">++</a> <a href="#scalaz.stream.wye.mergeHaltBoth" title="scalaz.stream.Wye[I,I,I]">mergeHaltBoth</a>
      case ReceiveR<span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I]#Y,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I]#Y,I]">++</a> <a href="#scalaz.stream.wye.mergeHaltBoth" title="scalaz.stream.Wye[I,I,I]">mergeHaltBoth</a>
      case <a href="ReceiveY.scala.html#scalaz.stream.ReceiveY.HaltOne.unapply" title="(ry: scalaz.stream.ReceiveY[Any,Any])Option[scalaz.stream.Cause]">HaltOne</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.mergeHaltBoth.$anonfun.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.mergeHaltBoth.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Like `merge`, but terminates whenever left side terminates.
   * use `flip` to reverse this for the right side
   */</span>
  def <a title="[I]=&gt; scalaz.stream.Wye[I,I,I]" id="scalaz.stream.wye.mergeHaltL">mergeHaltL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.mergeHaltL;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I,I]">Wye</a><span class="delimiter">[</span>I,I,I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.receiveBoth" title="(rcv: scalaz.stream.ReceiveY[I,I] =&gt; scalaz.stream.Wye[I,I,I])scalaz.stream.Wye[I,I,I]">receiveBoth</a> <a href="#scalaz.stream.wye.mergeHaltL.$anonfun.x0$8" title="scalaz.stream.Wye[I,I,I]" class="delimiter">{</a>
      case ReceiveL<span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I]#Y,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I]#Y,I]">++</a> <a href="#scalaz.stream.wye.mergeHaltL" title="scalaz.stream.Wye[I,I,I]">mergeHaltL</a>
      case ReceiveR<span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I]#Y,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I]#Y,I]">++</a> <a href="#scalaz.stream.wye.mergeHaltL" title="scalaz.stream.Wye[I,I,I]">mergeHaltL</a>
      case HaltR<span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span>   =&gt; <a href="Process.scala.html#scalaz.stream.Process.awaitL" title="scalaz.stream.Tee[I,Any,I]">awaitL</a>.<a href="Process.scala.html#scalaz.stream;Process.repeat" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,Any]#T,I]">repeat</a>
      case <a href="ReceiveY.scala.html#scalaz.stream.ReceiveY.HaltOne.unapply" title="(ry: scalaz.stream.ReceiveY[Any,Any])Option[scalaz.stream.Cause]">HaltOne</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.mergeHaltL.$anonfun.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.mergeHaltL.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Like `merge`, but terminates whenever right side terminates
   */</span>
  def <a title="[I]=&gt; scalaz.stream.Wye[I,I,I]" id="scalaz.stream.wye.mergeHaltR">mergeHaltR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.mergeHaltR;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I,I]">Wye</a><span class="delimiter">[</span>I,I,I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.flip" title="(y: scalaz.stream.Wye[I,I,I])scalaz.stream.Wye[I,I,I]">flip</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.mergeHaltL" title="scalaz.stream.Wye[I,I,I]">mergeHaltL</a><span class="delimiter">)</span>

  <span class="comment">/**
   * A `Wye` which blocks on the right side when either
   *   a) the age of the oldest unanswered element from the left size exceeds the given duration, or
   *   b) the number of unanswered elements from the left exceeds `maxSize`.
   */</span>
  def <a title="[I](d: scala.concurrent.duration.Duration, maxSize: Int)scalaz.stream.Wye[scala.concurrent.duration.Duration,I,I]" id="scalaz.stream.wye.timedQueue">timedQueue</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.timedQueue$default$2;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.concurrent.duration.Duration" id="scalaz.stream.wye.timedQueue.d">d</a>: <span title="scala.concurrent.duration.Duration">Duration</span>, <a title="Int" id="scalaz.stream.wye.timedQueue$default$2">maxSize</a>: <span title="Int">Int</span> = Int.<span title="Int(2147483647)">MaxValue</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[scala.concurrent.duration.Duration,I,I]">Wye</a><span class="delimiter">[</span>Duration,I,I<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(q: Vector[scala.concurrent.duration.Duration])scalaz.stream.Wye[scala.concurrent.duration.Duration,I,I]" id="scalaz.stream.wye.timedQueue.go">go</a><span class="delimiter">(</span><a title="Vector[scala.concurrent.duration.Duration]" id="scalaz.stream.wye.timedQueue.go.q">q</a>: <span title="Vector[scala.concurrent.duration.Duration]">Vector</span><span class="delimiter">[</span>Duration<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[scala.concurrent.duration.Duration,I,I]">Wye</a><span class="delimiter">[</span>Duration,I,I<span class="delimiter">]</span> =
      <a href="#scalaz.stream.wye.receiveBoth" title="(rcv: scalaz.stream.ReceiveY[scala.concurrent.duration.Duration,I] =&gt; scalaz.stream.Wye[scala.concurrent.duration.Duration,I,I])scalaz.stream.Wye[scala.concurrent.duration.Duration,I,I]">receiveBoth</a> <a href="#scalaz.stream.wye.timedQueue.go.$anonfun.x0$9" title="scalaz.stream.Wye[scala.concurrent.duration.Duration,I,I]" class="delimiter">{</a>
        case ReceiveL<span class="delimiter">(</span><a title="scala.concurrent.duration.Duration" id="scalaz.stream.wye.timedQueue.go.$anonfun.d2">d2</a><span class="delimiter">)</span> =&gt;
          if <span class="delimiter">(</span><a href="#scalaz.stream.wye.timedQueue.go.q" title="Vector[scala.concurrent.duration.Duration]">q</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;=</span> <a href="#scalaz.stream.wye.timedQueue$default$2" title="Int">maxSize</a> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#scalaz.stream.wye.timedQueue.go.$anonfun.d2" title="scala.concurrent.duration.Duration">d2</a> <span title="(other: scala.concurrent.duration.Duration)scala.concurrent.duration.Duration">-</span> <a href="#scalaz.stream.wye.timedQueue.go.q" title="Vector[scala.concurrent.duration.Duration]">q</a>.<span title="=&gt; Option[scala.concurrent.duration.Duration]">headOption</span>.<span title="(default: =&gt; scala.concurrent.duration.Duration)scala.concurrent.duration.Duration">getOrElse</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.timedQueue.go.$anonfun.d2" title="scala.concurrent.duration.Duration">d2</a><span class="delimiter">)</span> <span title="(that: scala.concurrent.duration.Duration)Boolean">&gt;</span> <a href="#scalaz.stream.wye.timedQueue.d" title="scala.concurrent.duration.Duration">d</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#scalaz.stream.wye.receiveR" title="(rcv: I =&gt; scalaz.stream.Wye[scala.concurrent.duration.Duration,I,I])scalaz.stream.Wye[scala.concurrent.duration.Duration,I,I]">receiveR</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.wye.timedQueue.go.$anonfun.$anonfun.i">i</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.timedQueue.go.$anonfun.$anonfun.i" title="I">i</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[scala.concurrent.duration.Duration,I]#Y,I])scalaz.stream.Process[scalaz.stream.Process.Env[scala.concurrent.duration.Duration,I]#Y,I]">++</a> <a href="#scalaz.stream.wye.timedQueue.go" title="(q: Vector[scala.concurrent.duration.Duration])scalaz.stream.Wye[scala.concurrent.duration.Duration,I,I]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.timedQueue.go.q" title="Vector[scala.concurrent.duration.Duration]">q</a>.<span title="(n: Int)scala.collection.immutable.Vector[scala.concurrent.duration.Duration]">drop</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          else
            <a href="#scalaz.stream.wye.timedQueue.go" title="(q: Vector[scala.concurrent.duration.Duration])scalaz.stream.Wye[scala.concurrent.duration.Duration,I,I]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.timedQueue.go.q" title="Vector[scala.concurrent.duration.Duration]">q</a> <span title="(elem: scala.concurrent.duration.Duration)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[scala.concurrent.duration.Duration],scala.concurrent.duration.Duration,Vector[scala.concurrent.duration.Duration]])Vector[scala.concurrent.duration.Duration]">:+</span> <a href="#scalaz.stream.wye.timedQueue.go.$anonfun.d2" title="scala.concurrent.duration.Duration">d2</a><span class="delimiter">)</span>
        case ReceiveR<span class="delimiter">(</span><a title="I" id="scalaz.stream.wye.timedQueue.go.$anonfun.i">i</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.timedQueue.go.$anonfun.i" title="I">i</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[scala.concurrent.duration.Duration,I]#Y,I])scalaz.stream.Process[scalaz.stream.Process.Env[scala.concurrent.duration.Duration,I]#Y,I]">++</a> <span class="delimiter">(</span><a href="#scalaz.stream.wye.timedQueue.go" title="(q: Vector[scala.concurrent.duration.Duration])scalaz.stream.Wye[scala.concurrent.duration.Duration,I,I]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.timedQueue.go.q" title="Vector[scala.concurrent.duration.Duration]">q</a>.<span title="(n: Int)scala.collection.immutable.Vector[scala.concurrent.duration.Duration]">drop</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case <a href="ReceiveY.scala.html#scalaz.stream.ReceiveY.HaltOne.unapply" title="(ry: scalaz.stream.ReceiveY[Any,Any])Option[scalaz.stream.Cause]">HaltOne</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.timedQueue.go.$anonfun.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.timedQueue.go.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#scalaz.stream.wye.timedQueue.go" title="(q: Vector[scala.concurrent.duration.Duration])scalaz.stream.Wye[scala.concurrent.duration.Duration,I,I]">go</a><span class="delimiter">(</span><span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>


  <span class="comment">/**
   * `Wye` which repeatedly awaits both branches, emitting any values
   * received from the right. Useful in conjunction with `connect`,
   * for instance `src.connect(snk)(unboundedQueue)`
   */</span>
  def <a title="[I]=&gt; scalaz.stream.Wye[Any,I,I]" id="scalaz.stream.wye.unboundedQueue">unboundedQueue</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.unboundedQueue;I">I</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[Any,I,I]">Wye</a><span class="delimiter">[</span>Any,I,I<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.receiveBoth" title="(rcv: scalaz.stream.ReceiveY[Any,I] =&gt; scalaz.stream.Wye[Any,I,I])scalaz.stream.Wye[Any,I,I]">receiveBoth</a> <a href="#scalaz.stream.wye.unboundedQueue.$anonfun.x0$10" title="scalaz.stream.Wye[Any,I,I]" class="delimiter">{</a>
      case ReceiveL<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.halt" title="=&gt; scalaz.stream.Process0[Nothing]">halt</a>
      case ReceiveR<span class="delimiter">(</span><a title="I" id="scalaz.stream.wye.unboundedQueue.$anonfun.i">i</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: I)scalaz.stream.Process0[I]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.unboundedQueue.$anonfun.i" title="I">i</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Any,I]#Y,I])scalaz.stream.Process[scalaz.stream.Process.Env[Any,I]#Y,I]">++</a> <a href="#scalaz.stream.wye.unboundedQueue" title="scalaz.stream.Wye[Any,I,I]">unboundedQueue</a>
      case <a href="ReceiveY.scala.html#scalaz.stream.ReceiveY.HaltOne.unapply" title="(ry: scalaz.stream.ReceiveY[Any,Any])Option[scalaz.stream.Cause]">HaltOne</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.unboundedQueue.$anonfun.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.unboundedQueue.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>


  <span class="comment">/** Nondeterministic version of `zip` which requests both sides in parallel. */</span>
  def <a title="[I, I2]=&gt; scalaz.stream.Wye[I,I2,(I, I2)]" id="scalaz.stream.wye.yip">yip</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.yip;I">I</a>,<a title="" id="scalaz.stream.wye.yip;I2">I2</a><span class="delimiter">]</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,(I, I2)]">Wye</a><span class="delimiter">[</span>I,I2,<span class="delimiter">(</span>I,I2<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#scalaz.stream.wye.yipWith" title="(f: (I, I2) =&gt; (I, I2))scalaz.stream.Wye[I,I2,(I, I2)]">yipWith</a><span class="delimiter">(</span><span title="(_1: I, _2: I2)(I, I2)" class="delimiter">(</span><a href="#scalaz.stream.wye.yip.$anonfun.x$1" title="I">_</a>,<a href="#scalaz.stream.wye.yip.$anonfun.x$2" title="I2">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Left-biased, buffered version of `yip`. Allows up to `n` elements to enqueue on the
   * left unanswered before requiring a response from the right. If buffer is empty,
   * always reads from the left.
   */</span>
  def <a title="[I, I2](n: Int)scalaz.stream.Wye[I,I2,(I, I2)]" id="scalaz.stream.wye.yipL">yipL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.yipL;I">I</a>,<a title="" id="scalaz.stream.wye.yipL;I2">I2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scalaz.stream.wye.yipL.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,(I, I2)]">Wye</a><span class="delimiter">[</span>I,I2,<span class="delimiter">(</span>I,I2<span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.yipWithL" title="(n: Int)(f: (I, I2) =&gt; (I, I2))scalaz.stream.Wye[I,I2,(I, I2)]">yipWithL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipL.n" title="Int">n</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(_1: I, _2: I2)(I, I2)" class="delimiter">(</span><a href="#scalaz.stream.wye.yipL.$anonfun.x$3" title="I">_</a>,<a href="#scalaz.stream.wye.yipL.$anonfun.x$4" title="I2">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Nondeterministic version of `zipWith` which requests both sides in parallel. */</span>
  def <a title="[I, I2, O](f: (I, I2) =&gt; O)scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.yipWith">yipWith</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.yipWith;I">I</a>,<a title="" id="scalaz.stream.wye.yipWith;I2">I2</a>,<a title="" id="scalaz.stream.wye.yipWith;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(I, I2) =&gt; O" id="scalaz.stream.wye.yipWith.f">f</a>: <span class="delimiter">(</span>I,I2<span class="delimiter">)</span> =&gt; O<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.receiveBoth" title="(rcv: scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">receiveBoth</a> <a href="#scalaz.stream.wye.yipWith.$anonfun.x0$11" title="scalaz.stream.Wye[I,I2,O]" class="delimiter">{</a>
      case ReceiveL<span class="delimiter">(</span><a title="I" id="scalaz.stream.wye.yipWith.$anonfun.i">i</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.wye.receiveR" title="(rcv: I2 =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">receiveR</a><span class="delimiter">(</span><a title="I2" id="scalaz.stream.wye.yipWith.$anonfun.$anonfun.i2">i2</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: O)scalaz.stream.Process0[O]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWith.f" title="(v1: I, v2: I2)O">f</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWith.$anonfun.i" title="I">i</a>,<a href="#scalaz.stream.wye.yipWith.$anonfun.$anonfun.i2" title="I2">i2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">++</a> <a href="#scalaz.stream.wye.yipWith" title="(f: (I, I2) =&gt; O)scalaz.stream.Wye[I,I2,O]">yipWith</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWith.f" title="(I, I2) =&gt; O">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case ReceiveR<span class="delimiter">(</span><a title="I2" id="scalaz.stream.wye.yipWith.$anonfun.i2">i2</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.wye.receiveL" title="(rcv: I =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">receiveL</a><span class="delimiter">(</span><a title="I" id="scalaz.stream.wye.yipWith.$anonfun.$anonfun.i">i</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: O)scalaz.stream.Process0[O]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWith.f" title="(v1: I, v2: I2)O">f</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWith.$anonfun.$anonfun.i" title="I">i</a>,<a href="#scalaz.stream.wye.yipWith.$anonfun.i2" title="I2">i2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">++</a> <a href="#scalaz.stream.wye.yipWith" title="(f: (I, I2) =&gt; O)scalaz.stream.Wye[I,I2,O]">yipWith</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWith.f" title="(I, I2) =&gt; O">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case <a href="ReceiveY.scala.html#scalaz.stream.ReceiveY.HaltOne.unapply" title="(ry: scalaz.stream.ReceiveY[Any,Any])Option[scalaz.stream.Cause]">HaltOne</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.yipWith.$anonfun.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWith.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Left-biased, buffered version of `yipWith`. Allows up to `n` elements to enqueue on the
   * left unanswered before requiring a response from the right. If buffer is empty,
   * always reads from the left.
   */</span>
  def <a title="[I, O, O2](n: Int)(f: (I, O) =&gt; O2)scalaz.stream.Wye[I,O,O2]" id="scalaz.stream.wye.yipWithL">yipWithL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.yipWithL;I">I</a>,<a title="" id="scalaz.stream.wye.yipWithL;O">O</a>,<a title="" id="scalaz.stream.wye.yipWithL;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scalaz.stream.wye.yipWithL.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(I, O) =&gt; O2" id="scalaz.stream.wye.yipWithL.f">f</a>: <span class="delimiter">(</span>I,O<span class="delimiter">)</span> =&gt; O2<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,O,O2]">Wye</a><span class="delimiter">[</span>I,O,O2<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(buf: Vector[I])scalaz.stream.Wye[I,O,O2]" id="scalaz.stream.wye.yipWithL.go">go</a><span class="delimiter">(</span><a title="Vector[I]" id="scalaz.stream.wye.yipWithL.go.buf">buf</a>: <span title="Vector[I]">Vector</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,O,O2]">Wye</a><span class="delimiter">[</span>I,O,O2<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWithL.go.buf" title="Vector[I]">buf</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <a href="#scalaz.stream.wye.yipWithL.n" title="Int">n</a><span class="delimiter">)</span> <a href="#scalaz.stream.wye.receiveR" title="(rcv: O =&gt; scalaz.stream.Wye[I,O,O2])scalaz.stream.Wye[I,O,O2]">receiveR</a> <span class="delimiter">{</span> <span title="O">o</span> =&gt;
        <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: O2)scalaz.stream.Process0[O2]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWithL.f" title="(v1: I, v2: O)O2">f</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWithL.go.buf" title="Vector[I]">buf</a>.<span title="=&gt; I">head</span>,<span title="O">o</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,O]#Y,O2])scalaz.stream.Process[scalaz.stream.Process.Env[I,O]#Y,O2]">++</a> <a href="#scalaz.stream.wye.yipWithL.go" title="(buf: Vector[I])scalaz.stream.Wye[I,O,O2]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWithL.go.buf" title="Vector[I]">buf</a>.<span title="=&gt; scala.collection.immutable.Vector[I]">tail</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      else if <span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWithL.go.buf" title="Vector[I]">buf</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#scalaz.stream.wye.receiveL" title="(rcv: I =&gt; scalaz.stream.Wye[I,O,O2])scalaz.stream.Wye[I,O,O2]">receiveL</a> <span class="delimiter">{</span> <span title="I">i</span> =&gt; <a href="#scalaz.stream.wye.yipWithL.go" title="(buf: Vector[I])scalaz.stream.Wye[I,O,O2]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWithL.go.buf" title="Vector[I]">buf</a> <span title="(elem: I)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[I],I,Vector[I]])Vector[I]">:+</span> <span title="I">i</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      else <a href="#scalaz.stream.wye.receiveBoth" title="(rcv: scalaz.stream.ReceiveY[I,O] =&gt; scalaz.stream.Wye[I,O,O2])scalaz.stream.Wye[I,O,O2]">receiveBoth</a> <a href="#scalaz.stream.wye.yipWithL.go.$anonfun.x0$12" title="scalaz.stream.Wye[I,O,O2]" class="delimiter">{</a>
        case ReceiveL<span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.wye.yipWithL.go" title="(buf: Vector[I])scalaz.stream.Wye[I,O,O2]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWithL.go.buf" title="Vector[I]">buf</a> <span title="(elem: I)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[I],I,Vector[I]])Vector[I]">:+</span> <span title="I">i</span><span class="delimiter">)</span>
        case ReceiveR<span class="delimiter">(</span><span title="O">o</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.emit" title="(o: O2)scalaz.stream.Process0[O2]">emit</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWithL.f" title="(v1: I, v2: O)O2">f</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWithL.go.buf" title="Vector[I]">buf</a>.<span title="=&gt; I">head</span>,<span title="O">o</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.++" title="(p2: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,O]#Y,O2])scalaz.stream.Process[scalaz.stream.Process.Env[I,O]#Y,O2]">++</a> <a href="#scalaz.stream.wye.yipWithL.go" title="(buf: Vector[I])scalaz.stream.Wye[I,O,O2]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWithL.go.buf" title="Vector[I]">buf</a>.<span title="=&gt; scala.collection.immutable.Vector[I]">tail</span><span class="delimiter">)</span>
        case <a href="ReceiveY.scala.html#scalaz.stream.ReceiveY.HaltOne.unapply" title="(ry: scalaz.stream.ReceiveY[Any,Any])Option[scalaz.stream.Cause]">HaltOne</a><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.yipWithL.go.$anonfun.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.yipWithL.go.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#scalaz.stream.wye.yipWithL.go" title="(buf: Vector[I])scalaz.stream.Wye[I,O,O2]">go</a><span class="delimiter">(</span><span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">//////////////////////////////////////////////////////////////////////</span>
  <span class="comment">// Helper combinator functions, useful when working with wye directly</span>
  <span class="comment">//////////////////////////////////////////////////////////////////////</span>

  <span class="comment">/**
   * Transform the left input of the given `Wye` using a `Process1`.
   */</span>
  def <a title="[I0, I, I2, O](p1: scalaz.stream.Process1[I0,I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I0,I2,O]" id="scalaz.stream.wye.attachL">attachL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.attachL;I0">I0</a>,<a title="" id="scalaz.stream.wye.attachL;I">I</a>,<a title="" id="scalaz.stream.wye.attachL;I2">I2</a>,<a title="" id="scalaz.stream.wye.attachL;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[I0,I]" id="scalaz.stream.wye.attachL.p1">p1</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I0,I]">Process1</a><span class="delimiter">[</span>I0,I<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.attachL.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I0,I2,O]">Wye</a><span class="delimiter">[</span>I0,I2,O<span class="delimiter">]</span> =  <span class="delimiter">{</span>
    <a href="#scalaz.stream.wye.attachL.y" title="scalaz.stream.Wye[I,I2,O]">y</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]">step</a> match <span class="delimiter">{</span>
      case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.Emit[O]" id="scalaz.stream.wye.attachL.emt">emt</a>@Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.wye.attachL.os">os</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.wye.attachL.emt" title="scalaz.stream.Process.Emit[O]">emt</a> <a href="Process.scala.html#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I0,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I0,I2]#Y,O]">onHalt</a> <span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.attachL.$anonfun.rsn">rsn</a> =&gt; <a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[I0,I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I0,I2,O]">attachL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.p1" title="scalaz.stream.Process1[I0,I]">p1</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>

      case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitL.unapply" title="(self: scalaz.stream.wye.WyeAwaitL[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitL</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I &gt;: I }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.wye.attachL.p1" title="scalaz.stream.Process1[I0,I]">p1</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I0,Any]#Is,I]">step</a> match <span class="delimiter">{</span>
        case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><span title="Seq[I]">is</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I0,Any]#Is,I]">cont1</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.suspend" title="(p: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I0,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I0,I2]#Y,O]">suspend</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[I0,I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I0,I2,O]">attachL</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I0,Any]#Is,I]">cont1</span>.<a href="Process.scala.html#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I0,Any]#Is,I]">continue</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL" title="(is: Seq[I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">feedL</a><span class="delimiter">(</span><span title="Seq[I]">is</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case Step<span class="delimiter">(</span><a href="process1.scala.html#scalaz.stream.process1.Await1.unapply" title="(self: scalaz.stream.Process1[I0,I])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I0] =&gt; scalaz.stream.Process1[I0,I]]">Await1</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I0] =&gt; scalaz.stream.Process1[I0,I]">rcv1</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I0,Any]#Is,I]">cont1</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.receiveLOr" title="(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I0,I2,O])(rcv: I0 =&gt; scalaz.stream.Wye[I0,I2,O])scalaz.stream.Wye[I0,I2,O]">receiveLOr</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">cause</span> =&gt; <a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[I0,I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I0,I2,O]">attachL</a><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I0])scalaz.stream.Process1[I0,I]">rcv1</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">cause</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I0,Any]#Is[x],I])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I0,Any]#Is[x],I]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I0,Any]#Is,I]">cont1</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
           <span title="I0">i0</span> =&gt; <a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[I0,I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I0,I2,O]">attachL</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.Process1Syntax(ed4aae368f)" title="(self: scalaz.stream.Process1[I0,I])scalaz.stream.Process.Process1Syntax[I0,I]">p1</a>.<a href="Process.scala.html#scalaz.stream.Process;Process1Syntax.feed1" title="(i: I0)scalaz.stream.Process1[I0,I]">feed1</a><span class="delimiter">(</span><span title="I0">i0</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span>
          <span class="delimiter">)</span>
        case <span title="scalaz.stream.Process.Halt">hlt</span>@Halt<span class="delimiter">(</span><span title="scalaz.stream.Cause">cause</span><span class="delimiter">)</span> =&gt;
          <a href="Process.scala.html#scalaz.stream.Process.suspend" title="(p: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Any,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[Any,I2]#Y,O]">suspend</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">cause</span>.<a href="Cause.scala.html#scalaz.stream;Cause.fold" title="(onEnd: =&gt; scalaz.stream.Wye[Any,I2,O])(f: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[Any,I2,O])scalaz.stream.Wye[Any,I2,O]">fold</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[Any,Nothing])(y: scalaz.stream.Wye[Nothing,I2,O])scalaz.stream.Wye[Any,I2,O]">attachL</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Halt">hlt</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.swallowKill" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">swallowKill</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
            <span title="scalaz.stream.Cause.EarlyCause">early</span> =&gt; <a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[Any,Nothing])(y: scalaz.stream.Wye[Nothing,I2,O])scalaz.stream.Wye[Any,I2,O]">attachL</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Halt">hlt</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">early</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="delimiter">}</span>

      case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitR.unapply" title="(self: scalaz.stream.wye.WyeAwaitR[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitR</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I2 &gt;: I2; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.receiveROr" title="(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I0,I2,O])(rcv: I2 =&gt; scalaz.stream.Wye[I0,I2,O])scalaz.stream.Wye[I0,I2,O]">receiveROr</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">early</span> =&gt; <a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[I0,I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I0,I2,O]">attachL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.p1" title="scalaz.stream.Process1[I0,I]">p1</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">early</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
          <span title="I2">i2</span> =&gt; <a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[I0,I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I0,I2,O]">attachL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.p1" title="scalaz.stream.Process1[I0,I]">p1</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feed1R" title="(i2: I2)(w: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">feed1R</a><span class="delimiter">(</span><span title="I2">i2</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>

      case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitBoth.unapply" title="(self: scalaz.stream.wye.WyeAwaitBoth[I,I2,O])Option[scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitBoth</a><span class="delimiter">(</span><span title="scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I2 &gt;: I2; type I &gt;: I; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.wye.attachL.p1" title="scalaz.stream.Process1[I0,I]">p1</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I0,Any]#Is,I]">step</a> match <span class="delimiter">{</span>
        case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><span title="Seq[I]">is</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I0,Any]#Is,I]">cont1</span><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process.suspend" title="(p: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I0,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I0,I2]#Y,O]">suspend</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[I0,I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I0,I2,O]">attachL</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I0,Any]#Is,I]">cont1</span>.<a href="Process.scala.html#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I0,Any]#Is,I]">continue</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL" title="(is: Seq[I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">feedL</a><span class="delimiter">(</span><span title="Seq[I]">is</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case Step<span class="delimiter">(</span><a href="process1.scala.html#scalaz.stream.process1.Await1.unapply" title="(self: scalaz.stream.Process1[I0,I])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I0] =&gt; scalaz.stream.Process1[I0,I]]">Await1</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I0] =&gt; scalaz.stream.Process1[I0,I]">rcv1</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt;
            <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.receiveBoth" title="[I, I2, O](rcv: scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">receiveBoth</a><span title="(rcv: scalaz.stream.ReceiveY[I0,I2] =&gt; scalaz.stream.Wye[I0,I2,O])scalaz.stream.Wye[I0,I2,O]" class="delimiter">[</span><a href="#scalaz.stream.wye.attachL;I0" title="I0">I0</a>,<a href="#scalaz.stream.wye.attachL;I2" title="I2">I2</a>,<a href="#scalaz.stream.wye.attachL;O" title="O">O</a><span class="delimiter">]</span> <a href="#scalaz.stream.wye.attachL.$anonfun.x0$13" title="scalaz.stream.Wye[I0,I2,O]" class="delimiter">{</a>
              case ReceiveL<span class="delimiter">(</span><span title="I0">i0</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[I0,I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I0,I2,O]">attachL</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.Process1Syntax(ed4aae368f)" title="(self: scalaz.stream.Process1[I0,I])scalaz.stream.Process.Process1Syntax[I0,I]">p1</a>.<a href="Process.scala.html#scalaz.stream.Process;Process1Syntax.feed1" title="(i: I0)scalaz.stream.Process1[I0,I]">feed1</a><span class="delimiter">(</span><span title="I0">i0</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span>
              case ReceiveR<span class="delimiter">(</span><span title="I2">i2</span><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[I0,I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I0,I2,O]">attachL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.p1" title="scalaz.stream.Process1[I0,I]">p1</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feed1R" title="(i2: I2)(w: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">feed1R</a><span class="delimiter">(</span><span title="I2">i2</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
              case HaltL<span class="delimiter">(</span><span title="scalaz.stream.Cause">cause</span><span class="delimiter">)</span> =&gt;
                <span title="scalaz.stream.Cause">cause</span>.<a href="Cause.scala.html#scalaz.stream;Cause.fold" title="(onEnd: =&gt; scalaz.stream.Wye[I0,I2,O])(f: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I0,I2,O])scalaz.stream.Wye[I0,I2,O]">fold</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[I0,I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I0,I2,O]">attachL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.p1" title="scalaz.stream.Process1[I0,I]">p1</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.swallowKill" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">swallowKill</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
                 <span title="scalaz.stream.Cause.EarlyCause">early</span> =&gt; <a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[I0,I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I0,I2,O]">attachL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.p1" title="scalaz.stream.Process1[I0,I]">p1</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">early</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="delimiter">)</span>
              case HaltR<span class="delimiter">(</span><span title="scalaz.stream.Cause">cause</span><span class="delimiter">)</span> =&gt;
                <span title="scalaz.stream.Cause">cause</span>.<a href="Cause.scala.html#scalaz.stream;Cause.fold" title="(onEnd: =&gt; scalaz.stream.Wye[I0,I2,O])(f: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I0,I2,O])scalaz.stream.Wye[I0,I2,O]">fold</a><span class="delimiter">(</span> <a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[I0,I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I0,I2,O]">attachL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.p1" title="scalaz.stream.Process1[I0,I]">p1</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectR</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.swallowKill" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">swallowKill</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
                 <span title="scalaz.stream.Cause.EarlyCause">early</span> =&gt; <a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[I0,I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I0,I2,O]">attachL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.p1" title="scalaz.stream.Process1[I0,I]">p1</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectR</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">early</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="delimiter">)</span>
            <span class="delimiter">}</span>
        case <span title="scalaz.stream.Process.Halt">hlt</span>@Halt<span class="delimiter">(</span><span title="scalaz.stream.Cause">cause</span><span class="delimiter">)</span> =&gt;
          val ny = <span title="(v1: scalaz.stream.ReceiveY[I,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><a href="ReceiveY.scala.html#scalaz.stream.ReceiveY;HaltL" title="(cause: scalaz.stream.Cause)scalaz.stream.ReceiveY.HaltL">HaltL</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">cause</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]" id="scalaz.stream.wye.attachL.ny">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span>
          <a href="Process.scala.html#scalaz.stream.Process.suspend" title="(p: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[Any,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[Any,I2]#Y,O]">suspend</a><span class="delimiter">(</span><span title="scalaz.stream.Cause">cause</span>.<a href="Cause.scala.html#scalaz.stream;Cause.fold" title="(onEnd: =&gt; scalaz.stream.Wye[Any,I2,O])(f: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[Any,I2,O])scalaz.stream.Wye[Any,I2,O]">fold</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[Any,Nothing])(y: scalaz.stream.Wye[Nothing,I2,O])scalaz.stream.Wye[Any,I2,O]">attachL</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Halt">hlt</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.ny" title="scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">ny</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.swallowKill" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">swallowKill</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
           <span title="scalaz.stream.Cause.EarlyCause">early</span> =&gt; <a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[Any,Nothing])(y: scalaz.stream.Wye[Nothing,I2,O])scalaz.stream.Wye[Any,I2,O]">attachL</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Halt">hlt</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">early</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL.ny" title="scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">ny</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="delimiter">}</span>

      case <span title="scalaz.stream.Process.Halt">hlt</span>@Halt<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <span title="scalaz.stream.Process.Halt">hlt</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Transform the right input of the given `Wye` using a `Process1`.
   */</span>
  def <a title="[I, I1, I2, O](p: scalaz.stream.Process1[I1,I2])(w: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I1,O]" id="scalaz.stream.wye.attachR">attachR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.attachR;I">I</a>,<a title="" id="scalaz.stream.wye.attachR;I1">I1</a>,<a title="" id="scalaz.stream.wye.attachR;I2">I2</a>,<a title="" id="scalaz.stream.wye.attachR;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process1[I1,I2]" id="scalaz.stream.wye.attachR.p">p</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process1[I1,I2]">Process1</a><span class="delimiter">[</span>I1,I2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.attachR.w">w</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I1,O]">Wye</a><span class="delimiter">[</span>I,I1,O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.flip" title="(y: scalaz.stream.Wye[I1,I,O])scalaz.stream.Wye[I,I1,O]">flip</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachL" title="(p1: scalaz.stream.Process1[I1,I2])(y: scalaz.stream.Wye[I2,I,O])scalaz.stream.Wye[I1,I,O]">attachL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachR.p" title="scalaz.stream.Process1[I1,I2]">p</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.flip" title="(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I2,I,O]">flip</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.attachR.w" title="scalaz.stream.Wye[I,I2,O]">w</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>


  <span class="comment">/**
   * Transforms the wye so it will stop to listen on left side.
   * Instead all requests on the left side are converted to termination with `Kill`,
   * and will terminate once the right side will terminate as well.
   * Transforms `AwaitBoth` to `AwaitR`
   * Transforms `AwaitL` to termination with `End`
   */</span>
  def <a title="[I, I2, O](y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.detach1L">detach1L</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.detach1L;I">I</a>,<a title="" id="scalaz.stream.wye.detach1L;I2">I2</a>,<a title="" id="scalaz.stream.wye.detach1L;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.detach1L.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.detach1L.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.swallowKill" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">swallowKill</a>


  <span class="comment">/** right alternative of detach1L */</span>
  def <a title="[I, I2, O](y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.detach1R">detach1R</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.detach1R;I">I</a>,<a title="" id="scalaz.stream.wye.detach1R;I2">I2</a>,<a title="" id="scalaz.stream.wye.detach1R;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.detach1R.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectR</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.detach1R.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.swallowKill" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">swallowKill</a>

  <span class="comment">/**
   * Feed a single `ReceiveY` value to a `Wye`.
   */</span>
  def <a title="[I, I2, O](r: scalaz.stream.ReceiveY[I,I2])(w: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.feed1">feed1</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.feed1;I">I</a>,<a title="" id="scalaz.stream.wye.feed1;I2">I2</a>,<a title="" id="scalaz.stream.wye.feed1;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.ReceiveY[I,I2]" id="scalaz.stream.wye.feed1.r">r</a>: <a href="ReceiveY.scala.html#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[I,I2]">ReceiveY</a><span class="delimiter">[</span>I,I2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.feed1.w">w</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.feed1.r" title="scalaz.stream.ReceiveY[I,I2]">r</a> match <span class="delimiter">{</span>
      case ReceiveL<span class="delimiter">(</span><a title="I" id="scalaz.stream.wye.feed1.i">i</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.wye.feed1L" title="(i: I)(w: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">feed1L</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feed1.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feed1.w" title="scalaz.stream.Wye[I,I2,O]">w</a><span class="delimiter">)</span>
      case ReceiveR<span class="delimiter">(</span><a title="I2" id="scalaz.stream.wye.feed1.i2">i2</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.wye.feed1R" title="(i2: I2)(w: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">feed1R</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feed1.i2" title="I2">i2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feed1.w" title="scalaz.stream.Wye[I,I2,O]">w</a><span class="delimiter">)</span>
      case HaltL<span class="delimiter">(</span><span title="scalaz.stream.Cause">cause</span><span class="delimiter">)</span> =&gt; <span title="scalaz.stream.Cause">cause</span>.<a href="Cause.scala.html#scalaz.stream;Cause.fold" title="(onEnd: =&gt; scalaz.stream.Wye[I,I2,O])(f: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">fold</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.detach1L" title="(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">detach1L</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feed1.w" title="scalaz.stream.Wye[I,I2,O]">w</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span> =&gt; <a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feed1.w" title="scalaz.stream.Wye[I,I2,O]">w</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case HaltR<span class="delimiter">(</span><span title="scalaz.stream.Cause">cause</span><span class="delimiter">)</span> =&gt; <span title="scalaz.stream.Cause">cause</span>.<a href="Cause.scala.html#scalaz.stream;Cause.fold" title="(onEnd: =&gt; scalaz.stream.Wye[I,I2,O])(f: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">fold</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.detach1R" title="(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">detach1R</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feed1.w" title="scalaz.stream.Wye[I,I2,O]">w</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span> =&gt; <a href="#scalaz.stream.wye.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectR</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feed1.w" title="scalaz.stream.Wye[I,I2,O]">w</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Feed a single value to the left branch of a `Wye`. */</span>
  def <a title="[I, I2, O](i: I)(w: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.feed1L">feed1L</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.feed1L;I">I</a>,<a title="" id="scalaz.stream.wye.feed1L;I2">I2</a>,<a title="" id="scalaz.stream.wye.feed1L;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I" id="scalaz.stream.wye.feed1L.i">i</a>: <a href="#scalaz.stream.wye.feed1L;I" title="I">I</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.feed1L.w">w</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.feedL" title="(is: Seq[I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">feedL</a><span class="delimiter">(</span><span title="(elems: I*)scala.collection.immutable.Vector[I]">Vector</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feed1L.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feed1L.w" title="scalaz.stream.Wye[I,I2,O]">w</a><span class="delimiter">)</span>

  <span class="comment">/** Feed a single value to the right branch of a `Wye`. */</span>
  def <a title="[I, I2, O](i2: I2)(w: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.feed1R">feed1R</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.feed1R;I">I</a>,<a title="" id="scalaz.stream.wye.feed1R;I2">I2</a>,<a title="" id="scalaz.stream.wye.feed1R;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I2" id="scalaz.stream.wye.feed1R.i2">i2</a>: <a href="#scalaz.stream.wye.feed1R;I2" title="I2">I2</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.feed1R.w">w</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> =
    <a href="#scalaz.stream.wye.feedR" title="(i2s: Seq[I2])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">feedR</a><span class="delimiter">(</span><span title="(elems: I2*)scala.collection.immutable.Vector[I2]">Vector</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feed1R.i2" title="I2">i2</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feed1R.w" title="scalaz.stream.Wye[I,I2,O]">w</a><span class="delimiter">)</span>

  <span class="comment">/** Feed a sequence of inputs to the left side of a `Wye`. */</span>
  def <a title="[I, I2, O](is: Seq[I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.feedL">feedL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.feedL;I">I</a>,<a title="" id="scalaz.stream.wye.feedL;I2">I2</a>,<a title="" id="scalaz.stream.wye.feedL;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[I]" id="scalaz.stream.wye.feedL.is">is</a>: <span title="Seq[I]">Seq</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.feedL.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(in: Seq[I], out: Vector[Seq[O]], cur: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.feedL.go">go</a><span class="delimiter">(</span><a title="Seq[I]" id="scalaz.stream.wye.feedL.go.in">in</a>: <span title="Seq[I]">Seq</span><span class="delimiter">[</span>I<span class="delimiter">]</span>, <a title="Vector[Seq[O]]" id="scalaz.stream.wye.feedL.go.out">out</a>: <span title="Vector[Seq[O]]">Vector</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.feedL.go.cur">cur</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL.go.in" title="Seq[I]">in</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#scalaz.stream.wye.feedL.go.cur" title="scalaz.stream.Wye[I,I2,O]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]">step</a> match <span class="delimiter">{</span>
        case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.wye.feedL.go.os">os</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.wye.feedL.go" title="(in: Seq[I], out: Vector[Seq[O]], cur: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL.go.in" title="Seq[I]">in</a>, <a href="#scalaz.stream.wye.feedL.go.out" title="Vector[Seq[O]]">out</a> <span title="(elem: Seq[O])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[Seq[O]],Seq[O],Vector[Seq[O]]])Vector[Seq[O]]">:+</span> <a href="#scalaz.stream.wye.feedL.go.os" title="Seq[O]">os</a>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span>.<a href="Process.scala.html#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">continue</a><span class="delimiter">)</span>

        case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitL.unapply" title="(self: scalaz.stream.wye.WyeAwaitL[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitL</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I &gt;: I }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.wye.feedL.go" title="(in: Seq[I], out: Vector[Seq[O]], cur: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL.go.in" title="Seq[I]">in</a>.<span title="=&gt; Seq[I]">tail</span>, <a href="#scalaz.stream.wye.feedL.go.out" title="Vector[Seq[O]]">out</a>,  <span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: I)scalaz.\/[Nothing,I]">right</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL.go.in" title="Seq[I]">in</a>.<span title="=&gt; I">head</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>

        case Step<span class="delimiter">(</span><a title="scalaz.stream.wye.WyeAwaitR[I,I2,O]" id="scalaz.stream.wye.feedL.go.awt">awt</a>@<a href="#scalaz.stream.wye.AwaitR.unapply" title="(self: scalaz.stream.wye.WyeAwaitR[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitR</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I2 &gt;: I2; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[O])scalaz.stream.Process0[O]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL.go.out" title="Vector[Seq[O]]">out</a>.<span title="(implicit asTraversable: Seq[O] =&gt; scala.collection.GenTraversableOnce[O])scala.collection.immutable.Vector[O]">flatten</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">onHalt</a> <a href="#scalaz.stream.wye.feedL.go.$anonfun.x0$14" title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]" class="delimiter">{</a>
            case <a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a>               =&gt; <a href="#scalaz.stream.wye.feedL.go.awt" title="scalaz.stream.wye.WyeAwaitR[I,I2,O]">awt</a>.<a href="Process.scala.html#scalaz.stream.Process;Await.extend" title="(f: scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.Process.Env[Any,I2]#T[I2],O]">extend</a><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]" id="scalaz.stream.wye.feedL.go.$anonfun.$anonfun.p">p</a> =&gt; <a href="#scalaz.stream.wye.feedL" title="(is: Seq[I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">feedL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL.go.in" title="Seq[I]">in</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL.go.$anonfun.$anonfun.p" title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">p</a> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>
            case <a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.wye.feedL.go.$anonfun.early">early</a>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a> =&gt; <a href="#scalaz.stream.wye.feedL" title="(is: Seq[I])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">feedL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL.go.in" title="Seq[I]">in</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL.go.$anonfun.early" title="scalaz.stream.Cause.EarlyCause">early</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>

        case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitBoth.unapply" title="(self: scalaz.stream.wye.WyeAwaitBoth[I,I2,O])Option[scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitBoth</a><span class="delimiter">(</span><span title="scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I2 &gt;: I2; type I &gt;: I; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.wye.feedL.go" title="(in: Seq[I], out: Vector[Seq[O]], cur: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL.go.in" title="Seq[I]">in</a>.<span title="=&gt; Seq[I]">tail</span>, <a href="#scalaz.stream.wye.feedL.go.out" title="Vector[Seq[O]]">out</a>, <a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">Try</a><span class="delimiter">(</span><span title="(v1: scalaz.stream.ReceiveY[I,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><a href="ReceiveY.scala.html#scalaz.stream.ReceiveY" title="scalaz.stream.ReceiveY.type">ReceiveY</a>.<a href="ReceiveY.scala.html#scalaz.stream.ReceiveY;ReceiveL" title="(get: I)scalaz.stream.ReceiveY.ReceiveL[I]">ReceiveL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL.go.in" title="Seq[I]">in</a>.<span title="=&gt; I">head</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>

        case Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.feedL.go.rsn">rsn</a><span class="delimiter">)</span>                  =&gt;
          <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[O])scalaz.stream.Process0[O]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL.go.out" title="Vector[Seq[O]]">out</a>.<span title="(implicit asTraversable: Seq[O] =&gt; scala.collection.GenTraversableOnce[O])scala.collection.immutable.Vector[O]">flatten</span><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Process[Nothing,O]">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL.go.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>

      <span class="delimiter">}</span> else <a href="#scalaz.stream.wye.feedL.go.cur" title="scalaz.stream.Wye[I,I2,O]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.prepend" title="(os: Seq[O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">prepend</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL.go.out" title="Vector[Seq[O]]">out</a>.<span title="(implicit asTraversable: Seq[O] =&gt; scala.collection.GenTraversableOnce[O])scala.collection.immutable.Vector[O]">flatten</span><span class="delimiter">)</span>

    <span class="delimiter">}</span>
    <a href="#scalaz.stream.wye.feedL.go" title="(in: Seq[I], out: Vector[Seq[O]], cur: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedL.is" title="Seq[I]">is</a>, <span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#scalaz.stream.wye.feedL.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span>

  <span class="delimiter">}</span>

  <span class="comment">/** Feed a sequence of inputs to the right side of a `Wye`. */</span>
  def <a title="[I, I2, O](i2s: Seq[I2])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.feedR">feedR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.feedR;I">I</a>,<a title="" id="scalaz.stream.wye.feedR;I2">I2</a>,<a title="" id="scalaz.stream.wye.feedR;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[I2]" id="scalaz.stream.wye.feedR.i2s">i2s</a>: <span title="Seq[I2]">Seq</span><span class="delimiter">[</span>I2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.feedR.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(in: Seq[I2], out: Vector[Seq[O]], cur: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.feedR.go">go</a><span class="delimiter">(</span><a title="Seq[I2]" id="scalaz.stream.wye.feedR.go.in">in</a>: <span title="Seq[I2]">Seq</span><span class="delimiter">[</span>I2<span class="delimiter">]</span>, <a title="Vector[Seq[O]]" id="scalaz.stream.wye.feedR.go.out">out</a>: <span title="Vector[Seq[O]]">Vector</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.feedR.go.cur">cur</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scalaz.stream.wye.feedR.go.in" title="Seq[I2]">in</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#scalaz.stream.wye.feedR.go.cur" title="scalaz.stream.Wye[I,I2,O]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]">step</a> match <span class="delimiter">{</span>
        case  Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.wye.feedR.go.os">os</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.wye.feedR.go" title="(in: Seq[I2], out: Vector[Seq[O]], cur: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedR.go.in" title="Seq[I2]">in</a>, <a href="#scalaz.stream.wye.feedR.go.out" title="Vector[Seq[O]]">out</a> <span title="(elem: Seq[O])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[Seq[O]],Seq[O],Vector[Seq[O]]])Vector[Seq[O]]">:+</span> <a href="#scalaz.stream.wye.feedR.go.os" title="Seq[O]">os</a>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span>.<a href="Process.scala.html#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">continue</a><span class="delimiter">)</span>

        case Step<span class="delimiter">(</span><a title="scalaz.stream.wye.WyeAwaitL[I,I2,O]" id="scalaz.stream.wye.feedR.go.awt">awt</a>@<a href="#scalaz.stream.wye.AwaitL.unapply" title="(self: scalaz.stream.wye.WyeAwaitL[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitL</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I &gt;: I }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[O])scalaz.stream.Process0[O]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedR.go.out" title="Vector[Seq[O]]">out</a>.<span title="(implicit asTraversable: Seq[O] =&gt; scala.collection.GenTraversableOnce[O])scala.collection.immutable.Vector[O]">flatten</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">onHalt</a> <a href="#scalaz.stream.wye.feedR.go.$anonfun.x0$15" title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]" class="delimiter">{</a>
            case <a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a>               =&gt; <a href="#scalaz.stream.wye.feedR.go.awt" title="scalaz.stream.wye.WyeAwaitL[I,I2,O]">awt</a>.<a href="Process.scala.html#scalaz.stream.Process;Await.extend" title="(f: scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.Process.Env[I,Any]#Is[I],O]">extend</a><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]" id="scalaz.stream.wye.feedR.go.$anonfun.$anonfun.p">p</a> =&gt; <a href="#scalaz.stream.wye.feedR" title="(i2s: Seq[I2])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">feedR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedR.go.in" title="Seq[I2]">in</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedR.go.$anonfun.$anonfun.p" title="scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">p</a> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>
            case <a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.wye.feedR.go.$anonfun.early">early</a>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a> =&gt; <a href="#scalaz.stream.wye.feedR" title="(i2s: Seq[I2])(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">feedR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedR.go.in" title="Seq[I2]">in</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedR.go.$anonfun.early" title="scalaz.stream.Cause.EarlyCause">early</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>

        case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitR.unapply" title="(self: scalaz.stream.wye.WyeAwaitR[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitR</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I2 &gt;: I2; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.wye.feedR.go" title="(in: Seq[I2], out: Vector[Seq[O]], cur: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedR.go.in" title="Seq[I2]">in</a>.<span title="=&gt; Seq[I2]">tail</span>, <a href="#scalaz.stream.wye.feedR.go.out" title="Vector[Seq[O]]">out</a>, <span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: I2)scalaz.\/[Nothing,I2]">right</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedR.go.in" title="Seq[I2]">in</a>.<span title="=&gt; I2">head</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>

        case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitBoth.unapply" title="(self: scalaz.stream.wye.WyeAwaitBoth[I,I2,O])Option[scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitBoth</a><span class="delimiter">(</span><span title="scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I2 &gt;: I2; type I &gt;: I; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.wye.feedR.go" title="(in: Seq[I2], out: Vector[Seq[O]], cur: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedR.go.in" title="Seq[I2]">in</a>.<span title="=&gt; Seq[I2]">tail</span>, <a href="#scalaz.stream.wye.feedR.go.out" title="Vector[Seq[O]]">out</a>, <span title="(v1: scalaz.stream.ReceiveY[I,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><a href="ReceiveY.scala.html#scalaz.stream.ReceiveY" title="scalaz.stream.ReceiveY.type">ReceiveY</a>.<a href="ReceiveY.scala.html#scalaz.stream.ReceiveY;ReceiveR" title="(get: I2)scalaz.stream.ReceiveY.ReceiveR[I2]">ReceiveR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedR.go.in" title="Seq[I2]">in</a>.<span title="=&gt; I2">head</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>

        case Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.feedR.go.rsn">rsn</a><span class="delimiter">)</span>                  =&gt;
          <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[O])scalaz.stream.Process0[O]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedR.go.out" title="Vector[Seq[O]]">out</a>.<span title="(implicit asTraversable: Seq[O] =&gt; scala.collection.GenTraversableOnce[O])scala.collection.immutable.Vector[O]">flatten</span><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.causedBy" title="(cause: scalaz.stream.Cause)scalaz.stream.Process[Nothing,O]">causedBy</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedR.go.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>

      <span class="delimiter">}</span> else <a href="#scalaz.stream.wye.feedR.go.cur" title="scalaz.stream.Wye[I,I2,O]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.prepend" title="(os: Seq[O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">prepend</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedR.go.out" title="Vector[Seq[O]]">out</a>.<span title="(implicit asTraversable: Seq[O] =&gt; scala.collection.GenTraversableOnce[O])scala.collection.immutable.Vector[O]">flatten</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#scalaz.stream.wye.feedR.go" title="(in: Seq[I2], out: Vector[Seq[O]], cur: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.feedR.i2s" title="Seq[I2]">i2s</a>, <span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#scalaz.stream.wye.feedR.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span>

  <span class="delimiter">}</span>

  <span class="comment">/**
   * Convert right requests to left requests and vice versa.
   */</span>
  def <a title="[I, I2, O](y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I2,I,O]" id="scalaz.stream.wye.flip">flip</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.flip;I">I</a>,<a title="" id="scalaz.stream.wye.flip;I2">I2</a>,<a title="" id="scalaz.stream.wye.flip;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.flip.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I2,I,O]">Wye</a><span class="delimiter">[</span>I2,I,O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#scalaz.stream.wye.flip.y" title="scalaz.stream.Wye[I,I2,O]">y</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]">step</a> match <span class="delimiter">{</span>
      case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.wye.flip.os">os</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>       =&gt; <a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[O])scalaz.stream.Process0[O]">emitAll</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.flip.os" title="Seq[O]">os</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I2,I]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I2,I]#Y,O]">onHalt</a> <span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.flip.$anonfun.rsn">rsn</a> =&gt; <a href="#scalaz.stream.wye.flip" title="(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I2,I,O]">flip</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.flip.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>

      case Step<span class="delimiter">(</span><a title="scalaz.stream.wye.WyeAwaitL[I,I2,O]" id="scalaz.stream.wye.flip.awt">awt</a>@<a href="#scalaz.stream.wye.AwaitL.unapply" title="(self: scalaz.stream.wye.WyeAwaitL[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitL</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I &gt;: I }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>    =&gt;
        <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.receiveROr" title="[I, I2, O](fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])(rcv: I2 =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">receiveROr</a><span title="(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I2,I,O])(rcv: I =&gt; scalaz.stream.Wye[I2,I,O])scalaz.stream.Wye[I2,I,O]" class="delimiter">[</span><a href="#scalaz.stream.wye.flip;I2" title="I2">I2</a>, <a href="#scalaz.stream.wye.flip;I" title="I">I</a>, <a href="#scalaz.stream.wye.flip;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span>=&gt;<a href="#scalaz.stream.wye.flip" title="(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I2,I,O]">flip</a><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
          <a title="I" id="scalaz.stream.wye.flip.$anonfun.i">i</a> =&gt; <a href="#scalaz.stream.wye.flip" title="(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I2,I,O]">flip</a><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: I)scalaz.\/[Nothing,I]">right</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.flip.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>

      case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitR.unapply" title="(self: scalaz.stream.wye.WyeAwaitR[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitR</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I2 &gt;: I2; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>    =&gt;
        <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.receiveLOr" title="[I, I2, O](fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])(rcv: I =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">receiveLOr</a><span title="(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I2,I,O])(rcv: I2 =&gt; scalaz.stream.Wye[I2,I,O])scalaz.stream.Wye[I2,I,O]" class="delimiter">[</span><a href="#scalaz.stream.wye.flip;I2" title="I2">I2</a>, <a href="#scalaz.stream.wye.flip;I" title="I">I</a>, <a href="#scalaz.stream.wye.flip;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span> =&gt;<a href="#scalaz.stream.wye.flip" title="(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I2,I,O]">flip</a><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
          <a title="I2" id="scalaz.stream.wye.flip.$anonfun.i2">i2</a> =&gt; <a href="#scalaz.stream.wye.flip" title="(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I2,I,O]">flip</a><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: I2)scalaz.\/[Nothing,I2]">right</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.flip.$anonfun.i2" title="I2">i2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>

      case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitBoth.unapply" title="(self: scalaz.stream.wye.WyeAwaitBoth[I,I2,O])Option[scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitBoth</a><span class="delimiter">(</span><span title="scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I2 &gt;: I2; type I &gt;: I; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.receiveBoth" title="[I, I2, O](rcv: scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">receiveBoth</a><span title="(rcv: scalaz.stream.ReceiveY[I2,I] =&gt; scalaz.stream.Wye[I2,I,O])scalaz.stream.Wye[I2,I,O]" class="delimiter">[</span><a href="#scalaz.stream.wye.flip;I2" title="I2">I2</a>, <a href="#scalaz.stream.wye.flip;I" title="I">I</a>, <a href="#scalaz.stream.wye.flip;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.ReceiveY[I2,I]" id="scalaz.stream.wye.flip.$anonfun.ry">ry</a> =&gt; <a href="#scalaz.stream.wye.flip" title="(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I2,I,O]">flip</a><span class="delimiter">(</span><span title="(v1: scalaz.stream.ReceiveY[I,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.flip.$anonfun.ry" title="scalaz.stream.ReceiveY[I2,I]">ry</a>.<a href="ReceiveY.scala.html#scalaz.stream;ReceiveY.flip" title="=&gt; scalaz.stream.ReceiveY[I,I2]">flip</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>

      case <a title="scalaz.stream.Process.Halt" id="scalaz.stream.wye.flip.hlt">hlt</a>@Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.flip.rsn">rsn</a><span class="delimiter">)</span>           =&gt; <a href="#scalaz.stream.wye.flip.hlt" title="scalaz.stream.Process.Halt">hlt</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Signals to wye, that Left side terminated.
   * Reason for termination is `cause`. Any `Left` requests will be terminated with `cause`
   * Wye will be switched to listen only on Right side, that means Await(Both) is converted to Await(R)
   */</span>
  def <a title="[I, I2, O](cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.disconnectL">disconnectL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.disconnectL;I">I</a>, <a title="" id="scalaz.stream.wye.disconnectL;I2">I2</a>, <a title="" id="scalaz.stream.wye.disconnectL;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.wye.disconnectL.cause">cause</a>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.disconnectL.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]" id="scalaz.stream.wye.disconnectL.ys">ys</a> = <a href="#scalaz.stream.wye.disconnectL.y" title="scalaz.stream.Wye[I,I2,O]">y</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]">step</a>
    <a href="#scalaz.stream.wye.disconnectL.ys" title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]">ys</a> match <span class="delimiter">{</span>
      case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.Emit[O]" id="scalaz.stream.wye.disconnectL.emt">emt</a>@Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.wye.disconnectL.os">os</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.wye.disconnectL.emt" title="scalaz.stream.Process.Emit[O]">emt</a> <a href="Process.scala.html#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">onHalt</a> <span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.disconnectL.$anonfun.rsn">rsn</a> =&gt; <a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>

      case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitL.unapply" title="(self: scalaz.stream.wye.WyeAwaitL[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitL</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I &gt;: I }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="Process.scala.html#scalaz.stream.Process.suspend" title="(p: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">suspend</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>

      case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitR.unapply" title="(self: scalaz.stream.wye.WyeAwaitR[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitR</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I2 &gt;: I2; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.receiveROr" title="[I, I2, O](fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])(rcv: I2 =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">receiveROr</a><span title="(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])(rcv: I2 =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" class="delimiter">[</span><a href="#scalaz.stream.wye.disconnectL;I" title="I">I</a>,<a href="#scalaz.stream.wye.disconnectL;I2" title="I2">I2</a>,<a href="#scalaz.stream.wye.disconnectL;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span> =&gt; <a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
          <a title="I2" id="scalaz.stream.wye.disconnectL.$anonfun.i">i</a> =&gt; <a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: I2)scalaz.\/[Nothing,I2]">right</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL.$anonfun.i" title="I2">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>

      case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitBoth.unapply" title="(self: scalaz.stream.wye.WyeAwaitBoth[I,I2,O])Option[scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitBoth</a><span class="delimiter">(</span><span title="scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I2 &gt;: I2; type I &gt;: I; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.receiveROr" title="(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])(rcv: I2 =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">receiveROr</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span> =&gt; <a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.ReceiveY[I,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><a href="ReceiveY.scala.html#scalaz.stream.ReceiveY;HaltR" title="(cause: scalaz.stream.Cause)scalaz.stream.ReceiveY.HaltR">HaltR</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
         <a title="I2" id="scalaz.stream.wye.disconnectL.$anonfun.i2">i2</a> =&gt; <a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.ReceiveY[I,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><a href="ReceiveY.scala.html#scalaz.stream.ReceiveY;ReceiveR" title="(get: I2)scalaz.stream.ReceiveY.ReceiveR[I2]">ReceiveR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL.$anonfun.i2" title="I2">i2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>

      case <a title="scalaz.stream.Process.Halt" id="scalaz.stream.wye.disconnectL.hlt">hlt</a>@Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.disconnectL.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  <span class="comment">/**
   * Right side alternative for `disconnectL`
   */</span>
  def <a title="[I, I2, O](cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.disconnectR">disconnectR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.disconnectR;I">I</a>, <a title="" id="scalaz.stream.wye.disconnectR;I2">I2</a>, <a title="" id="scalaz.stream.wye.disconnectR;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.wye.disconnectR.cause">cause</a>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.disconnectR.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
      val <a title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]" id="scalaz.stream.wye.disconnectR.ys">ys</a> = <a href="#scalaz.stream.wye.disconnectR.y" title="scalaz.stream.Wye[I,I2,O]">y</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]">step</a>
      <a href="#scalaz.stream.wye.disconnectR.ys" title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]">ys</a> match <span class="delimiter">{</span>
        case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.Emit[O]" id="scalaz.stream.wye.disconnectR.emt">emt</a>@Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.wye.disconnectR.os">os</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.wye.disconnectR.emt" title="scalaz.stream.Process.Emit[O]">emt</a> <a href="Process.scala.html#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">onHalt</a> <span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.disconnectR.$anonfun.rsn">rsn</a> =&gt; <a href="#scalaz.stream.wye.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectR.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectR.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>

        case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitR.unapply" title="(self: scalaz.stream.wye.WyeAwaitR[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitR</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I2 &gt;: I2; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="Process.scala.html#scalaz.stream.Process.suspend" title="(p: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">suspend</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectR.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectR.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>

        case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitL.unapply" title="(self: scalaz.stream.wye.WyeAwaitL[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitL</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I &gt;: I }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.receiveLOr" title="[I, I2, O](fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])(rcv: I =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">receiveLOr</a><span title="(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])(rcv: I =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" class="delimiter">[</span><a href="#scalaz.stream.wye.disconnectR;I" title="I">I</a>,<a href="#scalaz.stream.wye.disconnectR;I2" title="I2">I2</a>,<a href="#scalaz.stream.wye.disconnectR;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span> =&gt; <a href="#scalaz.stream.wye.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectR.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">(</span>
            <span title="I">i</span> =&gt; <a href="#scalaz.stream.wye.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectR.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: I)scalaz.\/[Nothing,I]">right</span><span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>
          <span class="delimiter">)</span>

        case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitBoth.unapply" title="(self: scalaz.stream.wye.WyeAwaitBoth[I,I2,O])Option[scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitBoth</a><span class="delimiter">(</span><span title="scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I2 &gt;: I2; type I &gt;: I; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.receiveLOr" title="(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])(rcv: I =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">receiveLOr</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span> =&gt; <a href="#scalaz.stream.wye.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectR.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.ReceiveY[I,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><a href="ReceiveY.scala.html#scalaz.stream.ReceiveY;HaltL" title="(cause: scalaz.stream.Cause)scalaz.stream.ReceiveY.HaltL">HaltL</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
           <span title="I">i</span> =&gt; <a href="#scalaz.stream.wye.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectR.cause" title="scalaz.stream.Cause.EarlyCause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.ReceiveY[I,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><a href="ReceiveY.scala.html#scalaz.stream.ReceiveY;ReceiveL" title="(get: I)scalaz.stream.ReceiveY.ReceiveL[I]">ReceiveL</a><span class="delimiter">(</span><span title="I">i</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>
          <span class="delimiter">)</span>

        case <a title="scalaz.stream.Process.Halt" id="scalaz.stream.wye.disconnectR.hlt">hlt</a>@Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.disconnectR.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectR.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  <span class="comment">/**
   * Signals to wye that left side halted with `cause`. Wye will be fed with `HaltL(cause)`
   * and will disconnect from Left side.
   */</span>
  def <a title="[I, I2, O](cause: scalaz.stream.Cause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.haltL">haltL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.haltL;I">I</a>, <a title="" id="scalaz.stream.wye.haltL;I2">I2</a>, <a title="" id="scalaz.stream.wye.haltL;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.haltL.cause">cause</a>: <a href="Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.haltL.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]" id="scalaz.stream.wye.haltL.ys">ys</a> = <a href="#scalaz.stream.wye.haltL.y" title="scalaz.stream.Wye[I,I2,O]">y</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]">step</a>
    <a href="#scalaz.stream.wye.haltL.ys" title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]">ys</a> match <span class="delimiter">{</span>
      case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.Emit[O]" id="scalaz.stream.wye.haltL.emt">emt</a>@Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.wye.haltL.os">os</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.wye.haltL.emt" title="scalaz.stream.Process.Emit[O]">emt</a> <a href="Process.scala.html#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">onHalt</a> <span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.haltL.$anonfun.rsn">rsn</a> =&gt; <a href="#scalaz.stream.wye.haltL" title="(cause: scalaz.stream.Cause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">haltL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltL.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltL.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitR.unapply" title="(self: scalaz.stream.wye.WyeAwaitR[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitR</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I2 &gt;: I2; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.receiveROr" title="[I, I2, O](fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])(rcv: I2 =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">receiveROr</a><span title="(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])(rcv: I2 =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" class="delimiter">[</span><a href="#scalaz.stream.wye.haltL;I" title="I">I</a>,<a href="#scalaz.stream.wye.haltL;I2" title="I2">I2</a>,<a href="#scalaz.stream.wye.haltL;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span> =&gt; <a href="#scalaz.stream.wye.haltL" title="(cause: scalaz.stream.Cause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">haltL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltL.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
          <a title="I2" id="scalaz.stream.wye.haltL.$anonfun.i">i</a> =&gt; <a href="#scalaz.stream.wye.haltL" title="(cause: scalaz.stream.Cause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">haltL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltL.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: I2)scalaz.\/[Nothing,I2]">right</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltL.$anonfun.i" title="I2">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>
      case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitL.unapply" title="(self: scalaz.stream.wye.WyeAwaitL[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitL</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I &gt;: I }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.wye.haltL.cause" title="scalaz.stream.Cause">cause</a>.<a href="Cause.scala.html#scalaz.stream;Cause.fold" title="(onEnd: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])(f: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">fold</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltL" title="(cause: scalaz.stream.Cause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">haltL</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltL.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.swallowKill" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">swallowKill</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span> =&gt; <a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitBoth.unapply" title="(self: scalaz.stream.wye.WyeAwaitBoth[I,I2,O])Option[scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitBoth</a><span class="delimiter">(</span><span title="scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I2 &gt;: I2; type I &gt;: I; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
        val ny = <span title="(v1: scalaz.stream.ReceiveY[I,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><a href="ReceiveY.scala.html#scalaz.stream.ReceiveY;HaltL" title="(cause: scalaz.stream.Cause)scalaz.stream.ReceiveY.HaltL">HaltL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltL.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]" id="scalaz.stream.wye.haltL.ny">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span>
        <a href="#scalaz.stream.wye.haltL.cause" title="scalaz.stream.Cause">cause</a>.<a href="Cause.scala.html#scalaz.stream;Cause.fold" title="(onEnd: =&gt; scalaz.stream.Wye[I,I2,O])(f: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">fold</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.detach1L" title="(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">detach1L</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltL.ny" title="scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">ny</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span> =&gt; <a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectL</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltL.ny" title="scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">ny</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.haltL.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltL.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  <span class="comment">/**
   * Right alternative for `haltL`
   */</span>
  def <a title="[I, I2, O](cause: scalaz.stream.Cause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.haltR">haltR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.haltR;I">I</a>, <a title="" id="scalaz.stream.wye.haltR;I2">I2</a>, <a title="" id="scalaz.stream.wye.haltR;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.haltR.cause">cause</a>: <a href="Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.haltR.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I, I2, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]" id="scalaz.stream.wye.haltR.ys">ys</a> = <a href="#scalaz.stream.wye.haltR.y" title="scalaz.stream.Wye[I,I2,O]">y</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]">step</a>
    <a href="#scalaz.stream.wye.haltR.ys" title="scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[I,I2]#Y,O]">ys</a> match <span class="delimiter">{</span>
      case Step<span class="delimiter">(</span><a title="scalaz.stream.Process.Emit[O]" id="scalaz.stream.wye.haltR.emt">emt</a>@Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.wye.haltR.os">os</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.wye.haltR.emt" title="scalaz.stream.Process.Emit[O]">emt</a> <a href="Process.scala.html#scalaz.stream;Process.onHalt" title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">onHalt</a> <span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.haltR.$anonfun.rsn">rsn</a> =&gt; <a href="#scalaz.stream.wye.haltR" title="(cause: scalaz.stream.Cause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">haltR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltR.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltR.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitL.unapply" title="(self: scalaz.stream.wye.WyeAwaitL[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitL</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I &gt;: I }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.receiveLOr" title="[I, I2, O](fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])(rcv: I =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">receiveLOr</a><span title="(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])(rcv: I =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" class="delimiter">[</span><a href="#scalaz.stream.wye.haltR;I" title="I">I</a>,<a href="#scalaz.stream.wye.haltR;I2" title="I2">I2</a>,<a href="#scalaz.stream.wye.haltR;O" title="O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span> =&gt; <a href="#scalaz.stream.wye.haltR" title="(cause: scalaz.stream.Cause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">haltR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltR.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
          <a title="I" id="scalaz.stream.wye.haltR.$anonfun.i">i</a> =&gt; <a href="#scalaz.stream.wye.haltR" title="(cause: scalaz.stream.Cause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">haltR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltR.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: I)scalaz.\/[Nothing,I]">right</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltR.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>
      case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitR.unapply" title="(self: scalaz.stream.wye.WyeAwaitR[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitR</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I2 &gt;: I2; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
        <a href="#scalaz.stream.wye.haltR.cause" title="scalaz.stream.Cause">cause</a>.<a href="Cause.scala.html#scalaz.stream;Cause.fold" title="(onEnd: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])(f: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">fold</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltR" title="(cause: scalaz.stream.Cause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">haltR</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltR.y" title="scalaz.stream.Wye[I,I2,O]">y</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.swallowKill" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">swallowKill</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span> =&gt; <a href="#scalaz.stream.wye.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectR</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.Cause.EarlyCause)scalaz.\/[scalaz.stream.Cause.EarlyCause,Nothing]">left</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O])scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitBoth.unapply" title="(self: scalaz.stream.wye.WyeAwaitBoth[I,I2,O])Option[scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">AwaitBoth</a><span class="delimiter">(</span><span title="scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O] forSome { type I &gt;: I; type I2 &gt;: I2; type I &gt;: I; type I2 &gt;: I2 }">rcv</span><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
        val ny = <span title="(v1: scalaz.stream.ReceiveY[I,I2])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">rcv</span><span class="delimiter">(</span><a href="ReceiveY.scala.html#scalaz.stream.ReceiveY;HaltR" title="(cause: scalaz.stream.Cause)scalaz.stream.ReceiveY.HaltR">HaltR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltR.cause" title="scalaz.stream.Cause">cause</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]" id="scalaz.stream.wye.haltR.ny">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[I,I2]#Y,O]">cont</span>
        <a href="#scalaz.stream.wye.haltR.cause" title="scalaz.stream.Cause">cause</a>.<a href="Cause.scala.html#scalaz.stream;Cause.fold" title="(onEnd: =&gt; scalaz.stream.Wye[I,I2,O])(f: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">fold</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.detach1R" title="(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">detach1R</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltR.ny" title="scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">ny</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span> =&gt; <a href="#scalaz.stream.wye.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]">disconnectR</a><span class="delimiter">(</span><span title="scalaz.stream.Cause.EarlyCause">e</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltR.ny" title="scalaz.stream.Process[[x]scalaz.stream.Process.Env[I,I2]#Y[x],O]">ny</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.haltR.rsn">rsn</a><span class="delimiter">)</span> =&gt; <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.haltR.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  <span class="comment">////////////////////////////////////////////////////////////////////////</span>
  <span class="comment">// Request Algebra</span>
  <span class="comment">////////////////////////////////////////////////////////////////////////</span>

  <span class="comment">/** Indicates required request side */</span>
  trait <a title="trait Request extends AnyRef" id="scalaz.stream.wye;Request">Request</a>

  object <a title="scalaz.stream.wye.Request.type" id="scalaz.stream.wye.Request">Request</a> <a href="#scalaz.stream.wye.Request" title="scalaz.stream.wye.Request.type" class="delimiter">{</a>
    <span class="comment">/** Left side */</span>
    case object <a href="#scalaz.stream.wye.Request.L.productElement.x$1" title="scalaz.stream.wye.Request.L.type" id="scalaz.stream.wye.Request.L.readResolve">L</a> extends <a href="#scalaz.stream.wye;Request" title="scalaz.stream.wye.Request">Request</a>
    <span class="comment">/** Right side */</span>
    case object <a href="#scalaz.stream.wye.Request.R.productElement.x$1" title="scalaz.stream.wye.Request.R.type" id="scalaz.stream.wye.Request.R.readResolve">R</a> extends <a href="#scalaz.stream.wye;Request" title="scalaz.stream.wye.Request">Request</a>
    <span class="comment">/** Both, or Any side */</span>
    case object <a href="#scalaz.stream.wye.Request.Both.productElement.x$1" title="scalaz.stream.wye.Request.Both.type" id="scalaz.stream.wye.Request.Both.readResolve">Both</a> extends <a href="#scalaz.stream.wye;Request" title="scalaz.stream.wye.Request">Request</a>
  <span class="delimiter">}</span>


  <span class="comment">//////////////////////////////////////////////////////////////////////</span>
  <span class="comment">// De-constructors and type helpers</span>
  <span class="comment">//////////////////////////////////////////////////////////////////////</span>

  type <a title="[I, I2, O]scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.Process.Env[I,Any]#Is[I],O]" id="scalaz.stream.wye;WyeAwaitL">WyeAwaitL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye;WyeAwaitL;I">I</a>,<a title="" id="scalaz.stream.wye;WyeAwaitL;I2">I2</a>,<a title="" id="scalaz.stream.wye;WyeAwaitL;O">O</a><span class="delimiter">]</span> = <a href="Process.scala.html#scalaz.stream.Process;Await" title="scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.Process.Env[I,Any]#Is[I],O]">Await</a><span class="delimiter">[</span>Env<span class="delimiter">[</span>I,I2<span class="delimiter">]</span>#Y,Env<span class="delimiter">[</span>I,Any<span class="delimiter">]</span>#Is<span class="delimiter">[</span>I<span class="delimiter">]</span>,O<span class="delimiter">]</span>
  type <a title="[I, I2, O]scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.Process.Env[Any,I2]#T[I2],O]" id="scalaz.stream.wye;WyeAwaitR">WyeAwaitR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye;WyeAwaitR;I">I</a>,<a title="" id="scalaz.stream.wye;WyeAwaitR;I2">I2</a>,<a title="" id="scalaz.stream.wye;WyeAwaitR;O">O</a><span class="delimiter">]</span> = <a href="Process.scala.html#scalaz.stream.Process;Await" title="scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.Process.Env[Any,I2]#T[I2],O]">Await</a><span class="delimiter">[</span>Env<span class="delimiter">[</span>I,I2<span class="delimiter">]</span>#Y,Env<span class="delimiter">[</span>Any,I2<span class="delimiter">]</span>#T<span class="delimiter">[</span>I2<span class="delimiter">]</span>,O<span class="delimiter">]</span>
  type <a title="[I, I2, O]scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]],O]" id="scalaz.stream.wye;WyeAwaitBoth">WyeAwaitBoth</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye;WyeAwaitBoth;I">I</a>,<a title="" id="scalaz.stream.wye;WyeAwaitBoth;I2">I2</a>,<a title="" id="scalaz.stream.wye;WyeAwaitBoth;O">O</a><span class="delimiter">]</span> = <a href="Process.scala.html#scalaz.stream.Process;Await" title="scalaz.stream.Process.Await[scalaz.stream.Process.Env[I,I2]#Y,scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]],O]">Await</a><span class="delimiter">[</span>Env<span class="delimiter">[</span>I,I2<span class="delimiter">]</span>#Y,Env<span class="delimiter">[</span>I,I2<span class="delimiter">]</span>#Y<span class="delimiter">[</span>ReceiveY<span class="delimiter">[</span>I,I2<span class="delimiter">]</span><span class="delimiter">]</span>,O<span class="delimiter">]</span>

  <span class="comment">//correctly typed wye constructors</span>
  def <a title="[I, I2, O](rcv: I =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.receiveL">receiveL</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.receiveL;I">I</a>,<a title="" id="scalaz.stream.wye.receiveL;I2">I2</a>,<a title="" id="scalaz.stream.wye.receiveL;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I =&gt; scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.receiveL.rcv">rcv</a>:I =&gt; Wye<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.await" title="(req: scalaz.stream.Process.Env[I,I2]#Y[I])(rcv: I =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">await</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.L" title="[I]=&gt; scalaz.stream.Process.Env[I,Any]#Is[I]">L</a><span title="scalaz.stream.Process.Env[I,Any]#Is[I]" class="delimiter">[</span><a href="#scalaz.stream.wye.receiveL;I" title="I">I</a><span class="delimiter">]</span>: Env<span class="delimiter">[</span>I,I2<span class="delimiter">]</span>#<a href="Process.scala.html#scalaz.stream.Process;Env;Y" title="scalaz.stream.Process.Env[I,I2]#Y[I]">Y</a><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.receiveL.rcv" title="I =&gt; scalaz.stream.Wye[I,I2,O]">rcv</a><span class="delimiter">)</span>

  def <a title="[I, I2, O](fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])(rcv: I =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.receiveLOr">receiveLOr</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.receiveLOr;I">I</a>,<a title="" id="scalaz.stream.wye.receiveLOr;I2">I2</a>,<a title="" id="scalaz.stream.wye.receiveLOr;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.receiveLOr.fb">fb</a>: EarlyCause =&gt; Wye<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="I =&gt; scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.receiveLOr.rcv">rcv</a>:I =&gt; Wye<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.awaitOr" title="(req: scalaz.stream.Process.Env[I,I2]#Y[I])(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])(rcv: I =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">awaitOr</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.L" title="[I]=&gt; scalaz.stream.Process.Env[I,Any]#Is[I]">L</a><span title="scalaz.stream.Process.Env[I,Any]#Is[I]" class="delimiter">[</span><a href="#scalaz.stream.wye.receiveLOr;I" title="I">I</a><span class="delimiter">]</span>: Env<span class="delimiter">[</span>I,I2<span class="delimiter">]</span>#<a href="Process.scala.html#scalaz.stream.Process;Env;Y" title="scalaz.stream.Process.Env[I,I2]#Y[I]">Y</a><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.receiveLOr.fb" title="scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O]">fb</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.receiveLOr.rcv" title="I =&gt; scalaz.stream.Wye[I,I2,O]">rcv</a><span class="delimiter">)</span>

  def <a title="[I, I2, O](rcv: I2 =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.receiveR">receiveR</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.receiveR;I">I</a>,<a title="" id="scalaz.stream.wye.receiveR;I2">I2</a>,<a title="" id="scalaz.stream.wye.receiveR;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="I2 =&gt; scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.receiveR.rcv">rcv</a>:I2 =&gt; Wye<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.await" title="(req: scalaz.stream.Process.Env[I,I2]#Y[I2])(rcv: I2 =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">await</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.R" title="[I2]=&gt; scalaz.stream.Process.Env[Any,I2]#T[I2]">R</a><span title="scalaz.stream.Process.Env[Any,I2]#T[I2]" class="delimiter">[</span><a href="#scalaz.stream.wye.receiveR;I2" title="I2">I2</a><span class="delimiter">]</span>: Env<span class="delimiter">[</span>I,I2<span class="delimiter">]</span>#<a href="Process.scala.html#scalaz.stream.Process;Env;Y" title="scalaz.stream.Process.Env[I,I2]#Y[I2]">Y</a><span class="delimiter">[</span>I2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.receiveR.rcv" title="I2 =&gt; scalaz.stream.Wye[I,I2,O]">rcv</a><span class="delimiter">)</span>

  def <a title="[I, I2, O](fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])(rcv: I2 =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.receiveROr">receiveROr</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.receiveROr;I">I</a>,<a title="" id="scalaz.stream.wye.receiveROr;I2">I2</a>,<a title="" id="scalaz.stream.wye.receiveROr;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.receiveROr.fb">fb</a>: EarlyCause =&gt; Wye<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="I2 =&gt; scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.receiveROr.rcv">rcv</a>:I2 =&gt; Wye<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.awaitOr" title="(req: scalaz.stream.Process.Env[I,I2]#Y[I2])(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])(rcv: I2 =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">awaitOr</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.R" title="[I2]=&gt; scalaz.stream.Process.Env[Any,I2]#T[I2]">R</a><span title="scalaz.stream.Process.Env[Any,I2]#T[I2]" class="delimiter">[</span><a href="#scalaz.stream.wye.receiveROr;I2" title="I2">I2</a><span class="delimiter">]</span>: Env<span class="delimiter">[</span>I,I2<span class="delimiter">]</span>#<a href="Process.scala.html#scalaz.stream.Process;Env;Y" title="scalaz.stream.Process.Env[I,I2]#Y[I2]">Y</a><span class="delimiter">[</span>I2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.receiveROr.fb" title="scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O]">fb</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.receiveROr.rcv" title="I2 =&gt; scalaz.stream.Wye[I,I2,O]">rcv</a><span class="delimiter">)</span>

  def <a title="[I, I2, O](rcv: scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.receiveBoth">receiveBoth</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.receiveBoth;I">I</a>,<a title="" id="scalaz.stream.wye.receiveBoth;I2">I2</a>,<a title="" id="scalaz.stream.wye.receiveBoth;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.receiveBoth.rcv">rcv</a>:ReceiveY<span class="delimiter">[</span>I,I2<span class="delimiter">]</span> =&gt; Wye<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.await" title="(req: scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]])(rcv: scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">await</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.Both" title="[I, I2]=&gt; scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]">Both</a><span title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]" class="delimiter">[</span><a href="#scalaz.stream.wye.receiveBoth;I" title="I">I</a>,<a href="#scalaz.stream.wye.receiveBoth;I2" title="I2">I2</a><span class="delimiter">]</span>: Env<span class="delimiter">[</span>I,I2<span class="delimiter">]</span>#<a href="Process.scala.html#scalaz.stream.Process;Env;Y" title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]">Y</a><span class="delimiter">[</span>ReceiveY<span class="delimiter">[</span>I,I2<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.receiveBoth.rcv" title="scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O]">rcv</a><span class="delimiter">)</span>

  def <a title="[I, I2, O](fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O])(rcv: scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O])scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.receiveBothOr">receiveBothOr</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.receiveBothOr;I">I</a>,<a title="" id="scalaz.stream.wye.receiveBothOr;I2">I2</a>,<a title="" id="scalaz.stream.wye.receiveBothOr;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.receiveBothOr.fb">fb</a>:EarlyCause =&gt; Wye<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> <span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O]" id="scalaz.stream.wye.receiveBothOr.rcv">rcv</a>:ReceiveY<span class="delimiter">[</span>I,I2<span class="delimiter">]</span> =&gt; Wye<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[I,I2,O]">Wye</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.awaitOr" title="(req: scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]])(fb: scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])(rcv: scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">awaitOr</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.Both" title="[I, I2]=&gt; scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]">Both</a><span title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]" class="delimiter">[</span><a href="#scalaz.stream.wye.receiveBothOr;I" title="I">I</a>,<a href="#scalaz.stream.wye.receiveBothOr;I2" title="I2">I2</a><span class="delimiter">]</span>: Env<span class="delimiter">[</span>I,I2<span class="delimiter">]</span>#<a href="Process.scala.html#scalaz.stream.Process;Env;Y" title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]">Y</a><span class="delimiter">[</span>ReceiveY<span class="delimiter">[</span>I,I2<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.receiveBothOr.fb" title="scalaz.stream.Cause.EarlyCause =&gt; scalaz.stream.Wye[I,I2,O]">fb</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.receiveBothOr.rcv" title="scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O]">rcv</a><span class="delimiter">)</span>


  object <a title="scalaz.stream.wye.AwaitL.type" id="scalaz.stream.wye.AwaitL">AwaitL</a> <a href="#scalaz.stream.wye.AwaitL" title="scalaz.stream.wye.AwaitL.type" class="delimiter">{</a>

    def <a title="[I, I2, O](self: scalaz.stream.wye.WyeAwaitL[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Wye[I,I2,O]]" id="scalaz.stream.wye.AwaitL.unapply">unapply</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.AwaitL.unapply;I">I</a>,<a title="" id="scalaz.stream.wye.AwaitL.unapply;I2">I2</a>,<a title="" id="scalaz.stream.wye.AwaitL.unapply;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.wye.WyeAwaitL[I,I2,O]" id="scalaz.stream.wye.AwaitL.unapply.self">self</a>: <a href="Process.scala.html#scalaz.stream.Process;Await" title="scalaz.stream.wye.WyeAwaitL[I,I2,O]">WyeAwaitL</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>:
    <span title="Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Wye[I,I2,O]]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>EarlyCause \/ I =&gt; Wye<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#scalaz.stream.wye.AwaitL.unapply.self" title="scalaz.stream.wye.WyeAwaitL[I,I2,O]">self</a> match <span class="delimiter">{</span>
      case Await<span class="delimiter">(</span><a title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.Process.Env[I,Any]#Is[I]]" id="scalaz.stream.wye.AwaitL.unapply.req">req</a>,<a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.Process.Env[I,Any]#Is[I]] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]]" id="scalaz.stream.wye.AwaitL.unapply.rcv">rcv</a><span class="delimiter">)</span>
        if <a href="#scalaz.stream.wye.AwaitL.unapply.req" title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.Process.Env[I,Any]#Is[I]]">req</a>.<a href="Process.scala.html#scalaz.stream.Process;Env;Y.tag" title="=&gt; Int">tag</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span> =&gt;
        <span title="(x: scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])Some[scalaz.\/[scalaz.stream.Cause.EarlyCause,I] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]]">Some</span><span class="delimiter">(</span><span class="delimiter">(</span>r : EarlyCause <span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I]">\/</span> I<span class="delimiter">)</span> =&gt;
          <a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitL.unapply.rcv" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.Process.Env[I,Any]#Is[I]] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]]">rcv</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I])scalaz.stream.Process.Trampoline[scalaz.stream.Wye[I,I2,O]]" class="delimiter">[</span><span class="delimiter">(</span>EarlyCause \/ I<span class="delimiter">)</span> =&gt; Trampoline<span class="delimiter">[</span>Wye<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitL.unapply.$anonfun.r" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I]">r</a><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Wye[I,I2,O]],scalaz.Free.Trampoline[scalaz.stream.Wye[I,I2,O]]])scalaz.stream.Wye[I,I2,O]">run</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>
      case _ =&gt; <span title="None.type">None</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Like `AwaitL.unapply` only allows fast test that wye is awaiting on left side */</span>
    object <a title="scalaz.stream.wye.AwaitL.is.type" id="scalaz.stream.wye.AwaitL.is">is</a> <a href="#scalaz.stream.wye.AwaitL.is" title="scalaz.stream.wye.AwaitL.is.type" class="delimiter">{</a>
      def <a title="[I, I2, O](self: scalaz.stream.wye.WyeAwaitL[I,I2,O])Boolean" id="scalaz.stream.wye.AwaitL.is.unapply">unapply</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.AwaitL.is.unapply;I">I</a>,<a title="" id="scalaz.stream.wye.AwaitL.is.unapply;I2">I2</a>,<a title="" id="scalaz.stream.wye.AwaitL.is.unapply;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.wye.WyeAwaitL[I,I2,O]" id="scalaz.stream.wye.AwaitL.is.unapply.self">self</a>: <a href="Process.scala.html#scalaz.stream.Process;Await" title="scalaz.stream.wye.WyeAwaitL[I,I2,O]">WyeAwaitL</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>:<span title="Boolean">Boolean</span> = <a href="#scalaz.stream.wye.AwaitL.is.unapply.self" title="scalaz.stream.wye.WyeAwaitL[I,I2,O]">self</a> match <span class="delimiter">{</span>
        case Await<span class="delimiter">(</span><a title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.Process.Env[I,Any]#Is[I]]" id="scalaz.stream.wye.AwaitL.is.unapply.req">req</a>,<a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.Process.Env[I,Any]#Is[I]] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]]" id="scalaz.stream.wye.AwaitL.is.unapply.rcv">rcv</a><span class="delimiter">)</span> if <a href="#scalaz.stream.wye.AwaitL.is.unapply.req" title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.Process.Env[I,Any]#Is[I]]">req</a>.<a href="Process.scala.html#scalaz.stream.Process;Env;Y.tag" title="=&gt; Int">tag</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span> =&gt; true
        case _ =&gt; false
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span title="AnyRef" class="delimiter">}</span>


  object <a title="scalaz.stream.wye.AwaitR.type" id="scalaz.stream.wye.AwaitR">AwaitR</a> <a href="#scalaz.stream.wye.AwaitR" title="scalaz.stream.wye.AwaitR.type" class="delimiter">{</a>
    def <a title="[I, I2, O](self: scalaz.stream.wye.WyeAwaitR[I,I2,O])Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Wye[I,I2,O]]" id="scalaz.stream.wye.AwaitR.unapply">unapply</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.AwaitR.unapply;I">I</a>,<a title="" id="scalaz.stream.wye.AwaitR.unapply;I2">I2</a>,<a title="" id="scalaz.stream.wye.AwaitR.unapply;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.wye.WyeAwaitR[I,I2,O]" id="scalaz.stream.wye.AwaitR.unapply.self">self</a>: <a href="Process.scala.html#scalaz.stream.Process;Await" title="scalaz.stream.wye.WyeAwaitR[I,I2,O]">WyeAwaitR</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>:
    <span title="Option[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>EarlyCause \/ I2 =&gt; Wye<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#scalaz.stream.wye.AwaitR.unapply.self" title="scalaz.stream.wye.WyeAwaitR[I,I2,O]">self</a> match <span class="delimiter">{</span>
      case Await<span class="delimiter">(</span><a title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.Process.Env[Any,I2]#T[I2]]" id="scalaz.stream.wye.AwaitR.unapply.req">req</a>,<a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.Process.Env[Any,I2]#T[I2]] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]]" id="scalaz.stream.wye.AwaitR.unapply.rcv">rcv</a><span class="delimiter">)</span>
        if <a href="#scalaz.stream.wye.AwaitR.unapply.req" title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.Process.Env[Any,I2]#T[I2]]">req</a>.<a href="Process.scala.html#scalaz.stream.Process;Env;Y.tag" title="=&gt; Int">tag</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span> =&gt; <span title="(x: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])Some[scalaz.\/[scalaz.stream.Cause.EarlyCause,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]]">Some</span><span class="delimiter">(</span><span class="delimiter">(</span>r : EarlyCause <span title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2]">\/</span> I2<span class="delimiter">)</span> =&gt;
        <a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitR.unapply.rcv" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.Process.Env[Any,I2]#T[I2]] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]]">rcv</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,I2])scalaz.stream.Process.Trampoline[scalaz.stream.Wye[I,I2,O]]" class="delimiter">[</span><span class="delimiter">(</span>EarlyCause \/ I2<span class="delimiter">)</span> =&gt; Trampoline<span class="delimiter">[</span>Wye<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitR.unapply.$anonfun.r" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,I2]">r</a><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Wye[I,I2,O]],scalaz.Free.Trampoline[scalaz.stream.Wye[I,I2,O]]])scalaz.stream.Wye[I,I2,O]">run</span><span class="delimiter">)</span>
      <span class="delimiter">)</span>
      case _ =&gt; <span title="None.type">None</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Like `AwaitR.unapply` only allows fast test that wye is awaiting on right side */</span>
    object <a title="scalaz.stream.wye.AwaitR.is.type" id="scalaz.stream.wye.AwaitR.is">is</a> <a href="#scalaz.stream.wye.AwaitR.is" title="scalaz.stream.wye.AwaitR.is.type" class="delimiter">{</a>
      def <a title="[I, I2, O](self: scalaz.stream.wye.WyeAwaitR[I,I2,O])Boolean" id="scalaz.stream.wye.AwaitR.is.unapply">unapply</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.AwaitR.is.unapply;I">I</a>,<a title="" id="scalaz.stream.wye.AwaitR.is.unapply;I2">I2</a>,<a title="" id="scalaz.stream.wye.AwaitR.is.unapply;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.wye.WyeAwaitR[I,I2,O]" id="scalaz.stream.wye.AwaitR.is.unapply.self">self</a>: <a href="Process.scala.html#scalaz.stream.Process;Await" title="scalaz.stream.wye.WyeAwaitR[I,I2,O]">WyeAwaitR</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>:<span title="Boolean">Boolean</span> = <a href="#scalaz.stream.wye.AwaitR.is.unapply.self" title="scalaz.stream.wye.WyeAwaitR[I,I2,O]">self</a> match <span class="delimiter">{</span>
        case Await<span class="delimiter">(</span><a title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.Process.Env[Any,I2]#T[I2]]" id="scalaz.stream.wye.AwaitR.is.unapply.req">req</a>,<a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.Process.Env[Any,I2]#T[I2]] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]]" id="scalaz.stream.wye.AwaitR.is.unapply.rcv">rcv</a><span class="delimiter">)</span> if <a href="#scalaz.stream.wye.AwaitR.is.unapply.req" title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.Process.Env[Any,I2]#T[I2]]">req</a>.<a href="Process.scala.html#scalaz.stream.Process;Env;Y.tag" title="=&gt; Int">tag</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span> =&gt; true
        case _ =&gt; false
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span title="AnyRef" class="delimiter">}</span>
  object <a title="scalaz.stream.wye.AwaitBoth.type" id="scalaz.stream.wye.AwaitBoth">AwaitBoth</a> <a href="#scalaz.stream.wye.AwaitBoth" title="scalaz.stream.wye.AwaitBoth.type" class="delimiter">{</a>
    def <a title="[I, I2, O](self: scalaz.stream.wye.WyeAwaitBoth[I,I2,O])Option[scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O]]" id="scalaz.stream.wye.AwaitBoth.unapply">unapply</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.AwaitBoth.unapply;I">I</a>,<a title="" id="scalaz.stream.wye.AwaitBoth.unapply;I2">I2</a>,<a title="" id="scalaz.stream.wye.AwaitBoth.unapply;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.wye.WyeAwaitBoth[I,I2,O]" id="scalaz.stream.wye.AwaitBoth.unapply.self">self</a>: <a href="Process.scala.html#scalaz.stream.Process;Await" title="scalaz.stream.wye.WyeAwaitBoth[I,I2,O]">WyeAwaitBoth</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>:
    <span title="Option[scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Wye[I,I2,O]]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>ReceiveY<span class="delimiter">[</span>I,I2<span class="delimiter">]</span> =&gt; Wye<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#scalaz.stream.wye.AwaitBoth.unapply.self" title="scalaz.stream.wye.WyeAwaitBoth[I,I2,O]">self</a> match <span class="delimiter">{</span>
      case Await<span class="delimiter">(</span><a title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]]" id="scalaz.stream.wye.AwaitBoth.unapply.req">req</a>,<a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]]" id="scalaz.stream.wye.AwaitBoth.unapply.rcv">rcv</a><span class="delimiter">)</span>
        if <a href="#scalaz.stream.wye.AwaitBoth.unapply.req" title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]]">req</a>.<a href="Process.scala.html#scalaz.stream.Process;Env;Y.tag" title="=&gt; Int">tag</a> <span title="(x: Int)Boolean">==</span> <span title="Int(2)" class="int">2</span> =&gt; <span title="(x: scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])Some[scalaz.stream.ReceiveY[I,I2] =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]]">Some</span><span class="delimiter">(</span><span class="delimiter">(</span>r : <a href="ReceiveY.scala.html#scalaz.stream;ReceiveY" title="scalaz.stream.ReceiveY[I,I2]">ReceiveY</a><span class="delimiter">[</span>I,I2<span class="delimiter">]</span><span class="delimiter">)</span> =&gt;
        <a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O])scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitBoth.unapply.rcv" title="scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]]">rcv</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.ReceiveY[I,I2]])scalaz.stream.Process.Trampoline[scalaz.stream.Wye[I,I2,O]]" class="delimiter">[</span><span class="delimiter">(</span>EarlyCause \/ ReceiveY<span class="delimiter">[</span>I,I2<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; Trampoline<span class="delimiter">[</span>Wye<span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="(v1: scalaz.stream.ReceiveY[I,I2])scalaz.\/[Nothing,scalaz.stream.ReceiveY[I,I2]]">right</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitBoth.unapply.$anonfun.r" title="scalaz.stream.ReceiveY[I,I2]">r</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Wye[I,I2,O]],scalaz.Free.Trampoline[scalaz.stream.Wye[I,I2,O]]])scalaz.stream.Wye[I,I2,O]">run</span><span class="delimiter">)</span>
      <span class="delimiter">)</span>
      case _ =&gt; <span title="None.type">None</span>
    <span class="delimiter">}</span>


    <span class="comment">/** Like `AwaitBoth.unapply` only allows fast test that wye is awaiting on both sides */</span>
    object <a title="scalaz.stream.wye.AwaitBoth.is.type" id="scalaz.stream.wye.AwaitBoth.is">is</a> <a href="#scalaz.stream.wye.AwaitBoth.is" title="scalaz.stream.wye.AwaitBoth.is.type" class="delimiter">{</a>
      def <a title="[I, I2, O](self: scalaz.stream.wye.WyeAwaitBoth[I,I2,O])Boolean" id="scalaz.stream.wye.AwaitBoth.is.unapply">unapply</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.AwaitBoth.is.unapply;I">I</a>,<a title="" id="scalaz.stream.wye.AwaitBoth.is.unapply;I2">I2</a>,<a title="" id="scalaz.stream.wye.AwaitBoth.is.unapply;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.wye.WyeAwaitBoth[I,I2,O]" id="scalaz.stream.wye.AwaitBoth.is.unapply.self">self</a>: <a href="Process.scala.html#scalaz.stream.Process;Await" title="scalaz.stream.wye.WyeAwaitBoth[I,I2,O]">WyeAwaitBoth</a><span class="delimiter">[</span>I,I2,O<span class="delimiter">]</span><span class="delimiter">)</span>:<span title="Boolean">Boolean</span> = <a href="#scalaz.stream.wye.AwaitBoth.is.unapply.self" title="scalaz.stream.wye.WyeAwaitBoth[I,I2,O]">self</a> match <span class="delimiter">{</span>
        case Await<span class="delimiter">(</span><a title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]]" id="scalaz.stream.wye.AwaitBoth.is.unapply.req">req</a>,<a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.stream.Process.Env[I,I2]#Y,O]]" id="scalaz.stream.wye.AwaitBoth.is.unapply.rcv">rcv</a><span class="delimiter">)</span> if <a href="#scalaz.stream.wye.AwaitBoth.is.unapply.req" title="scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.Process.Env[I,I2]#Y[scalaz.stream.ReceiveY[I,I2]]]">req</a>.<a href="Process.scala.html#scalaz.stream.Process;Env;Y.tag" title="=&gt; Int">tag</a> <span title="(x: Int)Boolean">==</span> <span title="Int(2)" class="int">2</span> =&gt; true
        case _ =&gt; false
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span title="AnyRef" class="delimiter">}</span>

  <span class="comment">//////////////////////////////////////////////////////////////////</span>
  <span class="comment">// Implementation</span>
  <span class="comment">//////////////////////////////////////////////////////////////////</span>

  <span class="comment">/**
   * Implementation of wye.
   *
   * @param pl    left process
   * @param pr    right process
   * @param y0    wye to control queueing and merging
   * @param S     strategy, preferably executor service based
   * @tparam L    Type of left process element
   * @tparam R    Type of right process elements
   * @tparam O    Output type of resulting process
   * @return      Process with merged elements.
   */</span>
  def <a title="[L, R, O](pl: scalaz.stream.Process[scalaz.concurrent.Task,L], pr: scalaz.stream.Process[scalaz.concurrent.Task,R])(y0: scalaz.stream.Wye[L,R,O])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,O]" id="scalaz.stream.wye.apply">apply</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.apply;L">L</a>, <a title="" id="scalaz.stream.wye.apply;R">R</a>, <a title="" id="scalaz.stream.wye.apply;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.concurrent.Task,L]" id="scalaz.stream.wye.apply.pl">pl</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,L]">Process</a><span class="delimiter">[</span>Task, L<span class="delimiter">]</span>, <a title="scalaz.stream.Process[scalaz.concurrent.Task,R]" id="scalaz.stream.wye.apply.pr">pr</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,R]">Process</a><span class="delimiter">[</span>Task, R<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[L,R,O]" id="scalaz.stream.wye.apply.y0">y0</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[L,R,O]">Wye</a><span class="delimiter">[</span>L, R, O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream.wye.apply.S">S</a>: <span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,O]">Process</a><span class="delimiter">[</span>Task, O<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.suspend" title="(p: =&gt; scalaz.stream.Process[scalaz.concurrent.Task,O])scalaz.stream.Process[scalaz.concurrent.Task,O]">suspend</a> <span class="delimiter">{</span>

      val <a title="scalaz.stream.Process.Env[L,R]#Left.type" id="scalaz.stream.wye.apply.Left">Left</a> = new <a href="Process.scala.html#scalaz.stream.Process;Env" title="scalaz.stream.Process.Env[L,R]">Env</a><span class="delimiter">[</span>L, R<span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream.Process;Env.Left" title="scalaz.stream.Process.Env[L,R]#Left.type">Left</a>
      val <a title="scalaz.stream.Process.Env[L,R]#Right.type" id="scalaz.stream.wye.apply.Right">Right</a> = new <a href="Process.scala.html#scalaz.stream.Process;Env" title="scalaz.stream.Process.Env[L,R]">Env</a><span class="delimiter">[</span>L, R<span class="delimiter">]</span>.<a href="Process.scala.html#scalaz.stream.Process;Env.Right" title="scalaz.stream.Process.Env[L,R]#Right.type">Right</a>

      sealed trait <a title="trait M extends AnyRef" id="scalaz.stream.wye.apply;M">M</a>
      case class <a href="#scalaz.stream.wye.apply;Ready.productElement.x$1" title="class Ready[A] extends AnyRef with M with Product with Serializable" id="scalaz.stream.wye.apply;Ready.readResolve">Ready</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.apply;Ready;A">A</a><span class="delimiter">]</span><span title="Product" class="delimiter">(</span><a title="scalaz.stream.Process.Env[L,R]#Y[A]" id="scalaz.stream.wye.apply;Ready.side">side</a>: Env<span class="delimiter">[</span>L, R<span class="delimiter">]</span>#<a href="Process.scala.html#scalaz.stream.Process;Env;Y" title="scalaz.stream.Process.Env[L,R]#Y[A]">Y</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])]" id="scalaz.stream.wye.apply;Ready.result">result</a>: Cause <span title="scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])]">\/</span> <span class="delimiter">(</span>Seq<span class="delimiter">[</span>A<span class="delimiter">]</span>, Cont<span class="delimiter">[</span>Task,A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> extends <a href="#scalaz.stream.wye.apply;M" title="M">M</a>
      case class <a title="class Get extends AnyRef with M with Product with Serializable" id="scalaz.stream.wye.apply;Get.readResolve">Get</a><span title="Product" class="delimiter">(</span><a title="scalaz.\/[scalaz.stream.Cause.Terminated,Seq[O]] =&gt; Unit" id="scalaz.stream.wye.apply;Get.cb">cb</a>: <span class="delimiter">(</span>Terminated \/ Seq<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">)</span> extends <a href="#scalaz.stream.wye.apply;M" title="M">M</a>
      case class <a title="class DownDone extends AnyRef with M with Product with Serializable" id="scalaz.stream.wye.apply;DownDone.readResolve">DownDone</a><span title="Product" class="delimiter">(</span><a title="scalaz.\/[Throwable,Unit] =&gt; Unit" id="scalaz.stream.wye.apply;DownDone.cb">cb</a>: <span class="delimiter">(</span>Throwable \/ Unit<span class="delimiter">)</span> =&gt; Unit<span class="delimiter">)</span> extends <a href="#scalaz.stream.wye.apply;M" title="M">M</a>

      type <a title="[A]scalaz.Either3[scalaz.stream.Cause,scalaz.stream.Cause.EarlyCause =&gt; Unit,scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]]" id="scalaz.stream.wye.apply;SideState">SideState</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.apply;SideState;A">A</a><span class="delimiter">]</span> = <span title="scalaz.Either3[scalaz.stream.Cause,scalaz.stream.Cause.EarlyCause =&gt; Unit,scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]]">Either3</span><span class="delimiter">[</span>Cause, EarlyCause =&gt; Unit, Cont<span class="delimiter">[</span>Task,A<span class="delimiter">]</span><span class="delimiter">]</span>

      <span class="comment">//current state of the wye</span>
      var <a title="scalaz.stream.Wye[L,R,O]" id="scalaz.stream.wye.apply.yy">yy</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[L,R,O]">Wye</a><span class="delimiter">[</span>L, R, O<span class="delimiter">]</span> = <a href="#scalaz.stream.wye.apply.y0" title="scalaz.stream.Wye[L,R,O]">y0</a>

      <span class="comment">//cb to be completed for `out` side</span>
      var <a title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]" id="scalaz.stream.wye.apply.out">out</a>: <span title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>Cause \/ Seq<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>  =&gt; Unit<span class="delimiter">]</span> = <span title="None.type">None</span>

      var <a title="Boolean" id="scalaz.stream.wye.apply.downDone">downDone</a>= false

      <span class="comment">//forward referenced actor</span>
      var <a title="scalaz.concurrent.Actor[M]" id="scalaz.stream.wye.apply.a">a</a>: <span title="scalaz.concurrent.Actor[M]">Actor</span><span class="delimiter">[</span>M<span class="delimiter">]</span> = null

      <span class="comment">//Bias for reading from either left or right.</span>
      var <a title="Boolean" id="scalaz.stream.wye.apply.leftBias">leftBias</a>: <span title="Boolean">Boolean</span> = true

      <span class="comment">// states of both sides</span>
      <span class="comment">// todo: resolve when we will get initially &quot;kill&quot;</span>
      def <a title="[A](p: scalaz.stream.Process[scalaz.concurrent.Task,A])scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]" id="scalaz.stream.wye.apply.initial">initial</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.apply.initial;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.concurrent.Task,A]" id="scalaz.stream.wye.apply.initial.p">p</a>:<a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,A]">Process</a><span class="delimiter">[</span>Task,A<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="Process.scala.html#scalaz.stream.Process;Cont" title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]">Cont</a><span class="delimiter">[</span>Task,A<span class="delimiter">]</span> = <span class="delimiter">{</span>
        val <a title="scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,A]]" id="scalaz.stream.wye.apply.initial.next">next</a>: Cause =&gt; Trampoline<span class="delimiter">[</span>Process<span class="delimiter">[</span>Task, A<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">(</span>c:<a href="Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.wye.apply.initial.next.$anonfun.c" title="scalaz.stream.Cause">c</a> match <span class="delimiter">{</span>
          case <a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.Trampoline" title="=&gt; scalaz.Trampoline.type">Trampoline</a>.<span title="(a: scalaz.stream.Process[scalaz.concurrent.Task,A])scalaz.Free.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,A]]">done</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.initial.p" title="scalaz.stream.Process[scalaz.concurrent.Task,A]">p</a><span class="delimiter">)</span>
          case <a title="scalaz.stream.Cause.EarlyCause" id="scalaz.stream.wye.apply.initial.next.$anonfun.e">e</a>: <a href="Cause.scala.html#scalaz.stream.Cause;EarlyCause" title="scalaz.stream.Cause.EarlyCause">EarlyCause</a> =&gt; <a href="Process.scala.html#scalaz.stream.Process.Trampoline" title="=&gt; scalaz.Trampoline.type">Trampoline</a>.<span title="(a: scalaz.stream.Process[scalaz.concurrent.Task,A])scalaz.Free.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,A]]">done</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.initial.p" title="scalaz.stream.Process[scalaz.concurrent.Task,A]">p</a>.<a href="Process.scala.html#scalaz.stream;Process.kill" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,Nothing]">kill</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="Process.scala.html#scalaz.stream.Process;Cont" title="(stack: Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,A]]])scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]">Cont</a><span class="delimiter">(</span><span title="(elems: scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,A]]*)scala.collection.immutable.Vector[scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,A]]]">Vector</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.initial.next" title="scalaz.stream.Cause =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,A]]">next</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      var <a title="SideState[L]" id="scalaz.stream.wye.apply.left">left</a>: <span title="SideState[L]">SideState</span><span class="delimiter">[</span>L<span class="delimiter">]</span> = <span title="scalaz.Either3.type">Either3</span>.<span title="(c: scalaz.stream.Process.Cont[scalaz.concurrent.Task,L])scalaz.Either3[Nothing,Nothing,scalaz.stream.Process.Cont[scalaz.concurrent.Task,L]]">right3</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.initial" title="(p: scalaz.stream.Process[scalaz.concurrent.Task,L])scalaz.stream.Process.Cont[scalaz.concurrent.Task,L]">initial</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.pl" title="scalaz.stream.Process[scalaz.concurrent.Task,L]">pl</a><span class="delimiter">)</span><span class="delimiter">)</span>
      var <a title="SideState[R]" id="scalaz.stream.wye.apply.right">right</a>: <span title="SideState[R]">SideState</span><span class="delimiter">[</span>R<span class="delimiter">]</span> = <span title="scalaz.Either3.type">Either3</span>.<span title="(c: scalaz.stream.Process.Cont[scalaz.concurrent.Task,R])scalaz.Either3[Nothing,Nothing,scalaz.stream.Process.Cont[scalaz.concurrent.Task,R]]">right3</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.initial" title="(p: scalaz.stream.Process[scalaz.concurrent.Task,R])scalaz.stream.Process.Cont[scalaz.concurrent.Task,R]">initial</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.pr" title="scalaz.stream.Process[scalaz.concurrent.Task,R]">pr</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="comment">// runs evaluation of next Seq[A] from either L/R</span>
      <span class="comment">// this signals to actor the next step of either left or right side</span>
      <span class="comment">// whenever that side is ready (emited Seq[O] or is done.</span>
      def <a title="[A](side: scalaz.stream.Process.Env[L,R]#Y[A])(state: SideState[A])SideState[A]" id="scalaz.stream.wye.apply.runSide">runSide</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.apply.runSide;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process.Env[L,R]#Y[A]" id="scalaz.stream.wye.apply.runSide.side">side</a>: Env<span class="delimiter">[</span>L, R<span class="delimiter">]</span>#<a href="Process.scala.html#scalaz.stream.Process;Env;Y" title="scalaz.stream.Process.Env[L,R]#Y[A]">Y</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="SideState[A]" id="scalaz.stream.wye.apply.runSide.state">state</a>: <span title="SideState[A]">SideState</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="SideState[A]">SideState</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#scalaz.stream.wye.apply.runSide.state" title="SideState[A]">state</a> match <span class="delimiter">{</span>
        case Left3<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.apply.runSide.rsn">rsn</a><span class="delimiter">)</span>         =&gt; <a href="#scalaz.stream.wye.apply.a" title="scalaz.concurrent.Actor[M]">a</a> <span title="(a: M)Unit">!</span> <a href="#scalaz.stream.wye.apply;Ready.readResolve" title="[A](side: scalaz.stream.Process.Env[L,R]#Y[A], result: scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])])Ready[A]">Ready</a><span title="(side: scalaz.stream.Process.Env[L,R]#Y[A], result: scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])])Ready[A]" class="delimiter">[</span><a href="#scalaz.stream.wye.apply.runSide;A" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.runSide.side" title="scalaz.stream.Process.Env[L,R]#Y[A]">side</a>, <span title="(a: scalaz.stream.Cause)scalaz.-\/[scalaz.stream.Cause]">-\/</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.runSide.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span><span class="delimiter">)</span>; <a href="#scalaz.stream.wye.apply.runSide.state" title="SideState[A]">state</a> <span class="comment">//just safety callback</span>
        case Middle3<span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause =&gt; Unit" id="scalaz.stream.wye.apply.runSide.interrupt">interrupt</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.wye.apply.runSide.state" title="SideState[A]">state</a> <span class="comment">//no-op already awaiting the result  //todo: don't wee nedd a calback there as well.</span>
        case Right3<span class="delimiter">(</span><a title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]" id="scalaz.stream.wye.apply.runSide.cont">cont</a><span class="delimiter">)</span>       =&gt; <span title="scalaz.Either3.type">Either3</span>.<span title="(b: scalaz.stream.Cause.EarlyCause =&gt; Unit)scalaz.Either3[Nothing,scalaz.stream.Cause.EarlyCause =&gt; Unit,Nothing]">middle3</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.runSide.cont" title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]">cont</a>.<a href="Process.scala.html#scalaz.stream.Process.SourceSyntax" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,A])scalaz.stream.Process.SourceSyntax[A]">continue</a> <a href="Process.scala.html#scalaz.stream.Process;SourceSyntax.stepAsync" title="(cb: scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])] =&gt; Unit)(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Cause.EarlyCause =&gt; Unit">stepAsync</a> <span class="delimiter">{</span> <a title="scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])]" id="scalaz.stream.wye.apply.runSide.$anonfun.res">res</a> =&gt; <a href="#scalaz.stream.wye.apply.a" title="scalaz.concurrent.Actor[M]">a</a> <span title="(a: M)Unit">!</span> <a href="#scalaz.stream.wye.apply;Ready.readResolve" title="[A](side: scalaz.stream.Process.Env[L,R]#Y[A], result: scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])])Ready[A]">Ready</a><span title="(side: scalaz.stream.Process.Env[L,R]#Y[A], result: scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])])Ready[A]" class="delimiter">[</span><a href="#scalaz.stream.wye.apply.runSide;A" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.runSide.side" title="scalaz.stream.Process.Env[L,R]#Y[A]">side</a>, <a href="#scalaz.stream.wye.apply.runSide.$anonfun.res" title="scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])]">res</a><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      val <a title="SideState[L] =&gt; SideState[L]" id="scalaz.stream.wye.apply.runSideLeft">runSideLeft</a> = <a href="#scalaz.stream.wye.apply.runSide" title="(side: scalaz.stream.Process.Env[L,R]#Y[L])(state: SideState[L])SideState[L]">runSide</a><a href="#scalaz.stream.wye.apply.runSideLeft.$anonfun.state" title="SideState[L]" class="delimiter">(</a><a href="#scalaz.stream.wye.apply.Left" title="scalaz.stream.Process.Env[L,R]#Left.type">Left</a><span class="delimiter">)</span> _
      val <a title="SideState[R] =&gt; SideState[R]" id="scalaz.stream.wye.apply.runSideRight">runSideRight</a> = <a href="#scalaz.stream.wye.apply.runSide" title="(side: scalaz.stream.Process.Env[L,R]#Y[R])(state: SideState[R])SideState[R]">runSide</a><a href="#scalaz.stream.wye.apply.runSideRight.$anonfun.state" title="SideState[R]" class="delimiter">(</a><a href="#scalaz.stream.wye.apply.Right" title="scalaz.stream.Process.Env[L,R]#Right.type">Right</a><span class="delimiter">)</span> _


      <span class="comment">// kills the given side either interrupts the execution</span>
      <span class="comment">// or creates next step for the process and then runs killed step.</span>
      <span class="comment">// note that this function apart from returning the next state perform the side effects</span>
      def <a title="[A](side: scalaz.stream.Process.Env[L,R]#Y[A])(state: SideState[A])SideState[A]" id="scalaz.stream.wye.apply.kill">kill</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.apply.kill;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process.Env[L,R]#Y[A]" id="scalaz.stream.wye.apply.kill.side">side</a>: Env<span class="delimiter">[</span>L, R<span class="delimiter">]</span>#<a href="Process.scala.html#scalaz.stream.Process;Env;Y" title="scalaz.stream.Process.Env[L,R]#Y[A]">Y</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="SideState[A]" id="scalaz.stream.wye.apply.kill.state">state</a>: <span title="SideState[A]">SideState</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="SideState[A]">SideState</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
        <a href="#scalaz.stream.wye.apply.kill.state" title="SideState[A]">state</a> match <span class="delimiter">{</span>
          case Middle3<span class="delimiter">(</span><a title="scalaz.stream.Cause.EarlyCause =&gt; Unit" id="scalaz.stream.wye.apply.kill.interrupt">interrupt</a><span class="delimiter">)</span> =&gt;
            <a href="#scalaz.stream.wye.apply.kill.interrupt" title="(v1: scalaz.stream.Cause.EarlyCause)Unit">interrupt</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span>
            <span title="scalaz.Either3.type">Either3</span>.<span title="(b: scalaz.stream.Cause =&gt; Unit)scalaz.Either3[Nothing,scalaz.stream.Cause =&gt; Unit,Nothing]">middle3</span><span class="delimiter">(</span><span class="delimiter">(</span>_: <a href="Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a><span class="delimiter">)</span> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">//rest the interrupt so it won't get interrupted again</span>

          case Right3<span class="delimiter">(</span><a title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]" id="scalaz.stream.wye.apply.kill.cont">cont</a><span class="delimiter">)</span> =&gt;
            <span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process.SourceSyntax" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,A])scalaz.stream.Process.SourceSyntax[A]">+:</a> <a href="#scalaz.stream.wye.apply.kill.cont" title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]">cont</a><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;SourceSyntax.stepAsync" title="(cb: scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])] =&gt; Unit)(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Cause.EarlyCause =&gt; Unit">stepAsync</a> <span class="delimiter">{</span> <a title="scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])]" id="scalaz.stream.wye.apply.kill.$anonfun.x$47">_</a> =&gt; <a href="#scalaz.stream.wye.apply.a" title="scalaz.concurrent.Actor[M]">a</a> <span title="(a: M)Unit">!</span> <a href="#scalaz.stream.wye.apply;Ready.readResolve" title="[A](side: scalaz.stream.Process.Env[L,R]#Y[A], result: scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])])Ready[A]">Ready</a><span title="(side: scalaz.stream.Process.Env[L,R]#Y[A], result: scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])])Ready[A]" class="delimiter">[</span><a href="#scalaz.stream.wye.apply.kill;A" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.kill.side" title="scalaz.stream.Process.Env[L,R]#Y[A]">side</a>, <span title="(a: scalaz.stream.Cause.Kill.type)scalaz.-\/[scalaz.stream.Cause.Kill.type]">-\/</span><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
            <span title="scalaz.Either3.type">Either3</span>.<span title="(b: scalaz.stream.Cause =&gt; Unit)scalaz.Either3[Nothing,scalaz.stream.Cause =&gt; Unit,Nothing]">middle3</span><span class="delimiter">(</span><span class="delimiter">(</span>_: <a href="Cause.scala.html#scalaz.stream;Cause" title="scalaz.stream.Cause">Cause</a><span class="delimiter">)</span> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// no-op cleanup can't be interrupted</span>

          case <a title="scalaz.Left3[scalaz.stream.Cause,scalaz.stream.Cause.EarlyCause =&gt; Unit,scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]]" id="scalaz.stream.wye.apply.kill.left">left</a>@Left3<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
            <a href="#scalaz.stream.wye.apply.kill.left" title="scalaz.Left3[scalaz.stream.Cause,scalaz.stream.Cause.EarlyCause =&gt; Unit,scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]]">left</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      def <a title="=&gt; SideState[L] =&gt; SideState[L]" id="scalaz.stream.wye.apply.killLeft">killLeft</a> = <a href="#scalaz.stream.wye.apply.kill" title="(side: scalaz.stream.Process.Env[L,R]#Y[L])(state: SideState[L])SideState[L]">kill</a><a href="#scalaz.stream.wye.apply.killLeft.$anonfun.state" title="SideState[L]" class="delimiter">(</a><a href="#scalaz.stream.wye.apply.Left" title="scalaz.stream.Process.Env[L,R]#Left.type">Left</a><span class="delimiter">)</span> _
      def <a title="=&gt; SideState[R] =&gt; SideState[R]" id="scalaz.stream.wye.apply.killRight">killRight</a> = <a href="#scalaz.stream.wye.apply.kill" title="(side: scalaz.stream.Process.Env[L,R]#Y[R])(state: SideState[R])SideState[R]">kill</a><a href="#scalaz.stream.wye.apply.killRight.$anonfun.state" title="SideState[R]" class="delimiter">(</a><a href="#scalaz.stream.wye.apply.Right" title="scalaz.stream.Process.Env[L,R]#Right.type">Right</a><span class="delimiter">)</span> _

      <span class="comment">//checks if given state is done</span>
      def <a title="[A](state: SideState[A])Boolean" id="scalaz.stream.wye.apply.isDone">isDone</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.apply.isDone;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="SideState[A]" id="scalaz.stream.wye.apply.isDone.state">state</a>: <span title="SideState[A]">SideState</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#scalaz.stream.wye.apply.isDone.state" title="SideState[A]">state</a>.<span title="(z: =&gt; Boolean)(f: scalaz.stream.Cause =&gt; Boolean)Boolean">leftOr</span><span class="delimiter">(</span>false<span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.apply.isDone.$anonfun.x$49">_</a> =&gt; true<span class="delimiter">)</span>


      <span class="comment">// halts the open request if wye and L/R are done, and returns None</span>
      <span class="comment">// otherwise returns cb</span>
      def <a title="(y: scalaz.stream.Wye[L,R,O], l: SideState[L], r: SideState[R], cb: Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]" id="scalaz.stream.wye.apply.haltIfDone">haltIfDone</a><span class="delimiter">(</span>
        <a title="scalaz.stream.Wye[L,R,O]" id="scalaz.stream.wye.apply.haltIfDone.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[L,R,O]">Wye</a><span class="delimiter">[</span>L, R, O<span class="delimiter">]</span>
        , <a title="SideState[L]" id="scalaz.stream.wye.apply.haltIfDone.l">l</a>: <span title="SideState[L]">SideState</span><span class="delimiter">[</span>L<span class="delimiter">]</span>
        , <a title="SideState[R]" id="scalaz.stream.wye.apply.haltIfDone.r">r</a>: <span title="SideState[R]">SideState</span><span class="delimiter">[</span>R<span class="delimiter">]</span>
        , <a title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]" id="scalaz.stream.wye.apply.haltIfDone.cb">cb</a>: <span title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>Cause \/ Seq<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">]</span>
        <span class="delimiter">)</span>: <span title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>Cause \/ Seq<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">]</span> = <span class="delimiter">{</span>
        <a href="#scalaz.stream.wye.apply.haltIfDone.cb" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">cb</a> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><a title="scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit" id="scalaz.stream.wye.apply.haltIfDone.cb0">cb0</a><span class="delimiter">)</span> =&gt;
            if <span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.isDone" title="(state: SideState[L])Boolean">isDone</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.haltIfDone.l" title="SideState[L]">l</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#scalaz.stream.wye.apply.isDone" title="(state: SideState[R])Boolean">isDone</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.haltIfDone.r" title="SideState[R]">r</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#scalaz.stream.wye.apply.haltIfDone.y" title="scalaz.stream.Wye[L,R,O]">y</a>.<a href="Process.scala.html#scalaz.stream;Process.unemit" title="=&gt; (Seq[O], scalaz.stream.Process[scalaz.stream.Process.Env[L,R]#Y,O])">unemit</a>.<span title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[L,R]#Y,O]">_2</span> match <span class="delimiter">{</span>
                case Halt<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.apply.haltIfDone.rsn">rsn</a><span class="delimiter">)</span> =&gt;
                  <a href="#scalaz.stream.wye.apply.yy" title="scalaz.stream.Wye[L,R,O]">yy</a> = <a href="Process.scala.html#scalaz.stream.Process;Halt" title="(cause: scalaz.stream.Cause)scalaz.stream.Process.Halt">Halt</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.haltIfDone.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>
                  <a href="#scalaz.stream.wye.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.haltIfDone.cb0" title="(v1: scalaz.\/[scalaz.stream.Cause,Seq[O]])Unit">cb0</a><span class="delimiter">(</span><span title="(a: scalaz.stream.Cause)scalaz.-\/[scalaz.stream.Cause]">-\/</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.haltIfDone.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>; <span title="None.type">None</span>
                case <a title="scalaz.stream.Process[scalaz.stream.Process.Env[L,R]#Y,O]" id="scalaz.stream.wye.apply.haltIfDone.other">other</a>     =&gt; <a href="#scalaz.stream.wye.apply.haltIfDone.cb" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">cb</a>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span> else <a href="#scalaz.stream.wye.apply.haltIfDone.cb" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">cb</a>
          case <span title="None.type">None</span>      =&gt; <span title="None.type">None</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <span class="comment">// Consumes any output form either side and updates wye with it.</span>
      <span class="comment">// note it signals if the other side has to be killed</span>
      def <a title="[A](side: scalaz.stream.Process.Env[L,R]#Y[A])(result: scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])])(SideState[A], scalaz.\/[scalaz.stream.Cause,Seq[A]])" id="scalaz.stream.wye.apply.sideReady">sideReady</a><span class="delimiter">[</span><a title="" id="scalaz.stream.wye.apply.sideReady;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span>
        <a title="scalaz.stream.Process.Env[L,R]#Y[A]" id="scalaz.stream.wye.apply.sideReady.side">side</a>: Env<span class="delimiter">[</span>L, R<span class="delimiter">]</span>#<a href="Process.scala.html#scalaz.stream.Process;Env;Y" title="scalaz.stream.Process.Env[L,R]#Y[A]">Y</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>
        <a title="scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])]" id="scalaz.stream.wye.apply.sideReady.result">result</a>: Cause <span title="scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])]">\/</span> <span class="delimiter">(</span>Seq<span class="delimiter">[</span>A<span class="delimiter">]</span>, Cont<span class="delimiter">[</span>Task,A<span class="delimiter">]</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>: <span title="(SideState[A], scalaz.\/[scalaz.stream.Cause,Seq[A]])" class="delimiter">(</span>SideState<span class="delimiter">[</span>A<span class="delimiter">]</span>, <span class="delimiter">(</span>Cause \/ Seq<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <a href="#scalaz.stream.wye.apply.sideReady.result" title="scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])]">result</a> match <span class="delimiter">{</span>
          case -\/<span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.apply.sideReady.rsn">rsn</a><span class="delimiter">)</span>        =&gt; <span title="(_1: scalaz.Either3[scalaz.stream.Cause,Nothing,Nothing], _2: scalaz.-\/[scalaz.stream.Cause])(scalaz.Either3[scalaz.stream.Cause,Nothing,Nothing], scalaz.-\/[scalaz.stream.Cause])" class="delimiter">(</span><span title="scalaz.Either3.type">Either3</span>.<span title="(a: scalaz.stream.Cause)scalaz.Either3[scalaz.stream.Cause,Nothing,Nothing]">left3</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReady.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span>, <span title="(a: scalaz.stream.Cause)scalaz.-\/[scalaz.stream.Cause]">-\/</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReady.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span><span class="delimiter">)</span>
          case \/-<span class="delimiter">(</span><span class="delimiter">(</span><a title="Seq[A]" id="scalaz.stream.wye.apply.sideReady.as">as</a>, <a title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]" id="scalaz.stream.wye.apply.sideReady.next">next</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span title="(_1: scalaz.Either3[Nothing,Nothing,scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]], _2: scalaz.\/-[Seq[A]])(scalaz.Either3[Nothing,Nothing,scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]], scalaz.\/-[Seq[A]])" class="delimiter">(</span><span title="scalaz.Either3.type">Either3</span>.<span title="(c: scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])scalaz.Either3[Nothing,Nothing,scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]]">right3</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReady.next" title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,A]">next</a><span class="delimiter">)</span>, <span title="(b: Seq[A])scalaz.\/-[Seq[A]]">\/-</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReady.as" title="Seq[A]">as</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      def <a title="(result: scalaz.\/[scalaz.stream.Cause,(Seq[L], scalaz.stream.Process.Cont[scalaz.concurrent.Task,L])], y: scalaz.stream.Wye[L,R,O])scalaz.stream.Wye[L,R,O]" id="scalaz.stream.wye.apply.sideReadyLeft">sideReadyLeft</a><span class="delimiter">(</span>
        <a title="scalaz.\/[scalaz.stream.Cause,(Seq[L], scalaz.stream.Process.Cont[scalaz.concurrent.Task,L])]" id="scalaz.stream.wye.apply.sideReadyLeft.result">result</a>: Cause <span title="scalaz.\/[scalaz.stream.Cause,(Seq[L], scalaz.stream.Process.Cont[scalaz.concurrent.Task,L])]">\/</span> <span class="delimiter">(</span>Seq<span class="delimiter">[</span>L<span class="delimiter">]</span>, Cont<span class="delimiter">[</span>Task,L<span class="delimiter">]</span><span class="delimiter">)</span>
        , <a title="scalaz.stream.Wye[L,R,O]" id="scalaz.stream.wye.apply.sideReadyLeft.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[L,R,O]">Wye</a><span class="delimiter">[</span>L, R, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[L,R,O]">Wye</a><span class="delimiter">[</span>L, R, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
        val <a href="#scalaz.stream.wye.apply.sideReadyLeft.state" title="(SideState[L], scalaz.\/[scalaz.stream.Cause,Seq[L]])" class="delimiter">(</a><a href="#scalaz.stream.wye.apply.sideReadyLeft.x$50" title="SideState[L]" id="scalaz.stream.wye.apply.sideReadyLeft.state">state</a>, <a href="#scalaz.stream.wye.apply.sideReadyLeft.x$50" title="scalaz.\/[scalaz.stream.Cause,Seq[L]]" id="scalaz.stream.wye.apply.sideReadyLeft.input">input</a><span class="delimiter">)</span> = <a href="#scalaz.stream.wye.apply.sideReady" title="(side: scalaz.stream.Process.Env[L,R]#Y[L])(result: scalaz.\/[scalaz.stream.Cause,(Seq[L], scalaz.stream.Process.Cont[scalaz.concurrent.Task,L])])(SideState[L], scalaz.\/[scalaz.stream.Cause,Seq[L]])">sideReady</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.Left" title="scalaz.stream.Process.Env[L,R]#Left.type">Left</a><span class="delimiter">)</span><span title="(SideState[L], scalaz.\/[scalaz.stream.Cause,Seq[L]]) @unchecked" class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReadyLeft.result" title="scalaz.\/[scalaz.stream.Cause,(Seq[L], scalaz.stream.Process.Cont[scalaz.concurrent.Task,L])]">result</a><span class="delimiter">)</span>
        <a href="#scalaz.stream.wye.apply.left" title="SideState[L]">left</a> = <a href="#scalaz.stream.wye.apply.sideReadyLeft.state" title="SideState[L]">state</a>
        <a href="#scalaz.stream.wye.apply.sideReadyLeft.input" title="scalaz.\/[scalaz.stream.Cause,Seq[L]]">input</a>.<span title="(l: scalaz.stream.Cause =&gt; scalaz.stream.Wye[L,R,O], r: Seq[L] =&gt; scalaz.stream.Wye[L,R,O])scalaz.stream.Wye[L,R,O]">fold</span><span class="delimiter">(</span>
          <a title="scalaz.stream.Cause" id="scalaz.stream.wye.apply.sideReadyLeft.$anonfun.rsn">rsn</a> =&gt; <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.haltL" title="(cause: scalaz.stream.Cause)(y: scalaz.stream.Wye[L,R,O])scalaz.stream.Wye[L,R,O]">haltL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReadyLeft.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReadyLeft.y" title="scalaz.stream.Wye[L,R,O]">y</a><span class="delimiter">)</span>
          , <a title="Seq[L]" id="scalaz.stream.wye.apply.sideReadyLeft.$anonfun.ls">ls</a> =&gt; <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.feedL" title="(is: Seq[L])(y: scalaz.stream.Wye[L,R,O])scalaz.stream.Wye[L,R,O]">feedL</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReadyLeft.$anonfun.ls" title="Seq[L]">ls</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReadyLeft.y" title="scalaz.stream.Wye[L,R,O]">y</a><span class="delimiter">)</span>
        <span class="delimiter">)</span>
      <span class="delimiter">}</span>

      def <a title="(result: scalaz.\/[scalaz.stream.Cause,(Seq[R], scalaz.stream.Process.Cont[scalaz.concurrent.Task,R])], y: scalaz.stream.Wye[L,R,O])scalaz.stream.Wye[L,R,O]" id="scalaz.stream.wye.apply.sideReadyRight">sideReadyRight</a><span class="delimiter">(</span>
        <a title="scalaz.\/[scalaz.stream.Cause,(Seq[R], scalaz.stream.Process.Cont[scalaz.concurrent.Task,R])]" id="scalaz.stream.wye.apply.sideReadyRight.result">result</a>: Cause <span title="scalaz.\/[scalaz.stream.Cause,(Seq[R], scalaz.stream.Process.Cont[scalaz.concurrent.Task,R])]">\/</span> <span class="delimiter">(</span>Seq<span class="delimiter">[</span>R<span class="delimiter">]</span>, Cont<span class="delimiter">[</span>Task,R<span class="delimiter">]</span><span class="delimiter">)</span>
        , <a title="scalaz.stream.Wye[L,R,O]" id="scalaz.stream.wye.apply.sideReadyRight.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[L,R,O]">Wye</a><span class="delimiter">[</span>L, R, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[L,R,O]">Wye</a><span class="delimiter">[</span>L, R, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
        val <a href="#scalaz.stream.wye.apply.sideReadyRight.state" title="(SideState[R], scalaz.\/[scalaz.stream.Cause,Seq[R]])" class="delimiter">(</a><a href="#scalaz.stream.wye.apply.sideReadyRight.x$51" title="SideState[R]" id="scalaz.stream.wye.apply.sideReadyRight.state">state</a>, <a href="#scalaz.stream.wye.apply.sideReadyRight.x$51" title="scalaz.\/[scalaz.stream.Cause,Seq[R]]" id="scalaz.stream.wye.apply.sideReadyRight.input">input</a><span class="delimiter">)</span> = <a href="#scalaz.stream.wye.apply.sideReady" title="(side: scalaz.stream.Process.Env[L,R]#Y[R])(result: scalaz.\/[scalaz.stream.Cause,(Seq[R], scalaz.stream.Process.Cont[scalaz.concurrent.Task,R])])(SideState[R], scalaz.\/[scalaz.stream.Cause,Seq[R]])">sideReady</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.Right" title="scalaz.stream.Process.Env[L,R]#Right.type">Right</a><span class="delimiter">)</span><span title="(SideState[R], scalaz.\/[scalaz.stream.Cause,Seq[R]]) @unchecked" class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReadyRight.result" title="scalaz.\/[scalaz.stream.Cause,(Seq[R], scalaz.stream.Process.Cont[scalaz.concurrent.Task,R])]">result</a><span class="delimiter">)</span>
        <a href="#scalaz.stream.wye.apply.right" title="SideState[R]">right</a> = <a href="#scalaz.stream.wye.apply.sideReadyRight.state" title="SideState[R]">state</a>
        <a href="#scalaz.stream.wye.apply.sideReadyRight.input" title="scalaz.\/[scalaz.stream.Cause,Seq[R]]">input</a>.<span title="(l: scalaz.stream.Cause =&gt; scalaz.stream.Wye[L,R,O], r: Seq[R] =&gt; scalaz.stream.Wye[L,R,O])scalaz.stream.Wye[L,R,O]">fold</span><span class="delimiter">(</span>
          <a title="scalaz.stream.Cause" id="scalaz.stream.wye.apply.sideReadyRight.$anonfun.rsn">rsn</a> =&gt; <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.haltR" title="(cause: scalaz.stream.Cause)(y: scalaz.stream.Wye[L,R,O])scalaz.stream.Wye[L,R,O]">haltR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReadyRight.$anonfun.rsn" title="scalaz.stream.Cause">rsn</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReadyRight.y" title="scalaz.stream.Wye[L,R,O]">y</a><span class="delimiter">)</span>
          , <a title="Seq[R]" id="scalaz.stream.wye.apply.sideReadyRight.$anonfun.rs">rs</a> =&gt; <a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.feedR" title="(i2s: Seq[R])(y: scalaz.stream.Wye[L,R,O])scalaz.stream.Wye[L,R,O]">feedR</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReadyRight.$anonfun.rs" title="Seq[R]">rs</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReadyRight.y" title="scalaz.stream.Wye[L,R,O]">y</a><span class="delimiter">)</span>
        <span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="comment">// interprets a single step of wye.</span>
      <span class="comment">// if wye is at emit, it tries to complete cb, if cb is nonEmpty</span>
      <span class="comment">// if wye is at await runs either side</span>
      <span class="comment">// if wye is halt kills either side</span>
      <span class="comment">// returns next state of wye and callback</span>
      def <a title="(y: scalaz.stream.Wye[L,R,O], cb: Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])" id="scalaz.stream.wye.apply.runY">runY</a><span class="delimiter">(</span><a title="scalaz.stream.Wye[L,R,O]" id="scalaz.stream.wye.apply.runY.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[L,R,O]">Wye</a><span class="delimiter">[</span>L, R, O<span class="delimiter">]</span>, <a title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]" id="scalaz.stream.wye.apply.runY.cb">cb</a>: <span title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>Cause \/ Seq<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">]</span><span class="delimiter">)</span>
      : <span title="(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])" class="delimiter">(</span>Wye<span class="delimiter">[</span>L, R, O<span class="delimiter">]</span>, Option<span class="delimiter">[</span><span class="delimiter">(</span>Cause \/ Seq<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
        @tailrec
        def <a title="(cur: scalaz.stream.Wye[L,R,O])(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])" id="scalaz.stream.wye.apply.runY.go">go</a><span class="delimiter">(</span><a title="scalaz.stream.Wye[L,R,O]" id="scalaz.stream.wye.apply.runY.go.cur">cur</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[L,R,O]">Wye</a><span class="delimiter">[</span>L, R, O<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])" class="delimiter">(</span>Wye<span class="delimiter">[</span>L, R, O<span class="delimiter">]</span>, Option<span class="delimiter">[</span><span class="delimiter">(</span>Cause \/ Seq<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
          <a href="#scalaz.stream.wye.apply.runY.go.cur" title="scalaz.stream.Wye[L,R,O]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.stream.Process.Env[L,R]#Y,O]">step</a> match <span class="delimiter">{</span>
            case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.runY.go.<unapply-selector>" title="(x: Seq[O])Some[Seq[O]]">Seq</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>,<span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[L,R]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
              <a href="#scalaz.stream.wye.apply.runY.go" title="(cur: scalaz.stream.Wye[L,R,O])(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])">go</a><span class="delimiter">(</span><span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[L,R]#Y,O]">cont</span>.<a href="Process.scala.html#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[L,R]#Y,O]">continue</a><span class="delimiter">)</span>

            case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><a title="Seq[O]" id="scalaz.stream.wye.apply.runY.go.os">os</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[L,R]#Y,O]">cont</span><span class="delimiter">)</span> =&gt;
              <a href="#scalaz.stream.wye.apply.runY.cb" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">cb</a> match <span class="delimiter">{</span>
                case Some<span class="delimiter">(</span><a title="scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit" id="scalaz.stream.wye.apply.runY.go.cb0">cb0</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.wye.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.runY.go.cb0" title="(v1: scalaz.\/[scalaz.stream.Cause,Seq[O]])Unit">cb0</a><span class="delimiter">(</span><span title="(b: Seq[O])scalaz.\/-[Seq[O]]">\/-</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.runY.go.os" title="Seq[O]">os</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>; <span title="(_1: scalaz.stream.Process[scalaz.stream.Process.Env[L,R]#Y,O], _2: None.type)(scalaz.stream.Process[scalaz.stream.Process.Env[L,R]#Y,O], None.type)" class="delimiter">(</span><span title="scalaz.stream.Process.Cont[scalaz.stream.Process.Env[L,R]#Y,O]">cont</span>.<a href="Process.scala.html#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[L,R]#Y,O]">continue</a>, <span title="None.type">None</span><span class="delimiter">)</span>
                case <span title="None.type">None</span>      =&gt; <span title="(_1: scalaz.stream.Wye[L,R,O], _2: None.type)(scalaz.stream.Wye[L,R,O], None.type)" class="delimiter">(</span><a href="#scalaz.stream.wye.apply.runY.go.cur" title="scalaz.stream.Wye[L,R,O]">cur</a>, <span title="None.type">None</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>

            case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitL" title="scalaz.stream.wye.AwaitL.type">AwaitL</a>.<a href="#scalaz.stream.wye.AwaitL.is.unapply" title="(self: scalaz.stream.wye.WyeAwaitL[I,I2,O])Boolean">is</a><span class="delimiter">(</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt;
              <a href="#scalaz.stream.wye.apply.left" title="SideState[L]">left</a> = <a href="#scalaz.stream.wye.apply.runSideLeft" title="(v1: SideState[L])SideState[L]">runSideLeft</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.left" title="SideState[L]">left</a><span class="delimiter">)</span>
              <a href="#scalaz.stream.wye.apply.leftBias" title="Boolean">leftBias</a> = false
              <span title="(_1: scalaz.stream.Wye[L,R,O], _2: Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])" class="delimiter">(</span><a href="#scalaz.stream.wye.apply.runY.go.cur" title="scalaz.stream.Wye[L,R,O]">cur</a>, <a href="#scalaz.stream.wye.apply.runY.cb" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">cb</a><span class="delimiter">)</span>

            case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitR" title="scalaz.stream.wye.AwaitR.type">AwaitR</a>.<a href="#scalaz.stream.wye.AwaitR.is.unapply" title="(self: scalaz.stream.wye.WyeAwaitR[I,I2,O])Boolean">is</a><span class="delimiter">(</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt;
              <a href="#scalaz.stream.wye.apply.right" title="SideState[R]">right</a> = <a href="#scalaz.stream.wye.apply.runSideRight" title="(v1: SideState[R])SideState[R]">runSideRight</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.right" title="SideState[R]">right</a><span class="delimiter">)</span>
              <a href="#scalaz.stream.wye.apply.leftBias" title="Boolean">leftBias</a> = true
              <span title="(_1: scalaz.stream.Wye[L,R,O], _2: Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])" class="delimiter">(</span><a href="#scalaz.stream.wye.apply.runY.go.cur" title="scalaz.stream.Wye[L,R,O]">cur</a>, <a href="#scalaz.stream.wye.apply.runY.cb" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">cb</a><span class="delimiter">)</span>

            case Step<span class="delimiter">(</span><a href="#scalaz.stream.wye.AwaitBoth" title="scalaz.stream.wye.AwaitBoth.type">AwaitBoth</a>.<a href="#scalaz.stream.wye.AwaitBoth.is.unapply" title="(self: scalaz.stream.wye.WyeAwaitBoth[I,I2,O])Boolean">is</a><span class="delimiter">(</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt;
              if <span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.leftBias" title="Boolean">leftBias</a><span class="delimiter">)</span> <span class="delimiter">{</span><a href="#scalaz.stream.wye.apply.left" title="SideState[L]">left</a> = <a href="#scalaz.stream.wye.apply.runSideLeft" title="(v1: SideState[L])SideState[L]">runSideLeft</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.left" title="SideState[L]">left</a><span class="delimiter">)</span>; <a href="#scalaz.stream.wye.apply.right" title="SideState[R]">right</a> = <a href="#scalaz.stream.wye.apply.runSideRight" title="(v1: SideState[R])SideState[R]">runSideRight</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.right" title="SideState[R]">right</a><span class="delimiter">)</span> <span class="delimiter">}</span>
              else <span class="delimiter">{</span><a href="#scalaz.stream.wye.apply.right" title="SideState[R]">right</a> = <a href="#scalaz.stream.wye.apply.runSideRight" title="(v1: SideState[R])SideState[R]">runSideRight</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.right" title="SideState[R]">right</a><span class="delimiter">)</span>; <a href="#scalaz.stream.wye.apply.left" title="SideState[L]">left</a> = <a href="#scalaz.stream.wye.apply.runSideLeft" title="(v1: SideState[L])SideState[L]">runSideLeft</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.left" title="SideState[L]">left</a><span class="delimiter">)</span> <span class="delimiter">}</span>
              <a href="#scalaz.stream.wye.apply.leftBias" title="Boolean">leftBias</a> = <span title="=&gt; Boolean">!</span><a href="#scalaz.stream.wye.apply.leftBias" title="Boolean">leftBias</a>
              <span title="(_1: scalaz.stream.Wye[L,R,O], _2: Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])" class="delimiter">(</span><a href="#scalaz.stream.wye.apply.runY.go.cur" title="scalaz.stream.Wye[L,R,O]">cur</a>, <a href="#scalaz.stream.wye.apply.runY.cb" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">cb</a><span class="delimiter">)</span>

            case Halt<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
              if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#scalaz.stream.wye.apply.isDone" title="(state: SideState[L])Boolean">isDone</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.left" title="SideState[L]">left</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scalaz.stream.wye.apply.left" title="SideState[L]">left</a> = <a href="#scalaz.stream.wye.apply.killLeft" title="(v1: SideState[L])SideState[L]">killLeft</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.left" title="SideState[L]">left</a><span class="delimiter">)</span>
              if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#scalaz.stream.wye.apply.isDone" title="(state: SideState[R])Boolean">isDone</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.right" title="SideState[R]">right</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scalaz.stream.wye.apply.right" title="SideState[R]">right</a> = <a href="#scalaz.stream.wye.apply.killRight" title="(v1: SideState[R])SideState[R]">killRight</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.right" title="SideState[R]">right</a><span class="delimiter">)</span>
              <span title="(_1: scalaz.stream.Wye[L,R,O], _2: Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])" class="delimiter">(</span><a href="#scalaz.stream.wye.apply.runY.go.cur" title="scalaz.stream.Wye[L,R,O]">cur</a>, <a href="#scalaz.stream.wye.apply.runY.cb" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">cb</a><span class="delimiter">)</span>

          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#scalaz.stream.wye.apply.runY.go" title="(cur: scalaz.stream.Wye[L,R,O])(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])">go</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.runY.y" title="scalaz.stream.Wye[L,R,O]">y</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>


      <a href="#scalaz.stream.wye.apply.a" title="scalaz.concurrent.Actor[M]">a</a> = <span title="[A](handler: A =&gt; Unit, onError: Throwable =&gt; Unit)(implicit strategy: scalaz.concurrent.Strategy)scalaz.concurrent.Actor[A]">Actor</span><span title="(handler: M =&gt; Unit, onError: Throwable =&gt; Unit)(implicit strategy: scalaz.concurrent.Strategy)scalaz.concurrent.Actor[M]" class="delimiter">[</span><a href="#scalaz.stream.wye.apply;M" title="M">M</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">{</span> <a title="M" id="scalaz.stream.wye.apply.$anonfun.m">m</a> =&gt;
        <a href="#scalaz.stream.wye.apply.$anonfun.m" title="M">m</a> match <span class="delimiter">{</span>
          case <a href="#scalaz.stream.wye.apply;Ready.readResolve" title="(x$0: Ready[A])Option[(scalaz.stream.Process.Env[L,R]#Y[A], scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])])]">Ready</a><span class="delimiter">(</span><a title="scalaz.stream.Process.Env[L,R]#Y[_]" id="scalaz.stream.wye.apply.$anonfun.side">side</a>, <a title="scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])] forSome { type A; type A; type A }" id="scalaz.stream.wye.apply.$anonfun.result">result</a><span class="delimiter">)</span> =&gt;
            val <a href="#scalaz.stream.wye.apply.$anonfun.x$52.y" title="(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])" class="delimiter">(</a><a href="#scalaz.stream.wye.apply.$anonfun.x$52" title="scalaz.stream.Wye[L,R,O]" id="scalaz.stream.wye.apply.$anonfun.x$52.y">y</a>, <a href="#scalaz.stream.wye.apply.$anonfun.x$52" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]" id="scalaz.stream.wye.apply.$anonfun.x$52.cb">cb</a><span class="delimiter">)</span> =
              if <span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.$anonfun.side" title="scalaz.stream.Process.Env[L,R]#Y[_]">side</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scalaz.stream.wye.apply.Left" title="scalaz.stream.Process.Env[L,R]#Left.type">Left</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                val <a title="scalaz.\/[scalaz.stream.Cause,(Seq[L], scalaz.stream.Process.Cont[scalaz.concurrent.Task,L])]" id="scalaz.stream.wye.apply.$anonfun.x$52.resultL">resultL</a> = <a href="#scalaz.stream.wye.apply.$anonfun.result" title="scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])] forSome { type A; type A; type A }">result</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scalaz.\/[scalaz.stream.Cause,(Seq[L], scalaz.stream.Process.Cont[scalaz.concurrent.Task,L])]" class="delimiter">[</span><span class="delimiter">(</span>Cause <span title="scalaz.\/[scalaz.stream.Cause,(Seq[L], scalaz.stream.Process.Cont[scalaz.concurrent.Task,L])]">\/</span> <span class="delimiter">(</span>Seq<span class="delimiter">[</span>L<span class="delimiter">]</span>, Cont<span class="delimiter">[</span>Task,L<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">]</span>
                <a href="#scalaz.stream.wye.apply.runY" title="(y: scalaz.stream.Wye[L,R,O], cb: Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])">runY</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReadyLeft" title="(result: scalaz.\/[scalaz.stream.Cause,(Seq[L], scalaz.stream.Process.Cont[scalaz.concurrent.Task,L])], y: scalaz.stream.Wye[L,R,O])scalaz.stream.Wye[L,R,O]">sideReadyLeft</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.$anonfun.x$52.resultL" title="scalaz.\/[scalaz.stream.Cause,(Seq[L], scalaz.stream.Process.Cont[scalaz.concurrent.Task,L])]">resultL</a>, <a href="#scalaz.stream.wye.apply.yy" title="scalaz.stream.Wye[L,R,O]">yy</a><span class="delimiter">)</span>, <a href="#scalaz.stream.wye.apply.out" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">out</a><span class="delimiter">)</span>
              <span class="delimiter">}</span> else <span class="delimiter">{</span>
                val <a title="scalaz.\/[scalaz.stream.Cause,(Seq[R], scalaz.stream.Process.Cont[scalaz.concurrent.Task,R])]" id="scalaz.stream.wye.apply.$anonfun.x$52.resultR">resultR</a> = <a href="#scalaz.stream.wye.apply.$anonfun.result" title="scalaz.\/[scalaz.stream.Cause,(Seq[A], scalaz.stream.Process.Cont[scalaz.concurrent.Task,A])] forSome { type A; type A; type A }">result</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scalaz.\/[scalaz.stream.Cause,(Seq[R], scalaz.stream.Process.Cont[scalaz.concurrent.Task,R])]" class="delimiter">[</span><span class="delimiter">(</span>Cause <span title="scalaz.\/[scalaz.stream.Cause,(Seq[R], scalaz.stream.Process.Cont[scalaz.concurrent.Task,R])]">\/</span> <span class="delimiter">(</span>Seq<span class="delimiter">[</span>R<span class="delimiter">]</span>, Cont<span class="delimiter">[</span>Task,R<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">]</span>
                <a href="#scalaz.stream.wye.apply.runY" title="(y: scalaz.stream.Wye[L,R,O], cb: Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])">runY</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.sideReadyRight" title="(result: scalaz.\/[scalaz.stream.Cause,(Seq[R], scalaz.stream.Process.Cont[scalaz.concurrent.Task,R])], y: scalaz.stream.Wye[L,R,O])scalaz.stream.Wye[L,R,O]">sideReadyRight</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.$anonfun.x$52.resultR" title="scalaz.\/[scalaz.stream.Cause,(Seq[R], scalaz.stream.Process.Cont[scalaz.concurrent.Task,R])]">resultR</a>, <a href="#scalaz.stream.wye.apply.yy" title="scalaz.stream.Wye[L,R,O]">yy</a><span class="delimiter">)</span>, <a href="#scalaz.stream.wye.apply.out" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">out</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <a href="#scalaz.stream.wye.apply.yy" title="scalaz.stream.Wye[L,R,O]">yy</a> = <span title="scalaz.stream.Wye[L,R,O]">y</span>
            <a href="#scalaz.stream.wye.apply.out" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">out</a> = <a href="#scalaz.stream.wye.apply.haltIfDone" title="(y: scalaz.stream.Wye[L,R,O], l: SideState[L], r: SideState[R], cb: Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">haltIfDone</a><span class="delimiter">(</span><span title="scalaz.stream.Wye[L,R,O]">y</span>, <a href="#scalaz.stream.wye.apply.left" title="SideState[L]">left</a>, <a href="#scalaz.stream.wye.apply.right" title="SideState[R]">right</a>, <span title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">cb</span><span class="delimiter">)</span>


          case <a href="#scalaz.stream.wye.apply;Get.readResolve" title="(x$0: Get)Option[scalaz.\/[scalaz.stream.Cause.Terminated,Seq[O]] =&gt; Unit]">Get</a><span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause.Terminated,Seq[O]] =&gt; Unit">cb0</span><span class="delimiter">)</span> =&gt;
            val <a href="#scalaz.stream.wye.apply.$anonfun.x$53.y" title="(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])" class="delimiter">(</a><a href="#scalaz.stream.wye.apply.$anonfun.x$53" title="scalaz.stream.Wye[L,R,O]" id="scalaz.stream.wye.apply.$anonfun.x$53.y">y</a>, <a href="#scalaz.stream.wye.apply.$anonfun.x$53" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]" id="scalaz.stream.wye.apply.$anonfun.x$53.cb">cb</a><span class="delimiter">)</span> = <a href="#scalaz.stream.wye.apply.runY" title="(y: scalaz.stream.Wye[L,R,O], cb: Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])">runY</a><span title="(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]) @unchecked" class="delimiter">(</span><a href="#scalaz.stream.wye.apply.yy" title="scalaz.stream.Wye[L,R,O]">yy</a>, <span title="(x: scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit)Some[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">Some</span><span class="delimiter">(</span><span class="delimiter">(</span>r:Cause <span title="scalaz.\/[scalaz.stream.Cause,Seq[O]]">\/</span> Seq<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span title="(v1: scalaz.\/[scalaz.stream.Cause.Terminated,Seq[O]])Unit">cb0</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.$anonfun.x$53.$anonfun.r" title="scalaz.\/[scalaz.stream.Cause,Seq[O]]">r</a>.<span title="(f: scalaz.stream.Cause =&gt; scalaz.stream.Cause.Terminated, g: Seq[O] =&gt; Seq[O])scalaz.\/[scalaz.stream.Cause.Terminated,Seq[O]]">bimap</span><span class="delimiter">(</span><a title="scalaz.stream.Cause" id="scalaz.stream.wye.apply.$anonfun.x$53.$anonfun.$anonfun.c">c</a>=&gt;<a href="Cause.scala.html#scalaz.stream.Cause;Terminated" title="(cause: scalaz.stream.Cause)scalaz.stream.Cause.Terminated">Terminated</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.$anonfun.x$53.$anonfun.$anonfun.c" title="scalaz.stream.Cause">c</a><span class="delimiter">)</span>,<a href="#scalaz.stream.wye.apply.$anonfun.x$53.$anonfun.$anonfun.x" title="(x: Seq[O])Seq[O]">identity</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#scalaz.stream.wye.apply.yy" title="scalaz.stream.Wye[L,R,O]">yy</a> = <span title="scalaz.stream.Wye[L,R,O]">y</span>
            <a href="#scalaz.stream.wye.apply.out" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">out</a> = <a href="#scalaz.stream.wye.apply.haltIfDone" title="(y: scalaz.stream.Wye[L,R,O], l: SideState[L], r: SideState[R], cb: Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">haltIfDone</a><span class="delimiter">(</span><span title="scalaz.stream.Wye[L,R,O]">y</span>, <a href="#scalaz.stream.wye.apply.left" title="SideState[L]">left</a>, <a href="#scalaz.stream.wye.apply.right" title="SideState[R]">right</a>, <span title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">cb</span><span class="delimiter">)</span>

          case <a href="#scalaz.stream.wye.apply;DownDone.readResolve" title="(x$0: DownDone)Option[scalaz.\/[Throwable,Unit] =&gt; Unit]">DownDone</a><span class="delimiter">(</span><span title="scalaz.\/[Throwable,Unit] =&gt; Unit">cb0</span><span class="delimiter">)</span> =&gt;
            if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#scalaz.stream.wye.apply.yy" title="scalaz.stream.Wye[L,R,O]">yy</a>.<a href="Process.scala.html#scalaz.stream;Process.isHalt" title="=&gt; Boolean">isHalt</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              val <a title="scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit" id="scalaz.stream.wye.apply.$anonfun.cb1">cb1</a> = <span class="delimiter">(</span>r: Cause <span title="scalaz.\/[scalaz.stream.Cause,Seq[O]]">\/</span> Seq<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span title="(v1: scalaz.\/[Throwable,Unit])Unit">cb0</span><span class="delimiter">(</span><span title="(b: Unit)scalaz.\/-[Unit]">\/-</span><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#scalaz.stream.wye.apply.downDone" title="Boolean">downDone</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="comment">// complete old callback (from `Get` if defined)</span>
                <a href="#scalaz.stream.wye.apply.out" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">out</a>.<span title="(f: (scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit) =&gt; (() =&gt; Unit))Unit">foreach</span><span class="delimiter">(</span><a title="scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit" id="scalaz.stream.wye.apply.$anonfun.$anonfun.cb">cb</a> =&gt; <a href="#scalaz.stream.wye.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.$anonfun.$anonfun.cb" title="(v1: scalaz.\/[scalaz.stream.Cause,Seq[O]])Unit">cb</a><span class="delimiter">(</span><span title="(a: scalaz.stream.Cause.Kill.type)scalaz.-\/[scalaz.stream.Cause.Kill.type]">-\/</span><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                val <a href="#scalaz.stream.wye.apply.$anonfun.x$54.y" title="(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])" class="delimiter">(</a><a href="#scalaz.stream.wye.apply.$anonfun.x$54" title="scalaz.stream.Wye[L,R,O]" id="scalaz.stream.wye.apply.$anonfun.x$54.y">y</a>,<a href="#scalaz.stream.wye.apply.$anonfun.x$54" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]" id="scalaz.stream.wye.apply.$anonfun.x$54.cb">cb</a><span class="delimiter">)</span> = <a href="#scalaz.stream.wye.apply.runY" title="(y: scalaz.stream.Wye[L,R,O], cb: Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])">runY</a><span title="(scalaz.stream.Wye[L,R,O], Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]) @unchecked" class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectL" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[L,R,O])scalaz.stream.Wye[L,R,O]">disconnectL</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.disconnectR" title="(cause: scalaz.stream.Cause.EarlyCause)(y: scalaz.stream.Wye[L,R,O])scalaz.stream.Wye[L,R,O]">disconnectR</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.yy" title="scalaz.stream.Wye[L,R,O]">yy</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.kill" title="=&gt; scalaz.stream.Process[scalaz.stream.Process.Env[L,R]#Y,Nothing]">kill</a>, <span title="(x: scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit)Some[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.$anonfun.cb1" title="scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit">cb1</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#scalaz.stream.wye.apply.yy" title="scalaz.stream.Wye[L,R,O]">yy</a> = <span title="scalaz.stream.Wye[L,R,O]">y</span>
                <a href="#scalaz.stream.wye.apply.out" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">out</a> = <span title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">cb</span>
                <a href="#scalaz.stream.wye.apply.downDone" title="Boolean">downDone</a> = true
              <span class="delimiter">}</span>
              else <span class="delimiter">{</span>
                <span class="comment">// important that existing callback is NOT erased. doing so can cause process to hang on terminate</span>
                <span class="comment">// first terminate is on interrupt, second when an awaited task completes</span>
                <a href="#scalaz.stream.wye.apply.out" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">out</a> = <a href="#scalaz.stream.wye.apply.out" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">out</a> match <span class="delimiter">{</span>
                  case Some<span class="delimiter">(</span><span title="scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit">cb</span><span class="delimiter">)</span> =&gt; <span title="(x: scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit)Some[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">Some</span><span class="delimiter">{</span><span class="delimiter">(</span>r: Cause <span title="scalaz.\/[scalaz.stream.Cause,Seq[O]]">\/</span> Seq<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span title="(v1: scalaz.\/[scalaz.stream.Cause,Seq[O]])Unit">cb</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.$anonfun.$anonfun.r" title="scalaz.\/[scalaz.stream.Cause,Seq[O]]">r</a><span class="delimiter">)</span>; <span title="(v1: scalaz.\/[Throwable,Unit])Unit">cb0</span><span class="delimiter">(</span><span title="(b: Unit)scalaz.\/-[Unit]">\/-</span><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">}</span>
                  case <span title="None.type">None</span> =&gt; <span title="(x: scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit)Some[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">Some</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.$anonfun.cb1" title="scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit">cb1</a><span class="delimiter">)</span> <span class="comment">// should never happen - if no cb, yy will be halt</span>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span>
              <a href="#scalaz.stream.wye.apply.out" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">out</a> = <a href="#scalaz.stream.wye.apply.haltIfDone" title="(y: scalaz.stream.Wye[L,R,O], l: SideState[L], r: SideState[R], cb: Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit])Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">haltIfDone</a><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.yy" title="scalaz.stream.Wye[L,R,O]">yy</a>, <a href="#scalaz.stream.wye.apply.left" title="SideState[L]">left</a>, <a href="#scalaz.stream.wye.apply.right" title="SideState[R]">right</a>, <a href="#scalaz.stream.wye.apply.out" title="Option[scalaz.\/[scalaz.stream.Cause,Seq[O]] =&gt; Unit]">out</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            else <a href="#scalaz.stream.wye.apply.S" title="(a: =&gt; Unit)() =&gt; Unit">S</a><span title="Unit" class="delimiter">(</span><span title="(v1: scalaz.\/[Throwable,Unit])Unit">cb0</span><span class="delimiter">(</span><span title="(b: Unit)scalaz.\/-[Unit]">\/-</span><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.wye.apply.S" title="scalaz.concurrent.Strategy">S</a><span class="delimiter">)</span>

      <a href="Process.scala.html#scalaz.stream.Process.repeatEval" title="(f: scalaz.concurrent.Task[Seq[O]])scalaz.stream.Process[scalaz.concurrent.Task,Seq[O]]">repeatEval</a><span class="delimiter">(</span><span title="scalaz.concurrent.Task.type">Task</span>.<span title="[A](register: (scalaz.\/[Throwable,A] =&gt; Unit) =&gt; Unit)scalaz.concurrent.Task[A]">async</span><span title="(register: (scalaz.\/[Throwable,Seq[O]] =&gt; Unit) =&gt; Unit)scalaz.concurrent.Task[Seq[O]]" class="delimiter">[</span><span title="Seq[O]">Seq</span><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span> <span title="scalaz.\/[Throwable,Seq[O]] =&gt; Unit">cb</span> =&gt; <a href="#scalaz.stream.wye.apply.a" title="scalaz.concurrent.Actor[M]">a</a> <span title="(a: M)Unit">!</span> <a href="#scalaz.stream.wye.apply;Get.readResolve" title="(cb: scalaz.\/[scalaz.stream.Cause.Terminated,Seq[O]] =&gt; Unit)Get">Get</a><span class="delimiter">(</span><span title="scalaz.\/[Throwable,Seq[O]] =&gt; Unit">cb</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>
      .<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: Seq[O] =&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],O])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],O]">flatMap</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.emitAll" title="(os: Seq[O])scalaz.stream.Process0[O]">emitAll</a><span class="delimiter">)</span>
      .<a href="Process.scala.html#scalaz.stream;Process.onComplete" title="(p2: =&gt; scalaz.stream.Process[[x]scalaz.concurrent.Task[x],O])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],O]">onComplete</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.eval_" title="(f: scalaz.concurrent.Task[Unit])scalaz.stream.Process[scalaz.concurrent.Task,Nothing]">eval_</a><span class="delimiter">(</span><span title="scalaz.concurrent.Task.type">Task</span>.<span title="[A](register: (scalaz.\/[Throwable,A] =&gt; Unit) =&gt; Unit)scalaz.concurrent.Task[A]">async</span><span title="(register: (scalaz.\/[Throwable,Unit] =&gt; Unit) =&gt; Unit)scalaz.concurrent.Task[Unit]" class="delimiter">[</span><span title="Unit">Unit</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="scalaz.\/[Throwable,Unit] =&gt; Unit">cb</span> =&gt; <a href="#scalaz.stream.wye.apply.a" title="scalaz.concurrent.Actor[M]">a</a> <span title="(a: M)Unit">!</span> <a href="#scalaz.stream.wye.apply;DownDone.readResolve" title="(cb: scalaz.\/[Throwable,Unit] =&gt; Unit)DownDone">DownDone</a><span class="delimiter">(</span><span title="scalaz.\/[Throwable,Unit] =&gt; Unit">cb</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>


protected<span class="delimiter">[</span>stream<span class="delimiter">]</span> trait <a title="trait WyeOps[+O] extends AnyRef" id="scalaz.stream;WyeOps">WyeOps</a><span class="delimiter">[</span>+<a title="" id="scalaz.stream;WyeOps;O">O</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>
  val <a title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,O]" id="scalaz.stream;WyeOps.self">self</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,O]">Process</a><span class="delimiter">[</span>Task, O<span class="delimiter">]</span>

  <span class="comment">/**
   * Like `tee`, but we allow the `Wye` to read non-deterministically
   * from both sides at once.
   *
   * If `y` is in the state of awaiting `Both`, this implementation
   * will continue feeding `y` from either left or right side,
   * until either it halts or _both_ sides halt.
   *
   * If `y` is in the state of awaiting `L`, and the left
   * input has halted, we halt. Likewise for the right side.
   *
   * For as long as `y` permits it, this implementation will _always_
   * feed it any leading `Emit` elements from either side before issuing
   * new `F` requests. More sophisticated chunking and fairness
   * policies do not belong here, but should be built into the `Wye`
   * and/or its inputs.
   *
   * The strategy passed in must be stack-safe, otherwise this implementation
   * will throw SOE. Preferably use one of the `Strategys.Executor(es)` based strategies
   */</span>
  final def <a title="[O2, O3](p2: scalaz.stream.Process[scalaz.concurrent.Task,O2])(y: scalaz.stream.Wye[O,O2,O3])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,O3]" id="scalaz.stream;WyeOps.wye">wye</a><span class="delimiter">[</span><a title="" id="scalaz.stream;WyeOps.wye;O2">O2</a>, <a title="" id="scalaz.stream;WyeOps.wye;O3">O3</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.concurrent.Task,O2]" id="scalaz.stream;WyeOps.wye.p2">p2</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,O2]">Process</a><span class="delimiter">[</span>Task, O2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.stream.Wye[O,O2,O3]" id="scalaz.stream;WyeOps.wye.y">y</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Wye[O,O2,O3]">Wye</a><span class="delimiter">[</span>O, O2, O3<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream;WyeOps.wye.S">S</a>: <span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,O3]">Process</a><span class="delimiter">[</span>Task, O3<span class="delimiter">]</span> =
    scalaz.stream.<a href="#scalaz.stream.wye.apply" title="[L, R, O](pl: scalaz.stream.Process[scalaz.concurrent.Task,L], pr: scalaz.stream.Process[scalaz.concurrent.Task,R])(y0: scalaz.stream.Wye[L,R,O])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,O]">wye</a><span title="(pl: scalaz.stream.Process[scalaz.concurrent.Task,O], pr: scalaz.stream.Process[scalaz.concurrent.Task,O2])(y0: scalaz.stream.Wye[O,O2,O3])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,O3]" class="delimiter">[</span><a href="#scalaz.stream;WyeOps;O" title="O">O</a>, <a href="#scalaz.stream;WyeOps.wye;O2" title="O2">O2</a>, <a href="#scalaz.stream;WyeOps.wye;O3" title="O3">O3</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream;WyeOps.self" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,O]">self</a>, <a href="#scalaz.stream;WyeOps.wye.p2" title="scalaz.stream.Process[scalaz.concurrent.Task,O2]">p2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;WyeOps.wye.y" title="scalaz.stream.Wye[O,O2,O3]">y</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream;WyeOps.wye.S" title="scalaz.concurrent.Strategy">S</a><span class="delimiter">)</span>

  <span class="comment">/** Non-deterministic version of `zipWith`. Note this terminates whenever one of streams terminate */</span>
  def <a title="[O2, O3](p2: scalaz.stream.Process[scalaz.concurrent.Task,O2])(f: (O, O2) =&gt; O3)(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,O3]" id="scalaz.stream;WyeOps.yipWith">yipWith</a><span class="delimiter">[</span><a title="" id="scalaz.stream;WyeOps.yipWith;O2">O2</a>,<a title="" id="scalaz.stream;WyeOps.yipWith;O3">O3</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.concurrent.Task,O2]" id="scalaz.stream;WyeOps.yipWith.p2">p2</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,O2]">Process</a><span class="delimiter">[</span>Task,O2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(O, O2) =&gt; O3" id="scalaz.stream;WyeOps.yipWith.f">f</a>: <span class="delimiter">(</span>O,O2<span class="delimiter">)</span> =&gt; O3<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream;WyeOps.yipWith.S">S</a>:<span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,O3]">Process</a><span class="delimiter">[</span>Task,O3<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.SourceSyntax" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,O])scalaz.stream.Process.SourceSyntax[O]">self</a>.<a href="#scalaz.stream;WyeOps.wye" title="(p2: scalaz.stream.Process[scalaz.concurrent.Task,O2])(y: scalaz.stream.Wye[O,O2,O3])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,O3]">wye</a><span class="delimiter">(</span><a href="#scalaz.stream;WyeOps.yipWith.p2" title="scalaz.stream.Process[scalaz.concurrent.Task,O2]">p2</a><span class="delimiter">)</span><a href="#scalaz.stream;WyeOps.yipWith.S" title="scalaz.concurrent.Strategy" class="delimiter">(</a>scalaz.stream.<a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.yipWith" title="(f: (O, O2) =&gt; O3)scalaz.stream.Wye[O,O2,O3]">yipWith</a><span class="delimiter">(</span><a href="#scalaz.stream;WyeOps.yipWith.f" title="(O, O2) =&gt; O3">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Non-deterministic version of `zip`. Note this terminates whenever one of streams terminate */</span>
  def <a title="[O2](p2: scalaz.stream.Process[scalaz.concurrent.Task,O2])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,(O, O2)]" id="scalaz.stream;WyeOps.yip">yip</a><span class="delimiter">[</span><a title="" id="scalaz.stream;WyeOps.yip;O2">O2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.concurrent.Task,O2]" id="scalaz.stream;WyeOps.yip.p2">p2</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,O2]">Process</a><span class="delimiter">[</span>Task,O2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream;WyeOps.yip.S">S</a>:<span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,(O, O2)]">Process</a><span class="delimiter">[</span>Task,<span class="delimiter">(</span>O,O2<span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.SourceSyntax" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,O])scalaz.stream.Process.SourceSyntax[O]">self</a>.<a href="#scalaz.stream;WyeOps.wye" title="(p2: scalaz.stream.Process[scalaz.concurrent.Task,O2])(y: scalaz.stream.Wye[O,O2,(O, O2)])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,(O, O2)]">wye</a><span class="delimiter">(</span><a href="#scalaz.stream;WyeOps.yip.p2" title="scalaz.stream.Process[scalaz.concurrent.Task,O2]">p2</a><span class="delimiter">)</span><a href="#scalaz.stream;WyeOps.yip.S" title="scalaz.concurrent.Strategy" class="delimiter">(</a>scalaz.stream.<a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.yip" title="scalaz.stream.Wye[O,O2,(O, O2)]">yip</a><span class="delimiter">)</span>

  <span class="comment">/** Non-deterministic interleave of both streams.
    * Emits values whenever either is defined. Note this terminates after BOTH sides terminate */</span>
  def <a title="[O2 &gt;: O](p2: scalaz.stream.Process[scalaz.concurrent.Task,O2])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,O2]" id="scalaz.stream;WyeOps.merge">merge</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;WyeOps.merge;O2">O2</a>&gt;:O<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.concurrent.Task,O2]" id="scalaz.stream;WyeOps.merge.p2">p2</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,O2]">Process</a><span class="delimiter">[</span>Task,O2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream;WyeOps.merge.S">S</a>:<span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,O2]">Process</a><span class="delimiter">[</span>Task,O2<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.SourceSyntax" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,O])scalaz.stream.Process.SourceSyntax[O]">self</a>.<a href="#scalaz.stream;WyeOps.wye" title="(p2: scalaz.stream.Process[scalaz.concurrent.Task,O2])(y: scalaz.stream.Wye[O,O2,O2])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,O2]">wye</a><span class="delimiter">(</span><a href="#scalaz.stream;WyeOps.merge.p2" title="scalaz.stream.Process[scalaz.concurrent.Task,O2]">p2</a><span class="delimiter">)</span><a href="#scalaz.stream;WyeOps.merge.S" title="scalaz.concurrent.Strategy" class="delimiter">(</a>scalaz.stream.<a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.merge" title="scalaz.stream.Wye[O2,O2,O2]">merge</a><span class="delimiter">)</span>

  <span class="comment">/** Non-deterministic interleave of both streams. Emits values whenever either is defined.
    * Note this terminates after BOTH sides terminate  */</span>
  def <a title="[O2 &gt;: O, O3](p2: scalaz.stream.Process[scalaz.concurrent.Task,O3])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[O2,O3]]" id="scalaz.stream;WyeOps.either">either</a><span class="delimiter">[</span><a title=" &gt;: O" id="scalaz.stream;WyeOps.either;O2">O2</a>&gt;:O,<a title="" id="scalaz.stream;WyeOps.either;O3">O3</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.concurrent.Task,O3]" id="scalaz.stream;WyeOps.either.p2">p2</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,O3]">Process</a><span class="delimiter">[</span>Task,O3<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scalaz.concurrent.Strategy" id="scalaz.stream;WyeOps.either.S">S</a>:<span title="scalaz.concurrent.Strategy">Strategy</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[O2,O3]]">Process</a><span class="delimiter">[</span>Task,O2 \/ O3<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.SourceSyntax" title="(self: scalaz.stream.Process[scalaz.concurrent.Task,O])scalaz.stream.Process.SourceSyntax[O]">self</a>.<a href="#scalaz.stream;WyeOps.wye" title="(p2: scalaz.stream.Process[scalaz.concurrent.Task,O3])(y: scalaz.stream.Wye[O,O3,scalaz.\/[O,O3]])(implicit S: scalaz.concurrent.Strategy)scalaz.stream.Process[scalaz.concurrent.Task,scalaz.\/[O,O3]]">wye</a><span class="delimiter">(</span><a href="#scalaz.stream;WyeOps.either.p2" title="scalaz.stream.Process[scalaz.concurrent.Task,O3]">p2</a><span class="delimiter">)</span><a href="#scalaz.stream;WyeOps.either.S" title="scalaz.concurrent.Strategy" class="delimiter">(</a>scalaz.stream.<a href="#scalaz.stream.wye" title="scalaz.stream.wye.type">wye</a>.<a href="#scalaz.stream.wye.either" title="scalaz.stream.Wye[O,O3,scalaz.\/[O,O3]]">either</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
