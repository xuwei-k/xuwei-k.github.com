<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scalaz-stream/scalaz/stream/io.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scalaz.stream

import java.io._

import scalaz.<span class="delimiter">{</span>-\/, \/-<span class="delimiter">}</span>
import scalaz.concurrent.Task

import scodec.bits.ByteVector

import scala.annotation.tailrec
import scala.io.<span class="delimiter">{</span>Codec, Source<span class="delimiter">}</span>

import <a href="Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>._

<span class="comment">/**
 * Module of `Process` functions and combinators for file and network I/O.
 */</span>
object <a title="scalaz.stream.io.type" id="scalaz.stream.io">io</a> <a href="#scalaz.stream.io" title="scalaz.stream.io.type" class="delimiter">{</a>

  <span class="comment">// NB: methods are in alphabetical order</span>

  <span class="comment">/**
   * Like resource, but the `release` action may emit a final value,
   * useful for flushing any internal buffers. NB: In the event of an
   * error, this final value is ignored.
   */</span>
  def <a title="[F[_], R, O](acquire: F[R])(flushAndRelease: R =&gt; F[O])(step: R =&gt; F[O])scalaz.stream.Process[F,O]" id="scalaz.stream.io.bufferedResource">bufferedResource</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.io.bufferedResource;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.io.bufferedResource;F;_">_</a><span class="delimiter">]</span>,<a title="" id="scalaz.stream.io.bufferedResource;R">R</a>,<a title="" id="scalaz.stream.io.bufferedResource;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[R]" id="scalaz.stream.io.bufferedResource.acquire">acquire</a>: <a href="#scalaz.stream.io.bufferedResource;F" title="F[R]">F</a><span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>
                            <a title="R =&gt; F[O]" id="scalaz.stream.io.bufferedResource.flushAndRelease">flushAndRelease</a>: R =&gt; F<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>
                            <a title="R =&gt; F[O]" id="scalaz.stream.io.bufferedResource.step">step</a>: R =&gt; F<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.eval" title="(f: F[R])scalaz.stream.Process[F,R]">eval</a><span class="delimiter">(</span><a href="#scalaz.stream.io.bufferedResource.acquire" title="F[R]">acquire</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: R =&gt; scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">flatMap</a> <span class="delimiter">{</span> <a title="R" id="scalaz.stream.io.bufferedResource.$anonfun.r">r</a> =&gt;
      <a href="Process.scala.html#scalaz.stream.Process.repeatEval" title="(f: F[O])scalaz.stream.Process[F,O]">repeatEval</a><span class="delimiter">(</span><a href="#scalaz.stream.io.bufferedResource.step" title="(v1: R)F[O]">step</a><span class="delimiter">(</span><a href="#scalaz.stream.io.bufferedResource.$anonfun.r" title="R">r</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.onComplete" title="(p2: =&gt; scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">onComplete</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.eval" title="(f: F[O])scalaz.stream.Process[F,O]">eval</a><span class="delimiter">(</span><a href="#scalaz.stream.io.bufferedResource.flushAndRelease" title="(v1: R)F[O]">flushAndRelease</a><span class="delimiter">(</span><a href="#scalaz.stream.io.bufferedResource.$anonfun.r" title="R">r</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Implementation of resource for channels where resource needs to be
   * flushed at the end of processing.
   */</span>
  def <a title="[R, I, O](acquire: scalaz.concurrent.Task[R])(flush: R =&gt; scalaz.concurrent.Task[O])(release: R =&gt; scalaz.concurrent.Task[Unit])(step: R =&gt; scalaz.concurrent.Task[I =&gt; scalaz.concurrent.Task[O]])scalaz.stream.Channel[scalaz.concurrent.Task,Option[I],O]" id="scalaz.stream.io.bufferedChannel">bufferedChannel</a><span class="delimiter">[</span><a title="" id="scalaz.stream.io.bufferedChannel;R">R</a>,<a title="" id="scalaz.stream.io.bufferedChannel;I">I</a>,<a title="" id="scalaz.stream.io.bufferedChannel;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.concurrent.Task[R]" id="scalaz.stream.io.bufferedChannel.acquire">acquire</a>: <span title="scalaz.concurrent.Task[R]">Task</span><span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>
                             <a title="R =&gt; scalaz.concurrent.Task[O]" id="scalaz.stream.io.bufferedChannel.flush">flush</a>: R =&gt; Task<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>
                             <a title="R =&gt; scalaz.concurrent.Task[Unit]" id="scalaz.stream.io.bufferedChannel.release">release</a>: R =&gt; Task<span class="delimiter">[</span>Unit<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>
                             <a title="R =&gt; scalaz.concurrent.Task[I =&gt; scalaz.concurrent.Task[O]]" id="scalaz.stream.io.bufferedChannel.step">step</a>: R =&gt; Task<span class="delimiter">[</span>I =&gt; Task<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Channel[scalaz.concurrent.Task,Option[I],O]">Channel</a><span class="delimiter">[</span>Task,Option<span class="delimiter">[</span>I<span class="delimiter">]</span>,O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#scalaz.stream.io.resource" title="(acquire: scalaz.concurrent.Task[R])(release: R =&gt; scalaz.concurrent.Task[Unit])(step: R =&gt; scalaz.concurrent.Task[Option[I] =&gt; scalaz.concurrent.Task[O]])scalaz.stream.Process[scalaz.concurrent.Task,Option[I] =&gt; scalaz.concurrent.Task[O]]">resource</a><span class="delimiter">(</span><a href="#scalaz.stream.io.bufferedChannel.acquire" title="scalaz.concurrent.Task[R]">acquire</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.io.bufferedChannel.release" title="R =&gt; scalaz.concurrent.Task[Unit]">release</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a title="R" id="scalaz.stream.io.bufferedChannel.$anonfun.r">r</a> =&gt;
        val <a title="scalaz.concurrent.Task[I =&gt; scalaz.concurrent.Task[O]]" id="scalaz.stream.io.bufferedChannel.$anonfun.s">s</a> = <a href="#scalaz.stream.io.bufferedChannel.step" title="(v1: R)scalaz.concurrent.Task[I =&gt; scalaz.concurrent.Task[O]]">step</a><span class="delimiter">(</span><a href="#scalaz.stream.io.bufferedChannel.$anonfun.r" title="R">r</a><span class="delimiter">)</span>
        <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: Option[I] =&gt; scalaz.concurrent.Task[O])scalaz.concurrent.Task[Option[I] =&gt; scalaz.concurrent.Task[O]]">now</span> <a href="#scalaz.stream.io.bufferedChannel.$anonfun.$anonfun.x0$1" title="scalaz.concurrent.Task[O]" class="delimiter">{</a>
          case Some<span class="delimiter">(</span><a title="I" id="scalaz.stream.io.bufferedChannel.$anonfun.$anonfun.i">i</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.io.bufferedChannel.$anonfun.s" title="scalaz.concurrent.Task[I =&gt; scalaz.concurrent.Task[O]]">s</a> <span title="(f: (I =&gt; scalaz.concurrent.Task[O]) =&gt; scalaz.concurrent.Task[O])scalaz.concurrent.Task[O]">flatMap</span> <span class="delimiter">(</span><a title="I =&gt; scalaz.concurrent.Task[O]" id="scalaz.stream.io.bufferedChannel.$anonfun.$anonfun.$anonfun.f">f</a> =&gt; <a href="#scalaz.stream.io.bufferedChannel.$anonfun.$anonfun.$anonfun.f" title="(v1: I)scalaz.concurrent.Task[O]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.io.bufferedChannel.$anonfun.$anonfun.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
          case <span title="None.type">None</span> =&gt; <a href="#scalaz.stream.io.bufferedChannel.flush" title="(v1: R)scalaz.concurrent.Task[O]">flush</a><span class="delimiter">(</span><a href="#scalaz.stream.io.bufferedChannel.$anonfun.r" title="R">r</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Creates a `Channel[Task,Int,ByteVector]` from an `InputStream` by
   * repeatedly requesting the given number of bytes. The last chunk
   * may be less than the requested size.
   *
   * This implementation requires an array allocation for each read.
   * To recycle the input buffer, use `unsafeChunkR`.
   *
   * This implementation closes the `InputStream` when finished
   * or in the event of an error.
   */</span>
  def <a title="(is: =&gt; java.io.InputStream)scalaz.stream.Channel[scalaz.concurrent.Task,Int,scodec.bits.ByteVector]" id="scalaz.stream.io.chunkR">chunkR</a><span class="delimiter">(</span><a title="=&gt; java.io.InputStream" id="scalaz.stream.io.chunkR.is">is</a>: =&gt; InputStream<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Channel[scalaz.concurrent.Task,Int,scodec.bits.ByteVector]">Channel</a><span class="delimiter">[</span>Task,Int,ByteVector<span class="delimiter">]</span> =
    <a href="#scalaz.stream.io.unsafeChunkR" title="(is: =&gt; java.io.InputStream)scalaz.stream.Channel[scalaz.concurrent.Task,Array[Byte],Array[Byte]]">unsafeChunkR</a><span class="delimiter">(</span><a href="#scalaz.stream.io.chunkR.is" title="=&gt; java.io.InputStream">is</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.map" title="(f: (Array[Byte] =&gt; scalaz.concurrent.Task[Array[Byte]]) =&gt; (Int =&gt; scalaz.concurrent.Task[scodec.bits.ByteVector]))scalaz.stream.Process[scalaz.concurrent.Task,Int =&gt; scalaz.concurrent.Task[scodec.bits.ByteVector]]">map</a><span class="delimiter">(</span><a title="Array[Byte] =&gt; scalaz.concurrent.Task[Array[Byte]]" id="scalaz.stream.io.chunkR.$anonfun.f">f</a> =&gt; <span class="delimiter">(</span>n: <span title="Int">Int</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
      val <a title="Array[Byte]" id="scalaz.stream.io.chunkR.$anonfun.$anonfun.buf">buf</a> = new <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span><span class="delimiter">(</span><a href="#scalaz.stream.io.chunkR.$anonfun.$anonfun.n" title="Int">n</a><span class="delimiter">)</span>
      <a href="#scalaz.stream.io.chunkR.$anonfun.f" title="(v1: Array[Byte])scalaz.concurrent.Task[Array[Byte]]">f</a><span class="delimiter">(</span><a href="#scalaz.stream.io.chunkR.$anonfun.$anonfun.buf" title="Array[Byte]">buf</a><span class="delimiter">)</span>.<span title="(f: Array[Byte] =&gt; scodec.bits.ByteVector)scalaz.concurrent.Task[scodec.bits.ByteVector]">map</span><span class="delimiter">(</span><span title="scodec.bits.ByteVector.type">ByteVector</span>.<a href="#scalaz.stream.io.chunkR.$anonfun.$anonfun.$anonfun.bytes" title="(bytes: Array[Byte])scodec.bits.ByteVector">view</a><span class="delimiter">)</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Creates a `Sink` from an `OutputStream`, which will be closed
   * when this `Process` is halted.
   */</span>
  def <a title="(os: =&gt; java.io.OutputStream)scalaz.stream.Sink[scalaz.concurrent.Task,scodec.bits.ByteVector]" id="scalaz.stream.io.chunkW">chunkW</a><span class="delimiter">(</span><a title="=&gt; java.io.OutputStream" id="scalaz.stream.io.chunkW.os">os</a>: =&gt; OutputStream<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Sink[scalaz.concurrent.Task,scodec.bits.ByteVector]">Sink</a><span class="delimiter">[</span>Task,ByteVector<span class="delimiter">]</span> =
    <a href="#scalaz.stream.io.resource" title="(acquire: scalaz.concurrent.Task[java.io.OutputStream])(release: java.io.OutputStream =&gt; scalaz.concurrent.Task[Unit])(step: java.io.OutputStream =&gt; scalaz.concurrent.Task[scodec.bits.ByteVector =&gt; scalaz.concurrent.Task[Unit]])scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector =&gt; scalaz.concurrent.Task[Unit]]">resource</a><span class="delimiter">(</span><span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; java.io.OutputStream)scalaz.concurrent.Task[java.io.OutputStream]">delay</span><span class="delimiter">(</span><a href="#scalaz.stream.io.chunkW.os" title="=&gt; java.io.OutputStream">os</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="java.io.OutputStream">os</span> =&gt; <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; Unit)scalaz.concurrent.Task[Unit]">delay</span><span class="delimiter">(</span><span title="java.io.OutputStream">os</span>.<span title="()Unit">close</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
      <span title="java.io.OutputStream">os</span> =&gt; <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: scodec.bits.ByteVector =&gt; scalaz.concurrent.Task[Unit])scalaz.concurrent.Task[scodec.bits.ByteVector =&gt; scalaz.concurrent.Task[Unit]]">now</span><span class="delimiter">(</span><span class="delimiter">(</span>bytes: <span title="scodec.bits.ByteVector">ByteVector</span><span class="delimiter">)</span> =&gt; <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; Unit)scalaz.concurrent.Task[Unit]">delay</span><span class="delimiter">(</span><span title="java.io.OutputStream">os</span>.<span title="(x$1: Array[Byte])Unit">write</span><span class="delimiter">(</span><a href="#scalaz.stream.io.chunkW.$anonfun.$anonfun.bytes" title="scodec.bits.ByteVector">bytes</a>.<span title="=&gt; Array[Byte]">toArray</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Creates a `Sink` from a file name and optional buffer size in bytes.
   *
   * @param append if true, then bytes will be written to the end of the file
   *               rather than the beginning
   */</span>
  def <a title="(f: String, bufferSize: Int, append: Boolean)scalaz.stream.Sink[scalaz.concurrent.Task,scodec.bits.ByteVector]" id="scalaz.stream.io.fileChunkW">fileChunkW</a><span class="delimiter">(</span><a title="String" id="scalaz.stream.io.fileChunkW.f">f</a>: <span title="String">String</span>, <a title="Int" id="scalaz.stream.io.fileChunkW$default$2">bufferSize</a>: <span title="Int">Int</span> = <span title="Int(4096)" class="int">4096</span>, <a title="Boolean" id="scalaz.stream.io.fileChunkW$default$3">append</a>: <span title="Boolean">Boolean</span> = false<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Sink[scalaz.concurrent.Task,scodec.bits.ByteVector]">Sink</a><span class="delimiter">[</span>Task,ByteVector<span class="delimiter">]</span> =
    <a href="#scalaz.stream.io.chunkW" title="(os: =&gt; java.io.OutputStream)scalaz.stream.Sink[scalaz.concurrent.Task,scodec.bits.ByteVector]">chunkW</a><span class="delimiter">(</span>new <span title="java.io.BufferedOutputStream">BufferedOutputStream</span><span class="delimiter">(</span>new <span title="java.io.FileOutputStream">FileOutputStream</span><span class="delimiter">(</span><a href="#scalaz.stream.io.fileChunkW.f" title="String">f</a>, <a href="#scalaz.stream.io.fileChunkW$default$3" title="Boolean">append</a><span class="delimiter">)</span>, <a href="#scalaz.stream.io.fileChunkW$default$2" title="Int">bufferSize</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Creates a `Channel` from a file name and optional buffer size in bytes. */</span>
  def <a title="(f: String, bufferSize: Int)scalaz.stream.Channel[scalaz.concurrent.Task,Int,scodec.bits.ByteVector]" id="scalaz.stream.io.fileChunkR">fileChunkR</a><span class="delimiter">(</span><a title="String" id="scalaz.stream.io.fileChunkR.f">f</a>: <span title="String">String</span>, <a title="Int" id="scalaz.stream.io.fileChunkR$default$2">bufferSize</a>: <span title="Int">Int</span> = <span title="Int(4096)" class="int">4096</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Channel[scalaz.concurrent.Task,Int,scodec.bits.ByteVector]">Channel</a><span class="delimiter">[</span>Task,Int,ByteVector<span class="delimiter">]</span> =
    <a href="#scalaz.stream.io.chunkR" title="(is: =&gt; java.io.InputStream)scalaz.stream.Channel[scalaz.concurrent.Task,Int,scodec.bits.ByteVector]">chunkR</a><span class="delimiter">(</span>new <span title="java.io.BufferedInputStream">BufferedInputStream</span><span class="delimiter">(</span>new <span title="java.io.FileInputStream">FileInputStream</span><span class="delimiter">(</span><a href="#scalaz.stream.io.fileChunkR.f" title="String">f</a><span class="delimiter">)</span>, <a href="#scalaz.stream.io.fileChunkR$default$2" title="Int">bufferSize</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A `Sink` which, as a side effect, adds elements to the given `Buffer`. */</span>
  def <a title="[A](buf: scala.collection.mutable.Buffer[A])scalaz.stream.Sink[scalaz.concurrent.Task,A]" id="scalaz.stream.io.fillBuffer">fillBuffer</a><span class="delimiter">[</span><a title="" id="scalaz.stream.io.fillBuffer;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.collection.mutable.Buffer[A]" id="scalaz.stream.io.fillBuffer.buf">buf</a>: collection.mutable.<span title="scala.collection.mutable.Buffer[A]">Buffer</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Sink[scalaz.concurrent.Task,A]">Sink</a><span class="delimiter">[</span>Task,A<span class="delimiter">]</span> =
    <a href="channel.scala.html#scalaz.stream.channel" title="scalaz.stream.channel.type">channel</a>.<a href="channel.scala.html#scalaz.stream.channel.lift" title="(f: A =&gt; scalaz.concurrent.Task[Unit])scalaz.stream.Channel[scalaz.concurrent.Task,A,Unit]">lift</a><span class="delimiter">(</span><span class="delimiter">(</span>a: <a href="#scalaz.stream.io.fillBuffer;A" title="A">A</a><span class="delimiter">)</span> =&gt; <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; Unit)scalaz.concurrent.Task[Unit]">delay</span> <span class="delimiter">{</span> <a href="#scalaz.stream.io.fillBuffer.buf" title="scala.collection.mutable.Buffer[A]">buf</a> <span title="(elem: A)buf.type">+=</span> <a href="#scalaz.stream.io.fillBuffer.$anonfun.a" title="A">a</a> <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Creates a `Process[Task,String]` from the lines of a file, using
   * the `resource` combinator to ensure the file is closed
   * when processing the stream of lines is finished.
   */</span>
  def <a title="(filename: String)(implicit codec: scala.io.Codec)scalaz.stream.Process[scalaz.concurrent.Task,String]" id="scalaz.stream.io.linesR(a59878835d)">linesR</a><span class="delimiter">(</span><a title="String" id="scalaz.stream.io.linesR(a59878835d).filename">filename</a>: <span title="String">String</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.io.Codec" id="scalaz.stream.io.linesR(a59878835d).codec">codec</a>: <span title="scala.io.Codec">Codec</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,String]">Process</a><span class="delimiter">[</span>Task,String<span class="delimiter">]</span> =
    <a href="#scalaz.stream.io.linesR(4202e4647f)" title="(src: =&gt; scala.io.Source)scalaz.stream.Process[scalaz.concurrent.Task,String]">linesR</a><span class="delimiter">(</span><span title="scala.io.Source.type">Source</span>.<span title="(name: String)(implicit codec: scala.io.Codec)scala.io.BufferedSource">fromFile</span><span class="delimiter">(</span><a href="#scalaz.stream.io.linesR(a59878835d).filename" title="String">filename</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.io.linesR(a59878835d).codec" title="scala.io.Codec">codec</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Creates a `Process[Task,String]` from the lines of the `InputStream`,
   * using the `resource` combinator to ensure the `InputStream` is closed
   * when processing the stream of lines is finished.
   */</span>
  def <a title="(in: =&gt; java.io.InputStream)(implicit codec: scala.io.Codec)scalaz.stream.Process[scalaz.concurrent.Task,String]" id="scalaz.stream.io.linesR(2b3488345c)">linesR</a><span class="delimiter">(</span><a title="=&gt; java.io.InputStream" id="scalaz.stream.io.linesR(2b3488345c).in">in</a>: =&gt; InputStream<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.io.Codec" id="scalaz.stream.io.linesR(2b3488345c).codec">codec</a>: <span title="scala.io.Codec">Codec</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,String]">Process</a><span class="delimiter">[</span>Task,String<span class="delimiter">]</span> =
    <a href="#scalaz.stream.io.linesR(4202e4647f)" title="(src: =&gt; scala.io.Source)scalaz.stream.Process[scalaz.concurrent.Task,String]">linesR</a><span class="delimiter">(</span><span title="scala.io.Source.type">Source</span>.<span title="(is: java.io.InputStream)(implicit codec: scala.io.Codec)scala.io.BufferedSource">fromInputStream</span><span class="delimiter">(</span><a href="#scalaz.stream.io.linesR(2b3488345c).in" title="=&gt; java.io.InputStream">in</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scalaz.stream.io.linesR(2b3488345c).codec" title="scala.io.Codec">codec</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Creates a `Process[Task,String]` from the lines of the `Source`,
   * using the `resource` combinator to ensure the `Source` is closed
   * when processing the stream of lines is finished.
   */</span>
  def <a title="(src: =&gt; scala.io.Source)scalaz.stream.Process[scalaz.concurrent.Task,String]" id="scalaz.stream.io.linesR(4202e4647f)">linesR</a><span class="delimiter">(</span><a title="=&gt; scala.io.Source" id="scalaz.stream.io.linesR(4202e4647f).src">src</a>: =&gt; Source<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,String]">Process</a><span class="delimiter">[</span>Task,String<span class="delimiter">]</span> =
    <a href="#scalaz.stream.io.resource" title="(acquire: scalaz.concurrent.Task[scala.io.Source])(release: scala.io.Source =&gt; scalaz.concurrent.Task[Unit])(step: scala.io.Source =&gt; scalaz.concurrent.Task[String])scalaz.stream.Process[scalaz.concurrent.Task,String]">resource</a><span class="delimiter">(</span><span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; scala.io.Source)scalaz.concurrent.Task[scala.io.Source]">delay</span><span class="delimiter">(</span><a href="#scalaz.stream.io.linesR(4202e4647f).src" title="=&gt; scala.io.Source">src</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="scala.io.Source">src</span> =&gt; <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; Unit)scalaz.concurrent.Task[Unit]">delay</span><span class="delimiter">(</span><span title="scala.io.Source">src</span>.<span title="()Unit">close</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="scala.io.Source">src</span> =&gt;
      lazy val <a title="Iterator[String]" id="scalaz.stream.io.linesR(4202e4647f).$anonfun.lines">lines</a> = <span title="scala.io.Source">src</span>.<span title="()Iterator[String]">getLines</span> <span class="comment">// A stateful iterator</span>
      <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; String)scalaz.concurrent.Task[String]">delay</span> <span class="delimiter">{</span> if <span class="delimiter">(</span><a href="#scalaz.stream.io.linesR(4202e4647f).$anonfun.lines" title="=&gt; Iterator[String]">lines</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <a href="#scalaz.stream.io.linesR(4202e4647f).$anonfun.lines" title="=&gt; Iterator[String]">lines</a>.<span title="()String">next</span> else throw <a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>.<a href="Cause.scala.html#scalaz.stream.Cause;Terminated" title="(cause: scalaz.stream.Cause)scalaz.stream.Cause.Terminated">Terminated</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>.<a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Creates `Sink` from an `PrintStream` using `f` to perform
   * specific side effects on that `PrintStream`.
   */</span>
  def <a title="[O](out: java.io.PrintStream)(f: (java.io.PrintStream, O) =&gt; Unit)scalaz.stream.Sink[scalaz.concurrent.Task,O]" id="scalaz.stream.io.printStreamSink">printStreamSink</a><span class="delimiter">[</span><a title="" id="scalaz.stream.io.printStreamSink;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="java.io.PrintStream" id="scalaz.stream.io.printStreamSink.out">out</a>: <span title="java.io.PrintStream">PrintStream</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(java.io.PrintStream, O) =&gt; Unit" id="scalaz.stream.io.printStreamSink.f">f</a>: <span class="delimiter">(</span>PrintStream, O<span class="delimiter">)</span> =&gt; Unit<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Sink[scalaz.concurrent.Task,O]">Sink</a><span class="delimiter">[</span>Task, O<span class="delimiter">]</span> =
    <a href="channel.scala.html#scalaz.stream.channel" title="scalaz.stream.channel.type">channel</a>.<a href="channel.scala.html#scalaz.stream.channel.lift" title="(f: O =&gt; scalaz.concurrent.Task[Unit])scalaz.stream.Channel[scalaz.concurrent.Task,O,Unit]">lift</a><span class="delimiter">(</span><span class="delimiter">(</span>o: <a href="#scalaz.stream.io.printStreamSink;O" title="O">O</a><span class="delimiter">)</span> =&gt; <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; Unit)scalaz.concurrent.Task[Unit]">delay</span> <span class="delimiter">{</span>
      <a href="#scalaz.stream.io.printStreamSink.f" title="(v1: java.io.PrintStream, v2: O)Unit">f</a><span class="delimiter">(</span><a href="#scalaz.stream.io.printStreamSink.out" title="java.io.PrintStream">out</a>, <a href="#scalaz.stream.io.printStreamSink.$anonfun.o" title="O">o</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scalaz.stream.io.printStreamSink.out" title="java.io.PrintStream">out</a>.<span title="()Boolean">checkError</span><span class="delimiter">)</span>
        throw <a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>.<a href="Cause.scala.html#scalaz.stream.Cause;Terminated" title="(cause: scalaz.stream.Cause)scalaz.stream.Cause.Terminated">Terminated</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>.<a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Turn a `PrintStream` into a `Sink`. This `Sink` does not
   * emit newlines after each element. For that, use `printLines`.
   */</span>
  def <a title="(out: java.io.PrintStream)scalaz.stream.Sink[scalaz.concurrent.Task,String]" id="scalaz.stream.io.print">print</a><span class="delimiter">(</span><a title="java.io.PrintStream" id="scalaz.stream.io.print.out">out</a>: <span title="java.io.PrintStream">PrintStream</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Sink[scalaz.concurrent.Task,String]">Sink</a><span class="delimiter">[</span>Task,String<span class="delimiter">]</span> = <a href="#scalaz.stream.io.printStreamSink" title="(out: java.io.PrintStream)(f: (java.io.PrintStream, String) =&gt; Unit)scalaz.stream.Sink[scalaz.concurrent.Task,String]">printStreamSink</a><span class="delimiter">(</span><a href="#scalaz.stream.io.print.out" title="java.io.PrintStream">out</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="java.io.PrintStream" id="scalaz.stream.io.print.$anonfun.ps">ps</a>, <a title="String" id="scalaz.stream.io.print.$anonfun.o">o</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.io.print.$anonfun.ps" title="java.io.PrintStream">ps</a>.<span title="(x$1: String)Unit">print</span><span class="delimiter">(</span><a href="#scalaz.stream.io.print.$anonfun.o" title="String">o</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Turn a `PrintStream` into a `Sink`. This `Sink` emits
   * newlines after each element. If this is not desired, use `print`.
   */</span>
  def <a title="(out: java.io.PrintStream)scalaz.stream.Sink[scalaz.concurrent.Task,String]" id="scalaz.stream.io.printLines">printLines</a><span class="delimiter">(</span><a title="java.io.PrintStream" id="scalaz.stream.io.printLines.out">out</a>: <span title="java.io.PrintStream">PrintStream</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Sink[scalaz.concurrent.Task,String]">Sink</a><span class="delimiter">[</span>Task,String<span class="delimiter">]</span> = <a href="#scalaz.stream.io.printStreamSink" title="(out: java.io.PrintStream)(f: (java.io.PrintStream, String) =&gt; Unit)scalaz.stream.Sink[scalaz.concurrent.Task,String]">printStreamSink</a><span class="delimiter">(</span><a href="#scalaz.stream.io.printLines.out" title="java.io.PrintStream">out</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="java.io.PrintStream" id="scalaz.stream.io.printLines.$anonfun.ps">ps</a>, <a title="String" id="scalaz.stream.io.printLines.$anonfun.o">o</a><span class="delimiter">)</span> =&gt; <a href="#scalaz.stream.io.printLines.$anonfun.ps" title="java.io.PrintStream">ps</a>.<span title="(x$1: String)Unit">println</span><span class="delimiter">(</span><a href="#scalaz.stream.io.printLines.$anonfun.o" title="String">o</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Generic combinator for producing a `Process[F,O]` from some
   * effectful `O` source. The source is tied to some resource,
   * `R` (like a file handle) that we want to ensure is released.
   * See `linesR` for an example use.
   */</span>
  def <a title="[F[_], R, O](acquire: F[R])(release: R =&gt; F[Unit])(step: R =&gt; F[O])scalaz.stream.Process[F,O]" id="scalaz.stream.io.resource">resource</a><span class="delimiter">[</span><a title="[_]" id="scalaz.stream.io.resource;F">F</a><span class="delimiter">[</span><a title="" id="scalaz.stream.io.resource;F;_">_</a><span class="delimiter">]</span>,<a title="" id="scalaz.stream.io.resource;R">R</a>,<a title="" id="scalaz.stream.io.resource;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[R]" id="scalaz.stream.io.resource.acquire">acquire</a>: <a href="#scalaz.stream.io.resource;F" title="F[R]">F</a><span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>
                         <a title="R =&gt; F[Unit]" id="scalaz.stream.io.resource.release">release</a>: R =&gt; F<span class="delimiter">[</span>Unit<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>
                         <a title="R =&gt; F[O]" id="scalaz.stream.io.resource.step">step</a>: R =&gt; F<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[F,O]">Process</a><span class="delimiter">[</span>F,O<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process.eval" title="(f: F[R])scalaz.stream.Process[F,R]">eval</a><span class="delimiter">(</span><a href="#scalaz.stream.io.resource.acquire" title="F[R]">acquire</a><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.flatMap" title="(f: R =&gt; scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">flatMap</a> <span class="delimiter">{</span> <a title="R" id="scalaz.stream.io.resource.$anonfun.r">r</a> =&gt;
      <a href="Process.scala.html#scalaz.stream.Process.repeatEval" title="(f: F[O])scalaz.stream.Process[F,O]">repeatEval</a><span class="delimiter">(</span><a href="#scalaz.stream.io.resource.step" title="(v1: R)F[O]">step</a><span class="delimiter">(</span><a href="#scalaz.stream.io.resource.$anonfun.r" title="R">r</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="Process.scala.html#scalaz.stream;Process.onComplete" title="(p2: =&gt; scalaz.stream.Process[[x]F[x],O])scalaz.stream.Process[[x]F[x],O]">onComplete</a><span class="delimiter">(</span><a href="Process.scala.html#scalaz.stream.Process.eval_" title="(f: F[Unit])scalaz.stream.Process[F,Nothing]">eval_</a><span class="delimiter">(</span><a href="#scalaz.stream.io.resource.release" title="(v1: R)F[Unit]">release</a><span class="delimiter">(</span><a href="#scalaz.stream.io.resource.$anonfun.r" title="R">r</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * The standard input stream, as `Process`. This `Process` repeatedly awaits
   * and emits chunks of bytes  from standard input.
   */</span>
  def <a title="=&gt; scalaz.stream.Channel[scalaz.concurrent.Task,Int,scodec.bits.ByteVector]" id="scalaz.stream.io.stdInBytes">stdInBytes</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Channel[scalaz.concurrent.Task,Int,scodec.bits.ByteVector]">Channel</a><span class="delimiter">[</span>Task, Int, ByteVector<span class="delimiter">]</span> =
    <a href="#scalaz.stream.io" title="scalaz.stream.io.type">io</a>.<a href="#scalaz.stream.io.chunkR" title="(is: =&gt; java.io.InputStream)scalaz.stream.Channel[scalaz.concurrent.Task,Int,scodec.bits.ByteVector]">chunkR</a><span class="delimiter">(</span><span title="System.type">System</span>.<span title="java.io.InputStream">in</span><span class="delimiter">)</span>

  <span class="comment">/**
   * The standard input stream, as `Process`. This `Process` repeatedly awaits
   * and emits lines from standard input.
   */</span>
  def <a title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,String]" id="scalaz.stream.io.stdInLines">stdInLines</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,String]">Process</a><span class="delimiter">[</span>Task,String<span class="delimiter">]</span> =
    <a href="Process.scala.html#scalaz.stream.Process" title="scalaz.stream.Process.type">Process</a>.<a href="Process.scala.html#scalaz.stream.Process.repeatEval" title="(f: scalaz.concurrent.Task[String])scalaz.stream.Process[scalaz.concurrent.Task,String]">repeatEval</a><span class="delimiter">(</span><span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; String)scalaz.concurrent.Task[String]">delay</span> <span class="delimiter">{</span> <span title="(x: String)Option[String]">Option</span><span class="delimiter">(</span>scala.<span title="Console.type">Console</span>.<span title="()String">readLine</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(default: =&gt; String)String">getOrElse</span><span class="delimiter">(</span>throw <a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>.<a href="Cause.scala.html#scalaz.stream.Cause;Terminated" title="(cause: scalaz.stream.Cause)scalaz.stream.Cause.Terminated">Terminated</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>.<a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="comment">/**
   * The standard output stream, as a `Sink`. This `Sink` does not
   * emit newlines after each element. For that, use `stdOutLines`.
   */</span>
  def <a title="=&gt; scalaz.stream.Sink[scalaz.concurrent.Task,String]" id="scalaz.stream.io.stdOut">stdOut</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Sink[scalaz.concurrent.Task,String]">Sink</a><span class="delimiter">[</span>Task,String<span class="delimiter">]</span> =
    <a href="#scalaz.stream.io.print" title="(out: java.io.PrintStream)scalaz.stream.Sink[scalaz.concurrent.Task,String]">print</a><span class="delimiter">(</span><span title="System.type">System</span>.<span title="java.io.PrintStream">out</span><span class="delimiter">)</span>

  <span class="comment">/**
   * The standard output stream, as a `ByteVector` `Sink`.
   */</span>
  def <a title="=&gt; scalaz.stream.Sink[scalaz.concurrent.Task,scodec.bits.ByteVector]" id="scalaz.stream.io.stdOutBytes">stdOutBytes</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Sink[scalaz.concurrent.Task,scodec.bits.ByteVector]">Sink</a><span class="delimiter">[</span>Task, ByteVector<span class="delimiter">]</span> =
    <a href="#scalaz.stream.io.chunkW" title="(os: =&gt; java.io.OutputStream)scalaz.stream.Sink[scalaz.concurrent.Task,scodec.bits.ByteVector]">chunkW</a><span class="delimiter">(</span><span title="System.type">System</span>.<span title="java.io.PrintStream">out</span><span class="delimiter">)</span>

  <span class="comment">/**
   * The standard output stream, as a `Sink`. This `Sink` emits
   * newlines after each element. If this is not desired, use `stdOut`.
   */</span>
  def <a title="=&gt; scalaz.stream.Sink[scalaz.concurrent.Task,String]" id="scalaz.stream.io.stdOutLines">stdOutLines</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Sink[scalaz.concurrent.Task,String]">Sink</a><span class="delimiter">[</span>Task,String<span class="delimiter">]</span> =
    <a href="#scalaz.stream.io.printLines" title="(out: java.io.PrintStream)scalaz.stream.Sink[scalaz.concurrent.Task,String]">printLines</a><span class="delimiter">(</span><span title="System.type">System</span>.<span title="java.io.PrintStream">out</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Creates a `Channel[Task,Array[Byte],Array[Byte]]` from an `InputStream` by
   * repeatedly filling the input buffer. The last chunk may be less
   * than the requested size.
   *
   * It is safe to recycle the same buffer for consecutive reads
   * as long as whatever consumes this `Process` never stores the `Array[Byte]`
   * returned or pipes it to a combinator (like `buffer`) that does.
   * Use `chunkR` for a safe version of this combinator - this takes
   * an `Int` number of bytes to read and allocates a fresh `Array[Byte]`
   * for each read.
   *
   * This implementation closes the `InputStream` when finished
   * or in the event of an error.
   */</span>
  def <a title="(is: =&gt; java.io.InputStream)scalaz.stream.Channel[scalaz.concurrent.Task,Array[Byte],Array[Byte]]" id="scalaz.stream.io.unsafeChunkR">unsafeChunkR</a><span class="delimiter">(</span><a title="=&gt; java.io.InputStream" id="scalaz.stream.io.unsafeChunkR.is">is</a>: =&gt; InputStream<span class="delimiter">)</span>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Channel[scalaz.concurrent.Task,Array[Byte],Array[Byte]]">Channel</a><span class="delimiter">[</span>Task,Array<span class="delimiter">[</span>Byte<span class="delimiter">]</span>,Array<span class="delimiter">[</span>Byte<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#scalaz.stream.io.resource" title="(acquire: scalaz.concurrent.Task[java.io.InputStream])(release: java.io.InputStream =&gt; scalaz.concurrent.Task[Unit])(step: java.io.InputStream =&gt; scalaz.concurrent.Task[Array[Byte] =&gt; scalaz.concurrent.Task[Array[Byte]]])scalaz.stream.Process[scalaz.concurrent.Task,Array[Byte] =&gt; scalaz.concurrent.Task[Array[Byte]]]">resource</a><span class="delimiter">(</span><span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; java.io.InputStream)scalaz.concurrent.Task[java.io.InputStream]">delay</span><span class="delimiter">(</span><a href="#scalaz.stream.io.unsafeChunkR.is" title="=&gt; java.io.InputStream">is</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
             <span title="java.io.InputStream">src</span> =&gt; <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; Unit)scalaz.concurrent.Task[Unit]">delay</span><span class="delimiter">(</span><span title="java.io.InputStream">src</span>.<span title="()Unit">close</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="java.io.InputStream">src</span> =&gt;
      <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: Array[Byte] =&gt; scalaz.concurrent.Task[Array[Byte]])scalaz.concurrent.Task[Array[Byte] =&gt; scalaz.concurrent.Task[Array[Byte]]]">now</span> <span class="delimiter">{</span> <span class="delimiter">(</span>buf: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span title="scalaz.concurrent.Task.type">Task</span>.<span title="(a: =&gt; Array[Byte])scalaz.concurrent.Task[Array[Byte]]">delay</span> <span class="delimiter">{</span>
        val <a title="Int" id="scalaz.stream.io.unsafeChunkR.$anonfun.$anonfun.m">m</a> = <span title="java.io.InputStream">src</span>.<span title="(x$1: Array[Byte])Int">read</span><span class="delimiter">(</span><a href="#scalaz.stream.io.unsafeChunkR.$anonfun.$anonfun.buf" title="Array[Byte]">buf</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scalaz.stream.io.unsafeChunkR.$anonfun.$anonfun.m" title="Int">m</a> <span title="(x: Int)Boolean">==</span> <a href="#scalaz.stream.io.unsafeChunkR.$anonfun.$anonfun.buf" title="Array[Byte]">buf</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#scalaz.stream.io.unsafeChunkR.$anonfun.$anonfun.buf" title="Array[Byte]">buf</a>
        else if <span class="delimiter">(</span><a href="#scalaz.stream.io.unsafeChunkR.$anonfun.$anonfun.m" title="Int">m</a> <span title="(x: Int)Boolean">==</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span> throw <a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>.<a href="Cause.scala.html#scalaz.stream.Cause;Terminated" title="(cause: scalaz.stream.Cause)scalaz.stream.Cause.Terminated">Terminated</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>.<a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a><span class="delimiter">)</span>
        else <a href="#scalaz.stream.io.unsafeChunkR.$anonfun.$anonfun.buf" title="implicit scala.Predef.byteArrayOps : (xs: Array[Byte])scala.collection.mutable.ArrayOps[Byte]">buf</a>.<span title="(n: Int)Array[Byte]">take</span><span class="delimiter">(</span><a href="#scalaz.stream.io.unsafeChunkR.$anonfun.$anonfun.m" title="Int">m</a><span class="delimiter">)</span>
      <span class="delimiter">}</span><span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Converts a source to a mutable `InputStream`.  The resulting input stream
   * should be reasonably efficient and supports early termination (i.e. all
   * finalizers associated with the input process will be run if the stream is
   * closed).
   */</span>
  def <a title="(p: scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector])java.io.InputStream" id="scalaz.stream.io.toInputStream">toInputStream</a><span class="delimiter">(</span><a title="scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]" id="scalaz.stream.io.toInputStream.p">p</a>: <a href="Process.scala.html#scalaz.stream;Process" title="scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]">Process</a><span class="delimiter">[</span>Task, ByteVector<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="java.io.InputStream">InputStream</span> = new <a title="&lt;$anon: java.io.InputStream&gt; extends java.io.InputStream" id="scalaz.stream.io.toInputStream;$anon">InputStream</a> <span class="delimiter">{</span>
    import <a href="Cause.scala.html#scalaz.stream.Cause" title="scalaz.stream.Cause.type">Cause</a>.<span class="delimiter">{</span>EarlyCause, End, Kill<span class="delimiter">}</span>

    var <a title="scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]" id="scalaz.stream.io.toInputStream;$anon.cur_=">cur</a> = <a href="#scalaz.stream.io.toInputStream.p" title="scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]">p</a>

    var <a title="Int" id="scalaz.stream.io.toInputStream;$anon.index_=">index</a> = <span title="Int(0)" class="int">0</span>
    var <a title="Seq[scodec.bits.ByteVector]" id="scalaz.stream.io.toInputStream;$anon.chunks_=">chunks</a>: <span title="Seq[scodec.bits.ByteVector]">Seq</span><span class="delimiter">[</span>ByteVector<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>    <span class="comment">// we only consider the head to be valid at any point in time</span>

    def <a title="()Int" id="scalaz.stream.io.toInputStream;$anon.read(c663c7b3ba)">read</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.cur_=" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.isHalt" title="=&gt; Boolean">isHalt</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#scalaz.stream.io.toInputStream;$anon.chunks_=" title="=&gt; Seq[scodec.bits.ByteVector]">chunks</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        -<span title="Int(-1)" class="int">1</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        val <a title="Array[Byte]" id="scalaz.stream.io.toInputStream;$anon.read(c663c7b3ba).buffer">buffer</a> = new <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
        val <a title="Int" id="scalaz.stream.io.toInputStream;$anon.read(c663c7b3ba).bytesRead">bytesRead</a> = <a href="#scalaz.stream.io.toInputStream;$anon" title="(x$1: Array[Byte])Int">read</a><span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.read(c663c7b3ba).buffer" title="Array[Byte]">buffer</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.read(c663c7b3ba).bytesRead" title="Int">bytesRead</a> <span title="(x: Int)Boolean">==</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          -<span title="Int(-1)" class="int">1</span>
        <span class="delimiter">}</span> else <span class="delimiter">{</span>
          <a href="#scalaz.stream.io.toInputStream;$anon.read(c663c7b3ba).buffer" title="(i: Int)Byte">buffer</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x: Int)Int">&amp;</span> <span title="Int(255)" class="int">0xff</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    override def <a title="(buffer: Array[Byte], offset: Int, length: Int)Int" id="scalaz.stream.io.toInputStream;$anon.read(88258ccb5f)">read</a><span class="delimiter">(</span><a title="Array[Byte]" id="scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).buffer">buffer</a>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span>, <a title="Int" id="scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).offset">offset</a>: <span title="Int">Int</span>, <a title="Int" id="scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).length">length</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.cur_=" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.isHalt" title="=&gt; Boolean">isHalt</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#scalaz.stream.io.toInputStream;$anon.chunks_=" title="=&gt; Seq[scodec.bits.ByteVector]">chunks</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        -<span title="Int(-1)" class="int">1</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <span class="comment">// when our index walks off the end of our last chunk, we need to Nil it out!</span>
        if <span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.chunks_=" title="=&gt; Seq[scodec.bits.ByteVector]">chunks</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#scalaz.stream.io.toInputStream;$anon.step" title="()Unit">step</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f)" title="(buffer: Array[Byte], offset: Int, length: Int)Int">read</a><span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).buffer" title="Array[Byte]">buffer</a>, <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).offset" title="Int">offset</a>, <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).length" title="Int">length</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> else <span class="delimiter">{</span>
          @tailrec
          def <a title="(offset: Int, length: Int, read: Int)Int" id="scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go">go</a><span class="delimiter">(</span><a title="Int" id="scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.offset">offset</a>: <span title="Int">Int</span>, <a title="Int" id="scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.length">length</a>: <span title="Int">Int</span>, <a title="Int" id="scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.read">read</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
            if <span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.chunks_=" title="=&gt; Seq[scodec.bits.ByteVector]">chunks</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="comment">// we already took care of the &quot;halted at start&quot; stillborn case, so we can safely just step</span>
              <a href="#scalaz.stream.io.toInputStream;$anon.step" title="()Unit">step</a><span class="delimiter">(</span><span class="delimiter">)</span>

              if <span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.cur_=" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.isHalt" title="=&gt; Boolean">isHalt</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#scalaz.stream.io.toInputStream;$anon.chunks_=" title="=&gt; Seq[scodec.bits.ByteVector]">chunks</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
                <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.read" title="Int">read</a>         <span class="comment">// whoops! we walked off the end of the stream and we're done</span>
              else
                <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go" title="(offset: Int, length: Int, read: Int)Int">go</a><span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.offset" title="Int">offset</a>, <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.length" title="Int">length</a>, <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.read" title="Int">read</a><span class="delimiter">)</span>
            <span class="delimiter">}</span> else <span class="delimiter">{</span>
              val <a title="scodec.bits.ByteVector" id="scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.chunk">chunk</a> = <a href="#scalaz.stream.io.toInputStream;$anon.chunks_=" title="=&gt; Seq[scodec.bits.ByteVector]">chunks</a>.<span title="=&gt; scodec.bits.ByteVector">head</span>
              val remaining = <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.chunk" title="scodec.bits.ByteVector">chunk</a>.<span title="=&gt; Int">length</span> <a title="Int" id="scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.remaining">-</a> <a href="#scalaz.stream.io.toInputStream;$anon.index_=" title="=&gt; Int">index</a>

              if <span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.length" title="Int">length</a> <span title="(x: Int)Boolean">&lt;=</span> <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.remaining" title="Int">remaining</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.chunk" title="scodec.bits.ByteVector">chunk</a>.<span title="(xs: Array[Byte], start: Int, offset: Int, size: Int)Unit">copyToArray</span><span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).buffer" title="Array[Byte]">buffer</a>, <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.offset" title="Int">offset</a>, <a href="#scalaz.stream.io.toInputStream;$anon.index_=" title="=&gt; Int">index</a>, <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.length" title="Int">length</a><span class="delimiter">)</span>

                if <span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.length" title="Int">length</a> <span title="(x: Int)Boolean">==</span> <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.remaining" title="Int">remaining</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <a href="#scalaz.stream.io.toInputStream;$anon.index_=" title="(x$1: Int)Unit">index</a> = <span title="Int(0)" class="int">0</span>
                  <a href="#scalaz.stream.io.toInputStream;$anon.chunks_=" title="(x$1: Seq[scodec.bits.ByteVector])Unit">chunks</a> = <a href="#scalaz.stream.io.toInputStream;$anon.chunks_=" title="=&gt; Seq[scodec.bits.ByteVector]">chunks</a>.<span title="=&gt; Seq[scodec.bits.ByteVector]">tail</span>
                <span class="delimiter">}</span> else <span class="delimiter">{</span>
                  <a href="#scalaz.stream.io.toInputStream;$anon.index_=" title="(x$1: Int)Unit">index</a> <span title="(x: Int)Int">+=</span> <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.length" title="Int">length</a>
                <span class="delimiter">}</span>

                <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.length" title="Int">length</a> <span title="(x: Int)Int">+</span> <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.read" title="Int">read</a>
              <span class="delimiter">}</span> else <span class="delimiter">{</span>
                <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.chunk" title="scodec.bits.ByteVector">chunk</a>.<span title="(xs: Array[Byte], start: Int, offset: Int, size: Int)Unit">copyToArray</span><span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).buffer" title="Array[Byte]">buffer</a>, <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.offset" title="Int">offset</a>, <a href="#scalaz.stream.io.toInputStream;$anon.index_=" title="=&gt; Int">index</a>, <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.remaining" title="Int">remaining</a><span class="delimiter">)</span>

                <a href="#scalaz.stream.io.toInputStream;$anon.chunks_=" title="(x$1: Seq[scodec.bits.ByteVector])Unit">chunks</a> = <a href="#scalaz.stream.io.toInputStream;$anon.chunks_=" title="=&gt; Seq[scodec.bits.ByteVector]">chunks</a>.<span title="=&gt; Seq[scodec.bits.ByteVector]">tail</span>
                <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go" title="(offset: Int, length: Int, read: Int)Int">go</a><span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.offset" title="Int">offset</a> <span title="(x: Int)Int">+</span> <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.remaining" title="Int">remaining</a>, <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.length" title="Int">length</a> <span title="(x: Int)Int">-</span> <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.remaining" title="Int">remaining</a>, <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.read" title="Int">read</a> <span title="(x: Int)Int">+</span> <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go.remaining" title="Int">remaining</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>

          <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).go" title="(offset: Int, length: Int, read: Int)Int">go</a><span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).offset" title="Int">offset</a>, <a href="#scalaz.stream.io.toInputStream;$anon.read(88258ccb5f).length" title="Int">length</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    @tailrec
    override def <a title="()Unit" id="scalaz.stream.io.toInputStream;$anon.close">close</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.cur_=" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.isHalt" title="=&gt; Boolean">isHalt</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#scalaz.stream.io.toInputStream;$anon.chunks_=" title="=&gt; Seq[scodec.bits.ByteVector]">chunks</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scalaz.stream.io.toInputStream;$anon.chunks_=" title="(x$1: Seq[scodec.bits.ByteVector])Unit">chunks</a> = <span title="scala.collection.immutable.Nil.type">Nil</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <a href="#scalaz.stream.io.toInputStream;$anon.cur_=" title="(x$1: scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector])Unit">cur</a> = <a href="#scalaz.stream.io.toInputStream;$anon.cur_=" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.kill" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,Nothing]">kill</a>
        <a href="#scalaz.stream.io.toInputStream;$anon.cur_=" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.concurrent.Task,scodec.bits.ByteVector]">step</a> match <span class="delimiter">{</span>
          case Halt<span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a> | <a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span> =&gt;
            <a href="#scalaz.stream.io.toInputStream;$anon.chunks_=" title="(x$1: Seq[scodec.bits.ByteVector])Unit">chunks</a> = <span title="scala.collection.immutable.Nil.type">Nil</span>

          <span class="comment">// rethrow halting errors</span>
          case Halt<span class="delimiter">(</span>Cause.Error<span class="delimiter">(</span><span title="Error">e</span>: <span title="Error">Error</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; throw <span title="Error">e</span>
          case Halt<span class="delimiter">(</span>Cause.Error<span class="delimiter">(</span><span title="Exception">e</span>: <span title="Exception">Exception</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; throw new <span title="java.io.IOException">IOException</span><span class="delimiter">(</span><span title="Exception">e</span><span class="delimiter">)</span>

          case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span>_<span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span>false<span class="delimiter">)</span>    <span class="comment">// this is impossible, according to the types</span>

          case Step<span class="delimiter">(</span>Await<span class="delimiter">(</span><a title="scalaz.concurrent.Task[Any]" id="scalaz.stream.io.toInputStream;$anon.close.request">request</a>, <a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]]" id="scalaz.stream.io.toInputStream;$anon.close.receive">receive</a><span class="delimiter">)</span>, <a title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,scodec.bits.ByteVector]" id="scalaz.stream.io.toInputStream;$anon.close.cont">cont</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
            <span class="comment">// yay! run the Task</span>
            <a href="#scalaz.stream.io.toInputStream;$anon.cur_=" title="(x$1: scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector])Unit">cur</a> = <a href="Util.scala.html#scalaz.stream.Util" title="scalaz.stream.Util.type">Util</a>.<a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector])scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.close.receive" title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,Any])scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]]">receive</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.EarlyCause" title="scalaz.stream.Cause.EarlyCause.type">EarlyCause</a>.<a href="Cause.scala.html#scalaz.stream.Cause.EarlyCause.fromTaskResult" title="(r: scalaz.\/[Throwable,Any])scalaz.\/[scalaz.stream.Cause.EarlyCause,Any]">fromTaskResult</a><span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.close.request" title="scalaz.concurrent.Task[Any]">request</a>.<span title="=&gt; scalaz.concurrent.Task[scalaz.\/[Throwable,Any]]">attempt</span>.<span title="=&gt; scalaz.\/[Throwable,Any]">run</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]],scalaz.Free.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]]])scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]">run</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.concurrent.Task[x],scodec.bits.ByteVector])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],scodec.bits.ByteVector]">+:</a> <a href="#scalaz.stream.io.toInputStream;$anon.close.cont" title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,scodec.bits.ByteVector]">cont</a>
            <a href="#scalaz.stream.io.toInputStream;$anon.close" title="()Unit">close</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    @tailrec
    def <a title="()Unit" id="scalaz.stream.io.toInputStream;$anon.step">step</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
      <a href="#scalaz.stream.io.toInputStream;$anon.index_=" title="(x$1: Int)Unit">index</a> = <span title="Int(0)" class="int">0</span>
      <a href="#scalaz.stream.io.toInputStream;$anon.cur_=" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]">cur</a>.<a href="Process.scala.html#scalaz.stream;Process.step" title="=&gt; scalaz.stream.Process.HaltOrStep[scalaz.concurrent.Task,scodec.bits.ByteVector]">step</a> match <span class="delimiter">{</span>
        case <span title="scalaz.stream.Process.Halt">h</span> @ Halt<span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.End" title="scalaz.stream.Cause.End.type">End</a> | <a href="Cause.scala.html#scalaz.stream.Cause.Kill" title="scalaz.stream.Cause.Kill.type">Kill</a><span class="delimiter">)</span> =&gt;
          <a href="#scalaz.stream.io.toInputStream;$anon.cur_=" title="(x$1: scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector])Unit">cur</a> = <span title="scalaz.stream.Process.Halt">h</span>

        <span class="comment">// rethrow halting errors</span>
        case <span title="scalaz.stream.Process.Halt">h</span> @ Halt<span class="delimiter">(</span>Cause.Error<span class="delimiter">(</span><span title="Error">e</span>: <span title="Error">Error</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
          <a href="#scalaz.stream.io.toInputStream;$anon.cur_=" title="(x$1: scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector])Unit">cur</a> = <span title="scalaz.stream.Process.Halt">h</span>
          throw <span title="Error">e</span>
        <span class="delimiter">}</span>

        case <span title="scalaz.stream.Process.Halt">h</span> @ Halt<span class="delimiter">(</span>Cause.Error<span class="delimiter">(</span><span title="Exception">e</span>: <span title="Exception">Exception</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
          <a href="#scalaz.stream.io.toInputStream;$anon.cur_=" title="(x$1: scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector])Unit">cur</a> = <span title="scalaz.stream.Process.Halt">h</span>
          throw new <span title="java.io.IOException">IOException</span><span class="delimiter">(</span><span title="Exception">e</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        case Step<span class="delimiter">(</span>Emit<span class="delimiter">(</span><a title="Seq[scodec.bits.ByteVector]" id="scalaz.stream.io.toInputStream;$anon.step.as">as</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,scodec.bits.ByteVector]">cont</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
          <a href="#scalaz.stream.io.toInputStream;$anon.chunks_=" title="(x$1: Seq[scodec.bits.ByteVector])Unit">chunks</a> = <a href="#scalaz.stream.io.toInputStream;$anon.step.as" title="Seq[scodec.bits.ByteVector]">as</a>
          <a href="#scalaz.stream.io.toInputStream;$anon.cur_=" title="(x$1: scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector])Unit">cur</a> = <span title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,scodec.bits.ByteVector]">cont</span>.<a href="Process.scala.html#scalaz.stream.Process;Cont.continue" title="=&gt; scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]">continue</a>
        <span class="delimiter">}</span>

        case Step<span class="delimiter">(</span>Await<span class="delimiter">(</span><a title="scalaz.concurrent.Task[Any]" id="scalaz.stream.io.toInputStream;$anon.step.request">request</a>, <a title="scalaz.\/[scalaz.stream.Cause.EarlyCause,Any] =&gt; scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]]" id="scalaz.stream.io.toInputStream;$anon.step.receive">receive</a><span class="delimiter">)</span>, <span title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,scodec.bits.ByteVector]">cont</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
          <span class="comment">// yay! run the Task</span>
          <a href="#scalaz.stream.io.toInputStream;$anon.cur_=" title="(x$1: scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector])Unit">cur</a> = <a href="Util.scala.html#scalaz.stream.Util" title="scalaz.stream.Util.type">Util</a>.<a href="Util.scala.html#scalaz.stream.Util.Try" title="(p: =&gt; scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector])scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]">Try</a><span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.step.receive" title="(v1: scalaz.\/[scalaz.stream.Cause.EarlyCause,Any])scalaz.stream.Process.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]]">receive</a><span class="delimiter">(</span><a href="Cause.scala.html#scalaz.stream.Cause.EarlyCause" title="scalaz.stream.Cause.EarlyCause.type">EarlyCause</a>.<a href="Cause.scala.html#scalaz.stream.Cause.EarlyCause.fromTaskResult" title="(r: scalaz.\/[Throwable,Any])scalaz.\/[scalaz.stream.Cause.EarlyCause,Any]">fromTaskResult</a><span class="delimiter">(</span><a href="#scalaz.stream.io.toInputStream;$anon.step.request" title="scalaz.concurrent.Task[Any]">request</a>.<span title="=&gt; scalaz.concurrent.Task[scalaz.\/[Throwable,Any]]">attempt</span>.<span title="=&gt; scalaz.\/[Throwable,Any]">run</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: =:=[scalaz.Free[Function0,scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]],scalaz.Free.Trampoline[scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]]])scalaz.stream.Process[scalaz.concurrent.Task,scodec.bits.ByteVector]">run</span><span class="delimiter">)</span> <a href="Process.scala.html#scalaz.stream.Process;Cont.+:" title="(p: scalaz.stream.Process[[x]scalaz.concurrent.Task[x],scodec.bits.ByteVector])scalaz.stream.Process[[x]scalaz.concurrent.Task[x],scodec.bits.ByteVector]">+:</a> <span title="scalaz.stream.Process.Cont[scalaz.concurrent.Task,scodec.bits.ByteVector]">cont</span>
          <a href="#scalaz.stream.io.toInputStream;$anon.step" title="()Unit">step</a><span class="delimiter">(</span><span class="delimiter">)</span>    <span class="comment">// push things onto the stack and then step further (tail recursively)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
