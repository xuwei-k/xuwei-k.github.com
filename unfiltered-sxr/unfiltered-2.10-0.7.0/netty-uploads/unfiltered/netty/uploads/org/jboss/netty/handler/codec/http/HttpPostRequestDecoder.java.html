<?xml version="1.0" encoding="utf-8"?>
			<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>netty-uploads/unfiltered/netty/uploads/org/jboss/netty/handler/codec/http/HttpPostRequestDecoder.java</title>
        <script type="text/javascript" src="../../../../../../../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../../../../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../../../../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
/*
 * Copyright 2011 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * Repackaged for use with netty 3.x
 */
<span class="keyword">package</span> org.jboss.netty.handler.codec.http;

<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.io.UnsupportedEncodingException;
<span class="keyword">import</span> java.net.URLDecoder;
<span class="keyword">import</span> java.nio.charset.Charset;
<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.List;
<span class="keyword">import</span> java.util.Map;
<span class="keyword">import</span> java.util.TreeMap;

<span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffer;
<span class="keyword">import</span> org.jboss.netty.buffer.ChannelBuffers;
<span class="keyword">import</span> org.jboss.netty.handler.codec.http.HttpPostBodyUtil.TransferEncodingMechanism;

<span class="keyword">import</span> org.jboss.netty.util.internal.CaseIgnoringComparator;

/**
 * This decoder will decode Body and can handle POST BODY.
 */
public <span class="keyword">class</span> <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.type" id="10235">HttpPostRequestDecoder</a> <span class="delimiter">{</span>
    /**
     * Factory used to create InterfaceHttpData
     */
    <span class="keyword">private</span> <span class="keyword">final</span> <a href="HttpDataFactory.java.html#10187" title="org.jboss.netty.handler.codec.http.HttpDataFactory">HttpDataFactory</a> <a title="org.jboss.netty.handler.codec.http.HttpDataFactory" id="65471">factory</a>;

    /**
     * Request to decode
     */
    <span class="keyword">private</span> <span class="keyword">final</span> <span title="org.jboss.netty.handler.codec.http.HttpRequest">HttpRequest</span> <a title="org.jboss.netty.handler.codec.http.HttpRequest" id="65472">request</a>;

    /**
     * Default charset to use
     */
    <span class="keyword">private</span> <span class="keyword">final</span> Charset <a title="java.nio.charset.Charset" id="65473">charset</a>;

    /**
     * Does request have a body to decode
     */
    <span class="keyword">private</span> boolean <a title="Boolean" id="65474">bodyToDecode</a>;

    /**
     * Does the last chunk already received
     */
    <span class="keyword">private</span> boolean <a title="Boolean" id="65475">isLastChunk</a>;

    /**
     * HttpDatas from Body
     */
    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;<a href="InterfaceHttpData.java.html#10241" title="org.jboss.netty.handler.codec.http.InterfaceHttpData">InterfaceHttpData</a>&gt; <a title="java.util.List[org.jboss.netty.handler.codec.http.InterfaceHttpData]" id="65476">bodyListHttpData</a> = <span class="keyword">new</span> ArrayList&lt;InterfaceHttpData&gt;<span class="delimiter">(</span><span class="delimiter">)</span>;

    /**
     * HttpDatas as Map from Body
     */
    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;<a href="InterfaceHttpData.java.html#10241" title="org.jboss.netty.handler.codec.http.InterfaceHttpData">InterfaceHttpData</a>&gt;&gt; <a title="java.util.Map[String,java.util.List[org.jboss.netty.handler.codec.http.InterfaceHttpData]]" id="65477">bodyMapHttpData</a> = <span class="keyword">new</span> TreeMap&lt;String, List&lt;InterfaceHttpData&gt;&gt;<span class="delimiter">(</span>
            CaseIgnoringComparator.INSTANCE<span class="delimiter">)</span>;

    /**
     * The current channelBuffer
     */
    <span class="keyword">private</span> ChannelBuffer <a title="org.jboss.netty.buffer.ChannelBuffer" id="65478">undecodedChunk</a>;

    /**
     * Does this request is a Multipart request
     */
    <span class="keyword">private</span> boolean <a title="Boolean" id="65479">isMultipart</a>;

    /**
     * Body HttpDatas current position
     */
    <span class="keyword">private</span> int <a title="Int" id="65480">bodyListHttpDataRank</a>;

    /**
     * If multipart, this is the boundary for the flobal multipart
     */
    <span class="keyword">private</span> String <a title="String" id="65481">multipartDataBoundary</a>;

    /**
     * If multipart, there could be internal multiparts (mixed) to the global multipart.
     * Only one level is allowed.
     */
    <span class="keyword">private</span> String <a title="String" id="65482">multipartMixedBoundary</a>;

    /**
     * Current status
     */
    <span class="keyword">private</span> MultiPartStatus <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus" id="65483">currentStatus</a> = MultiPartStatus.NOTSTARTED;

    /**
     * Used in Multipart
     */
    <span class="keyword">private</span> Map&lt;String, <a href="Attribute.java.html#10169" title="org.jboss.netty.handler.codec.http.Attribute">Attribute</a>&gt; <a title="java.util.Map[String,org.jboss.netty.handler.codec.http.Attribute]" id="65484">currentFieldAttributes</a>;

    /**
     * The current FileUpload that is currently in decode process
     */
    <span class="keyword">private</span> <a href="FileUpload.java.html#10181" title="org.jboss.netty.handler.codec.http.FileUpload">FileUpload</a> <a title="org.jboss.netty.handler.codec.http.FileUpload" id="65485">currentFileUpload</a>;

    /**
     * The current Attribute that is currently in decode process
     */
    <span class="keyword">private</span> <a href="Attribute.java.html#10169" title="org.jboss.netty.handler.codec.http.Attribute">Attribute</a> <a title="org.jboss.netty.handler.codec.http.Attribute" id="65486">currentAttribute</a>;

    /**
    *
    * @param request the request to decode
    * @throws NullPointerException for request
    * @throws IncompatibleDataDecoderException if the request has no body to decode
    * @throws ErrorDataDecoderException if the default charset was wrong when decoding or other errors
    */
    public HttpPostRequestDecoder<a href="#10235" title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder" class="delimiter">(</a><span title="org.jboss.netty.handler.codec.http.HttpRequest">HttpRequest</span> <a title="org.jboss.netty.handler.codec.http.HttpRequest" id="65524">request</a><span class="delimiter">)</span>
            throws ErrorDataDecoderException, IncompatibleDataDecoderException <span class="delimiter">{</span>
        <span class="keyword">this</span><span class="delimiter">(</span><span class="keyword">new</span> DefaultHttpDataFactory<span class="delimiter">(</span>DefaultHttpDataFactory.MINSIZE<span class="delimiter">)</span>,
                request, HttpConstants.DEFAULT_CHARSET<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    /**
     *
     * @param factory the factory used to create InterfaceHttpData
     * @param request the request to decode
     * @throws NullPointerException for request or factory
     * @throws IncompatibleDataDecoderException if the request has no body to decode
     * @throws ErrorDataDecoderException if the default charset was wrong when decoding or other errors
     */
    public HttpPostRequestDecoder<a title="(factory: org.jboss.netty.handler.codec.http.HttpDataFactory, request: org.jboss.netty.handler.codec.http.HttpRequest)org.jboss.netty.handler.codec.http.HttpPostRequestDecoder" id="65488" class="delimiter">(</a><a href="HttpDataFactory.java.html#10187" title="org.jboss.netty.handler.codec.http.HttpDataFactory">HttpDataFactory</a> <a title="org.jboss.netty.handler.codec.http.HttpDataFactory" id="65522">factory</a>, <span title="org.jboss.netty.handler.codec.http.HttpRequest">HttpRequest</span> <a title="org.jboss.netty.handler.codec.http.HttpRequest" id="65523">request</a><span class="delimiter">)</span>
            throws ErrorDataDecoderException, IncompatibleDataDecoderException <span class="delimiter">{</span>
        <span class="keyword">this</span><span class="delimiter">(</span>factory, request, HttpConstants.DEFAULT_CHARSET<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    /**
     *
     * @param factory the factory used to create InterfaceHttpData
     * @param request the request to decode
     * @param charset the charset to use as default
     * @throws NullPointerException for request or charset or factory
     * @throws IncompatibleDataDecoderException if the request has no body to decode
     * @throws ErrorDataDecoderException if the default charset was wrong when decoding or other errors
     */
    public HttpPostRequestDecoder<a title="(factory: org.jboss.netty.handler.codec.http.HttpDataFactory, request: org.jboss.netty.handler.codec.http.HttpRequest, charset: java.nio.charset.Charset)org.jboss.netty.handler.codec.http.HttpPostRequestDecoder" id="65489" class="delimiter">(</a><a href="HttpDataFactory.java.html#10187" title="org.jboss.netty.handler.codec.http.HttpDataFactory">HttpDataFactory</a> <a title="org.jboss.netty.handler.codec.http.HttpDataFactory" id="65519">factory</a>, <span title="org.jboss.netty.handler.codec.http.HttpRequest">HttpRequest</span> <a title="org.jboss.netty.handler.codec.http.HttpRequest" id="65520">request</a>,
            Charset <a title="java.nio.charset.Charset" id="65521">charset</a><span class="delimiter">)</span> throws ErrorDataDecoderException,
            IncompatibleDataDecoderException <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>factory == <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="string">&quot;factory&quot;</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>request == <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="string">&quot;request&quot;</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>charset == <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="string">&quot;charset&quot;</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">this</span>.request = request;
        HttpMethod method = request.getMethod<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">if</span> <span class="delimiter">(</span>method.equals<span class="delimiter">(</span>HttpMethod.POST<span class="delimiter">)</span> || method.equals<span class="delimiter">(</span>HttpMethod.PUT<span class="delimiter">)</span> || method.equals<span class="delimiter">(</span>HttpMethod.PATCH<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            bodyToDecode = <span class="keyword">true</span>;
        <span class="delimiter">}</span>
        <span class="keyword">this</span>.charset = charset;
        <span class="keyword">this</span>.factory = factory;
        // Fill default values
        <span class="keyword">if</span> <span class="delimiter">(</span><span class="keyword">this</span>.request.containsHeader<span class="delimiter">(</span>HttpHeaders.Names.CONTENT_TYPE<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            checkMultipart<span class="delimiter">(</span><span class="keyword">this</span>.request.getHeader<span class="delimiter">(</span>HttpHeaders.Names.CONTENT_TYPE<span class="delimiter">)</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            isMultipart = <span class="keyword">false</span>;
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>!bodyToDecode<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> IncompatibleDataDecoderException<span class="delimiter">(</span><span class="string">&quot;No Body to decode&quot;</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>!<span class="keyword">this</span>.request.isChunked<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            undecodedChunk = <span class="keyword">this</span>.request.getContent<span class="delimiter">(</span><span class="delimiter">)</span>;
            isLastChunk = <span class="keyword">true</span>;
            parseBody<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /**
     * states follow
     * NOTSTARTED PREAMBLE (
     *  (HEADERDELIMITER DISPOSITION (FIELD | FILEUPLOAD))*
     *  (HEADERDELIMITER DISPOSITION MIXEDPREAMBLE
     *     (MIXEDDELIMITER MIXEDDISPOSITION MIXEDFILEUPLOAD)+
     *   MIXEDCLOSEDELIMITER)*
     * CLOSEDELIMITER)+ EPILOGUE
     *
     *  First status is: NOSTARTED

        Content-type: multipart/form-data, boundary=AaB03x     =&gt; PREAMBLE in Header

        --AaB03x                                               =&gt; HEADERDELIMITER
        content-disposition: form-data; name=&quot;field1&quot;          =&gt; DISPOSITION

        Joe Blow                                               =&gt; FIELD
        --AaB03x                                               =&gt; HEADERDELIMITER
        content-disposition: form-data; name=&quot;pics&quot;            =&gt; DISPOSITION
        Content-type: multipart/mixed, boundary=BbC04y

        --BbC04y                                               =&gt; MIXEDDELIMITER
        Content-disposition: attachment; filename=&quot;file1.txt&quot;  =&gt; MIXEDDISPOSITION
        Content-Type: text/plain

        ... contents of file1.txt ...                          =&gt; MIXEDFILEUPLOAD
        --BbC04y                                               =&gt; MIXEDDELIMITER
        Content-disposition: file; filename=&quot;file2.gif&quot;  =&gt; MIXEDDISPOSITION
        Content-type: image/gif
        Content-Transfer-Encoding: binary

          ...contents of file2.gif...                          =&gt; MIXEDFILEUPLOAD
        --BbC04y--                                             =&gt; MIXEDCLOSEDELIMITER
        --AaB03x--                                             =&gt; CLOSEDELIMITER

       Once CLOSEDELIMITER is found, last status is EPILOGUE
     */
    <span class="keyword">private</span> enum <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus.type" id="65385">MultiPartStatus</a> <span class="delimiter">{</span>
        <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus(NOTSTARTED)" id="127420">NOTSTARTED</a>,
        <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus(PREAMBLE)" id="127421">PREAMBLE</a>,
        <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus(HEADERDELIMITER)" id="127422">HEADERDELIMITER</a>,
        <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus(DISPOSITION)" id="127423">DISPOSITION</a>,
        <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus(FIELD)" id="127424">FIELD</a>,
        <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus(FILEUPLOAD)" id="127425">FILEUPLOAD</a>,
        <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus(MIXEDPREAMBLE)" id="127426">MIXEDPREAMBLE</a>,
        <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus(MIXEDDELIMITER)" id="127427">MIXEDDELIMITER</a>,
        <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus(MIXEDDISPOSITION)" id="127428">MIXEDDISPOSITION</a>,
        <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus(MIXEDFILEUPLOAD)" id="127429">MIXEDFILEUPLOAD</a>,
        <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus(MIXEDCLOSEDELIMITER)" id="127430">MIXEDCLOSEDELIMITER</a>,
        <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus(CLOSEDELIMITER)" id="127431">CLOSEDELIMITER</a>,
        <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus(PREEPILOGUE)" id="127432">PREEPILOGUE</a>,
        <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus(EPILOGUE)" id="127433">EPILOGUE</a>
    <span class="delimiter">}</span>

    /**
     * Check from the request ContentType if this request is a Multipart request.
     * @param contentType
     * @throws ErrorDataDecoderException
     */
    <span class="keyword">private</span> void <a title="(contentType: String)Unit" id="65490">checkMultipart</a><span class="delimiter">(</span>String <a title="String" id="127474">contentType</a><span class="delimiter">)</span>
            throws ErrorDataDecoderException <span class="delimiter">{</span>
        // Check if Post using &quot;multipart/form-data; boundary=--89421926422648&quot;
        String<span class="delimiter">[</span><span class="delimiter">]</span> headerContentType = splitHeaderContentType<span class="delimiter">(</span>contentType<span class="delimiter">)</span>;
        <span class="keyword">if</span> <span class="delimiter">(</span>headerContentType<span class="delimiter">[</span><span class="int">0</span><span class="delimiter">]</span>.toLowerCase<span class="delimiter">(</span><span class="delimiter">)</span>.startsWith<span class="delimiter">(</span>
                HttpHeaders.Values.MULTIPART_FORM_DATA<span class="delimiter">)</span> &amp;&amp;
                headerContentType<span class="delimiter">[</span><span class="int">1</span><span class="delimiter">]</span>.toLowerCase<span class="delimiter">(</span><span class="delimiter">)</span>.startsWith<span class="delimiter">(</span>
                        HttpHeaders.Values.BOUNDARY<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            String<span class="delimiter">[</span><span class="delimiter">]</span> boundary = headerContentType<span class="delimiter">[</span><span class="int">1</span><span class="delimiter">]</span>.split<span class="delimiter">(</span><span class="string">&quot;=&quot;</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>boundary.length != <span class="int">2</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span><span class="string">&quot;Needs a boundary value&quot;</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
            multipartDataBoundary = <span class="string">&quot;--&quot;</span> + boundary<span class="delimiter">[</span><span class="int">1</span><span class="delimiter">]</span>;
            isMultipart = <span class="keyword">true</span>;
            currentStatus = MultiPartStatus.HEADERDELIMITER;
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            isMultipart = <span class="keyword">false</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /**
     * True if this request is a Multipart request
     * @return True if this request is a Multipart request
     */
    public boolean <a title="()Boolean" id="65491">isMultipart</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> isMultipart;
    <span class="delimiter">}</span>

    /**
     * This method returns a List of all HttpDatas from body.&lt;br&gt;
     *
     * If chunked, all chunks must have been offered using offer() method.
     * If not, NotEnoughDataDecoderException will be raised.
     *
     * @return the list of HttpDatas from Body part for POST method
     * @throws NotEnoughDataDecoderException Need more chunks
     */
    public List&lt;<a href="InterfaceHttpData.java.html#10241" title="org.jboss.netty.handler.codec.http.InterfaceHttpData">InterfaceHttpData</a>&gt; <a title="()java.util.List[org.jboss.netty.handler.codec.http.InterfaceHttpData]" id="65492">getBodyHttpDatas</a><span class="delimiter">(</span><span class="delimiter">)</span>
            throws NotEnoughDataDecoderException <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>!isLastChunk<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NotEnoughDataDecoderException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">return</span> bodyListHttpData;
    <span class="delimiter">}</span>

    /**
     * This method returns a List of all HttpDatas with the given name from body.&lt;br&gt;
     *
     * If chunked, all chunks must have been offered using offer() method.
     * If not, NotEnoughDataDecoderException will be raised.

     * @param name
     * @return All Body HttpDatas with the given name (ignore case)
     * @throws NotEnoughDataDecoderException need more chunks
     */
    public List&lt;<a href="InterfaceHttpData.java.html#10241" title="org.jboss.netty.handler.codec.http.InterfaceHttpData">InterfaceHttpData</a>&gt; <a title="(name: String)java.util.List[org.jboss.netty.handler.codec.http.InterfaceHttpData]" id="65493">getBodyHttpDatas</a><span class="delimiter">(</span>String <a title="String" id="65926">name</a><span class="delimiter">)</span>
            throws NotEnoughDataDecoderException <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>!isLastChunk<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NotEnoughDataDecoderException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">return</span> bodyMapHttpData.get<span class="delimiter">(</span>name<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    /**
     * This method returns the first InterfaceHttpData with the given name from body.&lt;br&gt;
     *
     * If chunked, all chunks must have been offered using offer() method.
     * If not, NotEnoughDataDecoderException will be raised.
    *
    * @param name
    * @return The first Body InterfaceHttpData with the given name (ignore case)
    * @throws NotEnoughDataDecoderException need more chunks
    */
    public <a href="InterfaceHttpData.java.html#10241" title="org.jboss.netty.handler.codec.http.InterfaceHttpData">InterfaceHttpData</a> <a title="(name: String)org.jboss.netty.handler.codec.http.InterfaceHttpData" id="65494">getBodyHttpData</a><span class="delimiter">(</span>String <a title="String" id="127475">name</a><span class="delimiter">)</span>
            throws NotEnoughDataDecoderException <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>!isLastChunk<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NotEnoughDataDecoderException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        List&lt;InterfaceHttpData&gt; list = bodyMapHttpData.get<span class="delimiter">(</span>name<span class="delimiter">)</span>;
        <span class="keyword">if</span> <span class="delimiter">(</span>list != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> list.get<span class="delimiter">(</span><span class="int">0</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">return</span> <span class="keyword">null</span>;
    <span class="delimiter">}</span>

    /**
     * Initialized the internals from a new chunk
     * @param chunk the new received chunk
     * @throws ErrorDataDecoderException if there is a problem with the charset decoding or
     *          other errors
     */
    public void <a title="(chunk: org.jboss.netty.handler.codec.http.HttpChunk)Unit" id="65495">offer</a><span class="delimiter">(</span><span title="org.jboss.netty.handler.codec.http.HttpChunk">HttpChunk</span> <a title="org.jboss.netty.handler.codec.http.HttpChunk" id="65553">chunk</a><span class="delimiter">)</span> throws ErrorDataDecoderException <span class="delimiter">{</span>
        ChannelBuffer chunked = chunk.getContent<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">if</span> <span class="delimiter">(</span>undecodedChunk == <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            undecodedChunk = chunked;
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            //undecodedChunk = ChannelBuffers.wrappedBuffer(undecodedChunk, chunk.getContent());
            // less memory usage
            undecodedChunk = ChannelBuffers.wrappedBuffer<span class="delimiter">(</span>
                    undecodedChunk, chunked<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>chunk.isLast<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            isLastChunk = <span class="keyword">true</span>;
        <span class="delimiter">}</span>
        parseBody<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    /**
     * True if at current status, there is an available decoded InterfaceHttpData from the Body.
     *
     * This method works for chunked and not chunked request.
     *
     * @return True if at current status, there is a decoded InterfaceHttpData
     * @throws EndOfDataDecoderException No more data will be available
     */
    public boolean <a title="()Boolean" id="65496">hasNext</a><span class="delimiter">(</span><span class="delimiter">)</span> throws EndOfDataDecoderException <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>currentStatus == MultiPartStatus.EPILOGUE<span class="delimiter">)</span> <span class="delimiter">{</span>
            // OK except if end of list
            <span class="keyword">if</span> <span class="delimiter">(</span>bodyListHttpDataRank &gt;= bodyListHttpData.size<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> EndOfDataDecoderException<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">return</span> bodyListHttpData.size<span class="delimiter">(</span><span class="delimiter">)</span> &gt; <span class="int">0</span> &amp;&amp;
                bodyListHttpDataRank &lt; bodyListHttpData.size<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    /**
     * Returns the next available InterfaceHttpData or null if, at the time it is called, there is no more
     * available InterfaceHttpData. A subsequent call to offer(httpChunk) could enable more data.
     *
     * @return the next available InterfaceHttpData or null if none
     * @throws EndOfDataDecoderException No more data will be available
     */
    public <a href="InterfaceHttpData.java.html#10241" title="org.jboss.netty.handler.codec.http.InterfaceHttpData">InterfaceHttpData</a> <a title="()org.jboss.netty.handler.codec.http.InterfaceHttpData" id="65497">next</a><span class="delimiter">(</span><span class="delimiter">)</span> throws EndOfDataDecoderException <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>hasNext<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> bodyListHttpData.get<span class="delimiter">(</span>bodyListHttpDataRank++<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">return</span> <span class="keyword">null</span>;
    <span class="delimiter">}</span>

    /**
     * This method will parse as much as possible data and fill the list and map
     * @throws ErrorDataDecoderException if there is a problem with the charset decoding or
     *          other errors
     */
    <span class="keyword">private</span> void <a title="()Unit" id="65498">parseBody</a><span class="delimiter">(</span><span class="delimiter">)</span> throws ErrorDataDecoderException <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>currentStatus == MultiPartStatus.PREEPILOGUE ||
                currentStatus == MultiPartStatus.EPILOGUE<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>isLastChunk<span class="delimiter">)</span> <span class="delimiter">{</span>
                currentStatus = MultiPartStatus.EPILOGUE;
            <span class="delimiter">}</span>
            <span class="keyword">return</span>;
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>isMultipart<span class="delimiter">)</span> <span class="delimiter">{</span>
            parseBodyMultipart<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            parseBodyAttributes<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /**
     * Utility function to add a new decoded data
     * @param data
     */
    <span class="keyword">private</span> void <a title="(data: org.jboss.netty.handler.codec.http.InterfaceHttpData)Unit" id="65499">addHttpData</a><span class="delimiter">(</span><a href="InterfaceHttpData.java.html#10241" title="org.jboss.netty.handler.codec.http.InterfaceHttpData">InterfaceHttpData</a> <a title="org.jboss.netty.handler.codec.http.InterfaceHttpData" id="127476">data</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>data == <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span>;
        <span class="delimiter">}</span>
        List&lt;InterfaceHttpData&gt; datas = bodyMapHttpData.get<span class="delimiter">(</span>data.getName<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
        <span class="keyword">if</span> <span class="delimiter">(</span>datas == <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            datas = <span class="keyword">new</span> ArrayList&lt;InterfaceHttpData&gt;<span class="delimiter">(</span><span class="int">1</span><span class="delimiter">)</span>;
            bodyMapHttpData.put<span class="delimiter">(</span>data.getName<span class="delimiter">(</span><span class="delimiter">)</span>, datas<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        datas.add<span class="delimiter">(</span>data<span class="delimiter">)</span>;
        bodyListHttpData.add<span class="delimiter">(</span>data<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    /**
      * This method fill the map and list with as much Attribute as possible from Body in
      * not Multipart mode.
      *
      * @throws ErrorDataDecoderException if there is a problem with the charset decoding or
      *          other errors
      */
    <span class="keyword">private</span> void <a title="()Unit" id="65500">parseBodyAttributes</a><span class="delimiter">(</span><span class="delimiter">)</span> throws ErrorDataDecoderException <span class="delimiter">{</span>
        int firstpos = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span>;
        int currentpos = firstpos;
        int equalpos = firstpos;
        int ampersandpos = firstpos;
        <span class="keyword">if</span> <span class="delimiter">(</span>currentStatus == MultiPartStatus.NOTSTARTED<span class="delimiter">)</span> <span class="delimiter">{</span>
            currentStatus = MultiPartStatus.DISPOSITION;
        <span class="delimiter">}</span>
        boolean contRead = <span class="keyword">true</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">while</span> <span class="delimiter">(</span>undecodedChunk.readable<span class="delimiter">(</span><span class="delimiter">)</span> &amp;&amp; contRead<span class="delimiter">)</span> <span class="delimiter">{</span>
                char read = <span class="delimiter">(</span>char<span class="delimiter">)</span> undecodedChunk.readUnsignedByte<span class="delimiter">(</span><span class="delimiter">)</span>;
                currentpos++;
                switch <span class="delimiter">(</span>currentStatus<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> DISPOSITION:// search '='
                    <span class="keyword">if</span> <span class="delimiter">(</span>read == <span class="char">'='</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                        currentStatus = MultiPartStatus.FIELD;
                        equalpos = currentpos - <span class="int">1</span>;
                        String key = decodeAttribute<span class="delimiter">(</span>
                                undecodedChunk.toString<span class="delimiter">(</span>firstpos, equalpos - firstpos, charset<span class="delimiter">)</span>,
                                charset<span class="delimiter">)</span>;
                        currentAttribute = factory.createAttribute<span class="delimiter">(</span>request, key<span class="delimiter">)</span>;
                        firstpos = currentpos;
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>read == <span class="char">'&amp;'</span><span class="delimiter">)</span> <span class="delimiter">{</span> // special empty FIELD
                        currentStatus = MultiPartStatus.DISPOSITION;
                        ampersandpos = currentpos - <span class="int">1</span>;
                        String key = decodeAttribute<span class="delimiter">(</span>undecodedChunk.toString<span class="delimiter">(</span>firstpos, ampersandpos - firstpos, charset<span class="delimiter">)</span>, charset<span class="delimiter">)</span>;
                        currentAttribute = factory.createAttribute<span class="delimiter">(</span>request, key<span class="delimiter">)</span>;
                        currentAttribute.setValue<span class="delimiter">(</span><span class="string">&quot;&quot;</span><span class="delimiter">)</span>; // empty
                        addHttpData<span class="delimiter">(</span>currentAttribute<span class="delimiter">)</span>;
                        currentAttribute = <span class="keyword">null</span>;
                        firstpos = currentpos;
                        contRead = <span class="keyword">true</span>;
                    <span class="delimiter">}</span>
                    break;
                <span class="keyword">case</span> FIELD:// search '&amp;' or end of line
                    <span class="keyword">if</span> <span class="delimiter">(</span>read == <span class="char">'&amp;'</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                        currentStatus = MultiPartStatus.DISPOSITION;
                        ampersandpos = currentpos - <span class="int">1</span>;
                        setFinalBuffer<span class="delimiter">(</span>undecodedChunk.slice<span class="delimiter">(</span>firstpos, ampersandpos - firstpos<span class="delimiter">)</span><span class="delimiter">)</span>;
                        firstpos = currentpos;
                        contRead = <span class="keyword">true</span>;
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>read == HttpConstants.CR<span class="delimiter">)</span> <span class="delimiter">{</span>
                        <span class="keyword">if</span> <span class="delimiter">(</span>undecodedChunk.readable<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                            read = <span class="delimiter">(</span>char<span class="delimiter">)</span> undecodedChunk.readUnsignedByte<span class="delimiter">(</span><span class="delimiter">)</span>;
                            currentpos++;
                            <span class="keyword">if</span> <span class="delimiter">(</span>read == HttpConstants.LF<span class="delimiter">)</span> <span class="delimiter">{</span>
                                currentStatus = MultiPartStatus.PREEPILOGUE;
                                ampersandpos = currentpos - <span class="int">2</span>;
                                setFinalBuffer<span class="delimiter">(</span>
                                        undecodedChunk.slice<span class="delimiter">(</span>firstpos, ampersandpos - firstpos<span class="delimiter">)</span><span class="delimiter">)</span>;
                                firstpos = currentpos;
                                contRead = <span class="keyword">false</span>;
                            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                                // Error
                                contRead = <span class="keyword">false</span>;
                                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span><span class="string">&quot;Bad end of line&quot;</span><span class="delimiter">)</span>;
                            <span class="delimiter">}</span>
                        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                            currentpos--;
                        <span class="delimiter">}</span>
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>read == HttpConstants.LF<span class="delimiter">)</span> <span class="delimiter">{</span>
                        currentStatus = MultiPartStatus.PREEPILOGUE;
                        ampersandpos = currentpos - <span class="int">1</span>;
                        setFinalBuffer<span class="delimiter">(</span>
                                undecodedChunk.slice<span class="delimiter">(</span>firstpos, ampersandpos - firstpos<span class="delimiter">)</span><span class="delimiter">)</span>;
                        firstpos = currentpos;
                        contRead = <span class="keyword">false</span>;
                    <span class="delimiter">}</span>
                    break;
                default:
                    // just stop
                    contRead = <span class="keyword">false</span>;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>isLastChunk &amp;&amp; currentAttribute != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                // special case
                ampersandpos = currentpos;
                <span class="keyword">if</span> <span class="delimiter">(</span>ampersandpos &gt; firstpos<span class="delimiter">)</span> <span class="delimiter">{</span>
                    setFinalBuffer<span class="delimiter">(</span>
                            undecodedChunk.slice<span class="delimiter">(</span>firstpos, ampersandpos - firstpos<span class="delimiter">)</span><span class="delimiter">)</span>;
                <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>! currentAttribute.isCompleted<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    setFinalBuffer<span class="delimiter">(</span>ChannelBuffers.EMPTY_BUFFER<span class="delimiter">)</span>;
                <span class="delimiter">}</span>
                firstpos = currentpos;
                currentStatus = MultiPartStatus.EPILOGUE;
                <span class="keyword">return</span>;
            <span class="delimiter">}</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>contRead &amp;&amp; currentAttribute != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                // reset index except if to continue in case of FIELD status
                <span class="keyword">if</span> <span class="delimiter">(</span>currentStatus == MultiPartStatus.FIELD<span class="delimiter">)</span> <span class="delimiter">{</span>
                    currentAttribute.addContent<span class="delimiter">(</span>
                            undecodedChunk.slice<span class="delimiter">(</span>firstpos, currentpos - firstpos<span class="delimiter">)</span>,
                            <span class="keyword">false</span><span class="delimiter">)</span>;
                    firstpos = currentpos;
                <span class="delimiter">}</span>
                undecodedChunk.readerIndex<span class="delimiter">(</span>firstpos<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                // end of line so keep index
            <span class="delimiter">}</span>
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>ErrorDataDecoderException e<span class="delimiter">)</span> <span class="delimiter">{</span>
            // error while decoding
            undecodedChunk.readerIndex<span class="delimiter">(</span>firstpos<span class="delimiter">)</span>;
            <span class="keyword">throw</span> e;
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IOException e<span class="delimiter">)</span> <span class="delimiter">{</span>
            // error while decoding
            undecodedChunk.readerIndex<span class="delimiter">(</span>firstpos<span class="delimiter">)</span>;
            <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">private</span> void <a title="(buffer: org.jboss.netty.buffer.ChannelBuffer)Unit" id="65501">setFinalBuffer</a><span class="delimiter">(</span>ChannelBuffer <a title="org.jboss.netty.buffer.ChannelBuffer" id="127477">buffer</a><span class="delimiter">)</span> throws ErrorDataDecoderException, IOException <span class="delimiter">{</span>
        currentAttribute.addContent<span class="delimiter">(</span>buffer, <span class="keyword">true</span><span class="delimiter">)</span>;
        String value = decodeAttribute<span class="delimiter">(</span>
                currentAttribute.getChannelBuffer<span class="delimiter">(</span><span class="delimiter">)</span>.toString<span class="delimiter">(</span>charset<span class="delimiter">)</span>,
                charset<span class="delimiter">)</span>;
        currentAttribute.setValue<span class="delimiter">(</span>value<span class="delimiter">)</span>;
        addHttpData<span class="delimiter">(</span>currentAttribute<span class="delimiter">)</span>;
        currentAttribute = <span class="keyword">null</span>;
    <span class="delimiter">}</span>

    /**
     * Decode component
     * @param s
     * @param charset
     * @return the decoded component
     * @throws ErrorDataDecoderException
     */
    <span class="keyword">private</span> static String <a title="(s: String, charset: java.nio.charset.Charset)String" id="65386">decodeAttribute</a><span class="delimiter">(</span>String <a title="String" id="127437">s</a>, Charset <a title="java.nio.charset.Charset" id="127438">charset</a><span class="delimiter">)</span>
            throws ErrorDataDecoderException <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>s == <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;
        <span class="delimiter">}</span>
        <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> URLDecoder.decode<span class="delimiter">(</span>s, charset.name<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>UnsupportedEncodingException e<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>charset.toString<span class="delimiter">(</span><span class="delimiter">)</span>, e<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /**
     * Parse the Body for multipart
     *
     * @throws ErrorDataDecoderException if there is a problem with the charset decoding or other errors
     */
    <span class="keyword">private</span> void <a title="()Unit" id="65502">parseBodyMultipart</a><span class="delimiter">(</span><span class="delimiter">)</span> throws ErrorDataDecoderException <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>undecodedChunk == <span class="keyword">null</span> || undecodedChunk.readableBytes<span class="delimiter">(</span><span class="delimiter">)</span> == <span class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            // nothing to decode
            <span class="keyword">return</span>;
        <span class="delimiter">}</span>
        InterfaceHttpData data = decodeMultipart<span class="delimiter">(</span>currentStatus<span class="delimiter">)</span>;
        <span class="keyword">while</span> <span class="delimiter">(</span>data != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            addHttpData<span class="delimiter">(</span>data<span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>currentStatus == MultiPartStatus.PREEPILOGUE ||
                    currentStatus == MultiPartStatus.EPILOGUE<span class="delimiter">)</span> <span class="delimiter">{</span>
                break;
            <span class="delimiter">}</span>
            data = decodeMultipart<span class="delimiter">(</span>currentStatus<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /**
     * Decode a multipart request by pieces&lt;br&gt;
     * &lt;br&gt;
     * NOTSTARTED PREAMBLE (&lt;br&gt;
     *  (HEADERDELIMITER DISPOSITION (FIELD | FILEUPLOAD))*&lt;br&gt;
     *  (HEADERDELIMITER DISPOSITION MIXEDPREAMBLE&lt;br&gt;
     *     (MIXEDDELIMITER MIXEDDISPOSITION MIXEDFILEUPLOAD)+&lt;br&gt;
     *   MIXEDCLOSEDELIMITER)*&lt;br&gt;
     * CLOSEDELIMITER)+ EPILOGUE&lt;br&gt;
     *
     * Inspired from HttpMessageDecoder
     *
     * @param state
     * @return the next decoded InterfaceHttpData or null if none until now.
     * @throws ErrorDataDecoderException if an error occurs
     */
    <span class="keyword">private</span> <a href="InterfaceHttpData.java.html#10241" title="org.jboss.netty.handler.codec.http.InterfaceHttpData">InterfaceHttpData</a> <a title="(state: org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus)org.jboss.netty.handler.codec.http.InterfaceHttpData" id="65503">decodeMultipart</a><span class="delimiter">(</span>MultiPartStatus <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus" id="127478">state</a><span class="delimiter">)</span>
            throws ErrorDataDecoderException <span class="delimiter">{</span>
        switch <span class="delimiter">(</span>state<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> NOTSTARTED:
            <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>
                    <span class="string">&quot;Should not be called with the current status&quot;</span><span class="delimiter">)</span>;
        <span class="keyword">case</span> PREAMBLE:
            // Content-type: multipart/form-data, boundary=AaB03x
            <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>
                    <span class="string">&quot;Should not be called with the current status&quot;</span><span class="delimiter">)</span>;
        <span class="keyword">case</span> HEADERDELIMITER: <span class="delimiter">{</span>
            // --AaB03x or --AaB03x--
            <span class="keyword">return</span> findMultipartDelimiter<span class="delimiter">(</span>multipartDataBoundary,
                    MultiPartStatus.DISPOSITION, MultiPartStatus.PREEPILOGUE<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">case</span> DISPOSITION: <span class="delimiter">{</span>
            //  content-disposition: form-data; name=&quot;field1&quot;
            //  content-disposition: form-data; name=&quot;pics&quot;; filename=&quot;file1.txt&quot;
            // and other immediate values like
            //  Content-type: image/gif
            //  Content-Type: text/plain
            //  Content-Type: text/plain; charset=ISO-8859-1
            //  Content-Transfer-Encoding: binary
            // The following line implies a change of mode (mixed mode)
            //  Content-type: multipart/mixed, boundary=BbC04y
            <span class="keyword">return</span> findMultipartDisposition<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">case</span> FIELD: <span class="delimiter">{</span>
            // Now get value according to Content-Type and Charset
            Charset localCharset = <span class="keyword">null</span>;
            Attribute charsetAttribute = currentFieldAttributes
                    .get<span class="delimiter">(</span>HttpHeaders.Values.CHARSET<span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>charsetAttribute != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">try</span> <span class="delimiter">{</span>
                    localCharset = Charset.forName<span class="delimiter">(</span>charsetAttribute.getValue<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
                <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IOException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            Attribute nameAttribute = currentFieldAttributes
                .get<span class="delimiter">(</span>HttpPostBodyUtil.NAME<span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>currentAttribute == <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">try</span> <span class="delimiter">{</span>
                    currentAttribute = factory.createAttribute<span class="delimiter">(</span>request, nameAttribute
                            .getValue<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
                <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>NullPointerException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IllegalArgumentException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IOException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                <span class="delimiter">}</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>localCharset != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    currentAttribute.setCharset<span class="delimiter">(</span>localCharset<span class="delimiter">)</span>;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            // load data
            <span class="keyword">try</span> <span class="delimiter">{</span>
                loadFieldMultipart<span class="delimiter">(</span>multipartDataBoundary<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>NotEnoughDataDecoderException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">return</span> <span class="keyword">null</span>;
            <span class="delimiter">}</span>
            Attribute finalAttribute = currentAttribute;
            currentAttribute = <span class="keyword">null</span>;
            currentFieldAttributes = <span class="keyword">null</span>;
            // ready to load the next one
            currentStatus = MultiPartStatus.HEADERDELIMITER;
            <span class="keyword">return</span> finalAttribute;
        <span class="delimiter">}</span>
        <span class="keyword">case</span> FILEUPLOAD: <span class="delimiter">{</span>
            // eventually restart from existing FileUpload
            <span class="keyword">return</span> getFileUpload<span class="delimiter">(</span>multipartDataBoundary<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">case</span> MIXEDDELIMITER: <span class="delimiter">{</span>
            // --AaB03x or --AaB03x--
            // Note that currentFieldAttributes exists
            <span class="keyword">return</span> findMultipartDelimiter<span class="delimiter">(</span>multipartMixedBoundary,
                    MultiPartStatus.MIXEDDISPOSITION,
                    MultiPartStatus.HEADERDELIMITER<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">case</span> MIXEDDISPOSITION: <span class="delimiter">{</span>
            <span class="keyword">return</span> findMultipartDisposition<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">case</span> MIXEDFILEUPLOAD: <span class="delimiter">{</span>
            // eventually restart from existing FileUpload
            <span class="keyword">return</span> getFileUpload<span class="delimiter">(</span>multipartMixedBoundary<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">case</span> PREEPILOGUE:
            <span class="keyword">return</span> <span class="keyword">null</span>;
        <span class="keyword">case</span> EPILOGUE:
            <span class="keyword">return</span> <span class="keyword">null</span>;
        default:
            <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span><span class="string">&quot;Shouldn't reach here.&quot;</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /**
     * Find the next Multipart Delimiter
     * @param delimiter delimiter to find
     * @param dispositionStatus the next status if the delimiter is a start
     * @param closeDelimiterStatus the next status if the delimiter is a close delimiter
     * @return the next InterfaceHttpData if any
     * @throws ErrorDataDecoderException
     */
    <span class="keyword">private</span> <a href="InterfaceHttpData.java.html#10241" title="org.jboss.netty.handler.codec.http.InterfaceHttpData">InterfaceHttpData</a> <a title="(delimiter: String, dispositionStatus: org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus, closeDelimiterStatus: org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus)org.jboss.netty.handler.codec.http.InterfaceHttpData" id="65504">findMultipartDelimiter</a><span class="delimiter">(</span>String <a title="String" id="127479">delimiter</a>,
            MultiPartStatus <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus" id="127480">dispositionStatus</a>,
            MultiPartStatus <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.MultiPartStatus" id="127481">closeDelimiterStatus</a><span class="delimiter">)</span>
            throws ErrorDataDecoderException <span class="delimiter">{</span>
        // --AaB03x or --AaB03x--
        int readerIndex = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span>;
        HttpPostBodyUtil.skipControlCharacters<span class="delimiter">(</span>undecodedChunk<span class="delimiter">)</span>;
        skipOneLine<span class="delimiter">(</span><span class="delimiter">)</span>;
        String newline;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            newline = readLine<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>NotEnoughDataDecoderException e<span class="delimiter">)</span> <span class="delimiter">{</span>
            undecodedChunk.readerIndex<span class="delimiter">(</span>readerIndex<span class="delimiter">)</span>;
            <span class="keyword">return</span> <span class="keyword">null</span>;
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>newline.equals<span class="delimiter">(</span>delimiter<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            currentStatus = dispositionStatus;
            <span class="keyword">return</span> decodeMultipart<span class="delimiter">(</span>dispositionStatus<span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>newline.equals<span class="delimiter">(</span>delimiter + <span class="string">&quot;--&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            // CLOSEDELIMITER or MIXED CLOSEDELIMITER found
            currentStatus = closeDelimiterStatus;
            <span class="keyword">if</span> <span class="delimiter">(</span>currentStatus == MultiPartStatus.HEADERDELIMITER<span class="delimiter">)</span> <span class="delimiter">{</span>
                // MIXEDCLOSEDELIMITER
                // end of the Mixed part
                currentFieldAttributes = <span class="keyword">null</span>;
                <span class="keyword">return</span> decodeMultipart<span class="delimiter">(</span>MultiPartStatus.HEADERDELIMITER<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
            <span class="keyword">return</span> <span class="keyword">null</span>;
        <span class="delimiter">}</span>
        undecodedChunk.readerIndex<span class="delimiter">(</span>readerIndex<span class="delimiter">)</span>;
        <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span><span class="string">&quot;No Multipart delimiter found&quot;</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    /**
     * Find the next Disposition
     * @return the next InterfaceHttpData if any
     * @throws ErrorDataDecoderException
     */
    <span class="keyword">private</span> <a href="InterfaceHttpData.java.html#10241" title="org.jboss.netty.handler.codec.http.InterfaceHttpData">InterfaceHttpData</a> <a title="()org.jboss.netty.handler.codec.http.InterfaceHttpData" id="65505">findMultipartDisposition</a><span class="delimiter">(</span><span class="delimiter">)</span>
            throws ErrorDataDecoderException <span class="delimiter">{</span>
        int readerIndex = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">if</span> <span class="delimiter">(</span>currentStatus == MultiPartStatus.DISPOSITION<span class="delimiter">)</span> <span class="delimiter">{</span>
            currentFieldAttributes = <span class="keyword">new</span> TreeMap&lt;String, Attribute&gt;<span class="delimiter">(</span>
                    CaseIgnoringComparator.INSTANCE<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        // read many lines until empty line with newline found! Store all data
        <span class="keyword">while</span> <span class="delimiter">(</span>!skipOneLine<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            HttpPostBodyUtil.skipControlCharacters<span class="delimiter">(</span>undecodedChunk<span class="delimiter">)</span>;
            String newline;
            <span class="keyword">try</span> <span class="delimiter">{</span>
                newline = readLine<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>NotEnoughDataDecoderException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                undecodedChunk.readerIndex<span class="delimiter">(</span>readerIndex<span class="delimiter">)</span>;
                <span class="keyword">return</span> <span class="keyword">null</span>;
            <span class="delimiter">}</span>
            String<span class="delimiter">[</span><span class="delimiter">]</span> contents = splitMultipartHeader<span class="delimiter">(</span>newline<span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>contents<span class="delimiter">[</span><span class="int">0</span><span class="delimiter">]</span>.equalsIgnoreCase<span class="delimiter">(</span>HttpPostBodyUtil.CONTENT_DISPOSITION<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                boolean checkSecondArg = <span class="keyword">false</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span>currentStatus == MultiPartStatus.DISPOSITION<span class="delimiter">)</span> <span class="delimiter">{</span>
                    checkSecondArg = contents<span class="delimiter">[</span><span class="int">1</span><span class="delimiter">]</span>
                            .equalsIgnoreCase<span class="delimiter">(</span>HttpPostBodyUtil.FORM_DATA<span class="delimiter">)</span>;
                <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                    checkSecondArg = contents<span class="delimiter">[</span><span class="int">1</span><span class="delimiter">]</span>
                            .equalsIgnoreCase<span class="delimiter">(</span>HttpPostBodyUtil.ATTACHMENT<span class="delimiter">)</span> ||
                            contents<span class="delimiter">[</span><span class="int">1</span><span class="delimiter">]</span>
                            .equalsIgnoreCase<span class="delimiter">(</span>HttpPostBodyUtil.FILE<span class="delimiter">)</span>;
                <span class="delimiter">}</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>checkSecondArg<span class="delimiter">)</span> <span class="delimiter">{</span>
                    // read next values and store them in the map as Attribute
                    <span class="keyword">for</span> <span class="delimiter">(</span>int i = <span class="int">2</span>; i &lt; contents.length; i ++<span class="delimiter">)</span> <span class="delimiter">{</span>
                        String<span class="delimiter">[</span><span class="delimiter">]</span> values = contents<span class="delimiter">[</span>i<span class="delimiter">]</span>.split<span class="delimiter">(</span><span class="string">&quot;=&quot;</span><span class="delimiter">)</span>;
                        Attribute attribute;
                        <span class="keyword">try</span> <span class="delimiter">{</span>
                            attribute = factory.createAttribute<span class="delimiter">(</span>request, values<span class="delimiter">[</span><span class="int">0</span><span class="delimiter">]</span>.trim<span class="delimiter">(</span><span class="delimiter">)</span>,
                                    decodeAttribute<span class="delimiter">(</span>cleanString<span class="delimiter">(</span>values<span class="delimiter">[</span><span class="int">1</span><span class="delimiter">]</span><span class="delimiter">)</span>, charset<span class="delimiter">)</span><span class="delimiter">)</span>;
                        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>NullPointerException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                            <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IllegalArgumentException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                            <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                        <span class="delimiter">}</span>
                        currentFieldAttributes.put<span class="delimiter">(</span>attribute.getName<span class="delimiter">(</span><span class="delimiter">)</span>,
                                attribute<span class="delimiter">)</span>;
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>contents<span class="delimiter">[</span><span class="int">0</span><span class="delimiter">]</span>
                    .equalsIgnoreCase<span class="delimiter">(</span>HttpHeaders.Names.CONTENT_TRANSFER_ENCODING<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                Attribute attribute;
                <span class="keyword">try</span> <span class="delimiter">{</span>
                    attribute = factory.createAttribute<span class="delimiter">(</span>request,
                            HttpHeaders.Names.CONTENT_TRANSFER_ENCODING,
                            cleanString<span class="delimiter">(</span>contents<span class="delimiter">[</span><span class="int">1</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>;
                <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>NullPointerException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IllegalArgumentException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                <span class="delimiter">}</span>
                currentFieldAttributes.put<span class="delimiter">(</span>
                        HttpHeaders.Names.CONTENT_TRANSFER_ENCODING, attribute<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>contents<span class="delimiter">[</span><span class="int">0</span><span class="delimiter">]</span>
                    .equalsIgnoreCase<span class="delimiter">(</span>HttpHeaders.Names.CONTENT_LENGTH<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                Attribute attribute;
                <span class="keyword">try</span> <span class="delimiter">{</span>
                    attribute = factory.createAttribute<span class="delimiter">(</span>request,
                            HttpHeaders.Names.CONTENT_LENGTH,
                            cleanString<span class="delimiter">(</span>contents<span class="delimiter">[</span><span class="int">1</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>;
                <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>NullPointerException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IllegalArgumentException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                <span class="delimiter">}</span>
                currentFieldAttributes.put<span class="delimiter">(</span>HttpHeaders.Names.CONTENT_LENGTH,
                        attribute<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>contents<span class="delimiter">[</span><span class="int">0</span><span class="delimiter">]</span>.equalsIgnoreCase<span class="delimiter">(</span>HttpHeaders.Names.CONTENT_TYPE<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                // Take care of possible &quot;multipart/mixed&quot;
                <span class="keyword">if</span> <span class="delimiter">(</span>contents<span class="delimiter">[</span><span class="int">1</span><span class="delimiter">]</span>.equalsIgnoreCase<span class="delimiter">(</span>HttpPostBodyUtil.MULTIPART_MIXED<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">if</span> <span class="delimiter">(</span>currentStatus == MultiPartStatus.DISPOSITION<span class="delimiter">)</span> <span class="delimiter">{</span>
                        String<span class="delimiter">[</span><span class="delimiter">]</span> values = contents<span class="delimiter">[</span><span class="int">2</span><span class="delimiter">]</span>.split<span class="delimiter">(</span><span class="string">&quot;=&quot;</span><span class="delimiter">)</span>;
                        multipartMixedBoundary = <span class="string">&quot;--&quot;</span> + values<span class="delimiter">[</span><span class="int">1</span><span class="delimiter">]</span>;
                        currentStatus = MultiPartStatus.MIXEDDELIMITER;
                        <span class="keyword">return</span> decodeMultipart<span class="delimiter">(</span>MultiPartStatus.MIXEDDELIMITER<span class="delimiter">)</span>;
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                        <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>
                                <span class="string">&quot;Mixed Multipart found in a previous Mixed Multipart&quot;</span><span class="delimiter">)</span>;
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                    <span class="keyword">for</span> <span class="delimiter">(</span>int i = <span class="int">1</span>; i &lt; contents.length; i ++<span class="delimiter">)</span> <span class="delimiter">{</span>
                        <span class="keyword">if</span> <span class="delimiter">(</span>contents<span class="delimiter">[</span>i<span class="delimiter">]</span>.toLowerCase<span class="delimiter">(</span><span class="delimiter">)</span>.startsWith<span class="delimiter">(</span>
                                HttpHeaders.Values.CHARSET<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                            String<span class="delimiter">[</span><span class="delimiter">]</span> values = contents<span class="delimiter">[</span>i<span class="delimiter">]</span>.split<span class="delimiter">(</span><span class="string">&quot;=&quot;</span><span class="delimiter">)</span>;
                            Attribute attribute;
                            <span class="keyword">try</span> <span class="delimiter">{</span>
                                attribute = factory.createAttribute<span class="delimiter">(</span>request,
                                        HttpHeaders.Values.CHARSET,
                                        cleanString<span class="delimiter">(</span>values<span class="delimiter">[</span><span class="int">1</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>;
                            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>NullPointerException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IllegalArgumentException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                            <span class="delimiter">}</span>
                            currentFieldAttributes.put<span class="delimiter">(</span>HttpHeaders.Values.CHARSET,
                                    attribute<span class="delimiter">)</span>;
                        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                            Attribute attribute;
                            <span class="keyword">try</span> <span class="delimiter">{</span>
                                attribute = factory.createAttribute<span class="delimiter">(</span>request,
                                        contents<span class="delimiter">[</span><span class="int">0</span><span class="delimiter">]</span>.trim<span class="delimiter">(</span><span class="delimiter">)</span>,
                                        decodeAttribute<span class="delimiter">(</span>cleanString<span class="delimiter">(</span>contents<span class="delimiter">[</span>i<span class="delimiter">]</span><span class="delimiter">)</span>, charset<span class="delimiter">)</span><span class="delimiter">)</span>;
                            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>NullPointerException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IllegalArgumentException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                            <span class="delimiter">}</span>
                            currentFieldAttributes.put<span class="delimiter">(</span>attribute.getName<span class="delimiter">(</span><span class="delimiter">)</span>,
                                    attribute<span class="delimiter">)</span>;
                        <span class="delimiter">}</span>
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span><span class="string">&quot;Unknown Params: &quot;</span> +
                        newline<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        // Is it a FileUpload
        Attribute filenameAttribute = currentFieldAttributes
                .get<span class="delimiter">(</span>HttpPostBodyUtil.FILENAME<span class="delimiter">)</span>;
        <span class="keyword">if</span> <span class="delimiter">(</span>currentStatus == MultiPartStatus.DISPOSITION<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>filenameAttribute != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                // FileUpload
                currentStatus = MultiPartStatus.FILEUPLOAD;
                // do not change the buffer position
                <span class="keyword">return</span> decodeMultipart<span class="delimiter">(</span>MultiPartStatus.FILEUPLOAD<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                // Field
                currentStatus = MultiPartStatus.FIELD;
                // do not change the buffer position
                <span class="keyword">return</span> decodeMultipart<span class="delimiter">(</span>MultiPartStatus.FIELD<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>filenameAttribute != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                // FileUpload
                currentStatus = MultiPartStatus.MIXEDFILEUPLOAD;
                // do not change the buffer position
                <span class="keyword">return</span> decodeMultipart<span class="delimiter">(</span>MultiPartStatus.MIXEDFILEUPLOAD<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                // Field is not supported in MIXED mode
                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span><span class="string">&quot;Filename not found&quot;</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /**
     * Get the FileUpload (new one or current one)
     * @param delimiter the delimiter to use
     * @return the InterfaceHttpData if any
     * @throws ErrorDataDecoderException
     */
    <span class="keyword">private</span> <a href="InterfaceHttpData.java.html#10241" title="org.jboss.netty.handler.codec.http.InterfaceHttpData">InterfaceHttpData</a> <a title="(delimiter: String)org.jboss.netty.handler.codec.http.InterfaceHttpData" id="65506">getFileUpload</a><span class="delimiter">(</span>String <a title="String" id="127482">delimiter</a><span class="delimiter">)</span>
            throws ErrorDataDecoderException <span class="delimiter">{</span>
        // eventually restart from existing FileUpload
        // Now get value according to Content-Type and Charset
        Attribute encoding = currentFieldAttributes
                .get<span class="delimiter">(</span>HttpHeaders.Names.CONTENT_TRANSFER_ENCODING<span class="delimiter">)</span>;
        Charset localCharset = charset;
        // Default
        TransferEncodingMechanism mechanism = TransferEncodingMechanism.BIT7;
        <span class="keyword">if</span> <span class="delimiter">(</span>encoding != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            String code;
            <span class="keyword">try</span> <span class="delimiter">{</span>
                code = encoding.getValue<span class="delimiter">(</span><span class="delimiter">)</span>.toLowerCase<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IOException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>code.equals<span class="delimiter">(</span>HttpPostBodyUtil.TransferEncodingMechanism.BIT7.value<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                localCharset = HttpPostBodyUtil.US_ASCII;
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>code.equals<span class="delimiter">(</span>HttpPostBodyUtil.TransferEncodingMechanism.BIT8.value<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                localCharset = HttpPostBodyUtil.ISO_8859_1;
                mechanism = TransferEncodingMechanism.BIT8;
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>code
                    .equals<span class="delimiter">(</span>HttpPostBodyUtil.TransferEncodingMechanism.BINARY.value<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                // no real charset, so let the default
                mechanism = TransferEncodingMechanism.BINARY;
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>
                        <span class="string">&quot;TransferEncoding Unknown: &quot;</span> + code<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        Attribute charsetAttribute = currentFieldAttributes
                .get<span class="delimiter">(</span>HttpHeaders.Values.CHARSET<span class="delimiter">)</span>;
        <span class="keyword">if</span> <span class="delimiter">(</span>charsetAttribute != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">try</span> <span class="delimiter">{</span>
                localCharset = Charset.forName<span class="delimiter">(</span>charsetAttribute.getValue<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IOException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>currentFileUpload == <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            Attribute filenameAttribute = currentFieldAttributes
                    .get<span class="delimiter">(</span>HttpPostBodyUtil.FILENAME<span class="delimiter">)</span>;
            Attribute nameAttribute = currentFieldAttributes
                    .get<span class="delimiter">(</span>HttpPostBodyUtil.NAME<span class="delimiter">)</span>;
            Attribute contentTypeAttribute = currentFieldAttributes
                    .get<span class="delimiter">(</span>HttpHeaders.Names.CONTENT_TYPE<span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>contentTypeAttribute == <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>
                        <span class="string">&quot;Content-Type is absent but required&quot;</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
            Attribute lengthAttribute = currentFieldAttributes
                    .get<span class="delimiter">(</span>HttpHeaders.Names.CONTENT_LENGTH<span class="delimiter">)</span>;
            long size;
            <span class="keyword">try</span> <span class="delimiter">{</span>
                size = lengthAttribute != <span class="keyword">null</span>? Long.parseLong<span class="delimiter">(</span>lengthAttribute
                        .getValue<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> : <span class="long">0L</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IOException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>NumberFormatException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                size = <span class="int">0</span>;
            <span class="delimiter">}</span>
            <span class="keyword">try</span> <span class="delimiter">{</span>
                currentFileUpload = factory.createFileUpload<span class="delimiter">(</span>
                        request,
                        nameAttribute.getValue<span class="delimiter">(</span><span class="delimiter">)</span>, filenameAttribute.getValue<span class="delimiter">(</span><span class="delimiter">)</span>,
                        contentTypeAttribute.getValue<span class="delimiter">(</span><span class="delimiter">)</span>, mechanism.value,
                        localCharset, size<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>NullPointerException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IllegalArgumentException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IOException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        // load data as much as possible
        <span class="keyword">try</span> <span class="delimiter">{</span>
            readFileUploadByteMultipart<span class="delimiter">(</span>delimiter<span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>NotEnoughDataDecoderException e<span class="delimiter">)</span> <span class="delimiter">{</span>
            // do not change the buffer position
            // since some can be already saved into FileUpload
            // So do not change the currentStatus
            <span class="keyword">return</span> <span class="keyword">null</span>;
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>currentFileUpload.isCompleted<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            // ready to load the next one
            <span class="keyword">if</span> <span class="delimiter">(</span>currentStatus == MultiPartStatus.FILEUPLOAD<span class="delimiter">)</span> <span class="delimiter">{</span>
                currentStatus = MultiPartStatus.HEADERDELIMITER;
                currentFieldAttributes = <span class="keyword">null</span>;
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                currentStatus = MultiPartStatus.MIXEDDELIMITER;
                cleanMixedAttributes<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
            FileUpload fileUpload = currentFileUpload;
            currentFileUpload = <span class="keyword">null</span>;
            <span class="keyword">return</span> fileUpload;
        <span class="delimiter">}</span>
        // do not change the buffer position
        // since some can be already saved into FileUpload
        // So do not change the currentStatus
        <span class="keyword">return</span> <span class="keyword">null</span>;
    <span class="delimiter">}</span>

    /**
     * Clean all HttpDatas (on Disk) for the current request.
 */
    public void <a title="()Unit" id="65507">cleanFiles</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        factory.cleanRequestHttpDatas<span class="delimiter">(</span>request<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    /**
     * Remove the given FileUpload from the list of FileUploads to clean
     */
    public void <a title="(data: org.jboss.netty.handler.codec.http.InterfaceHttpData)Unit" id="65508">removeHttpDataFromClean</a><span class="delimiter">(</span><a href="InterfaceHttpData.java.html#10241" title="org.jboss.netty.handler.codec.http.InterfaceHttpData">InterfaceHttpData</a> <a title="org.jboss.netty.handler.codec.http.InterfaceHttpData" id="127483">data</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        factory.removeHttpDataFromClean<span class="delimiter">(</span>request, data<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    /**
     * Remove all Attributes that should be cleaned between two FileUpload in Mixed mode
     */
    <span class="keyword">private</span> void <a title="()Unit" id="65509">cleanMixedAttributes</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        currentFieldAttributes.remove<span class="delimiter">(</span>HttpHeaders.Values.CHARSET<span class="delimiter">)</span>;
        currentFieldAttributes.remove<span class="delimiter">(</span>HttpHeaders.Names.CONTENT_LENGTH<span class="delimiter">)</span>;
        currentFieldAttributes.remove<span class="delimiter">(</span>HttpHeaders.Names.CONTENT_TRANSFER_ENCODING<span class="delimiter">)</span>;
        currentFieldAttributes.remove<span class="delimiter">(</span>HttpHeaders.Names.CONTENT_TYPE<span class="delimiter">)</span>;
        currentFieldAttributes.remove<span class="delimiter">(</span>HttpPostBodyUtil.FILENAME<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    /**
     * Read one line up to the CRLF or LF
     * @return the String from one line
     * @throws NotEnoughDataDecoderException Need more chunks and
     *   reset the readerInder to the previous value
     */
    <span class="keyword">private</span> String <a title="()String" id="65510">readLine</a><span class="delimiter">(</span><span class="delimiter">)</span> throws NotEnoughDataDecoderException <span class="delimiter">{</span>
        int readerIndex = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            StringBuilder sb = <span class="keyword">new</span> StringBuilder<span class="delimiter">(</span><span class="int">64</span><span class="delimiter">)</span>;
            <span class="keyword">while</span> <span class="delimiter">(</span>undecodedChunk.readable<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                byte nextByte = undecodedChunk.readByte<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.CR<span class="delimiter">)</span> <span class="delimiter">{</span>
                    nextByte = undecodedChunk.readByte<span class="delimiter">(</span><span class="delimiter">)</span>;
                    <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.LF<span class="delimiter">)</span> <span class="delimiter">{</span>
                        <span class="keyword">return</span> sb.toString<span class="delimiter">(</span><span class="delimiter">)</span>;
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.LF<span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">return</span> sb.toString<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                    sb.append<span class="delimiter">(</span><span class="delimiter">(</span>char<span class="delimiter">)</span> nextByte<span class="delimiter">)</span>;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IndexOutOfBoundsException e<span class="delimiter">)</span> <span class="delimiter">{</span>
            undecodedChunk.readerIndex<span class="delimiter">(</span>readerIndex<span class="delimiter">)</span>;
            <span class="keyword">throw</span> <span class="keyword">new</span> NotEnoughDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        undecodedChunk.readerIndex<span class="delimiter">(</span>readerIndex<span class="delimiter">)</span>;
        <span class="keyword">throw</span> <span class="keyword">new</span> NotEnoughDataDecoderException<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    /**
     * Read a FileUpload data as Byte (Binary) and add the bytes directly to the
     * FileUpload. If the delimiter is found, the FileUpload is completed.
     * @param delimiter
     * @throws NotEnoughDataDecoderException Need more chunks but
     *   do not reset the readerInder since some values will be already added to the FileOutput
     * @throws ErrorDataDecoderException write IO error occurs with the FileUpload
     */
    <span class="keyword">private</span> void <a title="(delimiter: String)Unit" id="65511">readFileUploadByteMultipart</a><span class="delimiter">(</span>String <a title="String" id="127484">delimiter</a><span class="delimiter">)</span>
            throws NotEnoughDataDecoderException, ErrorDataDecoderException <span class="delimiter">{</span>
        int readerIndex = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span>;
        // found the decoder limit
        boolean newLine = <span class="keyword">true</span>;
        int index = <span class="int">0</span>;
        int lastPosition = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span>;
        boolean found = <span class="keyword">false</span>;
        <span class="keyword">while</span> <span class="delimiter">(</span>undecodedChunk.readable<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            byte nextByte = undecodedChunk.readByte<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>newLine<span class="delimiter">)</span> <span class="delimiter">{</span>
                // Check the delimiter
                <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == delimiter.codePointAt<span class="delimiter">(</span>index<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    index ++;
                    <span class="keyword">if</span> <span class="delimiter">(</span>delimiter.length<span class="delimiter">(</span><span class="delimiter">)</span> == index<span class="delimiter">)</span> <span class="delimiter">{</span>
                        found = <span class="keyword">true</span>;
                        break;
                    <span class="delimiter">}</span>
                    continue;
                <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                    newLine = <span class="keyword">false</span>;
                    index = <span class="int">0</span>;
                    // continue until end of line
                    <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.CR<span class="delimiter">)</span> <span class="delimiter">{</span>
                        <span class="keyword">if</span> <span class="delimiter">(</span>undecodedChunk.readable<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                            nextByte = undecodedChunk.readByte<span class="delimiter">(</span><span class="delimiter">)</span>;
                            <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.LF<span class="delimiter">)</span> <span class="delimiter">{</span>
                                newLine = <span class="keyword">true</span>;
                                index = <span class="int">0</span>;
                                lastPosition = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span> - <span class="int">2</span>;
                            <span class="delimiter">}</span>
                        <span class="delimiter">}</span>
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.LF<span class="delimiter">)</span> <span class="delimiter">{</span>
                        newLine = <span class="keyword">true</span>;
                        index = <span class="int">0</span>;
                        lastPosition = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span> - <span class="int">1</span>;
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                        // save last valid position
                        lastPosition = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span>;
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                // continue until end of line
                <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.CR<span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">if</span> <span class="delimiter">(</span>undecodedChunk.readable<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                        nextByte = undecodedChunk.readByte<span class="delimiter">(</span><span class="delimiter">)</span>;
                        <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.LF<span class="delimiter">)</span> <span class="delimiter">{</span>
                            newLine = <span class="keyword">true</span>;
                            index = <span class="int">0</span>;
                            lastPosition = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span> - <span class="int">2</span>;
                        <span class="delimiter">}</span>
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.LF<span class="delimiter">)</span> <span class="delimiter">{</span>
                    newLine = <span class="keyword">true</span>;
                    index = <span class="int">0</span>;
                    lastPosition = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span> - <span class="int">1</span>;
                <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                    // save last valid position
                    lastPosition = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        ChannelBuffer buffer = undecodedChunk.slice<span class="delimiter">(</span>readerIndex, lastPosition -
                readerIndex<span class="delimiter">)</span>;
        <span class="keyword">if</span> <span class="delimiter">(</span>found<span class="delimiter">)</span> <span class="delimiter">{</span>
            // found so lastPosition is correct and final
            <span class="keyword">try</span> <span class="delimiter">{</span>
                currentFileUpload.addContent<span class="delimiter">(</span>buffer, <span class="keyword">true</span><span class="delimiter">)</span>;
                // just before the CRLF and delimiter
                undecodedChunk.readerIndex<span class="delimiter">(</span>lastPosition<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IOException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            // possibly the delimiter is partially found but still the last position is OK
            <span class="keyword">try</span> <span class="delimiter">{</span>
                currentFileUpload.addContent<span class="delimiter">(</span>buffer, <span class="keyword">false</span><span class="delimiter">)</span>;
                // last valid char (not CR, not LF, not beginning of delimiter)
                undecodedChunk.readerIndex<span class="delimiter">(</span>lastPosition<span class="delimiter">)</span>;
                <span class="keyword">throw</span> <span class="keyword">new</span> NotEnoughDataDecoderException<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IOException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /**
     * Load the field value from a Multipart request
     * @throws NotEnoughDataDecoderException Need more chunks
     * @throws ErrorDataDecoderException
     */
    <span class="keyword">private</span> void <a title="(delimiter: String)Unit" id="65512">loadFieldMultipart</a><span class="delimiter">(</span>String <a title="String" id="127485">delimiter</a><span class="delimiter">)</span>
            throws NotEnoughDataDecoderException, ErrorDataDecoderException <span class="delimiter">{</span>
        int readerIndex = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            // found the decoder limit
            boolean newLine = <span class="keyword">true</span>;
            int index = <span class="int">0</span>;
            int lastPosition = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span>;
            boolean found = <span class="keyword">false</span>;
            <span class="keyword">while</span> <span class="delimiter">(</span>undecodedChunk.readable<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                byte nextByte = undecodedChunk.readByte<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span>newLine<span class="delimiter">)</span> <span class="delimiter">{</span>
                    // Check the delimiter
                    <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == delimiter.codePointAt<span class="delimiter">(</span>index<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                        index ++;
                        <span class="keyword">if</span> <span class="delimiter">(</span>delimiter.length<span class="delimiter">(</span><span class="delimiter">)</span> == index<span class="delimiter">)</span> <span class="delimiter">{</span>
                            found = <span class="keyword">true</span>;
                            break;
                        <span class="delimiter">}</span>
                        continue;
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                        newLine = <span class="keyword">false</span>;
                        index = <span class="int">0</span>;
                        // continue until end of line
                        <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.CR<span class="delimiter">)</span> <span class="delimiter">{</span>
                            <span class="keyword">if</span> <span class="delimiter">(</span>undecodedChunk.readable<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                                nextByte = undecodedChunk.readByte<span class="delimiter">(</span><span class="delimiter">)</span>;
                                <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.LF<span class="delimiter">)</span> <span class="delimiter">{</span>
                                    newLine = <span class="keyword">true</span>;
                                    index = <span class="int">0</span>;
                                    lastPosition = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span> - <span class="int">2</span>;
                                <span class="delimiter">}</span>
                            <span class="delimiter">}</span>
                        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.LF<span class="delimiter">)</span> <span class="delimiter">{</span>
                            newLine = <span class="keyword">true</span>;
                            index = <span class="int">0</span>;
                            lastPosition = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span> - <span class="int">1</span>;
                        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                            lastPosition = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span>;
                        <span class="delimiter">}</span>
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                    // continue until end of line
                    <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.CR<span class="delimiter">)</span> <span class="delimiter">{</span>
                        <span class="keyword">if</span> <span class="delimiter">(</span>undecodedChunk.readable<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                            nextByte = undecodedChunk.readByte<span class="delimiter">(</span><span class="delimiter">)</span>;
                            <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.LF<span class="delimiter">)</span> <span class="delimiter">{</span>
                                newLine = <span class="keyword">true</span>;
                                index = <span class="int">0</span>;
                                lastPosition = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span> - <span class="int">2</span>;
                            <span class="delimiter">}</span>
                        <span class="delimiter">}</span>
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.LF<span class="delimiter">)</span> <span class="delimiter">{</span>
                        newLine = <span class="keyword">true</span>;
                        index = <span class="int">0</span>;
                        lastPosition = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span> - <span class="int">1</span>;
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                        lastPosition = undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span>;
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>found<span class="delimiter">)</span> <span class="delimiter">{</span>
                // found so lastPosition is correct
                // but position is just after the delimiter (either close delimiter or simple one)
                // so go back of delimiter size
                <span class="keyword">try</span> <span class="delimiter">{</span>
                    currentAttribute.addContent<span class="delimiter">(</span>
                            undecodedChunk.slice<span class="delimiter">(</span>readerIndex, lastPosition - readerIndex<span class="delimiter">)</span>,
                            <span class="keyword">true</span><span class="delimiter">)</span>;
                <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IOException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                <span class="delimiter">}</span>
                undecodedChunk.readerIndex<span class="delimiter">(</span>lastPosition<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                <span class="keyword">try</span> <span class="delimiter">{</span>
                    currentAttribute.addContent<span class="delimiter">(</span>
                            undecodedChunk.slice<span class="delimiter">(</span>readerIndex, lastPosition - readerIndex<span class="delimiter">)</span>,
                            <span class="keyword">false</span><span class="delimiter">)</span>;
                <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IOException e<span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                <span class="delimiter">}</span>
                undecodedChunk.readerIndex<span class="delimiter">(</span>lastPosition<span class="delimiter">)</span>;
                <span class="keyword">throw</span> <span class="keyword">new</span> NotEnoughDataDecoderException<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>IndexOutOfBoundsException e<span class="delimiter">)</span> <span class="delimiter">{</span>
            undecodedChunk.readerIndex<span class="delimiter">(</span>readerIndex<span class="delimiter">)</span>;
            <span class="keyword">throw</span> <span class="keyword">new</span> NotEnoughDataDecoderException<span class="delimiter">(</span>e<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /**
     * Clean the String from any unallowed character
     * @return the cleaned String
     */
    <span class="keyword">private</span> String <a title="(field: String)String" id="65513">cleanString</a><span class="delimiter">(</span>String <a title="String" id="127486">field</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        StringBuilder sb = <span class="keyword">new</span> StringBuilder<span class="delimiter">(</span>field.length<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
        int i = <span class="int">0</span>;
        <span class="keyword">for</span> <span class="delimiter">(</span>i = <span class="int">0</span>; i &lt; field.length<span class="delimiter">(</span><span class="delimiter">)</span>; i ++<span class="delimiter">)</span> <span class="delimiter">{</span>
            char nextChar = field.charAt<span class="delimiter">(</span>i<span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>nextChar == HttpConstants.COLON<span class="delimiter">)</span> <span class="delimiter">{</span>
                sb.append<span class="delimiter">(</span>HttpConstants.SP<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>nextChar == HttpConstants.COMMA<span class="delimiter">)</span> <span class="delimiter">{</span>
                sb.append<span class="delimiter">(</span>HttpConstants.SP<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>nextChar == HttpConstants.EQUALS<span class="delimiter">)</span> <span class="delimiter">{</span>
                sb.append<span class="delimiter">(</span>HttpConstants.SP<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>nextChar == HttpConstants.SEMICOLON<span class="delimiter">)</span> <span class="delimiter">{</span>
                sb.append<span class="delimiter">(</span>HttpConstants.SP<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>nextChar == HttpConstants.HT<span class="delimiter">)</span> <span class="delimiter">{</span>
                sb.append<span class="delimiter">(</span>HttpConstants.SP<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>nextChar == HttpConstants.DOUBLE_QUOTE<span class="delimiter">)</span> <span class="delimiter">{</span>
                // nothing added, just removes it
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                sb.append<span class="delimiter">(</span>nextChar<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">return</span> sb.toString<span class="delimiter">(</span><span class="delimiter">)</span>.trim<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    /**
     * Skip one empty line
     * @return True if one empty line was skipped
     */
    <span class="keyword">private</span> boolean <a title="()Boolean" id="65514">skipOneLine</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>!undecodedChunk.readable<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="delimiter">}</span>
        byte nextByte = undecodedChunk.readByte<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.CR<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>!undecodedChunk.readable<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                undecodedChunk.readerIndex<span class="delimiter">(</span>undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span> - <span class="int">1</span><span class="delimiter">)</span>;
                <span class="keyword">return</span> <span class="keyword">false</span>;
            <span class="delimiter">}</span>
            nextByte = undecodedChunk.readByte<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.LF<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">return</span> <span class="keyword">true</span>;
            <span class="delimiter">}</span>
            undecodedChunk.readerIndex<span class="delimiter">(</span>undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span> - <span class="int">2</span><span class="delimiter">)</span>;
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>nextByte == HttpConstants.LF<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="delimiter">}</span>
        undecodedChunk.readerIndex<span class="delimiter">(</span>undecodedChunk.readerIndex<span class="delimiter">(</span><span class="delimiter">)</span> - <span class="int">1</span><span class="delimiter">)</span>;
        <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="delimiter">}</span>

    /**
     * Split the very first line (Content-Type value) in 2 Strings
     * @param sb
     * @return the array of 2 Strings
     */
    <span class="keyword">private</span> String<span class="delimiter">[</span><span title="Array" class="delimiter">]</span> <a title="(sb: String)Array[String]" id="65515">splitHeaderContentType</a><span class="delimiter">(</span>String <a title="String" id="127487">sb</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        int size = sb.length<span class="delimiter">(</span><span class="delimiter">)</span>;
        int aStart;
        int aEnd;
        int bStart;
        int bEnd;
        aStart = HttpPostBodyUtil.findNonWhitespace<span class="delimiter">(</span>sb, <span class="int">0</span><span class="delimiter">)</span>;
        aEnd = HttpPostBodyUtil.findWhitespace<span class="delimiter">(</span>sb, aStart<span class="delimiter">)</span>;
        <span class="keyword">if</span> <span class="delimiter">(</span>aEnd &gt;= size<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> <span class="keyword">new</span> String<span class="delimiter">[</span><span class="delimiter">]</span> <span class="delimiter">{</span> sb, <span class="string">&quot;&quot;</span> <span class="delimiter">}</span>;
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>sb.charAt<span class="delimiter">(</span>aEnd<span class="delimiter">)</span> == <span class="char">';'</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            aEnd --;
        <span class="delimiter">}</span>
        bStart = HttpPostBodyUtil.findNonWhitespace<span class="delimiter">(</span>sb, aEnd<span class="delimiter">)</span>;
        bEnd = HttpPostBodyUtil.findEndOfString<span class="delimiter">(</span>sb<span class="delimiter">)</span>;
        <span class="keyword">return</span> <span class="keyword">new</span> String<span class="delimiter">[</span><span class="delimiter">]</span> <span class="delimiter">{</span> sb.substring<span class="delimiter">(</span>aStart, aEnd<span class="delimiter">)</span>,
                sb.substring<span class="delimiter">(</span>bStart, bEnd<span class="delimiter">)</span> <span class="delimiter">}</span>;
    <span class="delimiter">}</span>

    /**
     * Split one header in Multipart
     * @param sb
     * @return an array of String where rank 0 is the name of the header, follows by several
     *  values that were separated by ';' or ','
     */
    <span class="keyword">private</span> String<span class="delimiter">[</span><span title="Array" class="delimiter">]</span> <a title="(sb: String)Array[String]" id="65516">splitMultipartHeader</a><span class="delimiter">(</span>String <a title="String" id="127488">sb</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        ArrayList&lt;String&gt; headers = <span class="keyword">new</span> ArrayList&lt;String&gt;<span class="delimiter">(</span><span class="int">1</span><span class="delimiter">)</span>;
        int nameStart;
        int nameEnd;
        int colonEnd;
        int valueStart;
        int valueEnd;
        nameStart = HttpPostBodyUtil.findNonWhitespace<span class="delimiter">(</span>sb, <span class="int">0</span><span class="delimiter">)</span>;
        <span class="keyword">for</span> <span class="delimiter">(</span>nameEnd = nameStart; nameEnd &lt; sb.length<span class="delimiter">(</span><span class="delimiter">)</span>; nameEnd ++<span class="delimiter">)</span> <span class="delimiter">{</span>
            char ch = sb.charAt<span class="delimiter">(</span>nameEnd<span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>ch == <span class="char">':'</span> || Character.isWhitespace<span class="delimiter">(</span>ch<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                break;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">for</span> <span class="delimiter">(</span>colonEnd = nameEnd; colonEnd &lt; sb.length<span class="delimiter">(</span><span class="delimiter">)</span>; colonEnd ++<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>sb.charAt<span class="delimiter">(</span>colonEnd<span class="delimiter">)</span> == <span class="char">':'</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                colonEnd ++;
                break;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        valueStart = HttpPostBodyUtil.findNonWhitespace<span class="delimiter">(</span>sb, colonEnd<span class="delimiter">)</span>;
        valueEnd = HttpPostBodyUtil.findEndOfString<span class="delimiter">(</span>sb<span class="delimiter">)</span>;
        headers.add<span class="delimiter">(</span>sb.substring<span class="delimiter">(</span>nameStart, nameEnd<span class="delimiter">)</span><span class="delimiter">)</span>;
        String svalue = sb.substring<span class="delimiter">(</span>valueStart, valueEnd<span class="delimiter">)</span>;
        String<span class="delimiter">[</span><span class="delimiter">]</span> values = <span class="keyword">null</span>;
        <span class="keyword">if</span> <span class="delimiter">(</span>svalue.indexOf<span class="delimiter">(</span><span class="string">&quot;;&quot;</span><span class="delimiter">)</span> &gt;= <span class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            values = svalue.split<span class="delimiter">(</span><span class="string">&quot;;&quot;</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            values = svalue.split<span class="delimiter">(</span><span class="string">&quot;,&quot;</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">for</span> <span class="delimiter">(</span>String value: values<span class="delimiter">)</span> <span class="delimiter">{</span>
            headers.add<span class="delimiter">(</span>value.trim<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        String<span class="delimiter">[</span><span class="delimiter">]</span> array = <span class="keyword">new</span> String<span class="delimiter">[</span>headers.size<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">]</span>;
        <span class="keyword">for</span> <span class="delimiter">(</span>int i = <span class="int">0</span>; i &lt; headers.size<span class="delimiter">(</span><span class="delimiter">)</span>; i ++<span class="delimiter">)</span> <span class="delimiter">{</span>
            array<span class="delimiter">[</span>i<span class="delimiter">]</span> = headers.get<span class="delimiter">(</span>i<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">return</span> array;
    <span class="delimiter">}</span>

    /**
     * Exception when try reading data from request in chunked format, and not enough
     * data are available (need more chunks)
     */
    public static <span class="keyword">class</span> <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.NotEnoughDataDecoderException.type" id="65389">NotEnoughDataDecoderException</a> <span class="keyword">extends</span> Exception <span class="delimiter">{</span>
        /**
 */
        <span class="keyword">private</span> static <span class="keyword">final</span> long <a title="Long" id="127440">serialVersionUID</a> = -<span class="long">7846841864603865638L</span>;

        /**
 */
        public NotEnoughDataDecoderException<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="delimiter">}</span>

        /**
         * @param arg0
         */
        public NotEnoughDataDecoderException<a title="(arg0: String)org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.NotEnoughDataDecoderException" id="66197" class="delimiter">(</a>String <a title="String" id="127443">arg0</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">super</span><span class="delimiter">(</span>arg0<span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        /**
         * @param arg0
         */
        public NotEnoughDataDecoderException<a title="(arg0: Throwable)org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.NotEnoughDataDecoderException" id="66198" class="delimiter">(</a>Throwable <a title="Throwable" id="127445">arg0</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">super</span><span class="delimiter">(</span>arg0<span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        /**
         * @param arg0
         * @param arg1
         */
        public NotEnoughDataDecoderException<a title="(arg0: String, arg1: Throwable)org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.NotEnoughDataDecoderException" id="66199" class="delimiter">(</a>String <a title="String" id="127447">arg0</a>, Throwable <a title="Throwable" id="127448">arg1</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">super</span><span class="delimiter">(</span>arg0, arg1<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /**
     * Exception when the body is fully decoded, even if there is still data
     */
    public static <span class="keyword">class</span> <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.EndOfDataDecoderException.type" id="65392">EndOfDataDecoderException</a> <span class="keyword">extends</span> Exception <span class="delimiter">{</span>
        /**
 */
        <span class="keyword">private</span> static <span class="keyword">final</span> long <a title="Long" id="127450">serialVersionUID</a> = <span class="long">1336267941020800769L</span>;

    <span class="delimiter">}</span>

    /**
     * Exception when an error occurs while decoding
     */
    public static <span class="keyword">class</span> <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.ErrorDataDecoderException.type" id="65395">ErrorDataDecoderException</a> <span class="keyword">extends</span> Exception <span class="delimiter">{</span>
        /**
 */
        <span class="keyword">private</span> static <span class="keyword">final</span> long <a title="Long" id="127452">serialVersionUID</a> = <span class="long">5020247425493164465L</span>;

        /**
 */
        public ErrorDataDecoderException<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="delimiter">}</span>

        /**
         * @param arg0
         */
        public ErrorDataDecoderException<a title="(arg0: String)org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.ErrorDataDecoderException" id="65529" class="delimiter">(</a>String <a title="String" id="127455">arg0</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">super</span><span class="delimiter">(</span>arg0<span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        /**
         * @param arg0
         */
        public ErrorDataDecoderException<a title="(arg0: Throwable)org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.ErrorDataDecoderException" id="65530" class="delimiter">(</a>Throwable <a title="Throwable" id="127457">arg0</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">super</span><span class="delimiter">(</span>arg0<span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        /**
         * @param arg0
         * @param arg1
         */
        public ErrorDataDecoderException<a title="(arg0: String, arg1: Throwable)org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.ErrorDataDecoderException" id="65531" class="delimiter">(</a>String <a title="String" id="127459">arg0</a>, Throwable <a title="Throwable" id="127460">arg1</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">super</span><span class="delimiter">(</span>arg0, arg1<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /**
     * Exception when an unappropriated method was called on a request
     */
    public static <span class="keyword">class</span> <a title="org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.IncompatibleDataDecoderException.type" id="65398">IncompatibleDataDecoderException</a> <span class="keyword">extends</span> Exception <span class="delimiter">{</span>
        /**
 */
        <span class="keyword">private</span> static <span class="keyword">final</span> long <a title="Long" id="127462">serialVersionUID</a> = -<span class="long">953268047926250267L</span>;

        /**
 */
        public IncompatibleDataDecoderException<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="delimiter">}</span>

        /**
         * @param arg0
         */
        public IncompatibleDataDecoderException<a title="(arg0: String)org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.IncompatibleDataDecoderException" id="65535" class="delimiter">(</a>String <a title="String" id="127465">arg0</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">super</span><span class="delimiter">(</span>arg0<span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        /**
         * @param arg0
         */
        public IncompatibleDataDecoderException<a title="(arg0: Throwable)org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.IncompatibleDataDecoderException" id="65536" class="delimiter">(</a>Throwable <a title="Throwable" id="127467">arg0</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">super</span><span class="delimiter">(</span>arg0<span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        /**
         * @param arg0
         * @param arg1
         */
        public IncompatibleDataDecoderException<a title="(arg0: String, arg1: Throwable)org.jboss.netty.handler.codec.http.HttpPostRequestDecoder.IncompatibleDataDecoderException" id="65537" class="delimiter">(</a>String <a title="String" id="127469">arg0</a>, Throwable <a title="Throwable" id="127470">arg1</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">super</span><span class="delimiter">(</span>arg0, arg1<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>