<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/producer/async/DefaultEventHandler.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package kafka.producer.async

import kafka.common._
import kafka.message.<span class="delimiter">{</span>NoCompressionCodec, Message, ByteBufferMessageSet<span class="delimiter">}</span>
import kafka.producer._
import kafka.serializer.Encoder
import kafka.utils.<span class="delimiter">{</span>Utils, Logging, SystemTime<span class="delimiter">}</span>
import scala.util.Random
import scala.collection.<span class="delimiter">{</span>Seq, Map<span class="delimiter">}</span>
import scala.collection.mutable.<span class="delimiter">{</span>ArrayBuffer, HashMap, Set<span class="delimiter">}</span>
import java.util.concurrent.atomic._
import kafka.api.<span class="delimiter">{</span>TopicMetadata, ProducerRequest<span class="delimiter">}</span>

class <a title="class DefaultEventHandler[K, V] extends AnyRef with kafka.producer.async.EventHandler[K,V] with kafka.utils.Logging" id="kafka.producer.async.DefaultEventHandler">DefaultEventHandler</a><span class="delimiter">[</span><a title="" id="kafka.producer.async.DefaultEventHandler.<init>$default$6;K">K</a>,<a title="" id="kafka.producer.async.DefaultEventHandler.<init>$default$6;V">V</a><span class="delimiter">]</span><a href="#kafka.producer.async.DefaultEventHandler" title="kafka.producer.async.DefaultEventHandler[K,V]" class="delimiter">(</a><a title="kafka.producer.ProducerConfig" id="kafka.producer.async;DefaultEventHandler.config">config</a>: <a href="../ProducerConfig.scala.html#kafka.producer;ProducerConfig" title="kafka.producer.ProducerConfig">ProducerConfig</a>,
                               private val <a title="kafka.producer.Partitioner" id="kafka.producer.async;DefaultEventHandler.partitioner">partitioner</a>: <a href="../Partitioner.scala.html#kafka.producer;Partitioner" title="kafka.producer.Partitioner">Partitioner</a>,
                               private val <a title="kafka.serializer.Encoder[V]" id="kafka.producer.async;DefaultEventHandler.encoder">encoder</a>: <a href="../../serializer/Encoder.scala.html#kafka.serializer;Encoder" title="kafka.serializer.Encoder[V]">Encoder</a><span class="delimiter">[</span>V<span class="delimiter">]</span>,
                               private val <a title="kafka.serializer.Encoder[K]" id="kafka.producer.async;DefaultEventHandler.keyEncoder">keyEncoder</a>: <a href="../../serializer/Encoder.scala.html#kafka.serializer;Encoder" title="kafka.serializer.Encoder[K]">Encoder</a><span class="delimiter">[</span>K<span class="delimiter">]</span>,
                               private val <a title="kafka.producer.ProducerPool" id="kafka.producer.async;DefaultEventHandler.producerPool">producerPool</a>: <a href="../ProducerPool.scala.html#kafka.producer;ProducerPool" title="kafka.producer.ProducerPool">ProducerPool</a>,
                               private val <a title="scala.collection.mutable.HashMap[String,kafka.api.TopicMetadata]" id="kafka.producer.async.DefaultEventHandler.<init>$default$6">topicPartitionInfos</a>: <span title="scala.collection.mutable.HashMap[String,kafka.api.TopicMetadata]">HashMap</span><span class="delimiter">[</span>String, TopicMetadata<span class="delimiter">]</span> = new <span title="scala.collection.mutable.HashMap[String,kafka.api.TopicMetadata]">HashMap</span><span class="delimiter">[</span>String, TopicMetadata<span class="delimiter">]</span><span class="delimiter">)</span>
  extends <a href="EventHandler.scala.html#kafka.producer.async;EventHandler" title="kafka.producer.async.EventHandler[K,V]">EventHandler</a><span class="delimiter">[</span>K,V<span class="delimiter">]</span> with <a href="../../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> <span class="delimiter">{</span>
  val isSync = <span class="delimiter">(</span><span title="String(&quot;sync&quot;)" class="string">&quot;sync&quot;</span> <a title="Boolean" id="kafka.producer.async;DefaultEventHandler.isSync">==</a> <a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../ProducerConfig.scala.html#kafka.producer;ProducerConfig.producerType" title="=&gt; String">producerType</a><span class="delimiter">)</span>

  val <a title="java.util.concurrent.atomic.AtomicInteger" id="kafka.producer.async;DefaultEventHandler.correlationId">correlationId</a> = new <span title="java.util.concurrent.atomic.AtomicInteger">AtomicInteger</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
  val <a title="kafka.producer.BrokerPartitionInfo" id="kafka.producer.async;DefaultEventHandler.brokerPartitionInfo">brokerPartitionInfo</a> = new <a href="../BrokerPartitionInfo.scala.html#kafka.producer;BrokerPartitionInfo" title="kafka.producer.BrokerPartitionInfo">BrokerPartitionInfo</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>, <a href="#kafka.producer.async;DefaultEventHandler.producerPool" title="=&gt; kafka.producer.ProducerPool">producerPool</a>, <a href="#kafka.producer.async.DefaultEventHandler.<init>$default$6" title="=&gt; scala.collection.mutable.HashMap[String,kafka.api.TopicMetadata]">topicPartitionInfos</a><span class="delimiter">)</span>

  private val <a title="Int" id="kafka.producer.async;DefaultEventHandler.topicMetadataRefreshInterval">topicMetadataRefreshInterval</a> = <a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../ProducerConfig.scala.html#kafka.producer;ProducerConfig.topicMetadataRefreshIntervalMs" title="=&gt; Int">topicMetadataRefreshIntervalMs</a>
  private var <a title="Long" id="kafka.producer.async;DefaultEventHandler.lastTopicMetadataRefreshTime_=">lastTopicMetadataRefreshTime</a> = <span title="Long(0L)" class="long">0L</span>
  private val <a title="scala.collection.mutable.Set[String]" id="kafka.producer.async;DefaultEventHandler.topicMetadataToRefresh">topicMetadataToRefresh</a> = <span title="scala.collection.mutable.Set.type">Set</span>.<span title="[A]=&gt; scala.collection.mutable.Set[A]">empty</span><span title="scala.collection.mutable.Set[String]" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span>
  private val <a title="scala.collection.mutable.HashMap[String,Int]" id="kafka.producer.async;DefaultEventHandler.sendPartitionPerTopicCache">sendPartitionPerTopicCache</a> = <span title="scala.collection.mutable.HashMap.type">HashMap</span>.<span title="[A, B]=&gt; scala.collection.mutable.HashMap[A,B]">empty</span><span title="scala.collection.mutable.HashMap[String,Int]" class="delimiter">[</span><span title="String">String</span>, <span title="Int">Int</span><span class="delimiter">]</span>

  private val <a title="kafka.producer.ProducerStats" id="kafka.producer.async;DefaultEventHandler.producerStats">producerStats</a> = <a href="../ProducerStats.scala.html#kafka.producer.ProducerStatsRegistry" title="kafka.producer.ProducerStatsRegistry.type">ProducerStatsRegistry</a>.<a href="../ProducerStats.scala.html#kafka.producer.ProducerStatsRegistry.getProducerStats" title="(clientId: String)kafka.producer.ProducerStats">getProducerStats</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../SyncProducerConfig.scala.html#kafka.producer;SyncProducerConfigShared.clientId" title="=&gt; String">clientId</a><span class="delimiter">)</span>
  private val <a title="kafka.producer.ProducerTopicStats" id="kafka.producer.async;DefaultEventHandler.producerTopicStats">producerTopicStats</a> = <a href="../ProducerTopicStats.scala.html#kafka.producer.ProducerTopicStatsRegistry" title="kafka.producer.ProducerTopicStatsRegistry.type">ProducerTopicStatsRegistry</a>.<a href="../ProducerTopicStats.scala.html#kafka.producer.ProducerTopicStatsRegistry.getProducerTopicStats" title="(clientId: String)kafka.producer.ProducerTopicStats">getProducerTopicStats</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../SyncProducerConfig.scala.html#kafka.producer;SyncProducerConfigShared.clientId" title="=&gt; String">clientId</a><span class="delimiter">)</span>

  def <a title="(events: Seq[kafka.producer.KeyedMessage[K,V]])Unit" id="kafka.producer.async;DefaultEventHandler.handle">handle</a><span class="delimiter">(</span><a title="Seq[kafka.producer.KeyedMessage[K,V]]" id="kafka.producer.async;DefaultEventHandler.handle.events">events</a>: <span title="Seq[kafka.producer.KeyedMessage[K,V]]">Seq</span><span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]" id="kafka.producer.async;DefaultEventHandler.handle.serializedData">serializedData</a> = <a href="#kafka.producer.async;DefaultEventHandler.serialize" title="(events: Seq[kafka.producer.KeyedMessage[K,V]])Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">serialize</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.handle.events" title="Seq[kafka.producer.KeyedMessage[K,V]]">events</a><span class="delimiter">)</span>
    <a href="#kafka.producer.async;DefaultEventHandler.handle.serializedData" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">serializedData</a>.<span title="(f: kafka.producer.KeyedMessage[K,kafka.message.Message] =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span>
      <a title="kafka.producer.KeyedMessage[K,kafka.message.Message]" id="kafka.producer.async;DefaultEventHandler.handle.$anonfun.keyed">keyed</a> =&gt;
        val <a title="Int" id="kafka.producer.async;DefaultEventHandler.handle.$anonfun.dataSize">dataSize</a> = <a href="#kafka.producer.async;DefaultEventHandler.handle.$anonfun.keyed" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">keyed</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.message" title="=&gt; kafka.message.Message">message</a>.<a href="../../message/Message.scala.html#kafka.message;Message.payloadSize" title="=&gt; Int">payloadSize</a>
        <a href="#kafka.producer.async;DefaultEventHandler.producerTopicStats" title="=&gt; kafka.producer.ProducerTopicStats">producerTopicStats</a>.<a href="../ProducerTopicStats.scala.html#kafka.producer;ProducerTopicStats.getProducerTopicStats" title="(topic: String)kafka.producer.ProducerTopicMetrics">getProducerTopicStats</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.handle.$anonfun.keyed" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">keyed</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>.<a href="../ProducerTopicStats.scala.html#kafka.producer;ProducerTopicMetrics.byteRate" title="=&gt; com.yammer.metrics.core.Meter">byteRate</a>.<span title="(x$1: Long)Unit">mark</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.handle.$anonfun.dataSize" title="=&gt; Long">dataSize</a><span class="delimiter">)</span>
        <a href="#kafka.producer.async;DefaultEventHandler.producerTopicStats" title="=&gt; kafka.producer.ProducerTopicStats">producerTopicStats</a>.<a href="../ProducerTopicStats.scala.html#kafka.producer;ProducerTopicStats.getProducerAllTopicsStats" title="()kafka.producer.ProducerTopicMetrics">getProducerAllTopicsStats</a>.<a href="../ProducerTopicStats.scala.html#kafka.producer;ProducerTopicMetrics.byteRate" title="=&gt; com.yammer.metrics.core.Meter">byteRate</a>.<span title="(x$1: Long)Unit">mark</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.handle.$anonfun.dataSize" title="=&gt; Long">dataSize</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    var <a title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]" id="kafka.producer.async;DefaultEventHandler.handle.outstandingProduceRequests">outstandingProduceRequests</a> = <a href="#kafka.producer.async;DefaultEventHandler.handle.serializedData" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">serializedData</a>
    var remainingRetries = <a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../ProducerConfig.scala.html#kafka.producer;ProducerConfig.messageSendMaxRetries" title="=&gt; Int">messageSendMaxRetries</a> <a title="Int" id="kafka.producer.async;DefaultEventHandler.handle.remainingRetries">+</a> <span title="Int(1)" class="int">1</span>
    val <a title="Int" id="kafka.producer.async;DefaultEventHandler.handle.correlationIdStart">correlationIdStart</a> = <a href="#kafka.producer.async;DefaultEventHandler.correlationId" title="=&gt; java.util.concurrent.atomic.AtomicInteger">correlationId</a>.<span title="()Int">get</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="../../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Handling %d events&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.handle.events" title="Seq[kafka.producer.KeyedMessage[K,V]]">events</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span><span class="delimiter">)</span>
    while <span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.handle.remainingRetries" title="Int">remainingRetries</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.producer.async;DefaultEventHandler.handle.outstandingProduceRequests" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">outstandingProduceRequests</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#kafka.producer.async;DefaultEventHandler.handle.while$1" title="()Unit" class="delimiter">{</a>
      <a href="#kafka.producer.async;DefaultEventHandler.topicMetadataToRefresh" title="=&gt; scala.collection.mutable.Set[String]">topicMetadataToRefresh</a> <span title="(xs: scala.collection.TraversableOnce[String])DefaultEventHandler.this.topicMetadataToRefresh.type">++=</span> <a href="#kafka.producer.async;DefaultEventHandler.handle.outstandingProduceRequests" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">outstandingProduceRequests</a>.<span title="(f: kafka.producer.KeyedMessage[K,kafka.message.Message] =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]],String,scala.collection.TraversableOnce[String]])scala.collection.TraversableOnce[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.handle.$anonfun.x$1" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">_</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.topicMetadataRefreshInterval" title="=&gt; Int">topicMetadataRefreshInterval</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
          <a href="../../utils/Time.scala.html#kafka.utils.SystemTime" title="kafka.utils.SystemTime.type">SystemTime</a>.<a href="../../utils/Time.scala.html#kafka.utils.SystemTime.milliseconds" title="=&gt; Long">milliseconds</a> <span title="(x: Long)Long">-</span> <a href="#kafka.producer.async;DefaultEventHandler.lastTopicMetadataRefreshTime_=" title="=&gt; Long">lastTopicMetadataRefreshTime</a> <span title="(x: Int)Boolean">&gt;</span> <a href="#kafka.producer.async;DefaultEventHandler.topicMetadataRefreshInterval" title="=&gt; Int">topicMetadataRefreshInterval</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="../../utils/Utils.scala.html#kafka.utils.Utils" title="kafka.utils.Utils.type">Utils</a>.<a href="../../utils/Logging.scala.html#kafka.utils;Logging.swallowError" title="(action: =&gt; Unit)Unit">swallowError</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.brokerPartitionInfo" title="=&gt; kafka.producer.BrokerPartitionInfo">brokerPartitionInfo</a>.<a href="../BrokerPartitionInfo.scala.html#kafka.producer;BrokerPartitionInfo.updateInfo" title="(topics: Set[String], correlationId: Int)Unit">updateInfo</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.topicMetadataToRefresh" title="=&gt; scala.collection.mutable.Set[String]">topicMetadataToRefresh</a>.<span title="scala.collection.immutable.Set[String]">toSet</span>, <a href="#kafka.producer.async;DefaultEventHandler.correlationId" title="=&gt; java.util.concurrent.atomic.AtomicInteger">correlationId</a>.<span title="()Int">getAndIncrement</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#kafka.producer.async;DefaultEventHandler.sendPartitionPerTopicCache" title="=&gt; scala.collection.mutable.HashMap[String,Int]">sendPartitionPerTopicCache</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#kafka.producer.async;DefaultEventHandler.topicMetadataToRefresh" title="=&gt; scala.collection.mutable.Set[String]">topicMetadataToRefresh</a>.<span title="()Unit">clear</span>
        <a href="#kafka.producer.async;DefaultEventHandler.lastTopicMetadataRefreshTime_=" title="(x$1: Long)Unit">lastTopicMetadataRefreshTime</a> = <a href="../../utils/Time.scala.html#kafka.utils.SystemTime" title="kafka.utils.SystemTime.type">SystemTime</a>.<a href="../../utils/Time.scala.html#kafka.utils.SystemTime.milliseconds" title="=&gt; Long">milliseconds</a>
      <span class="delimiter">}</span>
      <a href="#kafka.producer.async;DefaultEventHandler.handle.outstandingProduceRequests" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">outstandingProduceRequests</a> = <a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData" title="(messages: Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]])Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">dispatchSerializedData</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.handle.outstandingProduceRequests" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">outstandingProduceRequests</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.handle.outstandingProduceRequests" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">outstandingProduceRequests</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="../../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Back off for %d ms before retrying send. Remaining retries = %d&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../ProducerConfig.scala.html#kafka.producer;ProducerConfig.retryBackoffMs" title="=&gt; Int">retryBackoffMs</a>, <a href="#kafka.producer.async;DefaultEventHandler.handle.remainingRetries" title="Int">remainingRetries</a><span title="(x: Int)Int">-</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="comment">// back off and update the topic metadata cache before attempting another send operation</span>
        <span title="Thread.type">Thread</span>.<span title="(x$1: Long)Unit">sleep</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../ProducerConfig.scala.html#kafka.producer;ProducerConfig.retryBackoffMs" title="=&gt; Long">retryBackoffMs</a><span class="delimiter">)</span>
        <span class="comment">// get topics of the outstanding produce requests and refresh metadata for those</span>
        <a href="../../utils/Utils.scala.html#kafka.utils.Utils" title="kafka.utils.Utils.type">Utils</a>.<a href="../../utils/Logging.scala.html#kafka.utils;Logging.swallowError" title="(action: =&gt; Unit)Unit">swallowError</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.brokerPartitionInfo" title="=&gt; kafka.producer.BrokerPartitionInfo">brokerPartitionInfo</a>.<a href="../BrokerPartitionInfo.scala.html#kafka.producer;BrokerPartitionInfo.updateInfo" title="(topics: Set[String], correlationId: Int)Unit">updateInfo</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.handle.outstandingProduceRequests" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">outstandingProduceRequests</a>.<span title="(f: kafka.producer.KeyedMessage[K,kafka.message.Message] =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]],String,Seq[String]])Seq[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.handle.$anonfun.x$2" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">_</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[String]">toSet</span>, <a href="#kafka.producer.async;DefaultEventHandler.correlationId" title="=&gt; java.util.concurrent.atomic.AtomicInteger">correlationId</a>.<span title="()Int">getAndIncrement</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#kafka.producer.async;DefaultEventHandler.sendPartitionPerTopicCache" title="=&gt; scala.collection.mutable.HashMap[String,Int]">sendPartitionPerTopicCache</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#kafka.producer.async;DefaultEventHandler.handle.remainingRetries" title="Int">remainingRetries</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
        <a href="#kafka.producer.async;DefaultEventHandler.producerStats" title="=&gt; kafka.producer.ProducerStats">producerStats</a>.<a href="../ProducerStats.scala.html#kafka.producer;ProducerStats.resendRate" title="=&gt; com.yammer.metrics.core.Meter">resendRate</a>.<span title="()Unit">mark</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    if<span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.handle.outstandingProduceRequests" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">outstandingProduceRequests</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.producer.async;DefaultEventHandler.producerStats" title="=&gt; kafka.producer.ProducerStats">producerStats</a>.<a href="../ProducerStats.scala.html#kafka.producer;ProducerStats.failedSendRate" title="=&gt; com.yammer.metrics.core.Meter">failedSendRate</a>.<span title="()Unit">mark</span><span class="delimiter">(</span><span class="delimiter">)</span>
      val <a title="Int" id="kafka.producer.async;DefaultEventHandler.handle.correlationIdEnd">correlationIdEnd</a> = <a href="#kafka.producer.async;DefaultEventHandler.correlationId" title="=&gt; java.util.concurrent.atomic.AtomicInteger">correlationId</a>.<span title="()Int">get</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="../../utils/Logging.scala.html#kafka.utils;Logging.error(1729dbc42f)" title="(msg: =&gt; String)Unit">error</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Failed to send requests for topics %s with correlation ids in [%d,%d]&quot;</span>
        .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.handle.outstandingProduceRequests" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">outstandingProduceRequests</a>.<span title="(f: kafka.producer.KeyedMessage[K,kafka.message.Message] =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]],String,Seq[String]])Seq[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.handle.$anonfun.x$3" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">_</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[String]">toSet</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>,
        <a href="#kafka.producer.async;DefaultEventHandler.handle.correlationIdStart" title="Int">correlationIdStart</a>, <a href="#kafka.producer.async;DefaultEventHandler.handle.correlationIdEnd" title="Int">correlationIdEnd</a><span title="(x: Int)Int">-</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
      throw new <a href="../../common/FailedToSendMessageException.scala.html#kafka.common;FailedToSendMessageException" title="kafka.common.FailedToSendMessageException">FailedToSendMessageException</a><span class="delimiter">(</span><span title="String(&quot;Failed to send messages after &quot;)" class="string">&quot;Failed to send messages after &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../ProducerConfig.scala.html#kafka.producer;ProducerConfig.messageSendMaxRetries" title="=&gt; Int">messageSendMaxRetries</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; tries.&quot;)" class="string">&quot; tries.&quot;</span>, null<span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  private def <a title="(messages: Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]])Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]" id="kafka.producer.async;DefaultEventHandler.dispatchSerializedData">dispatchSerializedData</a><span class="delimiter">(</span><a title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]" id="kafka.producer.async;DefaultEventHandler.dispatchSerializedData.messages">messages</a>: <span title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">Seq</span><span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">Seq</span><span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K, Message<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Option[scala.collection.Map[Int,scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]]]" id="kafka.producer.async;DefaultEventHandler.dispatchSerializedData.partitionedDataOpt">partitionedDataOpt</a> = <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate" title="(messages: Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]])Option[scala.collection.Map[Int,scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]]]">partitionAndCollate</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.messages" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">messages</a><span class="delimiter">)</span>
    <a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.partitionedDataOpt" title="Option[scala.collection.Map[Int,scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]]]">partitionedDataOpt</a> match <span class="delimiter">{</span>
      case Some<span class="delimiter">(</span><a title="scala.collection.Map[Int,scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]]" id="kafka.producer.async;DefaultEventHandler.dispatchSerializedData.partitionedData">partitionedData</a><span class="delimiter">)</span> =&gt;
        val <a title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]" id="kafka.producer.async;DefaultEventHandler.dispatchSerializedData.failedProduceRequests">failedProduceRequests</a> = new <span title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]">ArrayBuffer</span><span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">]</span>
        try <span class="delimiter">{</span>
          for <span class="delimiter">(</span><span class="delimiter">(</span><a title="Int" id="kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.brokerid">brokerid</a>, <a title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]" id="kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.messagesPerBrokerMap">messagesPerBrokerMap</a><span class="delimiter">)</span> &lt;- <a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.partitionedData" title="(f: ((Int, scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]])) =&gt; Unit)Unit">partitionedData</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            if <span class="delimiter">(</span><a href="../../utils/Logging.scala.html#kafka.utils;Logging.logger" title="=&gt; org.apache.log4j.Logger">logger</a>.<span title="()Boolean">isTraceEnabled</span><span class="delimiter">)</span>
              <a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.messagesPerBrokerMap" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">messagesPerBrokerMap</a>.<span title="(f: ((kafka.common.TopicAndPartition, Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]])) =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a title="(kafka.common.TopicAndPartition, Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]])" id="kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.$anonfun.partitionAndEvent">partitionAndEvent</a> =&gt;
                <a href="../../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Handling event for Topic: %s, Broker: %d, Partitions: %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.$anonfun.partitionAndEvent" title="(kafka.common.TopicAndPartition, Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]])">partitionAndEvent</a>.<span title="=&gt; kafka.common.TopicAndPartition">_1</span>, <a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.brokerid" title="Int">brokerid</a>, <a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.$anonfun.partitionAndEvent" title="(kafka.common.TopicAndPartition, Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]])">partitionAndEvent</a>.<span title="=&gt; Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">_2</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            val <a title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]" id="kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.messageSetPerBroker">messageSetPerBroker</a> = <a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet" title="(messagesPerTopicAndPartition: scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]])scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">groupMessagesToSet</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.messagesPerBrokerMap" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">messagesPerBrokerMap</a><span class="delimiter">)</span>

            val <a title="Seq[kafka.common.TopicAndPartition]" id="kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.failedTopicPartitions">failedTopicPartitions</a> = <a href="#kafka.producer.async;DefaultEventHandler.send" title="(brokerId: Int, messagesPerTopic: scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet])Seq[kafka.common.TopicAndPartition]">send</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.brokerid" title="Int">brokerid</a>, <a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.messageSetPerBroker" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">messageSetPerBroker</a><span class="delimiter">)</span>
            <a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.failedTopicPartitions" title="Seq[kafka.common.TopicAndPartition]">failedTopicPartitions</a>.<span title="(f: kafka.common.TopicAndPartition =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.$anonfun.topicPartition">topicPartition</a> =&gt; <span class="delimiter">{</span>
              <a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.messagesPerBrokerMap" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">messagesPerBrokerMap</a>.<span title="(key: kafka.common.TopicAndPartition)Option[Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">get</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.$anonfun.topicPartition" title="kafka.common.TopicAndPartition">topicPartition</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
                case Some<span class="delimiter">(</span><a title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]" id="kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.$anonfun.data">data</a><span class="delimiter">)</span> =&gt; <a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.failedProduceRequests" title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]">failedProduceRequests</a>.<span title="(xs: scala.collection.TraversableOnce[kafka.producer.KeyedMessage[K,kafka.message.Message]])Unit">appendAll</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.$anonfun.$anonfun.data" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">data</a><span class="delimiter">)</span>
                case <span title="None.type">None</span> =&gt; <span class="comment">// nothing</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span> catch <span class="delimiter">{</span>
          case <a title="Throwable" id="kafka.producer.async;DefaultEventHandler.dispatchSerializedData.t">t</a>: <span title="Throwable">Throwable</span> =&gt; <a href="../../utils/Logging.scala.html#kafka.utils;Logging.error(cfd112d89b)" title="(msg: =&gt; String, e: =&gt; Throwable)Unit">error</a><span class="delimiter">(</span><span title="String(&quot;Failed to send messages&quot;)" class="string">&quot;Failed to send messages&quot;</span>, <a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.t" title="Throwable">t</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.failedProduceRequests" title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]">failedProduceRequests</a>
      case <span title="None.type">None</span> =&gt; <span class="comment">// all produce requests failed</span>
        <a href="#kafka.producer.async;DefaultEventHandler.dispatchSerializedData.messages" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">messages</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(events: Seq[kafka.producer.KeyedMessage[K,V]])Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]" id="kafka.producer.async;DefaultEventHandler.serialize">serialize</a><span class="delimiter">(</span><a title="Seq[kafka.producer.KeyedMessage[K,V]]" id="kafka.producer.async;DefaultEventHandler.serialize.events">events</a>: <span title="Seq[kafka.producer.KeyedMessage[K,V]]">Seq</span><span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">Seq</span><span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]" id="kafka.producer.async;DefaultEventHandler.serialize.serializedMessages">serializedMessages</a> = new <span title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]">ArrayBuffer</span><span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.serialize.events" title="Seq[kafka.producer.KeyedMessage[K,V]]">events</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>
    <a href="#kafka.producer.async;DefaultEventHandler.serialize.events" title="Seq[kafka.producer.KeyedMessage[K,V]]">events</a>.<span title="(f: kafka.producer.KeyedMessage[K,V] =&gt; Any)Unit">foreach</span><span class="delimiter">{</span><a title="kafka.producer.KeyedMessage[K,V]" id="kafka.producer.async;DefaultEventHandler.serialize.$anonfun.e">e</a> =&gt;
      try <span class="delimiter">{</span>
        if<span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.serialize.$anonfun.e" title="kafka.producer.KeyedMessage[K,V]">e</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.hasKey" title="=&gt; Boolean">hasKey</a><span class="delimiter">)</span>
          <a href="#kafka.producer.async;DefaultEventHandler.serialize.serializedMessages" title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]">serializedMessages</a> <span title="(elem: kafka.producer.KeyedMessage[K,kafka.message.Message])serializedMessages.type">+=</span> new <a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">KeyedMessage</a><span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">(</span>topic = <a href="#kafka.producer.async;DefaultEventHandler.serialize.$anonfun.e" title="kafka.producer.KeyedMessage[K,V]">e</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.topic" title="=&gt; String">topic</a>, key = <a href="#kafka.producer.async;DefaultEventHandler.serialize.$anonfun.e" title="kafka.producer.KeyedMessage[K,V]">e</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.key" title="=&gt; K">key</a>, partKey = <a href="#kafka.producer.async;DefaultEventHandler.serialize.$anonfun.e" title="kafka.producer.KeyedMessage[K,V]">e</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.partKey" title="=&gt; Any">partKey</a>, message = new <a href="../../message/Message.scala.html#kafka.message;Message" title="kafka.message.Message">Message</a><span class="delimiter">(</span>key = <a href="#kafka.producer.async;DefaultEventHandler.keyEncoder" title="=&gt; kafka.serializer.Encoder[K]">keyEncoder</a>.<a href="../../serializer/Encoder.scala.html#kafka.serializer;Encoder.toBytes" title="(t: K)Array[Byte]">toBytes</a><a title="Array[Byte]" id="kafka.producer.async;DefaultEventHandler.serialize.$anonfun.x$11" class="delimiter">(</a><a href="#kafka.producer.async;DefaultEventHandler.serialize.$anonfun.e" title="kafka.producer.KeyedMessage[K,V]">e</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.key" title="=&gt; K">key</a><span class="delimiter">)</span>, bytes = <a href="#kafka.producer.async;DefaultEventHandler.encoder" title="=&gt; kafka.serializer.Encoder[V]">encoder</a>.<a href="../../serializer/Encoder.scala.html#kafka.serializer;Encoder.toBytes" title="(t: V)Array[Byte]">toBytes</a><a title="Array[Byte]" id="kafka.producer.async;DefaultEventHandler.serialize.$anonfun.x$12" class="delimiter">(</a><a href="#kafka.producer.async;DefaultEventHandler.serialize.$anonfun.e" title="kafka.producer.KeyedMessage[K,V]">e</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.message" title="=&gt; V">message</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        else
          <a href="#kafka.producer.async;DefaultEventHandler.serialize.serializedMessages" title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]">serializedMessages</a> <span title="(elem: kafka.producer.KeyedMessage[K,kafka.message.Message])serializedMessages.type">+=</span> new <a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">KeyedMessage</a><span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">(</span>topic = <a href="#kafka.producer.async;DefaultEventHandler.serialize.$anonfun.e" title="kafka.producer.KeyedMessage[K,V]">e</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.topic" title="=&gt; String">topic</a>, key = <a href="#kafka.producer.async;DefaultEventHandler.serialize.$anonfun.e" title="kafka.producer.KeyedMessage[K,V]">e</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.key" title="=&gt; K">key</a>, partKey = <a href="#kafka.producer.async;DefaultEventHandler.serialize.$anonfun.e" title="kafka.producer.KeyedMessage[K,V]">e</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.partKey" title="=&gt; Any">partKey</a>, message = new <a href="../../message/Message.scala.html#kafka.message;Message" title="kafka.message.Message">Message</a><span class="delimiter">(</span>bytes = <a href="#kafka.producer.async;DefaultEventHandler.encoder" title="=&gt; kafka.serializer.Encoder[V]">encoder</a>.<a href="../../serializer/Encoder.scala.html#kafka.serializer;Encoder.toBytes" title="(t: V)Array[Byte]">toBytes</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.serialize.$anonfun.e" title="kafka.producer.KeyedMessage[K,V]">e</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.message" title="=&gt; V">message</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> catch <span class="delimiter">{</span>
        case <a title="Throwable" id="kafka.producer.async;DefaultEventHandler.serialize.$anonfun.t">t</a>: <span title="Throwable">Throwable</span> =&gt;
          <a href="#kafka.producer.async;DefaultEventHandler.producerStats" title="=&gt; kafka.producer.ProducerStats">producerStats</a>.<a href="../ProducerStats.scala.html#kafka.producer;ProducerStats.serializationErrorRate" title="=&gt; com.yammer.metrics.core.Meter">serializationErrorRate</a>.<span title="()Unit">mark</span><span class="delimiter">(</span><span class="delimiter">)</span>
          if <span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.isSync" title="=&gt; Boolean">isSync</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            throw <a href="#kafka.producer.async;DefaultEventHandler.serialize.$anonfun.t" title="Throwable">t</a>
          <span class="delimiter">}</span> else <span class="delimiter">{</span>
            <span class="comment">// currently, if in async mode, we just log the serialization error. We need to revisit</span>
            <span class="comment">// this when doing kafka-496</span>
            <a href="../../utils/Logging.scala.html#kafka.utils;Logging.error(cfd112d89b)" title="(msg: =&gt; String, e: =&gt; Throwable)Unit">error</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Error serializing message for topic %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.serialize.$anonfun.e" title="kafka.producer.KeyedMessage[K,V]">e</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>, <a href="#kafka.producer.async;DefaultEventHandler.serialize.$anonfun.t" title="Throwable">t</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#kafka.producer.async;DefaultEventHandler.serialize.serializedMessages" title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]">serializedMessages</a>
  <span class="delimiter">}</span>

  def <a title="(messages: Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]])Option[scala.collection.Map[Int,scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]]]" id="kafka.producer.async;DefaultEventHandler.partitionAndCollate">partitionAndCollate</a><span class="delimiter">(</span><a title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]" id="kafka.producer.async;DefaultEventHandler.partitionAndCollate.messages">messages</a>: <span title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">Seq</span><span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[scala.collection.Map[Int,scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]]]">Option</span><span class="delimiter">[</span>Map<span class="delimiter">[</span>Int, collection.mutable.Map<span class="delimiter">[</span>TopicAndPartition, Seq<span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scala.collection.mutable.HashMap[Int,scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]]" id="kafka.producer.async;DefaultEventHandler.partitionAndCollate.ret">ret</a> = new <span title="scala.collection.mutable.HashMap[Int,scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]]">HashMap</span><span class="delimiter">[</span>Int, collection.mutable.Map<span class="delimiter">[</span>TopicAndPartition, Seq<span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
    try <span class="delimiter">{</span>
      for <span class="delimiter">(</span><a title="kafka.producer.KeyedMessage[K,kafka.message.Message]" id="kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.message">message</a> &lt;- <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.messages" title="(f: kafka.producer.KeyedMessage[K,kafka.message.Message] =&gt; Unit)Unit">messages</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="Seq[kafka.producer.PartitionAndLeader]" id="kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.topicPartitionsList">topicPartitionsList</a> = <a href="#kafka.producer.async;DefaultEventHandler.getPartitionListForTopic" title="(m: kafka.producer.KeyedMessage[K,kafka.message.Message])Seq[kafka.producer.PartitionAndLeader]">getPartitionListForTopic</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.message" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">message</a><span class="delimiter">)</span>
        val <a title="Int" id="kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.partitionIndex">partitionIndex</a> = <a href="#kafka.producer.async;DefaultEventHandler.getPartition" title="(topic: String, key: Any, topicPartitionList: Seq[kafka.producer.PartitionAndLeader])Int">getPartition</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.message" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">message</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.topic" title="=&gt; String">topic</a>, <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.message" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">message</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.partitionKey" title="=&gt; Any">partitionKey</a>, <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.topicPartitionsList" title="Seq[kafka.producer.PartitionAndLeader]">topicPartitionsList</a><span class="delimiter">)</span>
        val <a title="kafka.producer.PartitionAndLeader" id="kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.brokerPartition">brokerPartition</a> = <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.topicPartitionsList" title="(idx: Int)kafka.producer.PartitionAndLeader">topicPartitionsList</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.partitionIndex" title="Int">partitionIndex</a><span class="delimiter">)</span>

        <span class="comment">// postpone the failure until the send operation, so that requests for other brokers are handled correctly</span>
        val <a title="Int" id="kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.leaderBrokerId">leaderBrokerId</a> = <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.brokerPartition" title="kafka.producer.PartitionAndLeader">brokerPartition</a>.<a href="../BrokerPartitionInfo.scala.html#kafka.producer;PartitionAndLeader.leaderBrokerIdOpt" title="=&gt; Option[Int]">leaderBrokerIdOpt</a>.<span title="(default: =&gt; Int)Int">getOrElse</span><span class="delimiter">(</span>-<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span>

        var <a title="scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]" id="kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.dataPerBroker">dataPerBroker</a>: <span title="scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">HashMap</span><span class="delimiter">[</span>TopicAndPartition, Seq<span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = null
        <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.ret" title="scala.collection.mutable.HashMap[Int,scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]]">ret</a>.<span title="(key: Int)Option[scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]]">get</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.leaderBrokerId" title="Int">leaderBrokerId</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><span title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">element</span><span class="delimiter">)</span> =&gt;
            <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.dataPerBroker" title="scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">dataPerBroker</a> = <span title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">element</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]" class="delimiter">[</span><span title="scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">HashMap</span><span class="delimiter">[</span>TopicAndPartition, Seq<span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
          case <span title="None.type">None</span> =&gt;
            <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.dataPerBroker" title="scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">dataPerBroker</a> = new <span title="scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">HashMap</span><span class="delimiter">[</span>TopicAndPartition, Seq<span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
            <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.ret" title="scala.collection.mutable.HashMap[Int,scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]]">ret</a>.<span title="(key: Int, value: scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]])Option[scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]]">put</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.leaderBrokerId" title="Int">leaderBrokerId</a>, <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.dataPerBroker" title="scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">dataPerBroker</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        val <a title="kafka.common.TopicAndPartition" id="kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.topicAndPartition">topicAndPartition</a> = <a href="../../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.message" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">message</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.topic" title="=&gt; String">topic</a>, <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.brokerPartition" title="kafka.producer.PartitionAndLeader">brokerPartition</a>.<a href="../BrokerPartitionInfo.scala.html#kafka.producer;PartitionAndLeader.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span>
        var <a title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]" id="kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.dataPerTopicPartition">dataPerTopicPartition</a>: <span title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]">ArrayBuffer</span><span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">]</span> = null
        <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.dataPerBroker" title="scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">dataPerBroker</a>.<span title="(key: kafka.common.TopicAndPartition)Option[Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">get</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><span title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">element</span><span class="delimiter">)</span> =&gt;
            <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.dataPerTopicPartition" title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]">dataPerTopicPartition</a> = <span title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">element</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]" class="delimiter">[</span><span title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]">ArrayBuffer</span><span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
          case <span title="None.type">None</span> =&gt;
            <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.dataPerTopicPartition" title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]">dataPerTopicPartition</a> = new <span title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]">ArrayBuffer</span><span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">]</span>
            <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.dataPerBroker" title="scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">dataPerBroker</a>.<span title="(key: kafka.common.TopicAndPartition, value: Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]])Option[Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">put</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.dataPerTopicPartition" title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]">dataPerTopicPartition</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.dataPerTopicPartition" title="scala.collection.mutable.ArrayBuffer[kafka.producer.KeyedMessage[K,kafka.message.Message]]">dataPerTopicPartition</a>.<span title="(elems: kafka.producer.KeyedMessage[K,kafka.message.Message]*)Unit">append</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.$anonfun.message" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">message</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span title="(x: scala.collection.mutable.HashMap[Int,scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]])Some[scala.collection.mutable.HashMap[Int,scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]]]">Some</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.ret" title="scala.collection.mutable.HashMap[Int,scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]]">ret</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>catch <span class="delimiter">{</span>    <span class="comment">// Swallow recoverable exceptions and return None so that they can be retried.</span>
      case <a title="kafka.common.UnknownTopicOrPartitionException" id="kafka.producer.async;DefaultEventHandler.partitionAndCollate.ute">ute</a>: <a href="../../common/UnknownTopicOrPartitionException.scala.html#kafka.common;UnknownTopicOrPartitionException" title="kafka.common.UnknownTopicOrPartitionException">UnknownTopicOrPartitionException</a> =&gt; <a href="../../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="String(&quot;Failed to collate messages by topic,partition due to: &quot;)" class="string">&quot;Failed to collate messages by topic,partition due to: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.ute" title="kafka.common.UnknownTopicOrPartitionException">ute</a>.<span title="()String">getMessage</span><span class="delimiter">)</span>; <span title="None.type">None</span>
      case <a title="kafka.common.LeaderNotAvailableException" id="kafka.producer.async;DefaultEventHandler.partitionAndCollate.lnae">lnae</a>: <a href="../../common/LeaderNotAvailableException.scala.html#kafka.common;LeaderNotAvailableException" title="kafka.common.LeaderNotAvailableException">LeaderNotAvailableException</a> =&gt; <a href="../../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="String(&quot;Failed to collate messages by topic,partition due to: &quot;)" class="string">&quot;Failed to collate messages by topic,partition due to: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.lnae" title="kafka.common.LeaderNotAvailableException">lnae</a>.<span title="()String">getMessage</span><span class="delimiter">)</span>; <span title="None.type">None</span>
      case <a title="Throwable" id="kafka.producer.async;DefaultEventHandler.partitionAndCollate.oe">oe</a>: <span title="Throwable">Throwable</span> =&gt; <a href="../../utils/Logging.scala.html#kafka.utils;Logging.error(1729dbc42f)" title="(msg: =&gt; String)Unit">error</a><span class="delimiter">(</span><span title="String(&quot;Failed to collate messages by topic, partition due to: &quot;)" class="string">&quot;Failed to collate messages by topic, partition due to: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.producer.async;DefaultEventHandler.partitionAndCollate.oe" title="Throwable">oe</a>.<span title="()String">getMessage</span><span class="delimiter">)</span>; <span title="None.type">None</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  private def <a title="(m: kafka.producer.KeyedMessage[K,kafka.message.Message])Seq[kafka.producer.PartitionAndLeader]" id="kafka.producer.async;DefaultEventHandler.getPartitionListForTopic">getPartitionListForTopic</a><span class="delimiter">(</span><a title="kafka.producer.KeyedMessage[K,kafka.message.Message]" id="kafka.producer.async;DefaultEventHandler.getPartitionListForTopic.m">m</a>: <a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">KeyedMessage</a><span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[kafka.producer.PartitionAndLeader]">Seq</span><span class="delimiter">[</span>PartitionAndLeader<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Seq[kafka.producer.PartitionAndLeader]" id="kafka.producer.async;DefaultEventHandler.getPartitionListForTopic.topicPartitionsList">topicPartitionsList</a> = <a href="#kafka.producer.async;DefaultEventHandler.brokerPartitionInfo" title="=&gt; kafka.producer.BrokerPartitionInfo">brokerPartitionInfo</a>.<a href="../BrokerPartitionInfo.scala.html#kafka.producer;BrokerPartitionInfo.getBrokerPartitionInfo" title="(topic: String, correlationId: Int)Seq[kafka.producer.PartitionAndLeader]">getBrokerPartitionInfo</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.getPartitionListForTopic.m" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">m</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.topic" title="=&gt; String">topic</a>, <a href="#kafka.producer.async;DefaultEventHandler.correlationId" title="=&gt; java.util.concurrent.atomic.AtomicInteger">correlationId</a>.<span title="()Int">getAndIncrement</span><span class="delimiter">)</span>
    <a href="../../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Broker partitions registered for topic: %s are %s&quot;</span>
      .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.getPartitionListForTopic.m" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">m</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.topic" title="=&gt; String">topic</a>, <a href="#kafka.producer.async;DefaultEventHandler.getPartitionListForTopic.topicPartitionsList" title="Seq[kafka.producer.PartitionAndLeader]">topicPartitionsList</a>.<span title="(f: kafka.producer.PartitionAndLeader =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.producer.PartitionAndLeader],Int,Seq[Int]])Seq[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,Int,Seq[Int]]" class="delimiter">(</span><a title="kafka.producer.PartitionAndLeader" id="kafka.producer.async;DefaultEventHandler.getPartitionListForTopic.$anonfun.p">p</a> =&gt; <a href="#kafka.producer.async;DefaultEventHandler.getPartitionListForTopic.$anonfun.p" title="kafka.producer.PartitionAndLeader">p</a>.<a href="../BrokerPartitionInfo.scala.html#kafka.producer;PartitionAndLeader.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    val <a title="Int" id="kafka.producer.async;DefaultEventHandler.getPartitionListForTopic.totalNumPartitions">totalNumPartitions</a> = <a href="#kafka.producer.async;DefaultEventHandler.getPartitionListForTopic.topicPartitionsList" title="Seq[kafka.producer.PartitionAndLeader]">topicPartitionsList</a>.<span title="=&gt; Int">length</span>
    if<span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.getPartitionListForTopic.totalNumPartitions" title="Int">totalNumPartitions</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      throw new <a href="../../common/NoBrokersForPartitionException.scala.html#kafka.common;NoBrokersForPartitionException" title="kafka.common.NoBrokersForPartitionException">NoBrokersForPartitionException</a><span class="delimiter">(</span><span title="String(&quot;Partition key = &quot;)" class="string">&quot;Partition key = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.producer.async;DefaultEventHandler.getPartitionListForTopic.m" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">m</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.key" title="=&gt; K">key</a><span class="delimiter">)</span>
    <a href="#kafka.producer.async;DefaultEventHandler.getPartitionListForTopic.topicPartitionsList" title="Seq[kafka.producer.PartitionAndLeader]">topicPartitionsList</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Retrieves the partition id and throws an UnknownTopicOrPartitionException if
   * the value of partition is not between 0 and numPartitions-1
   * @param topic The topic
   * @param key the partition key
   * @param topicPartitionList the list of available partitions
   * @return the partition id
   */</span>
  private def <a title="(topic: String, key: Any, topicPartitionList: Seq[kafka.producer.PartitionAndLeader])Int" id="kafka.producer.async;DefaultEventHandler.getPartition">getPartition</a><span class="delimiter">(</span><a title="String" id="kafka.producer.async;DefaultEventHandler.getPartition.topic">topic</a>: <span title="String">String</span>, <a title="Any" id="kafka.producer.async;DefaultEventHandler.getPartition.key">key</a>: <span title="Any">Any</span>, <a title="Seq[kafka.producer.PartitionAndLeader]" id="kafka.producer.async;DefaultEventHandler.getPartition.topicPartitionList">topicPartitionList</a>: <span title="Seq[kafka.producer.PartitionAndLeader]">Seq</span><span class="delimiter">[</span>PartitionAndLeader<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
    val <a title="Int" id="kafka.producer.async;DefaultEventHandler.getPartition.numPartitions">numPartitions</a> = <a href="#kafka.producer.async;DefaultEventHandler.getPartition.topicPartitionList" title="Seq[kafka.producer.PartitionAndLeader]">topicPartitionList</a>.<span title="=&gt; Int">size</span>
    if<span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.getPartition.numPartitions" title="Int">numPartitions</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      throw new <a href="../../common/UnknownTopicOrPartitionException.scala.html#kafka.common;UnknownTopicOrPartitionException" title="kafka.common.UnknownTopicOrPartitionException">UnknownTopicOrPartitionException</a><span class="delimiter">(</span><span title="String(&quot;Topic &quot;)" class="string">&quot;Topic &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.producer.async;DefaultEventHandler.getPartition.topic" title="String">topic</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; doesn\'t exist&quot;)" class="string">&quot; doesn't exist&quot;</span><span class="delimiter">)</span>
    val <a title="Int" id="kafka.producer.async;DefaultEventHandler.getPartition.partition">partition</a> =
      if<span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.getPartition.key" title="Any">key</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// If the key is null, we don't really need a partitioner</span>
        <span class="comment">// So we look up in the send partition cache for the topic to decide the target partition</span>
        val <a title="Option[Int]" id="kafka.producer.async;DefaultEventHandler.getPartition.partition.id">id</a> = <a href="#kafka.producer.async;DefaultEventHandler.sendPartitionPerTopicCache" title="=&gt; scala.collection.mutable.HashMap[String,Int]">sendPartitionPerTopicCache</a>.<span title="(key: String)Option[Int]">get</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.getPartition.topic" title="String">topic</a><span class="delimiter">)</span>
        <a href="#kafka.producer.async;DefaultEventHandler.getPartition.partition.id" title="Option[Int]">id</a> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><span title="Int">partitionId</span><span class="delimiter">)</span> =&gt;
            <span class="comment">// directly return the partitionId without checking availability of the leader,</span>
            <span class="comment">// since we want to postpone the failure until the send operation anyways</span>
            <span title="Int">partitionId</span>
          case <span title="None.type">None</span> =&gt;
            val <a title="Seq[kafka.producer.PartitionAndLeader]" id="kafka.producer.async;DefaultEventHandler.getPartition.partition.availablePartitions">availablePartitions</a> = <a href="#kafka.producer.async;DefaultEventHandler.getPartition.topicPartitionList" title="Seq[kafka.producer.PartitionAndLeader]">topicPartitionList</a>.<span title="(p: kafka.producer.PartitionAndLeader =&gt; Boolean)Seq[kafka.producer.PartitionAndLeader]">filter</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.getPartition.partition.availablePartitions.$anonfun.x$5" title="kafka.producer.PartitionAndLeader">_</a>.<a href="../BrokerPartitionInfo.scala.html#kafka.producer;PartitionAndLeader.leaderBrokerIdOpt" title="=&gt; Option[Int]">leaderBrokerIdOpt</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span>
            if <span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.getPartition.partition.availablePartitions" title="Seq[kafka.producer.PartitionAndLeader]">availablePartitions</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
              throw new <a href="../../common/LeaderNotAvailableException.scala.html#kafka.common;LeaderNotAvailableException" title="kafka.common.LeaderNotAvailableException">LeaderNotAvailableException</a><span class="delimiter">(</span><span title="String(&quot;No leader for any partition in topic &quot;)" class="string">&quot;No leader for any partition in topic &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.producer.async;DefaultEventHandler.getPartition.topic" title="String">topic</a><span class="delimiter">)</span>
            val index = <a href="../../utils/Utils.scala.html#kafka.utils.Utils" title="kafka.utils.Utils.type">Utils</a>.<a href="../../utils/Utils.scala.html#kafka.utils.Utils.abs" title="(n: Int)Int">abs</a><span class="delimiter">(</span><span title="scala.util.Random.type">Random</span>.<span title="()Int">nextInt</span><span class="delimiter">)</span> <a title="Int" id="kafka.producer.async;DefaultEventHandler.getPartition.partition.index">%</a> <a href="#kafka.producer.async;DefaultEventHandler.getPartition.partition.availablePartitions" title="Seq[kafka.producer.PartitionAndLeader]">availablePartitions</a>.<span title="=&gt; Int">size</span>
            val <span title="Int">partitionId</span> = <a href="#kafka.producer.async;DefaultEventHandler.getPartition.partition.availablePartitions" title="(idx: Int)kafka.producer.PartitionAndLeader">availablePartitions</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.getPartition.partition.index" title="Int">index</a><span class="delimiter">)</span>.<a href="../BrokerPartitionInfo.scala.html#kafka.producer;PartitionAndLeader.partitionId" title="=&gt; Int">partitionId</a>
            <a href="#kafka.producer.async;DefaultEventHandler.sendPartitionPerTopicCache" title="=&gt; scala.collection.mutable.HashMap[String,Int]">sendPartitionPerTopicCache</a>.<span title="(key: String, value: Int)Option[Int]">put</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.getPartition.topic" title="String">topic</a>, <span title="Int">partitionId</span><span class="delimiter">)</span>
            <span title="Int">partitionId</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> else
        <a href="#kafka.producer.async;DefaultEventHandler.partitioner" title="=&gt; kafka.producer.Partitioner">partitioner</a>.<a href="../Partitioner.scala.html#kafka.producer;Partitioner.partition" title="(key: Any, numPartitions: Int)Int">partition</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.getPartition.key" title="Any">key</a>, <a href="#kafka.producer.async;DefaultEventHandler.getPartition.numPartitions" title="Int">numPartitions</a><span class="delimiter">)</span>
    if<span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.getPartition.partition" title="Int">partition</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#kafka.producer.async;DefaultEventHandler.getPartition.partition" title="Int">partition</a> <span title="(x: Int)Boolean">&gt;=</span> <a href="#kafka.producer.async;DefaultEventHandler.getPartition.numPartitions" title="Int">numPartitions</a><span class="delimiter">)</span>
      throw new <a href="../../common/UnknownTopicOrPartitionException.scala.html#kafka.common;UnknownTopicOrPartitionException" title="kafka.common.UnknownTopicOrPartitionException">UnknownTopicOrPartitionException</a><span class="delimiter">(</span><span title="String(&quot;Invalid partition id: &quot;)" class="string">&quot;Invalid partition id: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.producer.async;DefaultEventHandler.getPartition.partition" title="Int">partition</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; for topic &quot;)" class="string">&quot; for topic &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.producer.async;DefaultEventHandler.getPartition.topic" title="String">topic</a> <span title="(x$1: Any)String">+</span>
        <span title="String(&quot;; Valid values are in the inclusive range of [0, &quot;)" class="string">&quot;; Valid values are in the inclusive range of [0, &quot;</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.getPartition.numPartitions" title="Int">numPartitions</a><span title="(x: Int)Int">-</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
    <a href="../../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Assigning message of topic %s and key %s to a selected partition %d&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.getPartition.topic" title="String">topic</a>, if <span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.getPartition.key" title="Any">key</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span> <span title="String(&quot;[none]&quot;)" class="string">&quot;[none]&quot;</span> else <a href="#kafka.producer.async;DefaultEventHandler.getPartition.key" title="Any">key</a>.<span title="()String">toString</span>, <a href="#kafka.producer.async;DefaultEventHandler.getPartition.partition" title="Int">partition</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.producer.async;DefaultEventHandler.getPartition.partition" title="Int">partition</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Constructs and sends the produce request based on a map from (topic, partition) -&gt; messages
   *
   * @param brokerId the broker that will receive the request
   * @param messagesPerTopic the messages as a map from (topic, partition) -&gt; messages
   * @return the set (topic, partitions) messages which incurred an error sending or processing
   */</span>
  private def <a title="(brokerId: Int, messagesPerTopic: scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet])Seq[kafka.common.TopicAndPartition]" id="kafka.producer.async;DefaultEventHandler.send">send</a><span class="delimiter">(</span><a title="Int" id="kafka.producer.async;DefaultEventHandler.send.brokerId">brokerId</a>: <span title="Int">Int</span>, <a title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]" id="kafka.producer.async;DefaultEventHandler.send.messagesPerTopic">messagesPerTopic</a>: collection.mutable.<span title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">Map</span><span class="delimiter">[</span>TopicAndPartition, ByteBufferMessageSet<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    if<span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.brokerId" title="Int">brokerId</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Failed to send data since partitions %s don't have a leader&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.messagesPerTopic" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">messagesPerTopic</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.message.ByteBufferMessageSet)) =&gt; kafka.common.TopicAndPartition)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet],kafka.common.TopicAndPartition,scala.collection.mutable.Iterable[kafka.common.TopicAndPartition]])scala.collection.mutable.Iterable[kafka.common.TopicAndPartition]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.mutable.Iterable.Coll,kafka.common.TopicAndPartition,scala.collection.mutable.Iterable[kafka.common.TopicAndPartition]]" class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.$anonfun.x$6" title="(kafka.common.TopicAndPartition, kafka.message.ByteBufferMessageSet)">_</a>.<span title="=&gt; kafka.common.TopicAndPartition">_1</span><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.producer.async;DefaultEventHandler.send.messagesPerTopic" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">messagesPerTopic</a>.<span title="=&gt; Iterable[kafka.common.TopicAndPartition]">keys</span>.<span title="=&gt; Seq[kafka.common.TopicAndPartition]">toSeq</span>
    <span class="delimiter">}</span> else if<span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.messagesPerTopic" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">messagesPerTopic</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="Int" id="kafka.producer.async;DefaultEventHandler.send.currentCorrelationId">currentCorrelationId</a> = <a href="#kafka.producer.async;DefaultEventHandler.correlationId" title="=&gt; java.util.concurrent.atomic.AtomicInteger">correlationId</a>.<span title="()Int">getAndIncrement</span>
      val <a title="kafka.api.ProducerRequest" id="kafka.producer.async;DefaultEventHandler.send.producerRequest">producerRequest</a> = new <a href="../../api/ProducerRequest.scala.html#kafka.api;ProducerRequest" title="kafka.api.ProducerRequest">ProducerRequest</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.currentCorrelationId" title="Int">currentCorrelationId</a>, <a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../SyncProducerConfig.scala.html#kafka.producer;SyncProducerConfigShared.clientId" title="=&gt; String">clientId</a>, <a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../SyncProducerConfig.scala.html#kafka.producer;SyncProducerConfigShared.requestRequiredAcks" title="=&gt; Short">requestRequiredAcks</a>,
        <a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../SyncProducerConfig.scala.html#kafka.producer;SyncProducerConfigShared.requestTimeoutMs" title="=&gt; Int">requestTimeoutMs</a>, <a href="#kafka.producer.async;DefaultEventHandler.send.messagesPerTopic" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">messagesPerTopic</a><span class="delimiter">)</span>
      var <a title="Seq[kafka.common.TopicAndPartition]" id="kafka.producer.async;DefaultEventHandler.send.failedTopicPartitions">failedTopicPartitions</a> = <span title="scala.collection.Seq.type">Seq</span>.<span title="[A]=&gt; Seq[A]">empty</span><span title="Seq[kafka.common.TopicAndPartition]" class="delimiter">[</span><a href="../../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">]</span>
      try <span class="delimiter">{</span>
        val <a title="kafka.producer.SyncProducer" id="kafka.producer.async;DefaultEventHandler.send.syncProducer">syncProducer</a> = <a href="#kafka.producer.async;DefaultEventHandler.producerPool" title="=&gt; kafka.producer.ProducerPool">producerPool</a>.<a href="../ProducerPool.scala.html#kafka.producer;ProducerPool.getProducer" title="(brokerId: Int)kafka.producer.SyncProducer">getProducer</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.brokerId" title="Int">brokerId</a><span class="delimiter">)</span>
        <a href="../../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Producer sending messages with correlation id %d for topics %s to broker %d on %s:%d&quot;</span>
          .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.currentCorrelationId" title="Int">currentCorrelationId</a>, <a href="#kafka.producer.async;DefaultEventHandler.send.messagesPerTopic" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">messagesPerTopic</a>.<span title="=&gt; scala.collection.Set[kafka.common.TopicAndPartition]">keySet</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>, <a href="#kafka.producer.async;DefaultEventHandler.send.brokerId" title="Int">brokerId</a>, <a href="#kafka.producer.async;DefaultEventHandler.send.syncProducer" title="kafka.producer.SyncProducer">syncProducer</a>.<a href="../SyncProducer.scala.html#kafka.producer;SyncProducer.config" title="=&gt; kafka.producer.SyncProducerConfig">config</a>.<a href="../SyncProducerConfig.scala.html#kafka.producer;SyncProducerConfig.host" title="=&gt; String">host</a>, <a href="#kafka.producer.async;DefaultEventHandler.send.syncProducer" title="kafka.producer.SyncProducer">syncProducer</a>.<a href="../SyncProducer.scala.html#kafka.producer;SyncProducer.config" title="=&gt; kafka.producer.SyncProducerConfig">config</a>.<a href="../SyncProducerConfig.scala.html#kafka.producer;SyncProducerConfig.port" title="=&gt; Int">port</a><span class="delimiter">)</span><span class="delimiter">)</span>
        val <a title="kafka.api.ProducerResponse" id="kafka.producer.async;DefaultEventHandler.send.response">response</a> = <a href="#kafka.producer.async;DefaultEventHandler.send.syncProducer" title="kafka.producer.SyncProducer">syncProducer</a>.<a href="../SyncProducer.scala.html#kafka.producer;SyncProducer.send(1b2624f0ad)" title="(producerRequest: kafka.api.ProducerRequest)kafka.api.ProducerResponse">send</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.producerRequest" title="kafka.api.ProducerRequest">producerRequest</a><span class="delimiter">)</span>
        <a href="../../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Producer sent messages with correlation id %d for topics %s to broker %d on %s:%d&quot;</span>
          .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.currentCorrelationId" title="Int">currentCorrelationId</a>, <a href="#kafka.producer.async;DefaultEventHandler.send.messagesPerTopic" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">messagesPerTopic</a>.<span title="=&gt; scala.collection.Set[kafka.common.TopicAndPartition]">keySet</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>, <a href="#kafka.producer.async;DefaultEventHandler.send.brokerId" title="Int">brokerId</a>, <a href="#kafka.producer.async;DefaultEventHandler.send.syncProducer" title="kafka.producer.SyncProducer">syncProducer</a>.<a href="../SyncProducer.scala.html#kafka.producer;SyncProducer.config" title="=&gt; kafka.producer.SyncProducerConfig">config</a>.<a href="../SyncProducerConfig.scala.html#kafka.producer;SyncProducerConfig.host" title="=&gt; String">host</a>, <a href="#kafka.producer.async;DefaultEventHandler.send.syncProducer" title="kafka.producer.SyncProducer">syncProducer</a>.<a href="../SyncProducer.scala.html#kafka.producer;SyncProducer.config" title="=&gt; kafka.producer.SyncProducerConfig">config</a>.<a href="../SyncProducerConfig.scala.html#kafka.producer;SyncProducerConfig.port" title="=&gt; Int">port</a><span class="delimiter">)</span><span class="delimiter">)</span>
        if<span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.response" title="kafka.api.ProducerResponse">response</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.response" title="kafka.api.ProducerResponse">response</a>.<a href="../../api/ProducerResponse.scala.html#kafka.api;ProducerResponse.status" title="=&gt; scala.collection.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus]">status</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">!=</span> <a href="#kafka.producer.async;DefaultEventHandler.send.producerRequest" title="kafka.api.ProducerRequest">producerRequest</a>.<a href="../../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.data" title="=&gt; scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">data</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>
            throw new <a href="../../common/KafkaException.scala.html#kafka.common;KafkaException" title="kafka.common.KafkaException">KafkaException</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Incomplete response (%s) for producer request (%s)&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.response" title="kafka.api.ProducerResponse">response</a>, <a href="#kafka.producer.async;DefaultEventHandler.send.producerRequest" title="kafka.api.ProducerRequest">producerRequest</a><span class="delimiter">)</span><span class="delimiter">)</span>
          if <span class="delimiter">(</span><a href="../../utils/Logging.scala.html#kafka.utils;Logging.logger" title="=&gt; org.apache.log4j.Logger">logger</a>.<span title="()Boolean">isTraceEnabled</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            val <a title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus]" id="kafka.producer.async;DefaultEventHandler.send.successfullySentData">successfullySentData</a> = <a href="#kafka.producer.async;DefaultEventHandler.send.response" title="kafka.api.ProducerResponse">response</a>.<a href="../../api/ProducerResponse.scala.html#kafka.api;ProducerResponse.status" title="=&gt; scala.collection.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus]">status</a>.<span title="(p: ((kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)) =&gt; Boolean)scala.collection.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus]">filter</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.successfullySentData.$anonfun.x$7" title="(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)">_</a>.<span title="=&gt; kafka.api.ProducerResponseStatus">_2</span>.<a href="../../api/ProducerResponse.scala.html#kafka.api;ProducerResponseStatus.error" title="=&gt; Short">error</a> <span title="(x: Short)Boolean">==</span> <a href="../../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span>
            <a href="#kafka.producer.async;DefaultEventHandler.send.successfullySentData" title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus]">successfullySentData</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)) =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a title="(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)" id="kafka.producer.async;DefaultEventHandler.send.$anonfun.m">m</a> =&gt; <a href="#kafka.producer.async;DefaultEventHandler.send.messagesPerTopic" title="(key: kafka.common.TopicAndPartition)kafka.message.ByteBufferMessageSet">messagesPerTopic</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.$anonfun.m" title="(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)">m</a>.<span title="=&gt; kafka.common.TopicAndPartition">_1</span><span class="delimiter">)</span>.<span title="(f: kafka.message.MessageAndOffset =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a title="kafka.message.MessageAndOffset" id="kafka.producer.async;DefaultEventHandler.send.$anonfun.$anonfun.message">message</a> =&gt;
              <a href="../../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Successfully sent message: %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span>if<span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.$anonfun.$anonfun.message" title="kafka.message.MessageAndOffset">message</a>.<a href="../../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a>.<a href="../../message/Message.scala.html#kafka.message;Message.isNull" title="()Boolean">isNull</a><span class="delimiter">)</span> null else <a href="../../utils/Utils.scala.html#kafka.utils.Utils" title="kafka.utils.Utils.type">Utils</a>.<a href="../../utils/Utils.scala.html#kafka.utils.Utils.readString" title="(buffer: java.nio.ByteBuffer, encoding: String)String">readString</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.$anonfun.$anonfun.message" title="kafka.message.MessageAndOffset">message</a>.<a href="../../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a>.<a href="../../message/Message.scala.html#kafka.message;Message.payload" title="=&gt; java.nio.ByteBuffer">payload</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          val <a title="Seq[(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)]" id="kafka.producer.async;DefaultEventHandler.send.failedPartitionsAndStatus">failedPartitionsAndStatus</a> = <a href="#kafka.producer.async;DefaultEventHandler.send.response" title="kafka.api.ProducerResponse">response</a>.<a href="../../api/ProducerResponse.scala.html#kafka.api;ProducerResponse.status" title="=&gt; scala.collection.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus]">status</a>.<span title="(p: ((kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)) =&gt; Boolean)scala.collection.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus]">filter</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.failedPartitionsAndStatus.$anonfun.x$8" title="(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)">_</a>.<span title="=&gt; kafka.api.ProducerResponseStatus">_2</span>.<a href="../../api/ProducerResponse.scala.html#kafka.api;ProducerResponseStatus.error" title="=&gt; Short">error</a> <span title="(x: Short)Boolean">!=</span> <a href="../../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span>.<span title="=&gt; Seq[(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)]">toSeq</span>
          <a href="#kafka.producer.async;DefaultEventHandler.send.failedTopicPartitions" title="Seq[kafka.common.TopicAndPartition]">failedTopicPartitions</a> = <a href="#kafka.producer.async;DefaultEventHandler.send.failedPartitionsAndStatus" title="Seq[(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)]">failedPartitionsAndStatus</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)) =&gt; kafka.common.TopicAndPartition)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)],kafka.common.TopicAndPartition,Seq[kafka.common.TopicAndPartition]])Seq[kafka.common.TopicAndPartition]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,kafka.common.TopicAndPartition,Seq[kafka.common.TopicAndPartition]]" class="delimiter">(</span><a title="(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)" id="kafka.producer.async;DefaultEventHandler.send.$anonfun.partitionStatus">partitionStatus</a> =&gt; <a href="#kafka.producer.async;DefaultEventHandler.send.$anonfun.partitionStatus" title="(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)">partitionStatus</a>.<span title="=&gt; kafka.common.TopicAndPartition">_1</span><span class="delimiter">)</span>
          if<span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.failedTopicPartitions" title="Seq[kafka.common.TopicAndPartition]">failedTopicPartitions</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            val <a title="String" id="kafka.producer.async;DefaultEventHandler.send.errorString">errorString</a> = <a href="#kafka.producer.async;DefaultEventHandler.send.failedPartitionsAndStatus" title="Seq[(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)]">failedPartitionsAndStatus</a>
              .<span title="(lt: ((kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus), (kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)) =&gt; Boolean)Seq[(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)]">sortWith</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)" id="kafka.producer.async;DefaultEventHandler.send.errorString.$anonfun.p1">p1</a>, <a title="(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)" id="kafka.producer.async;DefaultEventHandler.send.errorString.$anonfun.p2">p2</a><span class="delimiter">)</span> =&gt; <a href="#kafka.producer.async;DefaultEventHandler.send.errorString.$anonfun.p1" title="(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)">p1</a>.<span title="=&gt; kafka.common.TopicAndPartition">_1</span>.<a href="../../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>.<span title="(x$1: String)Int">compareTo</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.errorString.$anonfun.p2" title="(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)">p2</a>.<span title="=&gt; kafka.common.TopicAndPartition">_1</span>.<a href="../../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span>
                                    <span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.errorString.$anonfun.p1" title="(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)">p1</a>.<span title="=&gt; kafka.common.TopicAndPartition">_1</span>.<a href="../../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>.<span title="(x$1: String)Int">compareTo</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.errorString.$anonfun.p2" title="(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)">p2</a>.<span title="=&gt; kafka.common.TopicAndPartition">_1</span>.<a href="../../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.producer.async;DefaultEventHandler.send.errorString.$anonfun.p1" title="(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)">p1</a>.<span title="=&gt; kafka.common.TopicAndPartition">_1</span>.<a href="../../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#kafka.producer.async;DefaultEventHandler.send.errorString.$anonfun.p2" title="(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)">p2</a>.<span title="=&gt; kafka.common.TopicAndPartition">_1</span>.<a href="../../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a><span class="delimiter">)</span><span class="delimiter">)</span>
              .<span title="(f: ((kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)],String,Seq[String]])Seq[String]">map</span><a href="#kafka.producer.async;DefaultEventHandler.send.errorString.$anonfun.x0$2" title="String" class="delimiter">{</a>
                case<span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.producer.async;DefaultEventHandler.send.errorString.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="kafka.api.ProducerResponseStatus" id="kafka.producer.async;DefaultEventHandler.send.errorString.$anonfun.status">status</a><span class="delimiter">)</span> =&gt;
                  <a href="#kafka.producer.async;DefaultEventHandler.send.errorString.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.toString" title="()String">toString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;: &quot;)" class="string">&quot;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="../../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.exceptionFor" title="(code: Short)Throwable">exceptionFor</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.errorString.$anonfun.status" title="kafka.api.ProducerResponseStatus">status</a>.<a href="../../api/ProducerResponse.scala.html#kafka.api;ProducerResponseStatus.error" title="=&gt; Short">error</a><span class="delimiter">)</span>.<span title="()Class[_]">getClass</span>.<span title="()String">getName</span>
              <span class="delimiter">}</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>
            <a href="../../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Produce request with correlation id %d failed due to %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.currentCorrelationId" title="Int">currentCorrelationId</a>, <a href="#kafka.producer.async;DefaultEventHandler.send.errorString" title="String">errorString</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <a href="#kafka.producer.async;DefaultEventHandler.send.failedTopicPartitions" title="Seq[kafka.common.TopicAndPartition]">failedTopicPartitions</a>
        <span class="delimiter">}</span> else <span class="delimiter">{</span>
          <span title="scala.collection.Seq.type">Seq</span>.<span title="[A]=&gt; Seq[A]">empty</span><span title="Seq[kafka.common.TopicAndPartition]" class="delimiter">[</span><a href="../../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">]</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> catch <span class="delimiter">{</span>
        case <a title="Throwable" id="kafka.producer.async;DefaultEventHandler.send.t">t</a>: <span title="Throwable">Throwable</span> =&gt;
          <a href="../../utils/Logging.scala.html#kafka.utils;Logging.warn(cfd112d89b)" title="(msg: =&gt; String, e: =&gt; Throwable)Unit">warn</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Failed to send producer request with correlation id %d to broker %d with data for partitions %s&quot;</span>
            .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.currentCorrelationId" title="Int">currentCorrelationId</a>, <a href="#kafka.producer.async;DefaultEventHandler.send.brokerId" title="Int">brokerId</a>, <a href="#kafka.producer.async;DefaultEventHandler.send.messagesPerTopic" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">messagesPerTopic</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.message.ByteBufferMessageSet)) =&gt; kafka.common.TopicAndPartition)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet],kafka.common.TopicAndPartition,scala.collection.mutable.Iterable[kafka.common.TopicAndPartition]])scala.collection.mutable.Iterable[kafka.common.TopicAndPartition]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.mutable.Iterable.Coll,kafka.common.TopicAndPartition,scala.collection.mutable.Iterable[kafka.common.TopicAndPartition]]" class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.send.$anonfun.x$9" title="(kafka.common.TopicAndPartition, kafka.message.ByteBufferMessageSet)">_</a>.<span title="=&gt; kafka.common.TopicAndPartition">_1</span><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#kafka.producer.async;DefaultEventHandler.send.t" title="Throwable">t</a><span class="delimiter">)</span>
          <a href="#kafka.producer.async;DefaultEventHandler.send.messagesPerTopic" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">messagesPerTopic</a>.<span title="=&gt; Iterable[kafka.common.TopicAndPartition]">keys</span>.<span title="=&gt; Seq[kafka.common.TopicAndPartition]">toSeq</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <span title="scala.collection.immutable.List.type">List</span>.<span title="List[Nothing]">empty</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  private def <a title="(messagesPerTopicAndPartition: scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]])scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]" id="kafka.producer.async;DefaultEventHandler.groupMessagesToSet">groupMessagesToSet</a><span class="delimiter">(</span><a title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]" id="kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicAndPartition">messagesPerTopicAndPartition</a>: collection.mutable.<span title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">Map</span><span class="delimiter">[</span>TopicAndPartition, Seq<span class="delimiter">[</span>KeyedMessage<span class="delimiter">[</span>K,Message<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="comment">/** enforce the compressed.topics config here.
      *  If the compression codec is anything other than NoCompressionCodec,
      *    Enable compression only for specified topics if any
      *    If the list of compressed topics is empty, then enable the specified compression codec for all topics
      *  If the compression codec is NoCompressionCodec, compression is disabled for all topics
      */</span>

    val <a title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]" id="kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition">messagesPerTopicPartition</a> = <a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicAndPartition" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]]">messagesPerTopicAndPartition</a>.<span title="(f: ((kafka.common.TopicAndPartition, Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]])) =&gt; (kafka.common.TopicAndPartition, kafka.message.ByteBufferMessageSet))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]],(kafka.common.TopicAndPartition, kafka.message.ByteBufferMessageSet),scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]])scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">map</span> <a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.x0$1" title="(kafka.common.TopicAndPartition, kafka.message.ByteBufferMessageSet)" class="delimiter">{</a> case <span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]" id="kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.messages">messages</a><span class="delimiter">)</span> =&gt;
      val <a title="Seq[kafka.message.Message]" id="kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.rawMessages">rawMessages</a> = <a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.messages" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">messages</a>.<span title="(f: kafka.producer.KeyedMessage[K,kafka.message.Message] =&gt; kafka.message.Message)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]],kafka.message.Message,Seq[kafka.message.Message]])Seq[kafka.message.Message]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,kafka.message.Message,Seq[kafka.message.Message]]" class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.rawMessages.$anonfun.x$10" title="kafka.producer.KeyedMessage[K,kafka.message.Message]">_</a>.<a href="../KeyedMessage.scala.html#kafka.producer;KeyedMessage.message" title="=&gt; kafka.message.Message">message</a><span class="delimiter">)</span>
      <span title="(_1: kafka.common.TopicAndPartition, _2: kafka.message.ByteBufferMessageSet)(kafka.common.TopicAndPartition, kafka.message.ByteBufferMessageSet)" class="delimiter">(</span> <a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>,
        <a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../ProducerConfig.scala.html#kafka.producer;ProducerConfig.compressionCodec" title="=&gt; kafka.message.CompressionCodec">compressionCodec</a> match <span class="delimiter">{</span>
          case <a href="../../message/CompressionCodec.scala.html#kafka.message.NoCompressionCodec" title="kafka.message.NoCompressionCodec.type">NoCompressionCodec</a> =&gt;
            <a href="../../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Sending %d messages with no compression to %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.messages" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">messages</a>.<span title="=&gt; Int">size</span>, <a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span><span class="delimiter">)</span>
            new <a href="../../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet">ByteBufferMessageSet</a><span class="delimiter">(</span><a href="../../message/CompressionCodec.scala.html#kafka.message.NoCompressionCodec" title="kafka.message.NoCompressionCodec.type">NoCompressionCodec</a>, <a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.rawMessages" title="Seq[kafka.message.Message]">rawMessages</a>: _*<span class="delimiter">)</span>
          case _ =&gt;
            <a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../ProducerConfig.scala.html#kafka.producer;ProducerConfig.compressedTopics" title="=&gt; Seq[String]">compressedTopics</a>.<span title="=&gt; Int">size</span> match <span class="delimiter">{</span>
              case <span title="Int(0)" class="int">0</span> =&gt;
                <a href="../../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Sending %d messages with compression codec %d to %s&quot;</span>
                  .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.messages" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">messages</a>.<span title="=&gt; Int">size</span>, <a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../ProducerConfig.scala.html#kafka.producer;ProducerConfig.compressionCodec" title="=&gt; kafka.message.CompressionCodec">compressionCodec</a>.<a href="../../message/CompressionCodec.scala.html#kafka.message;CompressionCodec.codec" title="=&gt; Int">codec</a>, <a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span><span class="delimiter">)</span>
                new <a href="../../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet">ByteBufferMessageSet</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../ProducerConfig.scala.html#kafka.producer;ProducerConfig.compressionCodec" title="=&gt; kafka.message.CompressionCodec">compressionCodec</a>, <a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.rawMessages" title="Seq[kafka.message.Message]">rawMessages</a>: _*<span class="delimiter">)</span>
              case _ =&gt;
                if<span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../ProducerConfig.scala.html#kafka.producer;ProducerConfig.compressedTopics" title="=&gt; Seq[String]">compressedTopics</a>.<span title="(elem: String)Boolean">contains</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <a href="../../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Sending %d messages with compression codec %d to %s&quot;</span>
                    .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.messages" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">messages</a>.<span title="=&gt; Int">size</span>, <a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../ProducerConfig.scala.html#kafka.producer;ProducerConfig.compressionCodec" title="=&gt; kafka.message.CompressionCodec">compressionCodec</a>.<a href="../../message/CompressionCodec.scala.html#kafka.message;CompressionCodec.codec" title="=&gt; Int">codec</a>, <a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  new <a href="../../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet">ByteBufferMessageSet</a><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../ProducerConfig.scala.html#kafka.producer;ProducerConfig.compressionCodec" title="=&gt; kafka.message.CompressionCodec">compressionCodec</a>, <a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.rawMessages" title="Seq[kafka.message.Message]">rawMessages</a>: _*<span class="delimiter">)</span>
                <span class="delimiter">}</span>
                else <span class="delimiter">{</span>
                  <a href="../../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Sending %d messages to %s with no compression as it is not in compressed.topics - %s&quot;</span>
                    .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.messages" title="Seq[kafka.producer.KeyedMessage[K,kafka.message.Message]]">messages</a>.<span title="=&gt; Int">size</span>, <a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.producer.async;DefaultEventHandler.config" title="kafka.producer.ProducerConfig">config</a>.<a href="../ProducerConfig.scala.html#kafka.producer;ProducerConfig.compressedTopics" title="=&gt; Seq[String]">compressedTopics</a>.<span title="()String">toString</span><span class="delimiter">)</span><span class="delimiter">)</span>
                  new <a href="../../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet">ByteBufferMessageSet</a><span class="delimiter">(</span><a href="../../message/CompressionCodec.scala.html#kafka.message.NoCompressionCodec" title="kafka.message.NoCompressionCodec.type">NoCompressionCodec</a>, <a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition.$anonfun.rawMessages" title="Seq[kafka.message.Message]">rawMessages</a>: _*<span class="delimiter">)</span>
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#kafka.producer.async;DefaultEventHandler.groupMessagesToSet.messagesPerTopicPartition" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">messagesPerTopicPartition</a>
  <span class="delimiter">}</span>

  def <a title="()Unit" id="kafka.producer.async;DefaultEventHandler.close">close</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#kafka.producer.async;DefaultEventHandler.producerPool" title="=&gt; kafka.producer.ProducerPool">producerPool</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span>
      <a href="#kafka.producer.async;DefaultEventHandler.producerPool" title="=&gt; kafka.producer.ProducerPool">producerPool</a>.<a href="../ProducerPool.scala.html#kafka.producer;ProducerPool.close" title="()Unit">close</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
