<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/log/LogCleaner.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package kafka.log

import kafka.common._
import kafka.message._
import kafka.utils._
import kafka.metrics.KafkaMetricsGroup

import scala.collection._
import scala.math
import java.nio._
import java.util.Date
import java.io.File
import java.lang.IllegalStateException
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit

import com.yammer.metrics.core.Gauge

<span class="comment">/**
 * The cleaner is responsible for removing obsolete records from logs which have the dedupe retention strategy.
 * A message with key K and offset O is obsolete if there exists a message with key K and offset O' such that O &lt; O'.
 * 
 * Each log can be thought of being split into two sections of segments: a &quot;clean&quot; section which has previously been cleaned followed by a
 * &quot;dirty&quot; section that has not yet been cleaned. The active log segment is always excluded from cleaning.
 *
 * The cleaning is carried out by a pool of background threads. Each thread chooses the dirtiest log that has the &quot;dedupe&quot; retention policy 
 * and cleans that. The dirtiness of the log is guessed by taking the ratio of bytes in the dirty section of the log to the total bytes in the log. 
 * 
 * To clean a log the cleaner first builds a mapping of key=&gt;last_offset for the dirty section of the log. See kafka.log.OffsetMap for details of
 * the implementation of the mapping. 
 * 
 * Once the key=&gt;offset map is built, the log is cleaned by recopying each log segment but omitting any key that appears in the offset map with a 
 * higher offset than what is found in the segment (i.e. messages with a key that appears in the dirty section of the log).
 * 
 * To avoid segments shrinking to very small sizes with repeated cleanings we implement a rule by which if we will merge successive segments when
 * doing a cleaning if their log and index size are less than the maximum log and index size prior to the clean beginning.
 * 
 * Cleaned segments are swapped into the log as they become available.
 * 
 * One nuance that the cleaner must handle is log truncation. If a log is truncated while it is being cleaned the cleaning of that log is aborted.
 * 
 * Messages with null payload are treated as deletes for the purpose of log compaction. This means that they receive special treatment by the cleaner. 
 * The cleaner will only retain delete records for a period of time to avoid accumulating space indefinitely. This period of time is configurable on a per-topic
 * basis and is measured from the time the segment enters the clean portion of the log (at which point any prior message with that key has been removed).
 * Delete markers in the clean section of the log that are older than this time will not be retained when log segments are being recopied as part of cleaning.
 * 
 * @param config Configuration parameters for the cleaner
 * @param logDirs The directories where offset checkpoints reside
 * @param logs The pool of logs
 * @param time A way to control the passage of time
 */</span>
class <a title="class LogCleaner extends AnyRef with kafka.utils.Logging with kafka.metrics.KafkaMetricsGroup" id="kafka.log.LogCleaner">LogCleaner</a><a href="#kafka.log.LogCleaner" title="kafka.log.LogCleaner" class="delimiter">(</a>val <a title="kafka.log.CleanerConfig" id="kafka.log;LogCleaner.config">config</a>: <a href="CleanerConfig.scala.html#kafka.log;CleanerConfig" title="kafka.log.CleanerConfig">CleanerConfig</a>,
                 val <a title="Array[java.io.File]" id="kafka.log;LogCleaner.logDirs">logDirs</a>: <span title="Array[java.io.File]">Array</span><span class="delimiter">[</span>File<span class="delimiter">]</span>,
                 val <a title="kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.log.Log]" id="kafka.log;LogCleaner.logs">logs</a>: <a href="../utils/Pool.scala.html#kafka.utils;Pool" title="kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.log.Log]">Pool</a><span class="delimiter">[</span>TopicAndPartition, Log<span class="delimiter">]</span>, 
                 <a title="kafka.utils.Time" id="kafka.log.LogCleaner.<init>$default$4">time</a>: <a href="../utils/Time.scala.html#kafka.utils;Time" title="kafka.utils.Time">Time</a> = <a href="../utils/Time.scala.html#kafka.utils.SystemTime" title="kafka.utils.SystemTime.type">SystemTime</a><span class="delimiter">)</span> extends <a href="../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> with <a href="../metrics/KafkaMetricsGroup.scala.html#kafka.metrics;KafkaMetricsGroup" title="kafka.metrics.KafkaMetricsGroup">KafkaMetricsGroup</a> <span class="delimiter">{</span>
  
  <span class="comment">/* for managing the state of partitions being cleaned. package-private to allow access in tests */</span>
  private<span class="delimiter">[</span>log<span class="delimiter">]</span> val <a title="kafka.log.LogCleanerManager" id="kafka.log;LogCleaner.cleanerManager">cleanerManager</a> = new <a href="LogCleanerManager.scala.html#kafka.log;LogCleanerManager" title="kafka.log.LogCleanerManager">LogCleanerManager</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner.logDirs" title="=&gt; Array[java.io.File]">logDirs</a>, <a href="#kafka.log;LogCleaner.logs" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.log.Log]">logs</a><span class="delimiter">)</span>;

  <span class="comment">/* a throttle used to limit the I/O of all the cleaner threads to a user-specified maximum rate */</span>
  private val <a title="kafka.utils.Throttler" id="kafka.log;LogCleaner.throttler">throttler</a> = new <a href="../utils/Throttler.scala.html#kafka.utils;Throttler" title="kafka.utils.Throttler">Throttler</a><span class="delimiter">(</span>desiredRatePerSec = <a href="#kafka.log;LogCleaner.config" title="=&gt; kafka.log.CleanerConfig">config</a>.<a href="CleanerConfig.scala.html#kafka.log;CleanerConfig.maxIoBytesPerSecond" title="=&gt; Double">maxIoBytesPerSecond</a>, 
                                        checkIntervalMs = <span title="Long(300L)" class="int">300</span>, 
                                        throttleDown = true, 
                                        <span title="String(&quot;cleaner-io&quot;)" class="string">&quot;cleaner-io&quot;</span>,
                                        <span title="String(&quot;bytes&quot;)" class="string">&quot;bytes&quot;</span>,
                                        time = <a href="#kafka.log.LogCleaner.<init>$default$4" title="kafka.utils.Time">time</a><span class="delimiter">)</span>
  
  <span class="comment">/* the threads */</span>
  private val <a title="scala.collection.immutable.IndexedSeq[LogCleaner.this.CleanerThread]" id="kafka.log;LogCleaner.cleaners">cleaners</a> = <span class="delimiter">(</span><span title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">0</span> <span title="(end: Int)scala.collection.immutable.Range">until</span> <a href="#kafka.log;LogCleaner.config" title="=&gt; kafka.log.CleanerConfig">config</a>.<a href="CleanerConfig.scala.html#kafka.log;CleanerConfig.numThreads" title="=&gt; Int">numThreads</a><span class="delimiter">)</span>.<span title="(f: Int =&gt; LogCleaner.this.CleanerThread)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Int],LogCleaner.this.CleanerThread,scala.collection.immutable.IndexedSeq[LogCleaner.this.CleanerThread]])scala.collection.immutable.IndexedSeq[LogCleaner.this.CleanerThread]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq.Coll,LogCleaner.this.CleanerThread,scala.collection.immutable.IndexedSeq[LogCleaner.this.CleanerThread]]" class="delimiter">(</span>new <a href="#kafka.log;LogCleaner;CleanerThread" title="LogCleaner.this.CleanerThread">CleanerThread</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner.cleaners.$anonfun.x$1" title="Int">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
  
  <span class="comment">/* a metric to track the maximum utilization of any thread's buffer in the last cleaning */</span>
  <a href="../metrics/KafkaMetricsGroup.scala.html#kafka.metrics;KafkaMetricsGroup.newGauge" title="(name: String, metric: com.yammer.metrics.core.Gauge[Int], tags: scala.collection.Map[String,String])com.yammer.metrics.core.Gauge[Int]">newGauge</a><span class="delimiter">(</span><span title="String(&quot;max-buffer-utilization-percent&quot;)" class="string">&quot;max-buffer-utilization-percent&quot;</span>, 
           new <span title="&lt;$anon: com.yammer.metrics.core.Gauge[Int]&gt; extends com.yammer.metrics.core.Gauge[Int]">Gauge</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> <span class="delimiter">{</span>
             def <span title="()Int">value</span>: <span title="Int">Int</span> = <a href="#kafka.log;LogCleaner.cleaners" title="=&gt; scala.collection.immutable.IndexedSeq[LogCleaner.this.CleanerThread]">cleaners</a>.<span title="(f: LogCleaner.this.CleanerThread =&gt; kafka.log.CleanerStats)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[LogCleaner.this.CleanerThread],kafka.log.CleanerStats,scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats]])scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq.Coll,kafka.log.CleanerStats,scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats]]" class="delimiter">(</span><a href="#kafka.log;LogCleaner.<local LogCleaner>;$anon.value.$anonfun.x$2" title="LogCleaner.this.CleanerThread">_</a>.<a href="#kafka.log;LogCleaner;CleanerThread.lastStats_=" title="=&gt; kafka.log.CleanerStats">lastStats</a><span class="delimiter">)</span>.<span title="(f: kafka.log.CleanerStats =&gt; Double)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats],Double,scala.collection.immutable.IndexedSeq[Double]])scala.collection.immutable.IndexedSeq[Double]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq.Coll,Double,scala.collection.immutable.IndexedSeq[Double]]" class="delimiter">(</span><span title="Int(100)" class="int">100</span> <span title="(x: Double)Double">*</span> <a href="#kafka.log;LogCleaner.<local LogCleaner>;$anon.value.$anonfun.x$3" title="kafka.log.CleanerStats">_</a>.<a href="#kafka.log;CleanerStats.bufferUtilization_=" title="=&gt; Double">bufferUtilization</a><span class="delimiter">)</span>.<span title="(implicit cmp: Ordering[Double])Double">max</span>.<span title="=&gt; Int">toInt</span>
           <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="comment">/* a metric to track the recopy rate of each thread's last cleaning */</span>
  <a href="../metrics/KafkaMetricsGroup.scala.html#kafka.metrics;KafkaMetricsGroup.newGauge" title="(name: String, metric: com.yammer.metrics.core.Gauge[Int], tags: scala.collection.Map[String,String])com.yammer.metrics.core.Gauge[Int]">newGauge</a><span class="delimiter">(</span><span title="String(&quot;cleaner-recopy-percent&quot;)" class="string">&quot;cleaner-recopy-percent&quot;</span>, 
           new <span title="&lt;$anon: com.yammer.metrics.core.Gauge[Int]&gt; extends com.yammer.metrics.core.Gauge[Int]">Gauge</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> <span class="delimiter">{</span>
             def <span title="()Int">value</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
               val <a title="scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats]" id="kafka.log;LogCleaner.<local LogCleaner>;$anon.value.stats">stats</a> = <a href="#kafka.log;LogCleaner.cleaners" title="=&gt; scala.collection.immutable.IndexedSeq[LogCleaner.this.CleanerThread]">cleaners</a>.<span title="(f: LogCleaner.this.CleanerThread =&gt; kafka.log.CleanerStats)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[LogCleaner.this.CleanerThread],kafka.log.CleanerStats,scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats]])scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq.Coll,kafka.log.CleanerStats,scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats]]" class="delimiter">(</span><a href="#kafka.log;LogCleaner.<local LogCleaner>;$anon.value.stats.$anonfun.x$4" title="LogCleaner.this.CleanerThread">_</a>.<a href="#kafka.log;LogCleaner;CleanerThread.lastStats_=" title="=&gt; kafka.log.CleanerStats">lastStats</a><span class="delimiter">)</span>
               val recopyRate = <a href="#kafka.log;LogCleaner.<local LogCleaner>;$anon.value.stats" title="scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats]">stats</a>.<span title="(f: kafka.log.CleanerStats =&gt; Long)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats],Long,scala.collection.immutable.IndexedSeq[Long]])scala.collection.immutable.IndexedSeq[Long]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq.Coll,Long,scala.collection.immutable.IndexedSeq[Long]]" class="delimiter">(</span><a href="#kafka.log;LogCleaner.<local LogCleaner>;$anon.value.recopyRate.$anonfun.x$5" title="kafka.log.CleanerStats">_</a>.<a href="#kafka.log;CleanerStats.bytesWritten_=" title="=&gt; Long">bytesWritten</a><span class="delimiter">)</span>.<span title="(implicit num: Numeric[Long])Long">sum</span>.<span title="=&gt; Double">toDouble</span> <a title="Double" id="kafka.log;LogCleaner.<local LogCleaner>;$anon.value.recopyRate">/</a> math.<span title="(x: Long, y: Long)Long">max</span><span class="delimiter">(</span><a href="#kafka.log;LogCleaner.<local LogCleaner>;$anon.value.stats" title="scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats]">stats</a>.<span title="(f: kafka.log.CleanerStats =&gt; Long)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats],Long,scala.collection.immutable.IndexedSeq[Long]])scala.collection.immutable.IndexedSeq[Long]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq.Coll,Long,scala.collection.immutable.IndexedSeq[Long]]" class="delimiter">(</span><a href="#kafka.log;LogCleaner.<local LogCleaner>;$anon.value.recopyRate.$anonfun.x$6" title="kafka.log.CleanerStats">_</a>.<a href="#kafka.log;CleanerStats.bytesRead_=" title="=&gt; Long">bytesRead</a><span class="delimiter">)</span>.<span title="(implicit num: Numeric[Long])Long">sum</span>, <span title="Long(1L)" class="int">1</span><span class="delimiter">)</span>
               <span class="delimiter">(</span><span title="Int(100)" class="int">100</span> <span title="(x: Double)Double">*</span> <a href="#kafka.log;LogCleaner.<local LogCleaner>;$anon.value.recopyRate" title="Double">recopyRate</a><span class="delimiter">)</span>.<span title="=&gt; Int">toInt</span>
             <span class="delimiter">}</span>
           <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="comment">/* a metric to track the maximum cleaning time for the last cleaning from each thread */</span>
  <a href="../metrics/KafkaMetricsGroup.scala.html#kafka.metrics;KafkaMetricsGroup.newGauge" title="(name: String, metric: com.yammer.metrics.core.Gauge[Int], tags: scala.collection.Map[String,String])com.yammer.metrics.core.Gauge[Int]">newGauge</a><span class="delimiter">(</span><span title="String(&quot;max-clean-time-secs&quot;)" class="string">&quot;max-clean-time-secs&quot;</span>,
           new <span title="&lt;$anon: com.yammer.metrics.core.Gauge[Int]&gt; extends com.yammer.metrics.core.Gauge[Int]">Gauge</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> <span class="delimiter">{</span>
             def <span title="()Int">value</span>: <span title="Int">Int</span> = <a href="#kafka.log;LogCleaner.cleaners" title="=&gt; scala.collection.immutable.IndexedSeq[LogCleaner.this.CleanerThread]">cleaners</a>.<span title="(f: LogCleaner.this.CleanerThread =&gt; kafka.log.CleanerStats)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[LogCleaner.this.CleanerThread],kafka.log.CleanerStats,scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats]])scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq.Coll,kafka.log.CleanerStats,scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats]]" class="delimiter">(</span><a href="#kafka.log;LogCleaner.<local LogCleaner>;$anon.value.$anonfun.x$7" title="LogCleaner.this.CleanerThread">_</a>.<a href="#kafka.log;LogCleaner;CleanerThread.lastStats_=" title="=&gt; kafka.log.CleanerStats">lastStats</a><span class="delimiter">)</span>.<span title="(f: kafka.log.CleanerStats =&gt; Double)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[kafka.log.CleanerStats],Double,scala.collection.immutable.IndexedSeq[Double]])scala.collection.immutable.IndexedSeq[Double]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq.Coll,Double,scala.collection.immutable.IndexedSeq[Double]]" class="delimiter">(</span><a href="#kafka.log;LogCleaner.<local LogCleaner>;$anon.value.$anonfun.x$8" title="kafka.log.CleanerStats">_</a>.<a href="#kafka.log;CleanerStats.elapsedSecs" title="=&gt; Double">elapsedSecs</a><span class="delimiter">)</span>.<span title="(implicit cmp: Ordering[Double])Double">max</span>.<span title="=&gt; Int">toInt</span>
           <span class="delimiter">}</span><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Start the background cleaning
   */</span>
  def <a title="()Unit" id="kafka.log;LogCleaner.startup">startup</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="String(&quot;Starting the log cleaner&quot;)" class="string">&quot;Starting the log cleaner&quot;</span><span class="delimiter">)</span>
    <a href="#kafka.log;LogCleaner.cleaners" title="=&gt; scala.collection.immutable.IndexedSeq[LogCleaner.this.CleanerThread]">cleaners</a>.<span title="(f: LogCleaner.this.CleanerThread =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#kafka.log;LogCleaner.startup.$anonfun.x$9" title="LogCleaner.this.CleanerThread">_</a>.<span title="()Unit">start</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Stop the background cleaning
   */</span>
  def <a title="()Unit" id="kafka.log;LogCleaner.shutdown">shutdown</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="String(&quot;Shutting down the log cleaner.&quot;)" class="string">&quot;Shutting down the log cleaner.&quot;</span><span class="delimiter">)</span>
    <a href="#kafka.log;LogCleaner.cleaners" title="=&gt; scala.collection.immutable.IndexedSeq[LogCleaner.this.CleanerThread]">cleaners</a>.<span title="(f: LogCleaner.this.CleanerThread =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#kafka.log;LogCleaner.shutdown.$anonfun.x$10" title="LogCleaner.this.CleanerThread">_</a>.<a href="#kafka.log;LogCleaner;CleanerThread.shutdown" title="()Unit">shutdown</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   *  Abort the cleaning of a particular partition, if it's in progress. This call blocks until the cleaning of
   *  the partition is aborted.
   */</span>
  def <a title="(topicAndPartition: kafka.common.TopicAndPartition)Unit" id="kafka.log;LogCleaner.abortCleaning">abortCleaning</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.log;LogCleaner.abortCleaning.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.log;LogCleaner.cleanerManager" title="=&gt; kafka.log.LogCleanerManager">cleanerManager</a>.<a href="LogCleanerManager.scala.html#kafka.log;LogCleanerManager.abortCleaning" title="(topicAndPartition: kafka.common.TopicAndPartition)Unit">abortCleaning</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner.abortCleaning.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Update checkpoint file, removing topics and partitions that no longer exist
   */</span>
  def <a title="(dataDir: java.io.File)Unit" id="kafka.log;LogCleaner.updateCheckpoints">updateCheckpoints</a><span class="delimiter">(</span><a title="java.io.File" id="kafka.log;LogCleaner.updateCheckpoints.dataDir">dataDir</a>: <span title="java.io.File">File</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.log;LogCleaner.cleanerManager" title="=&gt; kafka.log.LogCleanerManager">cleanerManager</a>.<a href="LogCleanerManager.scala.html#kafka.log;LogCleanerManager.updateCheckpoints" title="(dataDir: java.io.File, update: Option[(kafka.common.TopicAndPartition, Long)])Unit">updateCheckpoints</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner.updateCheckpoints.dataDir" title="java.io.File">dataDir</a>, update=<span title="None.type">None</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   *  Abort the cleaning of a particular partition if it's in progress, and pause any future cleaning of this partition.
   *  This call blocks until the cleaning of the partition is aborted and paused.
   */</span>
  def <a title="(topicAndPartition: kafka.common.TopicAndPartition)Unit" id="kafka.log;LogCleaner.abortAndPauseCleaning">abortAndPauseCleaning</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.log;LogCleaner.abortAndPauseCleaning.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.log;LogCleaner.cleanerManager" title="=&gt; kafka.log.LogCleanerManager">cleanerManager</a>.<a href="LogCleanerManager.scala.html#kafka.log;LogCleanerManager.abortAndPauseCleaning" title="(topicAndPartition: kafka.common.TopicAndPartition)Unit">abortAndPauseCleaning</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner.abortAndPauseCleaning.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   *  Resume the cleaning of a paused partition. This call blocks until the cleaning of a partition is resumed.
   */</span>
  def <a title="(topicAndPartition: kafka.common.TopicAndPartition)Unit" id="kafka.log;LogCleaner.resumeCleaning">resumeCleaning</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.log;LogCleaner.resumeCleaning.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.log;LogCleaner.cleanerManager" title="=&gt; kafka.log.LogCleanerManager">cleanerManager</a>.<a href="LogCleanerManager.scala.html#kafka.log;LogCleanerManager.resumeCleaning" title="(topicAndPartition: kafka.common.TopicAndPartition)Unit">resumeCleaning</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner.resumeCleaning.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * TODO:
   * For testing, a way to know when work has completed. This method blocks until the 
   * cleaner has processed up to the given offset on the specified topic/partition
   */</span>
  def <a title="(topic: String, part: Int, offset: Long, timeout: Long)Unit" id="kafka.log;LogCleaner.awaitCleaned">awaitCleaned</a><span class="delimiter">(</span><a title="String" id="kafka.log;LogCleaner.awaitCleaned.topic">topic</a>: <span title="String">String</span>, <a title="Int" id="kafka.log;LogCleaner.awaitCleaned.part">part</a>: <span title="Int">Int</span>, <a title="Long" id="kafka.log;LogCleaner.awaitCleaned.offset">offset</a>: <span title="Long">Long</span>, <a title="Long" id="kafka.log;LogCleaner.awaitCleaned$default$4">timeout</a>: <span title="Long">Long</span> = <span title="Long(30000L)" class="long">30000L</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    while<span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.log;LogCleaner.cleanerManager" title="=&gt; kafka.log.LogCleanerManager">cleanerManager</a>.<a href="LogCleanerManager.scala.html#kafka.log;LogCleanerManager.allCleanerCheckpoints" title="()Map[kafka.common.TopicAndPartition,Long]">allCleanerCheckpoints</a>.<span title="(key: kafka.common.TopicAndPartition)Boolean">contains</span><span class="delimiter">(</span><a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner.awaitCleaned.topic" title="String">topic</a>, <a href="#kafka.log;LogCleaner.awaitCleaned.part" title="Int">part</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="Thread.type">Thread</span>.<span title="(x$1: Long)Unit">sleep</span><a href="#kafka.log;LogCleaner.awaitCleaned.while$1" title="()Unit" class="delimiter">(</a><span title="Long(10L)" class="int">10</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * The cleaner threads do the actual log cleaning. Each thread processes does its cleaning repeatedly by
   * choosing the dirtiest log, cleaning it, and then swapping in the cleaned segments.
   */</span>
  private class <a title="class CleanerThread extends kafka.utils.ShutdownableThread" id="kafka.log;LogCleaner;CleanerThread">CleanerThread</a><a href="#kafka.log;LogCleaner;CleanerThread" title="LogCleaner.this.CleanerThread" class="delimiter">(</a><a title="Int" id="kafka.log;LogCleaner;CleanerThread.threadId">threadId</a>: <span title="Int">Int</span><span class="delimiter">)</span>
    extends <a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread" title="kafka.utils.ShutdownableThread">ShutdownableThread</a><span class="delimiter">(</span>name = <span title="String(&quot;kafka-log-cleaner-thread-&quot;)" class="string">&quot;kafka-log-cleaner-thread-&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogCleaner;CleanerThread.threadId" title="Int">threadId</a>, isInterruptible = false<span class="delimiter">)</span> <span class="delimiter">{</span>
    
    override val <a title="String" id="kafka.log;LogCleaner;CleanerThread.loggerName">loggerName</a> = classOf<span title="Class[kafka.log.LogCleaner](classOf[kafka.log.LogCleaner])" class="delimiter">[</span>LogCleaner<span class="delimiter">]</span>.<span title="()String">getName</span>
    
    if<span class="delimiter">(</span><a href="#kafka.log;LogCleaner.config" title="=&gt; kafka.log.CleanerConfig">config</a>.<a href="CleanerConfig.scala.html#kafka.log;CleanerConfig.dedupeBufferSize" title="=&gt; Long">dedupeBufferSize</a> <span title="(x: Int)Long">/</span> <a href="#kafka.log;LogCleaner.config" title="=&gt; kafka.log.CleanerConfig">config</a>.<a href="CleanerConfig.scala.html#kafka.log;CleanerConfig.numThreads" title="=&gt; Int">numThreads</a> <span title="(x: Int)Boolean">&gt;</span> Int.<span title="Int(2147483647)">MaxValue</span><span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="String(&quot;Cannot use more than 2G of cleaner buffer space per cleaner thread, ignoring excess buffer space...&quot;)" class="string">&quot;Cannot use more than 2G of cleaner buffer space per cleaner thread, ignoring excess buffer space...&quot;</span><span class="delimiter">)</span>

    val <a title="kafka.log.Cleaner" id="kafka.log;LogCleaner;CleanerThread.cleaner">cleaner</a> = new <a href="#kafka.log;Cleaner" title="kafka.log.Cleaner">Cleaner</a><span class="delimiter">(</span>id = <a href="#kafka.log;LogCleaner;CleanerThread.threadId" title="Int">threadId</a>,
                              offsetMap = new <a href="OffsetMap.scala.html#kafka.log;SkimpyOffsetMap" title="kafka.log.SkimpyOffsetMap">SkimpyOffsetMap</a><span class="delimiter">(</span>memory = math.<span title="(x: Long, y: Long)Long">min</span><span class="delimiter">(</span><a href="#kafka.log;LogCleaner.config" title="=&gt; kafka.log.CleanerConfig">config</a>.<a href="CleanerConfig.scala.html#kafka.log;CleanerConfig.dedupeBufferSize" title="=&gt; Long">dedupeBufferSize</a> <span title="(x: Int)Long">/</span> <a href="#kafka.log;LogCleaner.config" title="=&gt; kafka.log.CleanerConfig">config</a>.<a href="CleanerConfig.scala.html#kafka.log;CleanerConfig.numThreads" title="=&gt; Int">numThreads</a>, Int.<span title="Long(2147483647L)">MaxValue</span><span class="delimiter">)</span>.<span title="=&gt; Int">toInt</span>, 
                                                              hashAlgorithm = <a href="#kafka.log;LogCleaner.config" title="=&gt; kafka.log.CleanerConfig">config</a>.<a href="CleanerConfig.scala.html#kafka.log;CleanerConfig.hashAlgorithm" title="=&gt; String">hashAlgorithm</a><span class="delimiter">)</span>,
                              ioBufferSize = <a href="#kafka.log;LogCleaner.config" title="=&gt; kafka.log.CleanerConfig">config</a>.<a href="CleanerConfig.scala.html#kafka.log;CleanerConfig.ioBufferSize" title="=&gt; Int">ioBufferSize</a> <span title="(x: Int)Int">/</span> <a href="#kafka.log;LogCleaner.config" title="=&gt; kafka.log.CleanerConfig">config</a>.<a href="CleanerConfig.scala.html#kafka.log;CleanerConfig.numThreads" title="=&gt; Int">numThreads</a> <span title="(x: Int)Int">/</span> <span title="Int(2)" class="int">2</span>,
                              maxIoBufferSize = <a href="#kafka.log;LogCleaner.config" title="=&gt; kafka.log.CleanerConfig">config</a>.<a href="CleanerConfig.scala.html#kafka.log;CleanerConfig.maxMessageSize" title="=&gt; Int">maxMessageSize</a>,
                              dupBufferLoadFactor = <a href="#kafka.log;LogCleaner.config" title="=&gt; kafka.log.CleanerConfig">config</a>.<a href="CleanerConfig.scala.html#kafka.log;CleanerConfig.dedupeBufferLoadFactor" title="=&gt; Double">dedupeBufferLoadFactor</a>,
                              throttler = <a href="#kafka.log;LogCleaner.throttler" title="=&gt; kafka.utils.Throttler">throttler</a>,
                              time = <a href="#kafka.log.LogCleaner.<init>$default$4" title="kafka.utils.Time">time</a>,
                              checkDone = <a href="#kafka.log;LogCleaner;CleanerThread.checkDone" title="(topicAndPartition: kafka.common.TopicAndPartition)Unit">checkDone</a><span class="delimiter">)</span>
    
    @volatile var <a title="kafka.log.CleanerStats" id="kafka.log;LogCleaner;CleanerThread.lastStats_=">lastStats</a>: <a href="#kafka.log.CleanerStats.readResolve" title="kafka.log.CleanerStats">CleanerStats</a> = new <a href="#kafka.log.CleanerStats.readResolve" title="kafka.log.CleanerStats">CleanerStats</a><span class="delimiter">(</span><span class="delimiter">)</span>
    private val <a title="java.util.concurrent.CountDownLatch" id="kafka.log;LogCleaner;CleanerThread.backOffWaitLatch">backOffWaitLatch</a> = new <span title="java.util.concurrent.CountDownLatch">CountDownLatch</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

    private def <a title="(topicAndPartition: kafka.common.TopicAndPartition)Unit" id="kafka.log;LogCleaner;CleanerThread.checkDone">checkDone</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.log;LogCleaner;CleanerThread.checkDone.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread.isRunning" title="=&gt; java.util.concurrent.atomic.AtomicBoolean">isRunning</a>.<span title="()Boolean">get</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
        throw new <a href="../common/ThreadShutdownException.scala.html#kafka.common;ThreadShutdownException" title="kafka.common.ThreadShutdownException">ThreadShutdownException</a>
      <a href="#kafka.log;LogCleaner.cleanerManager" title="=&gt; kafka.log.LogCleanerManager">cleanerManager</a>.<a href="LogCleanerManager.scala.html#kafka.log;LogCleanerManager.checkCleaningAborted" title="(topicAndPartition: kafka.common.TopicAndPartition)Unit">checkCleaningAborted</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.checkDone.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * The main loop for the cleaner thread
     */</span>
    override def <a title="()Unit" id="kafka.log;LogCleaner;CleanerThread.doWork">doWork</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.log;LogCleaner;CleanerThread.cleanOrSleep" title="()Unit">cleanOrSleep</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    
    
    override def <a title="()Unit" id="kafka.log;LogCleaner;CleanerThread.shutdown">shutdown</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    	 <a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread.initiateShutdown" title="()Boolean">initiateShutdown</a><span class="delimiter">(</span><span class="delimiter">)</span>
    	 <a href="#kafka.log;LogCleaner;CleanerThread.backOffWaitLatch" title="=&gt; java.util.concurrent.CountDownLatch">backOffWaitLatch</a>.<span title="()Unit">countDown</span><span class="delimiter">(</span><span class="delimiter">)</span>
    	 <a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread.awaitShutdown" title="()Unit">awaitShutdown</a><span class="delimiter">(</span><span class="delimiter">)</span>
     <span class="delimiter">}</span>
     
    <span class="comment">/**
     * Clean a log if there is a dirty log available, otherwise sleep for a bit
     */</span>
    private def <a title="()Unit" id="kafka.log;LogCleaner;CleanerThread.cleanOrSleep">cleanOrSleep</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.log;LogCleaner.cleanerManager" title="=&gt; kafka.log.LogCleanerManager">cleanerManager</a>.<a href="LogCleanerManager.scala.html#kafka.log;LogCleanerManager.grabFilthiestLog" title="()Option[kafka.log.LogToClean]">grabFilthiestLog</a><span class="delimiter">(</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case <span title="None.type">None</span> =&gt;
          <span class="comment">// there are no cleanable logs, sleep a while</span>
          <a href="#kafka.log;LogCleaner;CleanerThread.backOffWaitLatch" title="=&gt; java.util.concurrent.CountDownLatch">backOffWaitLatch</a>.<span title="(x$1: Long, x$2: java.util.concurrent.TimeUnit)Boolean">await</span><span title="Unit" class="delimiter">(</span><a href="#kafka.log;LogCleaner.config" title="=&gt; kafka.log.CleanerConfig">config</a>.<a href="CleanerConfig.scala.html#kafka.log;CleanerConfig.backOffMs" title="=&gt; Long">backOffMs</a>, TimeUnit.<span title="java.util.concurrent.TimeUnit(MILLISECONDS)">MILLISECONDS</span><span class="delimiter">)</span>
        case Some<span class="delimiter">(</span><a title="kafka.log.LogToClean" id="kafka.log;LogCleaner;CleanerThread.cleanOrSleep.cleanable">cleanable</a><span class="delimiter">)</span> =&gt;
          <span class="comment">// there's a log, clean it</span>
          var <a title="Long" id="kafka.log;LogCleaner;CleanerThread.cleanOrSleep.endOffset">endOffset</a> = <a href="#kafka.log;LogCleaner;CleanerThread.cleanOrSleep.cleanable" title="kafka.log.LogToClean">cleanable</a>.<a href="#kafka.log;LogToClean.firstDirtyOffset" title="=&gt; Long">firstDirtyOffset</a>
          try <span class="delimiter">{</span>
            <a href="#kafka.log;LogCleaner;CleanerThread.cleanOrSleep.endOffset" title="Long">endOffset</a> = <a href="#kafka.log;LogCleaner;CleanerThread.cleaner" title="=&gt; kafka.log.Cleaner">cleaner</a>.<a href="#kafka.log;Cleaner.clean" title="(cleanable: kafka.log.LogToClean)Long">clean</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.cleanOrSleep.cleanable" title="kafka.log.LogToClean">cleanable</a><span class="delimiter">)</span>
            <a href="#kafka.log;LogCleaner;CleanerThread.recordStats" title="(id: Int, name: String, from: Long, to: Long, stats: kafka.log.CleanerStats)Unit">recordStats</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.cleaner" title="=&gt; kafka.log.Cleaner">cleaner</a>.<a href="#kafka.log;Cleaner.id" title="=&gt; Int">id</a>, <a href="#kafka.log;LogCleaner;CleanerThread.cleanOrSleep.cleanable" title="kafka.log.LogToClean">cleanable</a>.<a href="#kafka.log;LogToClean.log" title="=&gt; kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.name" title="=&gt; String">name</a>, <a href="#kafka.log;LogCleaner;CleanerThread.cleanOrSleep.cleanable" title="kafka.log.LogToClean">cleanable</a>.<a href="#kafka.log;LogToClean.firstDirtyOffset" title="=&gt; Long">firstDirtyOffset</a>, <a href="#kafka.log;LogCleaner;CleanerThread.cleanOrSleep.endOffset" title="Long">endOffset</a>, <a href="#kafka.log;LogCleaner;CleanerThread.cleaner" title="=&gt; kafka.log.Cleaner">cleaner</a>.<a href="#kafka.log;Cleaner.stats" title="=&gt; kafka.log.CleanerStats">stats</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> catch <span class="delimiter">{</span>
            case <a title="kafka.common.LogCleaningAbortedException" id="kafka.log;LogCleaner;CleanerThread.cleanOrSleep.pe">pe</a>: <a href="../common/LogCleaningAbortedException.scala.html#kafka.common;LogCleaningAbortedException" title="kafka.common.LogCleaningAbortedException">LogCleaningAbortedException</a> =&gt; <span class="comment">// task can be aborted, let it go.</span>
          <span class="delimiter">}</span> finally <span class="delimiter">{</span>
            <a href="#kafka.log;LogCleaner.cleanerManager" title="=&gt; kafka.log.LogCleanerManager">cleanerManager</a>.<a href="LogCleanerManager.scala.html#kafka.log;LogCleanerManager.doneCleaning" title="(topicAndPartition: kafka.common.TopicAndPartition, dataDir: java.io.File, endOffset: Long)Unit">doneCleaning</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.cleanOrSleep.cleanable" title="kafka.log.LogToClean">cleanable</a>.<a href="#kafka.log;LogToClean.topicPartition" title="=&gt; kafka.common.TopicAndPartition">topicPartition</a>, <a href="#kafka.log;LogCleaner;CleanerThread.cleanOrSleep.cleanable" title="kafka.log.LogToClean">cleanable</a>.<a href="#kafka.log;LogToClean.log" title="=&gt; kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.dir" title="=&gt; java.io.File">dir</a>.<span title="()java.io.File">getParentFile</span>, <a href="#kafka.log;LogCleaner;CleanerThread.cleanOrSleep.endOffset" title="Long">endOffset</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    
    <span class="comment">/**
     * Log out statistics on a single run of the cleaner.
     */</span>
    def <a title="(id: Int, name: String, from: Long, to: Long, stats: kafka.log.CleanerStats)Unit" id="kafka.log;LogCleaner;CleanerThread.recordStats">recordStats</a><span class="delimiter">(</span><a title="Int" id="kafka.log;LogCleaner;CleanerThread.recordStats.id">id</a>: <span title="Int">Int</span>, <a title="String" id="kafka.log;LogCleaner;CleanerThread.recordStats.name">name</a>: <span title="String">String</span>, <a title="Long" id="kafka.log;LogCleaner;CleanerThread.recordStats.from">from</a>: <span title="Long">Long</span>, <a title="Long" id="kafka.log;LogCleaner;CleanerThread.recordStats.to">to</a>: <span title="Long">Long</span>, <a title="kafka.log.CleanerStats" id="kafka.log;LogCleaner;CleanerThread.recordStats.stats">stats</a>: <a href="#kafka.log.CleanerStats.readResolve" title="kafka.log.CleanerStats">CleanerStats</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      this.<a href="#kafka.log;LogCleaner;CleanerThread.lastStats_=" title="(x$1: kafka.log.CleanerStats)Unit">lastStats</a> = <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>
      <a href="#kafka.log;LogCleaner;CleanerThread.cleaner" title="=&gt; kafka.log.Cleaner">cleaner</a>.<a href="#kafka.log;Cleaner.statsUnderlying" title="=&gt; (kafka.log.CleanerStats, kafka.log.CleanerStats)">statsUnderlying</a>.<span title="=&gt; (kafka.log.CleanerStats, kafka.log.CleanerStats)">swap</span>
      def <a title="(bytes: Double)Double" id="kafka.log;LogCleaner;CleanerThread.recordStats.mb">mb</a><span class="delimiter">(</span><a title="Double" id="kafka.log;LogCleaner;CleanerThread.recordStats.mb.bytes">bytes</a>: <span title="Double">Double</span><span class="delimiter">)</span> = <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.mb.bytes" title="Double">bytes</a> <span title="(x: Int)Double">/</span> <span class="delimiter">(</span><span class="int">1024</span><span title="Int(1048576)">*</span><span class="int">1024</span><span class="delimiter">)</span>
      val message = 
        <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%n\tLog cleaner thread %d cleaned log %s (dirty section = [%d, %d])%n&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.id" title="Int">id</a>, <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.name" title="String">name</a>, <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.from" title="Long">from</a>, <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.to" title="Long">to</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> 
        <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;\t%,.1f MB of log processed in %,.1f seconds (%,.1f MB/sec).%n&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.mb" title="(bytes: Double)Double">mb</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.bytesRead_=" title="=&gt; Double">bytesRead</a><span class="delimiter">)</span>, 
                                                                                <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.elapsedSecs" title="=&gt; Double">elapsedSecs</a>, 
                                                                                <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.mb" title="(bytes: Double)Double">mb</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.bytesRead_=" title="=&gt; Long">bytesRead</a><span title="(x: Double)Double">/</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.elapsedSecs" title="=&gt; Double">elapsedSecs</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> 
        <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;\tIndexed %,.1f MB in %.1f seconds (%,.1f Mb/sec, %.1f%% of total time)%n&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.mb" title="(bytes: Double)Double">mb</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.mapBytesRead_=" title="=&gt; Double">mapBytesRead</a><span class="delimiter">)</span>, 
                                                                                           <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.elapsedIndexSecs" title="=&gt; Double">elapsedIndexSecs</a>, 
                                                                                           <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.mb" title="(bytes: Double)Double">mb</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.mapBytesRead_=" title="=&gt; Double">mapBytesRead</a><span class="delimiter">)</span><span title="(x: Double)Double">/</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.elapsedIndexSecs" title="=&gt; Double">elapsedIndexSecs</a>, 
                                                                                           <span title="Int(100)" class="int">100</span> <span title="(x: Double)Double">*</span> <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.elapsedIndexSecs" title="=&gt; Double">elapsedIndexSecs</a>.<span title="=&gt; Double">toDouble</span><span title="(x: Double)Double">/</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.elapsedSecs" title="=&gt; Double">elapsedSecs</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> 
        <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;\tBuffer utilization: %.1f%%%n&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><span title="Int(100)" class="int">100</span> <span title="(x: Double)Double">*</span> <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.bufferUtilization_=" title="=&gt; Double">bufferUtilization</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span>
        <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;\tCleaned %,.1f MB in %.1f seconds (%,.1f Mb/sec, %.1f%% of total time)%n&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.mb" title="(bytes: Double)Double">mb</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.bytesRead_=" title="=&gt; Double">bytesRead</a><span class="delimiter">)</span>, 
                                                                                           <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.elapsedSecs" title="=&gt; Double">elapsedSecs</a> <span title="(x: Double)Double">-</span> <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.elapsedIndexSecs" title="=&gt; Double">elapsedIndexSecs</a>, 
                                                                                           <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.mb" title="(bytes: Double)Double">mb</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.bytesRead_=" title="=&gt; Double">bytesRead</a><span class="delimiter">)</span><span title="(x: Double)Double">/</span><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.elapsedSecs" title="=&gt; Double">elapsedSecs</a> <span title="(x: Double)Double">-</span> <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.elapsedIndexSecs" title="=&gt; Double">elapsedIndexSecs</a><span class="delimiter">)</span>, <span title="Int(100)" class="int">100</span> <span title="(x: Double)Double">*</span> <span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.elapsedSecs" title="=&gt; Double">elapsedSecs</a> <span title="(x: Double)Double">-</span> <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.elapsedIndexSecs" title="=&gt; Double">elapsedIndexSecs</a><span class="delimiter">)</span>.<span title="=&gt; Double">toDouble</span><span title="(x: Double)Double">/</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.elapsedSecs" title="=&gt; Double">elapsedSecs</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> 
        <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;\tStart size: %,.1f MB (%,d messages)%n&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.mb" title="(bytes: Double)Double">mb</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.bytesRead_=" title="=&gt; Double">bytesRead</a><span class="delimiter">)</span>, <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.messagesRead_=" title="=&gt; Long">messagesRead</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span>
        <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;\tEnd size: %,.1f MB (%,d messages)%n&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.mb" title="(bytes: Double)Double">mb</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.bytesWritten_=" title="=&gt; Double">bytesWritten</a><span class="delimiter">)</span>, <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.messagesWritten_=" title="=&gt; Long">messagesWritten</a><span class="delimiter">)</span> <a title="String" id="kafka.log;LogCleaner;CleanerThread.recordStats.message">+</a> 
        <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;\t%.1f%% size reduction (%.1f%% fewer messages)%n&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><span title="Double(100.0)" class="double">100.0</span> <span title="(x: Double)Double">*</span> <span class="delimiter">(</span><span title="Double(1.0)" class="double">1.0</span> <span title="(x: Double)Double">-</span> <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.bytesWritten_=" title="=&gt; Long">bytesWritten</a>.<span title="=&gt; Double">toDouble</span><span title="(x: Long)Double">/</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.bytesRead_=" title="=&gt; Long">bytesRead</a><span class="delimiter">)</span>, 
                                                                   <span title="Double(100.0)" class="double">100.0</span> <span title="(x: Double)Double">*</span> <span class="delimiter">(</span><span title="Double(1.0)" class="double">1.0</span> <span title="(x: Double)Double">-</span> <a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.messagesWritten_=" title="=&gt; Long">messagesWritten</a>.<span title="=&gt; Double">toDouble</span><span title="(x: Long)Double">/</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.stats" title="kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.messagesRead_=" title="=&gt; Long">messagesRead</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><a href="#kafka.log;LogCleaner;CleanerThread.recordStats.message" title="String">message</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
   
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * This class holds the actual logic for cleaning a log
 * @param id An identifier used for logging
 * @param offsetMap The map used for deduplication
 * @param bufferSize The size of the buffers to use. Memory usage will be 2x this number as there is a read and write buffer.
 * @param throttler The throttler instance to use for limiting I/O rate.
 * @param time The time instance
 */</span>
private<span class="delimiter">[</span>log<span class="delimiter">]</span> class <a title="class Cleaner extends AnyRef with kafka.utils.Logging" id="kafka.log;Cleaner">Cleaner</a><a href="#kafka.log;Cleaner" title="kafka.log.Cleaner" class="delimiter">(</a>val <a title="Int" id="kafka.log;Cleaner.id">id</a>: <span title="Int">Int</span>,
                           val <a title="kafka.log.OffsetMap" id="kafka.log;Cleaner.offsetMap">offsetMap</a>: <a href="OffsetMap.scala.html#kafka.log;OffsetMap" title="kafka.log.OffsetMap">OffsetMap</a>,
                           <a title="Int" id="kafka.log;Cleaner.ioBufferSize">ioBufferSize</a>: <span title="Int">Int</span>,
                           <a title="Int" id="kafka.log;Cleaner.maxIoBufferSize">maxIoBufferSize</a>: <span title="Int">Int</span>,
                           <a title="Double" id="kafka.log;Cleaner.dupBufferLoadFactor">dupBufferLoadFactor</a>: <span title="Double">Double</span>,
                           <a title="kafka.utils.Throttler" id="kafka.log;Cleaner.throttler">throttler</a>: <a href="../utils/Throttler.scala.html#kafka.utils;Throttler" title="kafka.utils.Throttler">Throttler</a>,
                           <a title="kafka.utils.Time" id="kafka.log;Cleaner.time">time</a>: <a href="../utils/Time.scala.html#kafka.utils;Time" title="kafka.utils.Time">Time</a>,
                           <a title="kafka.common.TopicAndPartition =&gt; Unit" id="kafka.log;Cleaner.checkDone">checkDone</a>: <span class="delimiter">(</span>TopicAndPartition<span class="delimiter">)</span> =&gt; Unit<span class="delimiter">)</span> extends <a href="../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> <span class="delimiter">{</span>
  
  override val <a title="String" id="kafka.log;Cleaner.loggerName">loggerName</a> = classOf<span title="Class[kafka.log.LogCleaner](classOf[kafka.log.LogCleaner])" class="delimiter">[</span>LogCleaner<span class="delimiter">]</span>.<span title="()String">getName</span>

  this.<a href="../utils/Logging.scala.html#kafka.utils;Logging.logIdent_=" title="(x$1: String)Unit">logIdent</a> = <span title="String(&quot;Cleaner &quot;)" class="string">&quot;Cleaner &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;Cleaner.id" title="=&gt; Int">id</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;: &quot;)" class="string">&quot;: &quot;</span>
  
  <span class="comment">/* cleaning stats - one instance for the current (or next) cleaning cycle and one for the last completed cycle */</span>
  val <a title="(kafka.log.CleanerStats, kafka.log.CleanerStats)" id="kafka.log;Cleaner.statsUnderlying">statsUnderlying</a> = <span title="(_1: kafka.log.CleanerStats, _2: kafka.log.CleanerStats)(kafka.log.CleanerStats, kafka.log.CleanerStats)" class="delimiter">(</span>new <a href="#kafka.log.CleanerStats.readResolve" title="kafka.log.CleanerStats">CleanerStats</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.time" title="kafka.utils.Time">time</a><span class="delimiter">)</span>, new <a href="#kafka.log.CleanerStats.readResolve" title="kafka.log.CleanerStats">CleanerStats</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.time" title="kafka.utils.Time">time</a><span class="delimiter">)</span><span class="delimiter">)</span>
  def <a title="=&gt; kafka.log.CleanerStats" id="kafka.log;Cleaner.stats">stats</a> = <a href="#kafka.log;Cleaner.statsUnderlying" title="=&gt; (kafka.log.CleanerStats, kafka.log.CleanerStats)">statsUnderlying</a>.<span title="=&gt; kafka.log.CleanerStats">_1</span>

  <span class="comment">/* buffer used for read i/o */</span>
  private var <a title="java.nio.ByteBuffer" id="kafka.log;Cleaner.readBuffer_=">readBuffer</a> = <span title="java.nio.ByteBuffer.type">ByteBuffer</span>.<span title="(x$1: Int)java.nio.ByteBuffer">allocate</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.ioBufferSize" title="Int">ioBufferSize</a><span class="delimiter">)</span>
  
  <span class="comment">/* buffer used for write i/o */</span>
  private var <a title="java.nio.ByteBuffer" id="kafka.log;Cleaner.writeBuffer_=">writeBuffer</a> = <span title="java.nio.ByteBuffer.type">ByteBuffer</span>.<span title="(x$1: Int)java.nio.ByteBuffer">allocate</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.ioBufferSize" title="Int">ioBufferSize</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Clean the given log
   *
   * @param cleanable The log to be cleaned
   *
   * @return The first offset not cleaned
   */</span>
  private<span class="delimiter">[</span>log<span class="delimiter">]</span> def <a title="(cleanable: kafka.log.LogToClean)Long" id="kafka.log;Cleaner.clean">clean</a><span class="delimiter">(</span><a title="kafka.log.LogToClean" id="kafka.log;Cleaner.clean.cleanable">cleanable</a>: <a href="#kafka.log.LogToClean.readResolve" title="kafka.log.LogToClean">LogToClean</a><span class="delimiter">)</span>: <span title="Long">Long</span> = <span class="delimiter">{</span>
    <a href="#kafka.log;Cleaner.stats" title="=&gt; kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.clear" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Beginning cleaning of log %s.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.clean.cleanable" title="kafka.log.LogToClean">cleanable</a>.<a href="#kafka.log;LogToClean.log" title="=&gt; kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.name" title="=&gt; String">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
    val <a title="kafka.log.Log" id="kafka.log;Cleaner.clean.log">log</a> = <a href="#kafka.log;Cleaner.clean.cleanable" title="kafka.log.LogToClean">cleanable</a>.<a href="#kafka.log;LogToClean.log" title="=&gt; kafka.log.Log">log</a>

    <span class="comment">// build the offset map</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Building offset map for %s...&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.clean.cleanable" title="kafka.log.LogToClean">cleanable</a>.<a href="#kafka.log;LogToClean.log" title="=&gt; kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.name" title="=&gt; String">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
    val <a title="Long" id="kafka.log;Cleaner.clean.upperBoundOffset">upperBoundOffset</a> = <a href="#kafka.log;Cleaner.clean.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.activeSegment" title="=&gt; kafka.log.LogSegment">activeSegment</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.baseOffset" title="=&gt; Long">baseOffset</a>
    val endOffset = <a href="#kafka.log;Cleaner.buildOffsetMap" title="(log: kafka.log.Log, start: Long, end: Long, map: kafka.log.OffsetMap)Long">buildOffsetMap</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.clean.log" title="kafka.log.Log">log</a>, <a href="#kafka.log;Cleaner.clean.cleanable" title="kafka.log.LogToClean">cleanable</a>.<a href="#kafka.log;LogToClean.firstDirtyOffset" title="=&gt; Long">firstDirtyOffset</a>, <a href="#kafka.log;Cleaner.clean.upperBoundOffset" title="Long">upperBoundOffset</a>, <a href="#kafka.log;Cleaner.offsetMap" title="=&gt; kafka.log.OffsetMap">offsetMap</a><span class="delimiter">)</span> <a title="Long" id="kafka.log;Cleaner.clean.endOffset">+</a> <span title="Int(1)" class="int">1</span>
    <a href="#kafka.log;Cleaner.stats" title="=&gt; kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.indexDone" title="()Unit">indexDone</a><span class="delimiter">(</span><span class="delimiter">)</span>
    
    <span class="comment">// figure out the timestamp below which it is safe to remove delete tombstones</span>
    <span class="comment">// this position is defined to be a configurable time beneath the last modified time of the last clean segment</span>
    val <a title="Long" id="kafka.log;Cleaner.clean.deleteHorizonMs">deleteHorizonMs</a> = 
      <a href="#kafka.log;Cleaner.clean.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.logSegments(3f205903bd)" title="(from: Long, to: Long)Iterable[kafka.log.LogSegment]">logSegments</a><span class="delimiter">(</span><span title="Long(0L)" class="int">0</span>, <a href="#kafka.log;Cleaner.clean.cleanable" title="kafka.log.LogToClean">cleanable</a>.<a href="#kafka.log;LogToClean.firstDirtyOffset" title="=&gt; Long">firstDirtyOffset</a><span class="delimiter">)</span>.<span title="=&gt; Option[kafka.log.LogSegment]">lastOption</span> match <span class="delimiter">{</span>
        case <span title="None.type">None</span> =&gt; <span title="Long(0L)" class="long">0L</span>
        case Some<span class="delimiter">(</span><a title="kafka.log.LogSegment" id="kafka.log;Cleaner.clean.deleteHorizonMs.seg">seg</a><span class="delimiter">)</span> =&gt; <a href="#kafka.log;Cleaner.clean.deleteHorizonMs.seg" title="kafka.log.LogSegment">seg</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.lastModified" title="=&gt; Long">lastModified</a> <span title="(x: Long)Long">-</span> <a href="#kafka.log;Cleaner.clean.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.config" title="=&gt; kafka.log.LogConfig">config</a>.<a href="LogConfig.scala.html#kafka.log;LogConfig.deleteRetentionMs" title="=&gt; Long">deleteRetentionMs</a>
    <span class="delimiter">}</span>
        
    <span class="comment">// group the segments and clean the groups</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Cleaning log %s (discarding tombstones prior to %s)...&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.clean.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.name" title="=&gt; String">name</a>, new <span title="java.util.Date">Date</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.clean.deleteHorizonMs" title="Long">deleteHorizonMs</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    for <span class="delimiter">(</span><a title="Seq[kafka.log.LogSegment]" id="kafka.log;Cleaner.clean.$anonfun.group">group</a> &lt;- <a href="#kafka.log;Cleaner.groupSegmentsBySize" title="(segments: Iterable[kafka.log.LogSegment], maxSize: Int, maxIndexSize: Int)List[Seq[kafka.log.LogSegment]]">groupSegmentsBySize</a><span title="(f: Seq[kafka.log.LogSegment] =&gt; Unit)Unit" class="delimiter">(</span><a href="#kafka.log;Cleaner.clean.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.logSegments(3f205903bd)" title="(from: Long, to: Long)Iterable[kafka.log.LogSegment]">logSegments</a><span class="delimiter">(</span><span title="Long(0L)" class="int">0</span>, <a href="#kafka.log;Cleaner.clean.endOffset" title="Long">endOffset</a><span class="delimiter">)</span>, <a href="#kafka.log;Cleaner.clean.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.config" title="=&gt; kafka.log.LogConfig">config</a>.<a href="LogConfig.scala.html#kafka.log;LogConfig.segmentSize" title="=&gt; Int">segmentSize</a>, <a href="#kafka.log;Cleaner.clean.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.config" title="=&gt; kafka.log.LogConfig">config</a>.<a href="LogConfig.scala.html#kafka.log;LogConfig.maxIndexSize" title="=&gt; Int">maxIndexSize</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.log;Cleaner.cleanSegments" title="(log: kafka.log.Log, segments: Seq[kafka.log.LogSegment], map: kafka.log.OffsetMap, deleteHorizonMs: Long)Unit">cleanSegments</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.clean.log" title="kafka.log.Log">log</a>, <a href="#kafka.log;Cleaner.clean.$anonfun.group" title="Seq[kafka.log.LogSegment]">group</a>, <a href="#kafka.log;Cleaner.offsetMap" title="=&gt; kafka.log.OffsetMap">offsetMap</a>, <a href="#kafka.log;Cleaner.clean.deleteHorizonMs" title="Long">deleteHorizonMs</a><span class="delimiter">)</span>
      
    <span class="comment">// record buffer utilization</span>
    <a href="#kafka.log;Cleaner.stats" title="=&gt; kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.bufferUtilization_=" title="(x$1: Double)Unit">bufferUtilization</a> = <a href="#kafka.log;Cleaner.offsetMap" title="=&gt; kafka.log.OffsetMap">offsetMap</a>.<a href="OffsetMap.scala.html#kafka.log;OffsetMap.utilization" title="=&gt; Double">utilization</a>
    
    <a href="#kafka.log;Cleaner.stats" title="=&gt; kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.allDone" title="()Unit">allDone</a><span class="delimiter">(</span><span class="delimiter">)</span>

    <a href="#kafka.log;Cleaner.clean.endOffset" title="Long">endOffset</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Clean a group of segments into a single replacement segment
   *
   * @param log The log being cleaned
   * @param segments The group of segments being cleaned
   * @param map The offset map to use for cleaning segments
   * @param deleteHorizonMs The time to retain delete tombstones
   */</span>
  private<span class="delimiter">[</span>log<span class="delimiter">]</span> def <a title="(log: kafka.log.Log, segments: Seq[kafka.log.LogSegment], map: kafka.log.OffsetMap, deleteHorizonMs: Long)Unit" id="kafka.log;Cleaner.cleanSegments">cleanSegments</a><span class="delimiter">(</span><a title="kafka.log.Log" id="kafka.log;Cleaner.cleanSegments.log">log</a>: <a href="Log.scala.html#kafka.log;Log" title="kafka.log.Log">Log</a>,
                                 <a title="Seq[kafka.log.LogSegment]" id="kafka.log;Cleaner.cleanSegments.segments">segments</a>: <span title="Seq[kafka.log.LogSegment]">Seq</span><span class="delimiter">[</span>LogSegment<span class="delimiter">]</span>, 
                                 <a title="kafka.log.OffsetMap" id="kafka.log;Cleaner.cleanSegments.map">map</a>: <a href="OffsetMap.scala.html#kafka.log;OffsetMap" title="kafka.log.OffsetMap">OffsetMap</a>, 
                                 <a title="Long" id="kafka.log;Cleaner.cleanSegments.deleteHorizonMs">deleteHorizonMs</a>: <span title="Long">Long</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">// create a new segment with the suffix .cleaned appended to both the log and index name</span>
    val <a title="java.io.File" id="kafka.log;Cleaner.cleanSegments.logFile">logFile</a> = new <span title="java.io.File">File</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanSegments.segments" title="Seq[kafka.log.LogSegment]">segments</a>.<span title="=&gt; kafka.log.LogSegment">head</span>.<a href="LogSegment.scala.html#kafka.log;LogSegment.log" title="=&gt; kafka.log.FileMessageSet">log</a>.<a href="FileMessageSet.scala.html#kafka.log;FileMessageSet.file" title="=&gt; java.io.File">file</a>.<span title="()String">getPath</span> <span title="(x$1: Any)String">+</span> <a href="Log.scala.html#kafka.log.Log" title="kafka.log.Log.type">Log</a>.<a href="Log.scala.html#kafka.log.Log.CleanedFileSuffix" title="=&gt; String">CleanedFileSuffix</a><span class="delimiter">)</span>
    <a href="#kafka.log;Cleaner.cleanSegments.logFile" title="java.io.File">logFile</a>.<span title="()Boolean">delete</span><span class="delimiter">(</span><span class="delimiter">)</span>
    val <a title="java.io.File" id="kafka.log;Cleaner.cleanSegments.indexFile">indexFile</a> = new <span title="java.io.File">File</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanSegments.segments" title="Seq[kafka.log.LogSegment]">segments</a>.<span title="=&gt; kafka.log.LogSegment">head</span>.<a href="LogSegment.scala.html#kafka.log;LogSegment.index" title="=&gt; kafka.log.OffsetIndex">index</a>.<a href="OffsetIndex.scala.html#kafka.log;OffsetIndex.file" title="=&gt; java.io.File">file</a>.<span title="()String">getPath</span> <span title="(x$1: Any)String">+</span> <a href="Log.scala.html#kafka.log.Log" title="kafka.log.Log.type">Log</a>.<a href="Log.scala.html#kafka.log.Log.CleanedFileSuffix" title="=&gt; String">CleanedFileSuffix</a><span class="delimiter">)</span>
    <a href="#kafka.log;Cleaner.cleanSegments.indexFile" title="java.io.File">indexFile</a>.<span title="()Boolean">delete</span><span class="delimiter">(</span><span class="delimiter">)</span>
    val <a title="kafka.log.FileMessageSet" id="kafka.log;Cleaner.cleanSegments.messages">messages</a> = new <a href="FileMessageSet.scala.html#kafka.log;FileMessageSet" title="kafka.log.FileMessageSet">FileMessageSet</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanSegments.logFile" title="java.io.File">logFile</a><span class="delimiter">)</span>
    val <a title="kafka.log.OffsetIndex" id="kafka.log;Cleaner.cleanSegments.index">index</a> = new <a href="OffsetIndex.scala.html#kafka.log;OffsetIndex" title="kafka.log.OffsetIndex">OffsetIndex</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanSegments.indexFile" title="java.io.File">indexFile</a>, <a href="#kafka.log;Cleaner.cleanSegments.segments" title="Seq[kafka.log.LogSegment]">segments</a>.<span title="=&gt; kafka.log.LogSegment">head</span>.<a href="LogSegment.scala.html#kafka.log;LogSegment.baseOffset" title="=&gt; Long">baseOffset</a>, <a href="#kafka.log;Cleaner.cleanSegments.segments" title="Seq[kafka.log.LogSegment]">segments</a>.<span title="=&gt; kafka.log.LogSegment">head</span>.<a href="LogSegment.scala.html#kafka.log;LogSegment.index" title="=&gt; kafka.log.OffsetIndex">index</a>.<a href="OffsetIndex.scala.html#kafka.log;OffsetIndex.maxIndexSize" title="=&gt; Int">maxIndexSize</a><span class="delimiter">)</span>
    val <a title="kafka.log.LogSegment" id="kafka.log;Cleaner.cleanSegments.cleaned">cleaned</a> = new <a href="LogSegment.scala.html#kafka.log;LogSegment" title="kafka.log.LogSegment">LogSegment</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanSegments.messages" title="kafka.log.FileMessageSet">messages</a>, <a href="#kafka.log;Cleaner.cleanSegments.index" title="kafka.log.OffsetIndex">index</a>, <a href="#kafka.log;Cleaner.cleanSegments.segments" title="Seq[kafka.log.LogSegment]">segments</a>.<span title="=&gt; kafka.log.LogSegment">head</span>.<a href="LogSegment.scala.html#kafka.log;LogSegment.baseOffset" title="=&gt; Long">baseOffset</a>, <a href="#kafka.log;Cleaner.cleanSegments.segments" title="Seq[kafka.log.LogSegment]">segments</a>.<span title="=&gt; kafka.log.LogSegment">head</span>.<a href="LogSegment.scala.html#kafka.log;LogSegment.indexIntervalBytes" title="=&gt; Int">indexIntervalBytes</a>, <a href="#kafka.log;Cleaner.cleanSegments.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.config" title="=&gt; kafka.log.LogConfig">config</a>.<a href="LogConfig.scala.html#kafka.log;LogConfig.randomSegmentJitter" title="=&gt; Long">randomSegmentJitter</a>, <a href="#kafka.log;Cleaner.time" title="kafka.utils.Time">time</a><span class="delimiter">)</span>

    try <span class="delimiter">{</span>
      <span class="comment">// clean segments into the new destination segment</span>
      for <span class="delimiter">(</span><a title="kafka.log.LogSegment" id="kafka.log;Cleaner.cleanSegments.$anonfun.old">old</a> &lt;- <a href="#kafka.log;Cleaner.cleanSegments.segments" title="(f: kafka.log.LogSegment =&gt; Unit)Unit">segments</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val retainDeletes = <a href="#kafka.log;Cleaner.cleanSegments.$anonfun.old" title="kafka.log.LogSegment">old</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.lastModified" title="=&gt; Long">lastModified</a> <a title="Boolean" id="kafka.log;Cleaner.cleanSegments.$anonfun.retainDeletes">&gt;</a> <a href="#kafka.log;Cleaner.cleanSegments.deleteHorizonMs" title="Long">deleteHorizonMs</a>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Cleaning segment %s in log %s (last modified %s) into %s, %s deletes.&quot;</span>
            .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanSegments.$anonfun.old" title="kafka.log.LogSegment">old</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.baseOffset" title="=&gt; Long">baseOffset</a>, <a href="#kafka.log;Cleaner.cleanSegments.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.name" title="=&gt; String">name</a>, new <span title="java.util.Date">Date</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanSegments.$anonfun.old" title="kafka.log.LogSegment">old</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.lastModified" title="=&gt; Long">lastModified</a><span class="delimiter">)</span>, <a href="#kafka.log;Cleaner.cleanSegments.cleaned" title="kafka.log.LogSegment">cleaned</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.baseOffset" title="=&gt; Long">baseOffset</a>, if<span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanSegments.$anonfun.retainDeletes" title="Boolean">retainDeletes</a><span class="delimiter">)</span> <span title="String(&quot;retaining&quot;)" class="string">&quot;retaining&quot;</span> else <span title="String(&quot;discarding&quot;)" class="string">&quot;discarding&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#kafka.log;Cleaner.cleanInto" title="(topicAndPartition: kafka.common.TopicAndPartition, source: kafka.log.LogSegment, dest: kafka.log.LogSegment, map: kafka.log.OffsetMap, retainDeletes: Boolean)Unit">cleanInto</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanSegments.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.topicAndPartition" title="=&gt; kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.log;Cleaner.cleanSegments.$anonfun.old" title="kafka.log.LogSegment">old</a>, <a href="#kafka.log;Cleaner.cleanSegments.cleaned" title="kafka.log.LogSegment">cleaned</a>, <a href="#kafka.log;Cleaner.cleanSegments.map" title="kafka.log.OffsetMap">map</a>, <a href="#kafka.log;Cleaner.cleanSegments.$anonfun.retainDeletes" title="Boolean">retainDeletes</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="comment">// trim excess index</span>
      <a href="#kafka.log;Cleaner.cleanSegments.index" title="kafka.log.OffsetIndex">index</a>.<a href="OffsetIndex.scala.html#kafka.log;OffsetIndex.trimToValidSize" title="()Unit">trimToValidSize</a><span class="delimiter">(</span><span class="delimiter">)</span>

      <span class="comment">// flush new segment to disk before swap</span>
      <a href="#kafka.log;Cleaner.cleanSegments.cleaned" title="kafka.log.LogSegment">cleaned</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.flush" title="()Unit">flush</a><span class="delimiter">(</span><span class="delimiter">)</span>

      <span class="comment">// update the modification date to retain the last modified date of the original files</span>
      val <a title="Long" id="kafka.log;Cleaner.cleanSegments.modified">modified</a> = <a href="#kafka.log;Cleaner.cleanSegments.segments" title="Seq[kafka.log.LogSegment]">segments</a>.<span title="=&gt; kafka.log.LogSegment">last</span>.<a href="LogSegment.scala.html#kafka.log;LogSegment.lastModified" title="=&gt; Long">lastModified</a>
      <a href="#kafka.log;Cleaner.cleanSegments.cleaned" title="kafka.log.LogSegment">cleaned</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.lastModified_=" title="(ms: Long)Boolean">lastModified</a> = <a href="#kafka.log;Cleaner.cleanSegments.modified" title="Long">modified</a>

      <span class="comment">// swap in new segment</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Swapping in cleaned segment %d for segment(s) %s in log %s.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanSegments.cleaned" title="kafka.log.LogSegment">cleaned</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.baseOffset" title="=&gt; Long">baseOffset</a>, <a href="#kafka.log;Cleaner.cleanSegments.segments" title="Seq[kafka.log.LogSegment]">segments</a>.<span title="(f: kafka.log.LogSegment =&gt; Long)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.log.LogSegment],Long,Seq[Long]])Seq[Long]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,Long,Seq[Long]]" class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanSegments.$anonfun.x$11" title="kafka.log.LogSegment">_</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.baseOffset" title="=&gt; Long">baseOffset</a><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>, <a href="#kafka.log;Cleaner.cleanSegments.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.name" title="=&gt; String">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.log;Cleaner.cleanSegments.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.replaceSegments" title="(newSegment: kafka.log.LogSegment, oldSegments: Seq[kafka.log.LogSegment])Unit">replaceSegments</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanSegments.cleaned" title="kafka.log.LogSegment">cleaned</a>, <a href="#kafka.log;Cleaner.cleanSegments.segments" title="Seq[kafka.log.LogSegment]">segments</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> catch <span class="delimiter">{</span>
      case <a title="kafka.common.LogCleaningAbortedException" id="kafka.log;Cleaner.cleanSegments.e">e</a>: <a href="../common/LogCleaningAbortedException.scala.html#kafka.common;LogCleaningAbortedException" title="kafka.common.LogCleaningAbortedException">LogCleaningAbortedException</a> =&gt;
        <a href="#kafka.log;Cleaner.cleanSegments.cleaned" title="kafka.log.LogSegment">cleaned</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.delete" title="()Unit">delete</a><span class="delimiter">(</span><span class="delimiter">)</span>
        throw  <a href="#kafka.log;Cleaner.cleanSegments.e" title="kafka.common.LogCleaningAbortedException">e</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Clean the given source log segment into the destination segment using the key=&gt;offset mapping
   * provided
   *
   * @param source The dirty log segment
   * @param dest The cleaned log segment
   * @param map The key=&gt;offset mapping
   * @param retainDeletes Should delete tombstones be retained while cleaning this segment
   *
   * TODO: Implement proper compression support
   */</span>
  private<span class="delimiter">[</span>log<span class="delimiter">]</span> def <a title="(topicAndPartition: kafka.common.TopicAndPartition, source: kafka.log.LogSegment, dest: kafka.log.LogSegment, map: kafka.log.OffsetMap, retainDeletes: Boolean)Unit" id="kafka.log;Cleaner.cleanInto">cleanInto</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.log;Cleaner.cleanInto.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a>, <a title="kafka.log.LogSegment" id="kafka.log;Cleaner.cleanInto.source">source</a>: <a href="LogSegment.scala.html#kafka.log;LogSegment" title="kafka.log.LogSegment">LogSegment</a>,
                             <a title="kafka.log.LogSegment" id="kafka.log;Cleaner.cleanInto.dest">dest</a>: <a href="LogSegment.scala.html#kafka.log;LogSegment" title="kafka.log.LogSegment">LogSegment</a>, <a title="kafka.log.OffsetMap" id="kafka.log;Cleaner.cleanInto.map">map</a>: <a href="OffsetMap.scala.html#kafka.log;OffsetMap" title="kafka.log.OffsetMap">OffsetMap</a>, <a title="Boolean" id="kafka.log;Cleaner.cleanInto.retainDeletes">retainDeletes</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    var <a title="Int" id="kafka.log;Cleaner.cleanInto.position">position</a> = <span title="Int(0)" class="int">0</span>
    while <span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanInto.position" title="Int">position</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#kafka.log;Cleaner.cleanInto.source" title="kafka.log.LogSegment">source</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.log" title="=&gt; kafka.log.FileMessageSet">log</a>.<a href="FileMessageSet.scala.html#kafka.log;FileMessageSet.sizeInBytes" title="()Int">sizeInBytes</a><span class="delimiter">)</span> <a href="#kafka.log;Cleaner.cleanInto.while$2" title="()Unit" class="delimiter">{</a>
      <a href="#kafka.log;Cleaner.checkDone" title="(v1: kafka.common.TopicAndPartition)Unit">checkDone</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanInto.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
      <span class="comment">// read a chunk of messages and copy any that are to be retained to the write buffer to be written out</span>
      <a href="#kafka.log;Cleaner.readBuffer_=" title="=&gt; java.nio.ByteBuffer">readBuffer</a>.<span title="()java.nio.Buffer">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#kafka.log;Cleaner.writeBuffer_=" title="=&gt; java.nio.ByteBuffer">writeBuffer</a>.<span title="()java.nio.Buffer">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
      val <a title="kafka.message.ByteBufferMessageSet" id="kafka.log;Cleaner.cleanInto.messages">messages</a> = new <a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet">ByteBufferMessageSet</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanInto.source" title="kafka.log.LogSegment">source</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.log" title="=&gt; kafka.log.FileMessageSet">log</a>.<a href="FileMessageSet.scala.html#kafka.log;FileMessageSet.readInto" title="(buffer: java.nio.ByteBuffer, relativePosition: Int)java.nio.ByteBuffer">readInto</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.readBuffer_=" title="=&gt; java.nio.ByteBuffer">readBuffer</a>, <a href="#kafka.log;Cleaner.cleanInto.position" title="Int">position</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.log;Cleaner.throttler" title="kafka.utils.Throttler">throttler</a>.<a href="../utils/Throttler.scala.html#kafka.utils;Throttler.maybeThrottle" title="(observed: Double)Unit">maybeThrottle</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanInto.messages" title="kafka.message.ByteBufferMessageSet">messages</a>.<a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet.sizeInBytes" title="=&gt; Double">sizeInBytes</a><span class="delimiter">)</span>
      <span class="comment">// check each message to see if it is to be retained</span>
      var <a title="Int" id="kafka.log;Cleaner.cleanInto.messagesRead">messagesRead</a> = <span title="Int(0)" class="int">0</span>
      for <span class="delimiter">(</span><a title="kafka.message.MessageAndOffset" id="kafka.log;Cleaner.cleanInto.$anonfun.entry">entry</a> &lt;- <a href="#kafka.log;Cleaner.cleanInto.messages" title="(f: kafka.message.MessageAndOffset =&gt; Unit)Unit">messages</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#kafka.log;Cleaner.cleanInto.messagesRead" title="Int">messagesRead</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
        val <a title="Int" id="kafka.log;Cleaner.cleanInto.$anonfun.size">size</a> = <a href="../message/MessageSet.scala.html#kafka.message.MessageSet" title="kafka.message.MessageSet.type">MessageSet</a>.<a href="../message/MessageSet.scala.html#kafka.message.MessageSet.entrySize" title="(message: kafka.message.Message)Int">entrySize</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanInto.$anonfun.entry" title="kafka.message.MessageAndOffset">entry</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a><span class="delimiter">)</span>
        <a href="#kafka.log;Cleaner.cleanInto.position" title="Int">position</a> <span title="(x: Int)Int">+=</span> <a href="#kafka.log;Cleaner.cleanInto.$anonfun.size" title="Int">size</a>
        <a href="#kafka.log;Cleaner.stats" title="=&gt; kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.readMessage" title="(size: Int)Unit">readMessage</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanInto.$anonfun.size" title="Int">size</a><span class="delimiter">)</span>
        val <a title="java.nio.ByteBuffer" id="kafka.log;Cleaner.cleanInto.$anonfun.key">key</a> = <a href="#kafka.log;Cleaner.cleanInto.$anonfun.entry" title="kafka.message.MessageAndOffset">entry</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a>.<a href="../message/Message.scala.html#kafka.message;Message.key" title="=&gt; java.nio.ByteBuffer">key</a>
        <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanInto.$anonfun.key" title="java.nio.ByteBuffer">key</a> <span title="(x$1: Any)Boolean">!=</span> null, <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Found null key in log segment %s which is marked as dedupe.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanInto.source" title="kafka.log.LogSegment">source</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.log" title="=&gt; kafka.log.FileMessageSet">log</a>.<a href="FileMessageSet.scala.html#kafka.log;FileMessageSet.file" title="=&gt; java.io.File">file</a>.<span title="()String">getAbsolutePath</span><span class="delimiter">)</span><span class="delimiter">)</span>
        val <a title="Long" id="kafka.log;Cleaner.cleanInto.$anonfun.foundOffset">foundOffset</a> = <a href="#kafka.log;Cleaner.cleanInto.map" title="kafka.log.OffsetMap">map</a>.<a href="OffsetMap.scala.html#kafka.log;OffsetMap.get" title="(key: java.nio.ByteBuffer)Long">get</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanInto.$anonfun.key" title="java.nio.ByteBuffer">key</a><span class="delimiter">)</span>
        <span class="comment">/* two cases in which we can get rid of a message:
         *   1) if there exists a message with the same key but higher offset
         *   2) if the message is a delete &quot;tombstone&quot; marker and enough time has passed
         */</span>
        val redundant = <a href="#kafka.log;Cleaner.cleanInto.$anonfun.foundOffset" title="Long">foundOffset</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span> <a title="Boolean" id="kafka.log;Cleaner.cleanInto.$anonfun.redundant">&amp;&amp;</a> <a href="#kafka.log;Cleaner.cleanInto.$anonfun.entry" title="kafka.message.MessageAndOffset">entry</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.offset" title="=&gt; Long">offset</a> <span title="(x: Long)Boolean">&lt;</span> <a href="#kafka.log;Cleaner.cleanInto.$anonfun.foundOffset" title="Long">foundOffset</a>
        val obsoleteDelete = <span title="=&gt; Boolean">!</span><a href="#kafka.log;Cleaner.cleanInto.retainDeletes" title="Boolean">retainDeletes</a> <a title="Boolean" id="kafka.log;Cleaner.cleanInto.$anonfun.obsoleteDelete">&amp;&amp;</a> <a href="#kafka.log;Cleaner.cleanInto.$anonfun.entry" title="kafka.message.MessageAndOffset">entry</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a>.<a href="../message/Message.scala.html#kafka.message;Message.isNull" title="()Boolean">isNull</a>
        if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.log;Cleaner.cleanInto.$anonfun.redundant" title="Boolean">redundant</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#kafka.log;Cleaner.cleanInto.$anonfun.obsoleteDelete" title="Boolean">obsoleteDelete</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="../message/ByteBufferMessageSet.scala.html#kafka.message.ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet.type">ByteBufferMessageSet</a>.<a href="../message/ByteBufferMessageSet.scala.html#kafka.message.ByteBufferMessageSet.writeMessage" title="(buffer: java.nio.ByteBuffer, message: kafka.message.Message, offset: Long)Unit">writeMessage</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.writeBuffer_=" title="=&gt; java.nio.ByteBuffer">writeBuffer</a>, <a href="#kafka.log;Cleaner.cleanInto.$anonfun.entry" title="kafka.message.MessageAndOffset">entry</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a>, <a href="#kafka.log;Cleaner.cleanInto.$anonfun.entry" title="kafka.message.MessageAndOffset">entry</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.offset" title="=&gt; Long">offset</a><span class="delimiter">)</span>
          <a href="#kafka.log;Cleaner.stats" title="=&gt; kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.recopyMessage" title="(size: Int)Unit">recopyMessage</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanInto.$anonfun.size" title="Int">size</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span class="comment">// if any messages are to be retained, write them out</span>
      if<span class="delimiter">(</span><a href="#kafka.log;Cleaner.writeBuffer_=" title="=&gt; java.nio.ByteBuffer">writeBuffer</a>.<span title="()Int">position</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#kafka.log;Cleaner.writeBuffer_=" title="=&gt; java.nio.ByteBuffer">writeBuffer</a>.<span title="()java.nio.Buffer">flip</span><span class="delimiter">(</span><span class="delimiter">)</span>
        val <a title="kafka.message.ByteBufferMessageSet" id="kafka.log;Cleaner.cleanInto.retained">retained</a> = new <a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet">ByteBufferMessageSet</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.writeBuffer_=" title="=&gt; java.nio.ByteBuffer">writeBuffer</a><span class="delimiter">)</span>
        <a href="#kafka.log;Cleaner.cleanInto.dest" title="kafka.log.LogSegment">dest</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.append" title="(offset: Long, messages: kafka.message.ByteBufferMessageSet)Unit">append</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.cleanInto.retained" title="kafka.message.ByteBufferMessageSet">retained</a>.<span title="=&gt; kafka.message.MessageAndOffset">head</span>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.offset" title="=&gt; Long">offset</a>, <a href="#kafka.log;Cleaner.cleanInto.retained" title="kafka.message.ByteBufferMessageSet">retained</a><span class="delimiter">)</span>
        <a href="#kafka.log;Cleaner.throttler" title="kafka.utils.Throttler">throttler</a>.<a href="../utils/Throttler.scala.html#kafka.utils;Throttler.maybeThrottle" title="(observed: Double)Unit">maybeThrottle</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.writeBuffer_=" title="=&gt; java.nio.ByteBuffer">writeBuffer</a>.<span title="=&gt; Double">limit</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      
      <span class="comment">// if we read bytes but didn't get even one complete message, our I/O buffer is too small, grow it and try again</span>
      if<span class="delimiter">(</span><a href="#kafka.log;Cleaner.readBuffer_=" title="=&gt; java.nio.ByteBuffer">readBuffer</a>.<span title="()Int">limit</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.log;Cleaner.cleanInto.messagesRead" title="Int">messagesRead</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
        <a href="#kafka.log;Cleaner.growBuffers" title="()Unit">growBuffers</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#kafka.log;Cleaner.restoreBuffers" title="()Unit">restoreBuffers</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Double the I/O buffer capacity
   */</span>
  def <a title="()Unit" id="kafka.log;Cleaner.growBuffers">growBuffers</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    if<span class="delimiter">(</span><a href="#kafka.log;Cleaner.readBuffer_=" title="=&gt; java.nio.ByteBuffer">readBuffer</a>.<span title="()Int">capacity</span> <span title="(x: Int)Boolean">&gt;=</span> <a href="#kafka.log;Cleaner.maxIoBufferSize" title="Int">maxIoBufferSize</a> <span title="(x: Boolean)Boolean">||</span> <a href="#kafka.log;Cleaner.writeBuffer_=" title="=&gt; java.nio.ByteBuffer">writeBuffer</a>.<span title="()Int">capacity</span> <span title="(x: Int)Boolean">&gt;=</span> <a href="#kafka.log;Cleaner.maxIoBufferSize" title="Int">maxIoBufferSize</a><span class="delimiter">)</span>
      throw new <span title="IllegalStateException">IllegalStateException</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;This log contains a message larger than maximum allowable size of %s.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.maxIoBufferSize" title="Int">maxIoBufferSize</a><span class="delimiter">)</span><span class="delimiter">)</span>
    val <a title="Int" id="kafka.log;Cleaner.growBuffers.newSize">newSize</a> = math.<span title="(x: Int, y: Int)Int">min</span><span class="delimiter">(</span>this.<a href="#kafka.log;Cleaner.readBuffer_=" title="=&gt; java.nio.ByteBuffer">readBuffer</a>.<span title="()Int">capacity</span> <span title="(x: Int)Int">*</span> <span title="Int(2)" class="int">2</span>, <a href="#kafka.log;Cleaner.maxIoBufferSize" title="Int">maxIoBufferSize</a><span class="delimiter">)</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="String(&quot;Growing cleaner I/O buffers from &quot;)" class="string">&quot;Growing cleaner I/O buffers from &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;Cleaner.readBuffer_=" title="=&gt; java.nio.ByteBuffer">readBuffer</a>.<span title="()Int">capacity</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;bytes to &quot;)" class="string">&quot;bytes to &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;Cleaner.growBuffers.newSize" title="Int">newSize</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; bytes.&quot;)" class="string">&quot; bytes.&quot;</span><span class="delimiter">)</span>
    this.<a href="#kafka.log;Cleaner.readBuffer_=" title="(x$1: java.nio.ByteBuffer)Unit">readBuffer</a> = <span title="java.nio.ByteBuffer.type">ByteBuffer</span>.<span title="(x$1: Int)java.nio.ByteBuffer">allocate</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.growBuffers.newSize" title="Int">newSize</a><span class="delimiter">)</span>
    this.<a href="#kafka.log;Cleaner.writeBuffer_=" title="(x$1: java.nio.ByteBuffer)Unit">writeBuffer</a> = <span title="java.nio.ByteBuffer.type">ByteBuffer</span>.<span title="(x$1: Int)java.nio.ByteBuffer">allocate</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.growBuffers.newSize" title="Int">newSize</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Restore the I/O buffer capacity to its original size
   */</span>
  def <a title="()Unit" id="kafka.log;Cleaner.restoreBuffers">restoreBuffers</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    if<span class="delimiter">(</span>this.<a href="#kafka.log;Cleaner.readBuffer_=" title="=&gt; java.nio.ByteBuffer">readBuffer</a>.<span title="()Int">capacity</span> <span title="(x: Int)Boolean">&gt;</span> this.<a href="#kafka.log;Cleaner.ioBufferSize" title="Int">ioBufferSize</a><span class="delimiter">)</span>
      this.<a href="#kafka.log;Cleaner.readBuffer_=" title="(x$1: java.nio.ByteBuffer)Unit">readBuffer</a> = <span title="java.nio.ByteBuffer.type">ByteBuffer</span>.<span title="(x$1: Int)java.nio.ByteBuffer">allocate</span><span class="delimiter">(</span>this.<a href="#kafka.log;Cleaner.ioBufferSize" title="Int">ioBufferSize</a><span class="delimiter">)</span>
    if<span class="delimiter">(</span>this.<a href="#kafka.log;Cleaner.writeBuffer_=" title="=&gt; java.nio.ByteBuffer">writeBuffer</a>.<span title="()Int">capacity</span> <span title="(x: Int)Boolean">&gt;</span> this.<a href="#kafka.log;Cleaner.ioBufferSize" title="Int">ioBufferSize</a><span class="delimiter">)</span>
      this.<a href="#kafka.log;Cleaner.writeBuffer_=" title="(x$1: java.nio.ByteBuffer)Unit">writeBuffer</a> = <span title="java.nio.ByteBuffer.type">ByteBuffer</span>.<span title="(x$1: Int)java.nio.ByteBuffer">allocate</span><span class="delimiter">(</span>this.<a href="#kafka.log;Cleaner.ioBufferSize" title="Int">ioBufferSize</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Group the segments in a log into groups totaling less than a given size. the size is enforced separately for the log data and the index data.
   * We collect a group of such segments together into a single
   * destination segment. This prevents segment sizes from shrinking too much.
   *
   * @param segments The log segments to group
   * @param maxSize the maximum size in bytes for the total of all log data in a group
   * @param maxIndexSize the maximum size in bytes for the total of all index data in a group
   *
   * @return A list of grouped segments
   */</span>
  private<span class="delimiter">[</span>log<span class="delimiter">]</span> def <a title="(segments: Iterable[kafka.log.LogSegment], maxSize: Int, maxIndexSize: Int)List[Seq[kafka.log.LogSegment]]" id="kafka.log;Cleaner.groupSegmentsBySize">groupSegmentsBySize</a><span class="delimiter">(</span><a title="Iterable[kafka.log.LogSegment]" id="kafka.log;Cleaner.groupSegmentsBySize.segments">segments</a>: <span title="Iterable[kafka.log.LogSegment]">Iterable</span><span class="delimiter">[</span>LogSegment<span class="delimiter">]</span>, <a title="Int" id="kafka.log;Cleaner.groupSegmentsBySize.maxSize">maxSize</a>: <span title="Int">Int</span>, <a title="Int" id="kafka.log;Cleaner.groupSegmentsBySize.maxIndexSize">maxIndexSize</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="List[Seq[kafka.log.LogSegment]]">List</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>LogSegment<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    var <a title="List[List[kafka.log.LogSegment]]" id="kafka.log;Cleaner.groupSegmentsBySize.grouped">grouped</a> = List<span class="delimiter">[</span>List<span class="delimiter">[</span>LogSegment<span class="delimiter">]</span><span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>
    var <a title="List[kafka.log.LogSegment]" id="kafka.log;Cleaner.groupSegmentsBySize.segs">segs</a> = <a href="#kafka.log;Cleaner.groupSegmentsBySize.segments" title="Iterable[kafka.log.LogSegment]">segments</a>.<span title="=&gt; List[kafka.log.LogSegment]">toList</span>
    while<span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.log;Cleaner.groupSegmentsBySize.segs" title="List[kafka.log.LogSegment]">segs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#kafka.log;Cleaner.groupSegmentsBySize.while$4" title="()Unit" class="delimiter">{</a>
      var <a title="List[kafka.log.LogSegment]" id="kafka.log;Cleaner.groupSegmentsBySize.group">group</a> = <span title="(xs: kafka.log.LogSegment*)List[kafka.log.LogSegment]">List</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.groupSegmentsBySize.segs" title="List[kafka.log.LogSegment]">segs</a>.<span title="=&gt; kafka.log.LogSegment">head</span><span class="delimiter">)</span>
      var <a title="Long" id="kafka.log;Cleaner.groupSegmentsBySize.logSize">logSize</a> = <a href="#kafka.log;Cleaner.groupSegmentsBySize.segs" title="List[kafka.log.LogSegment]">segs</a>.<span title="=&gt; kafka.log.LogSegment">head</span>.<a href="LogSegment.scala.html#kafka.log;LogSegment.size" title="=&gt; Long">size</a>
      var <a title="Int" id="kafka.log;Cleaner.groupSegmentsBySize.indexSize">indexSize</a> = <a href="#kafka.log;Cleaner.groupSegmentsBySize.segs" title="List[kafka.log.LogSegment]">segs</a>.<span title="=&gt; kafka.log.LogSegment">head</span>.<a href="LogSegment.scala.html#kafka.log;LogSegment.index" title="=&gt; kafka.log.OffsetIndex">index</a>.<a href="OffsetIndex.scala.html#kafka.log;OffsetIndex.sizeInBytes" title="()Int">sizeInBytes</a>
      <a href="#kafka.log;Cleaner.groupSegmentsBySize.segs" title="List[kafka.log.LogSegment]">segs</a> = <a href="#kafka.log;Cleaner.groupSegmentsBySize.segs" title="List[kafka.log.LogSegment]">segs</a>.<span title="=&gt; List[kafka.log.LogSegment]">tail</span>
      while<span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.log;Cleaner.groupSegmentsBySize.segs" title="List[kafka.log.LogSegment]">segs</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#kafka.log;Cleaner.groupSegmentsBySize.logSize" title="Long">logSize</a> <span title="(x: Long)Long">+</span> <a href="#kafka.log;Cleaner.groupSegmentsBySize.segs" title="List[kafka.log.LogSegment]">segs</a>.<span title="=&gt; kafka.log.LogSegment">head</span>.<a href="LogSegment.scala.html#kafka.log;LogSegment.size" title="=&gt; Long">size</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#kafka.log;Cleaner.groupSegmentsBySize.maxSize" title="Int">maxSize</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#kafka.log;Cleaner.groupSegmentsBySize.indexSize" title="Int">indexSize</a> <span title="(x: Int)Int">+</span> <a href="#kafka.log;Cleaner.groupSegmentsBySize.segs" title="List[kafka.log.LogSegment]">segs</a>.<span title="=&gt; kafka.log.LogSegment">head</span>.<a href="LogSegment.scala.html#kafka.log;LogSegment.index" title="=&gt; kafka.log.OffsetIndex">index</a>.<a href="OffsetIndex.scala.html#kafka.log;OffsetIndex.sizeInBytes" title="()Int">sizeInBytes</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#kafka.log;Cleaner.groupSegmentsBySize.maxIndexSize" title="Int">maxIndexSize</a><span class="delimiter">)</span> <a href="#kafka.log;Cleaner.groupSegmentsBySize.while$3" title="()Unit" class="delimiter">{</a>
        <a href="#kafka.log;Cleaner.groupSegmentsBySize.group" title="List[kafka.log.LogSegment]">group</a> = <a href="#kafka.log;Cleaner.groupSegmentsBySize.segs" title="List[kafka.log.LogSegment]">segs</a>.<span title="=&gt; kafka.log.LogSegment">head</span> <a href="#kafka.log;Cleaner.groupSegmentsBySize.x$12" title="(x: kafka.log.LogSegment)List[kafka.log.LogSegment]">::</a> <a href="#kafka.log;Cleaner.groupSegmentsBySize.group" title="List[kafka.log.LogSegment]">group</a>
        <a href="#kafka.log;Cleaner.groupSegmentsBySize.logSize" title="Long">logSize</a> <span title="(x: Long)Long">+=</span> <a href="#kafka.log;Cleaner.groupSegmentsBySize.segs" title="List[kafka.log.LogSegment]">segs</a>.<span title="=&gt; kafka.log.LogSegment">head</span>.<a href="LogSegment.scala.html#kafka.log;LogSegment.size" title="=&gt; Long">size</a>
        <a href="#kafka.log;Cleaner.groupSegmentsBySize.indexSize" title="Int">indexSize</a> <span title="(x: Int)Int">+=</span> <a href="#kafka.log;Cleaner.groupSegmentsBySize.segs" title="List[kafka.log.LogSegment]">segs</a>.<span title="=&gt; kafka.log.LogSegment">head</span>.<a href="LogSegment.scala.html#kafka.log;LogSegment.index" title="=&gt; kafka.log.OffsetIndex">index</a>.<a href="OffsetIndex.scala.html#kafka.log;OffsetIndex.sizeInBytes" title="()Int">sizeInBytes</a>
        <a href="#kafka.log;Cleaner.groupSegmentsBySize.segs" title="List[kafka.log.LogSegment]">segs</a> = <a href="#kafka.log;Cleaner.groupSegmentsBySize.segs" title="List[kafka.log.LogSegment]">segs</a>.<span title="=&gt; List[kafka.log.LogSegment]">tail</span>
      <span class="delimiter">}</span>
      <a href="#kafka.log;Cleaner.groupSegmentsBySize.grouped" title="List[List[kafka.log.LogSegment]]">grouped</a> <span title="(x: List[kafka.log.LogSegment])List[List[kafka.log.LogSegment]]">::=</span> <a href="#kafka.log;Cleaner.groupSegmentsBySize.group" title="List[kafka.log.LogSegment]">group</a>.<span title="=&gt; List[kafka.log.LogSegment]">reverse</span>
    <span class="delimiter">}</span>
    <a href="#kafka.log;Cleaner.groupSegmentsBySize.grouped" title="List[List[kafka.log.LogSegment]]">grouped</a>.<span title="=&gt; List[List[kafka.log.LogSegment]]">reverse</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Build a map of key_hash =&gt; offset for the keys in the dirty portion of the log to use in cleaning.
   * @param log The log to use
   * @param start The offset at which dirty messages begin
   * @param end The ending offset for the map that is being built
   * @param map The map in which to store the mappings
   *
   * @return The final offset the map covers
   */</span>
  private<span class="delimiter">[</span>log<span class="delimiter">]</span> def <a title="(log: kafka.log.Log, start: Long, end: Long, map: kafka.log.OffsetMap)Long" id="kafka.log;Cleaner.buildOffsetMap">buildOffsetMap</a><span class="delimiter">(</span><a title="kafka.log.Log" id="kafka.log;Cleaner.buildOffsetMap.log">log</a>: <a href="Log.scala.html#kafka.log;Log" title="kafka.log.Log">Log</a>, <a title="Long" id="kafka.log;Cleaner.buildOffsetMap.start">start</a>: <span title="Long">Long</span>, <a title="Long" id="kafka.log;Cleaner.buildOffsetMap.end">end</a>: <span title="Long">Long</span>, <a title="kafka.log.OffsetMap" id="kafka.log;Cleaner.buildOffsetMap.map">map</a>: <a href="OffsetMap.scala.html#kafka.log;OffsetMap" title="kafka.log.OffsetMap">OffsetMap</a><span class="delimiter">)</span>: <span title="Long">Long</span> = <span class="delimiter">{</span>
    <a href="#kafka.log;Cleaner.buildOffsetMap.map" title="kafka.log.OffsetMap">map</a>.<a href="OffsetMap.scala.html#kafka.log;OffsetMap.clear" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>
    val <a title="Seq[kafka.log.LogSegment]" id="kafka.log;Cleaner.buildOffsetMap.dirty">dirty</a> = <a href="#kafka.log;Cleaner.buildOffsetMap.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.logSegments(3f205903bd)" title="(from: Long, to: Long)Iterable[kafka.log.LogSegment]">logSegments</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMap.start" title="Long">start</a>, <a href="#kafka.log;Cleaner.buildOffsetMap.end" title="Long">end</a><span class="delimiter">)</span>.<span title="=&gt; Seq[kafka.log.LogSegment]">toSeq</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Building offset map for log %s for %d segments in offset range [%d, %d).&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMap.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.name" title="=&gt; String">name</a>, <a href="#kafka.log;Cleaner.buildOffsetMap.dirty" title="Seq[kafka.log.LogSegment]">dirty</a>.<span title="=&gt; Int">size</span>, <a href="#kafka.log;Cleaner.buildOffsetMap.start" title="Long">start</a>, <a href="#kafka.log;Cleaner.buildOffsetMap.end" title="Long">end</a><span class="delimiter">)</span><span class="delimiter">)</span>
    
    <span class="comment">// Add all the dirty segments. We must take at least map.slots * load_factor,</span>
    <span class="comment">// but we may be able to fit more (if there is lots of duplication in the dirty section of the log)</span>
    var <a title="Long" id="kafka.log;Cleaner.buildOffsetMap.offset">offset</a> = <a href="#kafka.log;Cleaner.buildOffsetMap.dirty" title="Seq[kafka.log.LogSegment]">dirty</a>.<span title="=&gt; kafka.log.LogSegment">head</span>.<a href="LogSegment.scala.html#kafka.log;LogSegment.baseOffset" title="=&gt; Long">baseOffset</a>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMap.offset" title="Long">offset</a> <span title="(x: Long)Boolean">==</span> <a href="#kafka.log;Cleaner.buildOffsetMap.start" title="Long">start</a>, <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Last clean offset is %d but segment base offset is %d for log %s.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMap.start" title="Long">start</a>, <a href="#kafka.log;Cleaner.buildOffsetMap.offset" title="Long">offset</a>, <a href="#kafka.log;Cleaner.buildOffsetMap.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.name" title="=&gt; String">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
    val <a title="Long" id="kafka.log;Cleaner.buildOffsetMap.minStopOffset">minStopOffset</a> = <span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMap.start" title="Long">start</a> <span title="(x: Double)Double">+</span> <a href="#kafka.log;Cleaner.buildOffsetMap.map" title="kafka.log.OffsetMap">map</a>.<a href="OffsetMap.scala.html#kafka.log;OffsetMap.slots" title="=&gt; Int">slots</a> <span title="(x: Double)Double">*</span> this.<a href="#kafka.log;Cleaner.dupBufferLoadFactor" title="Double">dupBufferLoadFactor</a><span class="delimiter">)</span>.<span title="=&gt; Long">toLong</span>
    for <span class="delimiter">(</span><a title="kafka.log.LogSegment" id="kafka.log;Cleaner.buildOffsetMap.$anonfun.segment">segment</a> &lt;- <a href="#kafka.log;Cleaner.buildOffsetMap.dirty" title="(f: kafka.log.LogSegment =&gt; Unit)Unit">dirty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.log;Cleaner.checkDone" title="(v1: kafka.common.TopicAndPartition)Unit">checkDone</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMap.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.topicAndPartition" title="=&gt; kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
      if<span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMap.$anonfun.segment" title="kafka.log.LogSegment">segment</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.baseOffset" title="=&gt; Long">baseOffset</a> <span title="(x: Long)Boolean">&lt;=</span> <a href="#kafka.log;Cleaner.buildOffsetMap.minStopOffset" title="Long">minStopOffset</a> <span title="(x: Boolean)Boolean">||</span> <a href="#kafka.log;Cleaner.buildOffsetMap.map" title="kafka.log.OffsetMap">map</a>.<a href="OffsetMap.scala.html#kafka.log;OffsetMap.utilization" title="=&gt; Double">utilization</a> <span title="(x: Double)Boolean">&lt;</span> this.<a href="#kafka.log;Cleaner.dupBufferLoadFactor" title="Double">dupBufferLoadFactor</a><span class="delimiter">)</span>
        <a href="#kafka.log;Cleaner.buildOffsetMap.offset" title="Long">offset</a> = <a href="#kafka.log;Cleaner.buildOffsetMapForSegment" title="(topicAndPartition: kafka.common.TopicAndPartition, segment: kafka.log.LogSegment, map: kafka.log.OffsetMap)Long">buildOffsetMapForSegment</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMap.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.topicAndPartition" title="=&gt; kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.log;Cleaner.buildOffsetMap.$anonfun.segment" title="kafka.log.LogSegment">segment</a>, <a href="#kafka.log;Cleaner.buildOffsetMap.map" title="kafka.log.OffsetMap">map</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Offset map for log %s complete.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMap.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.name" title="=&gt; String">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.log;Cleaner.buildOffsetMap.offset" title="Long">offset</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Add the messages in the given segment to the offset map
   *
   * @param segment The segment to index
   * @param map The map in which to store the key=&gt;offset mapping
   *
   * @return The final offset covered by the map
   */</span>
  private def <a title="(topicAndPartition: kafka.common.TopicAndPartition, segment: kafka.log.LogSegment, map: kafka.log.OffsetMap)Long" id="kafka.log;Cleaner.buildOffsetMapForSegment">buildOffsetMapForSegment</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.log;Cleaner.buildOffsetMapForSegment.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a>, <a title="kafka.log.LogSegment" id="kafka.log;Cleaner.buildOffsetMapForSegment.segment">segment</a>: <a href="LogSegment.scala.html#kafka.log;LogSegment" title="kafka.log.LogSegment">LogSegment</a>, <a title="kafka.log.OffsetMap" id="kafka.log;Cleaner.buildOffsetMapForSegment.map">map</a>: <a href="OffsetMap.scala.html#kafka.log;OffsetMap" title="kafka.log.OffsetMap">OffsetMap</a><span class="delimiter">)</span>: <span title="Long">Long</span> = <span class="delimiter">{</span>
    var <a title="Int" id="kafka.log;Cleaner.buildOffsetMapForSegment.position">position</a> = <span title="Int(0)" class="int">0</span>
    var <a title="Long" id="kafka.log;Cleaner.buildOffsetMapForSegment.offset">offset</a> = <a href="#kafka.log;Cleaner.buildOffsetMapForSegment.segment" title="kafka.log.LogSegment">segment</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.baseOffset" title="=&gt; Long">baseOffset</a>
    while <span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMapForSegment.position" title="Int">position</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#kafka.log;Cleaner.buildOffsetMapForSegment.segment" title="kafka.log.LogSegment">segment</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.log" title="=&gt; kafka.log.FileMessageSet">log</a>.<a href="FileMessageSet.scala.html#kafka.log;FileMessageSet.sizeInBytes" title="()Int">sizeInBytes</a><span class="delimiter">)</span> <a href="#kafka.log;Cleaner.buildOffsetMapForSegment.while$5" title="()Unit" class="delimiter">{</a>
      <a href="#kafka.log;Cleaner.checkDone" title="(v1: kafka.common.TopicAndPartition)Unit">checkDone</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMapForSegment.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
      <a href="#kafka.log;Cleaner.readBuffer_=" title="=&gt; java.nio.ByteBuffer">readBuffer</a>.<span title="()java.nio.Buffer">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
      val <a title="kafka.message.ByteBufferMessageSet" id="kafka.log;Cleaner.buildOffsetMapForSegment.messages">messages</a> = new <a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet">ByteBufferMessageSet</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMapForSegment.segment" title="kafka.log.LogSegment">segment</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.log" title="=&gt; kafka.log.FileMessageSet">log</a>.<a href="FileMessageSet.scala.html#kafka.log;FileMessageSet.readInto" title="(buffer: java.nio.ByteBuffer, relativePosition: Int)java.nio.ByteBuffer">readInto</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.readBuffer_=" title="=&gt; java.nio.ByteBuffer">readBuffer</a>, <a href="#kafka.log;Cleaner.buildOffsetMapForSegment.position" title="Int">position</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.log;Cleaner.throttler" title="kafka.utils.Throttler">throttler</a>.<a href="../utils/Throttler.scala.html#kafka.utils;Throttler.maybeThrottle" title="(observed: Double)Unit">maybeThrottle</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMapForSegment.messages" title="kafka.message.ByteBufferMessageSet">messages</a>.<a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet.sizeInBytes" title="=&gt; Double">sizeInBytes</a><span class="delimiter">)</span>
      val <a title="Int" id="kafka.log;Cleaner.buildOffsetMapForSegment.startPosition">startPosition</a> = <a href="#kafka.log;Cleaner.buildOffsetMapForSegment.position" title="Int">position</a>
      for <span class="delimiter">(</span><a title="kafka.message.MessageAndOffset" id="kafka.log;Cleaner.buildOffsetMapForSegment.$anonfun.entry">entry</a> &lt;- <a href="#kafka.log;Cleaner.buildOffsetMapForSegment.messages" title="(f: kafka.message.MessageAndOffset =&gt; Unit)Unit">messages</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="kafka.message.Message" id="kafka.log;Cleaner.buildOffsetMapForSegment.$anonfun.message">message</a> = <a href="#kafka.log;Cleaner.buildOffsetMapForSegment.$anonfun.entry" title="kafka.message.MessageAndOffset">entry</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a>
        <span title="(requirement: Boolean)Unit">require</span><span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMapForSegment.$anonfun.message" title="kafka.message.Message">message</a>.<a href="../message/Message.scala.html#kafka.message;Message.hasKey" title="=&gt; Boolean">hasKey</a><span class="delimiter">)</span>
        val <a title="Int" id="kafka.log;Cleaner.buildOffsetMapForSegment.$anonfun.size">size</a> = <a href="../message/MessageSet.scala.html#kafka.message.MessageSet" title="kafka.message.MessageSet.type">MessageSet</a>.<a href="../message/MessageSet.scala.html#kafka.message.MessageSet.entrySize" title="(message: kafka.message.Message)Int">entrySize</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMapForSegment.$anonfun.message" title="kafka.message.Message">message</a><span class="delimiter">)</span>
        <a href="#kafka.log;Cleaner.buildOffsetMapForSegment.position" title="Int">position</a> <span title="(x: Int)Int">+=</span> <a href="#kafka.log;Cleaner.buildOffsetMapForSegment.$anonfun.size" title="Int">size</a>
        <a href="#kafka.log;Cleaner.buildOffsetMapForSegment.map" title="kafka.log.OffsetMap">map</a>.<a href="OffsetMap.scala.html#kafka.log;OffsetMap.put" title="(key: java.nio.ByteBuffer, offset: Long)Unit">put</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMapForSegment.$anonfun.message" title="kafka.message.Message">message</a>.<a href="../message/Message.scala.html#kafka.message;Message.key" title="=&gt; java.nio.ByteBuffer">key</a>, <a href="#kafka.log;Cleaner.buildOffsetMapForSegment.$anonfun.entry" title="kafka.message.MessageAndOffset">entry</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.offset" title="=&gt; Long">offset</a><span class="delimiter">)</span>
        <a href="#kafka.log;Cleaner.buildOffsetMapForSegment.offset" title="Long">offset</a> = <a href="#kafka.log;Cleaner.buildOffsetMapForSegment.$anonfun.entry" title="kafka.message.MessageAndOffset">entry</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.offset" title="=&gt; Long">offset</a>
        <a href="#kafka.log;Cleaner.stats" title="=&gt; kafka.log.CleanerStats">stats</a>.<a href="#kafka.log;CleanerStats.indexMessage" title="(size: Int)Unit">indexMessage</a><span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMapForSegment.$anonfun.size" title="Int">size</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="comment">// if we didn't read even one complete message, our read buffer may be too small</span>
      if<span class="delimiter">(</span><a href="#kafka.log;Cleaner.buildOffsetMapForSegment.position" title="Int">position</a> <span title="(x: Int)Boolean">==</span> <a href="#kafka.log;Cleaner.buildOffsetMapForSegment.startPosition" title="Int">startPosition</a><span class="delimiter">)</span>
        <a href="#kafka.log;Cleaner.growBuffers" title="()Unit">growBuffers</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#kafka.log;Cleaner.restoreBuffers" title="()Unit">restoreBuffers</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#kafka.log;Cleaner.buildOffsetMapForSegment.offset" title="Long">offset</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * A simple struct for collecting stats about log cleaning
 */</span>
private case class <a title="class CleanerStats extends AnyRef with Product with Serializable" id="kafka.log.CleanerStats.readResolve">CleanerStats</a><a href="#kafka.log.CleanerStats.readResolve" title="Product" class="delimiter">(</a><a title="kafka.utils.Time" id="kafka.log.CleanerStats.apply$default$1">time</a>: <a href="../utils/Time.scala.html#kafka.utils;Time" title="kafka.utils.Time">Time</a> = <a href="../utils/Time.scala.html#kafka.utils.SystemTime" title="kafka.utils.SystemTime.type">SystemTime</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  var <a title="Long" id="kafka.log;CleanerStats.startTime_=">startTime</a>, <a title="Long" id="kafka.log;CleanerStats.mapCompleteTime_=">mapCompleteTime</a>, <a title="Long" id="kafka.log;CleanerStats.endTime_=">endTime</a>, <a title="Long" id="kafka.log;CleanerStats.bytesRead_=">bytesRead</a>, <a title="Long" id="kafka.log;CleanerStats.bytesWritten_=">bytesWritten</a>, <a title="Long" id="kafka.log;CleanerStats.mapBytesRead_=">mapBytesRead</a>, <a title="Long" id="kafka.log;CleanerStats.mapMessagesRead_=">mapMessagesRead</a>, <a title="Long" id="kafka.log;CleanerStats.messagesRead_=">messagesRead</a>, <a title="Long" id="kafka.log;CleanerStats.messagesWritten_=">messagesWritten</a> = <span title="Long(0L)" class="long">0L</span>
  var <a title="Double" id="kafka.log;CleanerStats.bufferUtilization_=">bufferUtilization</a> = <span title="Double(0.0)" class="double">0.0d</span>
  <a href="#kafka.log;CleanerStats.clear" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>
  
  def <a title="(size: Int)Unit" id="kafka.log;CleanerStats.readMessage">readMessage</a><span class="delimiter">(</span><a title="Int" id="kafka.log;CleanerStats.readMessage.size">size</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.log;CleanerStats.messagesRead_=" title="(x$1: Long)Unit">messagesRead</a> <span title="(x: Int)Long">+=</span> <span title="Int(1)" class="int">1</span>
    <a href="#kafka.log;CleanerStats.bytesRead_=" title="(x$1: Long)Unit">bytesRead</a> <span title="(x: Int)Long">+=</span> <a href="#kafka.log;CleanerStats.readMessage.size" title="Int">size</a>
  <span class="delimiter">}</span>
  
  def <a title="(size: Int)Unit" id="kafka.log;CleanerStats.recopyMessage">recopyMessage</a><span class="delimiter">(</span><a title="Int" id="kafka.log;CleanerStats.recopyMessage.size">size</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.log;CleanerStats.messagesWritten_=" title="(x$1: Long)Unit">messagesWritten</a> <span title="(x: Int)Long">+=</span> <span title="Int(1)" class="int">1</span>
    <a href="#kafka.log;CleanerStats.bytesWritten_=" title="(x$1: Long)Unit">bytesWritten</a> <span title="(x: Int)Long">+=</span> <a href="#kafka.log;CleanerStats.recopyMessage.size" title="Int">size</a>
  <span class="delimiter">}</span>
  
  def <a title="(size: Int)Unit" id="kafka.log;CleanerStats.indexMessage">indexMessage</a><span class="delimiter">(</span><a title="Int" id="kafka.log;CleanerStats.indexMessage.size">size</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.log;CleanerStats.mapMessagesRead_=" title="(x$1: Long)Unit">mapMessagesRead</a> <span title="(x: Int)Long">+=</span> <span title="Int(1)" class="int">1</span>
    <a href="#kafka.log;CleanerStats.mapBytesRead_=" title="(x$1: Long)Unit">mapBytesRead</a> <span title="(x: Int)Long">+=</span> <a href="#kafka.log;CleanerStats.indexMessage.size" title="Int">size</a>
  <span class="delimiter">}</span>
  
  def <a title="()Unit" id="kafka.log;CleanerStats.indexDone">indexDone</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.log;CleanerStats.mapCompleteTime_=" title="(x$1: Long)Unit">mapCompleteTime</a> = <a href="#kafka.log.CleanerStats.apply$default$1" title="=&gt; kafka.utils.Time">time</a>.<a href="../utils/Time.scala.html#kafka.utils;Time.milliseconds" title="=&gt; Long">milliseconds</a>
  <span class="delimiter">}</span>
  
  def <a title="()Unit" id="kafka.log;CleanerStats.allDone">allDone</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.log;CleanerStats.endTime_=" title="(x$1: Long)Unit">endTime</a> = <a href="#kafka.log.CleanerStats.apply$default$1" title="=&gt; kafka.utils.Time">time</a>.<a href="../utils/Time.scala.html#kafka.utils;Time.milliseconds" title="=&gt; Long">milliseconds</a>
  <span class="delimiter">}</span>
  
  def <a title="=&gt; Double" id="kafka.log;CleanerStats.elapsedSecs">elapsedSecs</a> = <span class="delimiter">(</span><a href="#kafka.log;CleanerStats.endTime_=" title="=&gt; Long">endTime</a> <span title="(x: Long)Long">-</span> <a href="#kafka.log;CleanerStats.startTime_=" title="=&gt; Long">startTime</a><span class="delimiter">)</span><span title="(x: Double)Double">/</span><span title="Double(1000.0)" class="double">1000.0</span>
  
  def <a title="=&gt; Double" id="kafka.log;CleanerStats.elapsedIndexSecs">elapsedIndexSecs</a> = <span class="delimiter">(</span><a href="#kafka.log;CleanerStats.mapCompleteTime_=" title="=&gt; Long">mapCompleteTime</a> <span title="(x: Long)Long">-</span> <a href="#kafka.log;CleanerStats.startTime_=" title="=&gt; Long">startTime</a><span class="delimiter">)</span><span title="(x: Double)Double">/</span><span title="Double(1000.0)" class="double">1000.0</span>
  
  def <a title="()Unit" id="kafka.log;CleanerStats.clear">clear</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.log;CleanerStats.startTime_=" title="(x$1: Long)Unit">startTime</a> = <a href="#kafka.log.CleanerStats.apply$default$1" title="=&gt; kafka.utils.Time">time</a>.<a href="../utils/Time.scala.html#kafka.utils;Time.milliseconds" title="=&gt; Long">milliseconds</a>
    <a href="#kafka.log;CleanerStats.mapCompleteTime_=" title="(x$1: Long)Unit">mapCompleteTime</a> = -<span title="Long(-1L)" class="long">1L</span>
    <a href="#kafka.log;CleanerStats.endTime_=" title="(x$1: Long)Unit">endTime</a> = -<span title="Long(-1L)" class="long">1L</span>
    <a href="#kafka.log;CleanerStats.bytesRead_=" title="(x$1: Long)Unit">bytesRead</a> = <span title="Long(0L)" class="long">0L</span>
    <a href="#kafka.log;CleanerStats.bytesWritten_=" title="(x$1: Long)Unit">bytesWritten</a> = <span title="Long(0L)" class="long">0L</span>
    <a href="#kafka.log;CleanerStats.mapBytesRead_=" title="(x$1: Long)Unit">mapBytesRead</a> = <span title="Long(0L)" class="long">0L</span>
    <a href="#kafka.log;CleanerStats.mapMessagesRead_=" title="(x$1: Long)Unit">mapMessagesRead</a> = <span title="Long(0L)" class="long">0L</span>
    <a href="#kafka.log;CleanerStats.messagesRead_=" title="(x$1: Long)Unit">messagesRead</a> = <span title="Long(0L)" class="long">0L</span>
    <a href="#kafka.log;CleanerStats.messagesWritten_=" title="(x$1: Long)Unit">messagesWritten</a> = <span title="Long(0L)" class="long">0L</span>
    <a href="#kafka.log;CleanerStats.bufferUtilization_=" title="(x$1: Double)Unit">bufferUtilization</a> = <span title="Double(0.0)" class="double">0.0d</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Helper class for a log, its topic/partition, and the last clean position
 */</span>
private case class <a title="class LogToClean extends AnyRef with Ordered[kafka.log.LogToClean] with Product with Serializable" id="kafka.log.LogToClean.readResolve">LogToClean</a><span title="Product" class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.log;LogToClean.topicPartition">topicPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a>, <a title="kafka.log.Log" id="kafka.log;LogToClean.log">log</a>: <a href="Log.scala.html#kafka.log;Log" title="kafka.log.Log">Log</a>, <a title="Long" id="kafka.log;LogToClean.firstDirtyOffset">firstDirtyOffset</a>: <span title="Long">Long</span><span class="delimiter">)</span> extends <a href="#kafka.log.LogToClean.readResolve" title="Ordered[kafka.log.LogToClean]">Ordered</a><span class="delimiter">[</span>LogToClean<span class="delimiter">]</span> <span class="delimiter">{</span>
  val <a title="Long" id="kafka.log;LogToClean.cleanBytes">cleanBytes</a> = <a href="#kafka.log;LogToClean.log" title="=&gt; kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.logSegments(3f205903bd)" title="(from: Long, to: Long)Iterable[kafka.log.LogSegment]">logSegments</a><span class="delimiter">(</span>-<span title="Long(-1L)" class="int">1</span>, <a href="#kafka.log;LogToClean.firstDirtyOffset" title="=&gt; Long">firstDirtyOffset</a><span title="(x: Int)Long">-</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>.<span title="(f: kafka.log.LogSegment =&gt; Long)(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[kafka.log.LogSegment],Long,Iterable[Long]])Iterable[Long]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,Long,Iterable[Long]]" class="delimiter">(</span><a href="#kafka.log;LogToClean.cleanBytes.$anonfun.x$13" title="kafka.log.LogSegment">_</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.size" title="=&gt; Long">size</a><span class="delimiter">)</span>.<span title="(implicit num: Numeric[Long])Long">sum</span>
  val <a title="Long" id="kafka.log;LogToClean.dirtyBytes">dirtyBytes</a> = <a href="#kafka.log;LogToClean.log" title="=&gt; kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.logSegments(3f205903bd)" title="(from: Long, to: Long)Iterable[kafka.log.LogSegment]">logSegments</a><span class="delimiter">(</span><a href="#kafka.log;LogToClean.firstDirtyOffset" title="=&gt; Long">firstDirtyOffset</a>, math.<span title="(x: Long, y: Long)Long">max</span><span class="delimiter">(</span><a href="#kafka.log;LogToClean.firstDirtyOffset" title="=&gt; Long">firstDirtyOffset</a>, <a href="#kafka.log;LogToClean.log" title="=&gt; kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.activeSegment" title="=&gt; kafka.log.LogSegment">activeSegment</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.baseOffset" title="=&gt; Long">baseOffset</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(f: kafka.log.LogSegment =&gt; Long)(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[kafka.log.LogSegment],Long,Iterable[Long]])Iterable[Long]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,Long,Iterable[Long]]" class="delimiter">(</span><a href="#kafka.log;LogToClean.dirtyBytes.$anonfun.x$14" title="kafka.log.LogSegment">_</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.size" title="=&gt; Long">size</a><span class="delimiter">)</span>.<span title="(implicit num: Numeric[Long])Long">sum</span>
  val cleanableRatio = <a href="#kafka.log;LogToClean.dirtyBytes" title="=&gt; Long">dirtyBytes</a> <a title="Double" id="kafka.log;LogToClean.cleanableRatio">/</a> <a href="#kafka.log;LogToClean.totalBytes" title="=&gt; Long">totalBytes</a>.<span title="=&gt; Double">toDouble</span>
  def <a title="=&gt; Long" id="kafka.log;LogToClean.totalBytes">totalBytes</a> = <a href="#kafka.log;LogToClean.cleanBytes" title="=&gt; Long">cleanBytes</a> <span title="(x: Long)Long">+</span> <a href="#kafka.log;LogToClean.dirtyBytes" title="=&gt; Long">dirtyBytes</a>
  override def <a title="(that: kafka.log.LogToClean)Int" id="kafka.log;LogToClean.compare">compare</a><span class="delimiter">(</span><a title="kafka.log.LogToClean" id="kafka.log;LogToClean.compare.that">that</a>: <a href="#kafka.log.LogToClean.readResolve" title="kafka.log.LogToClean">LogToClean</a><span class="delimiter">)</span>: <span title="Int">Int</span> = math.<span title="(x: Double)Double">signum</span><span class="delimiter">(</span>this.<a href="#kafka.log;LogToClean.cleanableRatio" title="=&gt; Double">cleanableRatio</a> <span title="(x: Double)Double">-</span> <a href="#kafka.log;LogToClean.compare.that" title="kafka.log.LogToClean">that</a>.<a href="#kafka.log;LogToClean.cleanableRatio" title="=&gt; Double">cleanableRatio</a><span class="delimiter">)</span>.<span title="=&gt; Int">toInt</span>
<span class="delimiter">}</span>
        </pre>
    </body>
</html>
