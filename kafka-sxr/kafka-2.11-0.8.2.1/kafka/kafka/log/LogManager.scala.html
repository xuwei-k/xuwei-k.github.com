<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/log/LogManager.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package kafka.log

import java.io._
import java.util.concurrent.TimeUnit
import kafka.utils._
import scala.collection._
import kafka.common.<span class="delimiter">{</span>TopicAndPartition, KafkaException<span class="delimiter">}</span>
import kafka.server.<span class="delimiter">{</span>RecoveringFromUncleanShutdown, BrokerState, OffsetCheckpoint<span class="delimiter">}</span>
import java.util.concurrent.<span class="delimiter">{</span>Executors, ExecutorService, ExecutionException, Future<span class="delimiter">}</span>

<span class="comment">/**
 * The entry point to the kafka log management subsystem. The log manager is responsible for log creation, retrieval, and cleaning.
 * All read and write operations are delegated to the individual log instances.
 * 
 * The log manager maintains logs in one or more directories. New logs are created in the data directory
 * with the fewest logs. No attempt is made to move partitions after the fact or balance based on
 * size or I/O rate.
 * 
 * A background thread handles log retention by periodically truncating excess log segments.
 */</span>
@threadsafe
class <a title="class LogManager extends AnyRef with kafka.utils.Logging" id="kafka.log;LogManager">LogManager</a><a href="#kafka.log;LogManager" title="kafka.log.LogManager" class="delimiter">(</a>val <a title="Array[java.io.File]" id="kafka.log;LogManager.logDirs">logDirs</a>: <span title="Array[java.io.File]">Array</span><span class="delimiter">[</span>File<span class="delimiter">]</span>,
                 val <a title="scala.collection.Map[String,kafka.log.LogConfig]" id="kafka.log;LogManager.topicConfigs">topicConfigs</a>: <span title="scala.collection.Map[String,kafka.log.LogConfig]">Map</span><span class="delimiter">[</span>String, LogConfig<span class="delimiter">]</span>,
                 val <a title="kafka.log.LogConfig" id="kafka.log;LogManager.defaultConfig">defaultConfig</a>: <a href="LogConfig.scala.html#kafka.log;LogConfig" title="kafka.log.LogConfig">LogConfig</a>,
                 val <a title="kafka.log.CleanerConfig" id="kafka.log;LogManager.cleanerConfig">cleanerConfig</a>: <a href="CleanerConfig.scala.html#kafka.log;CleanerConfig" title="kafka.log.CleanerConfig">CleanerConfig</a>,
                 <a title="Int" id="kafka.log;LogManager.ioThreads">ioThreads</a>: <span title="Int">Int</span>,
                 val <a title="Long" id="kafka.log;LogManager.flushCheckMs">flushCheckMs</a>: <span title="Long">Long</span>,
                 val <a title="Long" id="kafka.log;LogManager.flushCheckpointMs">flushCheckpointMs</a>: <span title="Long">Long</span>,
                 val <a title="Long" id="kafka.log;LogManager.retentionCheckMs">retentionCheckMs</a>: <span title="Long">Long</span>,
                 <a title="kafka.utils.Scheduler" id="kafka.log;LogManager.scheduler">scheduler</a>: <a href="../utils/KafkaScheduler.scala.html#kafka.utils;Scheduler" title="kafka.utils.Scheduler">Scheduler</a>,
                 val <a title="kafka.server.BrokerState" id="kafka.log;LogManager.brokerState">brokerState</a>: <a href="../server/BrokerStates.scala.html#kafka.server;BrokerState" title="kafka.server.BrokerState">BrokerState</a>,
                 private val <a title="kafka.utils.Time" id="kafka.log;LogManager.time">time</a>: <a href="../utils/Time.scala.html#kafka.utils;Time" title="kafka.utils.Time">Time</a><span class="delimiter">)</span> extends <a href="../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> <span class="delimiter">{</span>
  val <a title="String" id="kafka.log;LogManager.RecoveryPointCheckpointFile">RecoveryPointCheckpointFile</a> = <span title="String(&quot;recovery-point-offset-checkpoint&quot;)" class="string">&quot;recovery-point-offset-checkpoint&quot;</span>
  val <a title="String" id="kafka.log;LogManager.LockFile">LockFile</a> = <span title="String(&quot;.lock&quot;)" class="string">&quot;.lock&quot;</span>
  val InitialTaskDelayMs = <span class="int">30</span><a title="Int" id="kafka.log;LogManager.InitialTaskDelayMs">*</a><span class="int">1000</span>
  private val <a title="Object" id="kafka.log;LogManager.logCreationOrDeletionLock">logCreationOrDeletionLock</a> = new <span title="Object">Object</span>
  private val <a title="kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.log.Log]" id="kafka.log;LogManager.logs">logs</a> = new <a href="../utils/Pool.scala.html#kafka.utils;Pool" title="kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.log.Log]">Pool</a><span class="delimiter">[</span>TopicAndPartition, Log<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>

  <a href="#kafka.log;LogManager.createAndValidateLogDirs" title="(dirs: Seq[java.io.File])Unit">createAndValidateLogDirs</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.logDirs" title="(xs: Array[java.io.File])scala.collection.mutable.WrappedArray[java.io.File]">logDirs</a><span class="delimiter">)</span>
  private val <a title="Seq[kafka.utils.FileLock]" id="kafka.log;LogManager.dirLocks">dirLocks</a> = <a href="#kafka.log;LogManager.lockLogDirs" title="(dirs: Seq[java.io.File])Seq[kafka.utils.FileLock]">lockLogDirs</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.logDirs" title="(xs: Array[java.io.File])scala.collection.mutable.WrappedArray[java.io.File]">logDirs</a><span class="delimiter">)</span>
  private val <a title="scala.collection.immutable.Map[java.io.File,kafka.server.OffsetCheckpoint]" id="kafka.log;LogManager.recoveryPointCheckpoints">recoveryPointCheckpoints</a> = <a href="#kafka.log;LogManager.logDirs" title="(xs: Array[java.io.File])scala.collection.mutable.ArrayOps[java.io.File]">logDirs</a>.<span title="(f: java.io.File =&gt; (java.io.File, kafka.server.OffsetCheckpoint))(implicit bf: scala.collection.generic.CanBuildFrom[Array[java.io.File],(java.io.File, kafka.server.OffsetCheckpoint),Array[(java.io.File, kafka.server.OffsetCheckpoint)]])Array[(java.io.File, kafka.server.OffsetCheckpoint)]">map</span><span title="(xs: Array[(java.io.File, kafka.server.OffsetCheckpoint)])scala.collection.mutable.ArrayOps[(java.io.File, kafka.server.OffsetCheckpoint)]" class="delimiter">(</span><a title="java.io.File" id="kafka.log;LogManager.recoveryPointCheckpoints.$anonfun.dir">dir</a> =&gt; <span title="(_1: java.io.File, _2: kafka.server.OffsetCheckpoint)(java.io.File, kafka.server.OffsetCheckpoint)" class="delimiter">(</span><a href="#kafka.log;LogManager.recoveryPointCheckpoints.$anonfun.dir" title="java.io.File">dir</a>, new <a href="../server/OffsetCheckpoint.scala.html#kafka.server;OffsetCheckpoint" title="kafka.server.OffsetCheckpoint">OffsetCheckpoint</a><span class="delimiter">(</span>new <span title="java.io.File">File</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.recoveryPointCheckpoints.$anonfun.dir" title="java.io.File">dir</a>, <a href="#kafka.log;LogManager.RecoveryPointCheckpointFile" title="=&gt; String">RecoveryPointCheckpointFile</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: &lt;:&lt;[(java.io.File, kafka.server.OffsetCheckpoint),(java.io.File, kafka.server.OffsetCheckpoint)])scala.collection.immutable.Map[java.io.File,kafka.server.OffsetCheckpoint]">toMap</span>
  <a href="#kafka.log;LogManager.loadLogs" title="()Unit">loadLogs</a><span class="delimiter">(</span><span class="delimiter">)</span>

  <span class="comment">// public, so we can access this from kafka.admin.DeleteTopicTest</span>
  val <a title="kafka.log.LogCleaner" id="kafka.log;LogManager.cleaner">cleaner</a>: <a href="LogCleaner.scala.html#kafka.log;LogCleaner" title="kafka.log.LogCleaner">LogCleaner</a> =
    if<span class="delimiter">(</span><a href="#kafka.log;LogManager.cleanerConfig" title="=&gt; kafka.log.CleanerConfig">cleanerConfig</a>.<a href="CleanerConfig.scala.html#kafka.log;CleanerConfig.enableCleaner" title="=&gt; Boolean">enableCleaner</a><span class="delimiter">)</span>
      new <a href="LogCleaner.scala.html#kafka.log;LogCleaner" title="kafka.log.LogCleaner">LogCleaner</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.cleanerConfig" title="=&gt; kafka.log.CleanerConfig">cleanerConfig</a>, <a href="#kafka.log;LogManager.logDirs" title="=&gt; Array[java.io.File]">logDirs</a>, <a href="#kafka.log;LogManager.logs" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.log.Log]">logs</a>, time = <a href="#kafka.log;LogManager.time" title="=&gt; kafka.utils.Time">time</a><span class="delimiter">)</span>
    else
      null
  
  <span class="comment">/**
   * Create and check validity of the given directories, specifically:
   * &lt;ol&gt;
   * &lt;li&gt; Ensure that there are no duplicates in the directory list
   * &lt;li&gt; Create each directory if it doesn't exist
   * &lt;li&gt; Check that each path is a readable directory 
   * &lt;/ol&gt;
   */</span>
  private def <a title="(dirs: Seq[java.io.File])Unit" id="kafka.log;LogManager.createAndValidateLogDirs">createAndValidateLogDirs</a><span class="delimiter">(</span><a title="Seq[java.io.File]" id="kafka.log;LogManager.createAndValidateLogDirs.dirs">dirs</a>: <span title="Seq[java.io.File]">Seq</span><span class="delimiter">[</span>File<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    if<span class="delimiter">(</span><a href="#kafka.log;LogManager.createAndValidateLogDirs.dirs" title="Seq[java.io.File]">dirs</a>.<span title="(f: java.io.File =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[java.io.File],String,Seq[String]])Seq[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a href="#kafka.log;LogManager.createAndValidateLogDirs.$anonfun.x$1" title="java.io.File">_</a>.<span title="()String">getCanonicalPath</span><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[String]">toSet</span>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&lt;</span> <a href="#kafka.log;LogManager.createAndValidateLogDirs.dirs" title="Seq[java.io.File]">dirs</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>
      throw new <a href="../common/KafkaException.scala.html#kafka.common;KafkaException" title="kafka.common.KafkaException">KafkaException</a><span class="delimiter">(</span><span title="String(&quot;Duplicate log directory found: &quot;)" class="string">&quot;Duplicate log directory found: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogManager.logDirs" title="(xs: Array[java.io.File])scala.collection.mutable.ArrayOps[java.io.File]">logDirs</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    for<span class="delimiter">(</span><a title="java.io.File" id="kafka.log;LogManager.createAndValidateLogDirs.$anonfun.dir">dir</a> &lt;- <a href="#kafka.log;LogManager.createAndValidateLogDirs.dirs" title="(f: java.io.File =&gt; Unit)Unit">dirs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if<span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.log;LogManager.createAndValidateLogDirs.$anonfun.dir" title="java.io.File">dir</a>.<span title="()Boolean">exists</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="String(&quot;Log directory \'&quot;)" class="string">&quot;Log directory '&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogManager.createAndValidateLogDirs.$anonfun.dir" title="java.io.File">dir</a>.<span title="()String">getAbsolutePath</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\' not found, creating it.&quot;)" class="string">&quot;' not found, creating it.&quot;</span><span class="delimiter">)</span>
        val <a title="Boolean" id="kafka.log;LogManager.createAndValidateLogDirs.$anonfun.created">created</a> = <a href="#kafka.log;LogManager.createAndValidateLogDirs.$anonfun.dir" title="java.io.File">dir</a>.<span title="()Boolean">mkdirs</span><span class="delimiter">(</span><span class="delimiter">)</span>
        if<span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.log;LogManager.createAndValidateLogDirs.$anonfun.created" title="Boolean">created</a><span class="delimiter">)</span>
          throw new <a href="../common/KafkaException.scala.html#kafka.common;KafkaException" title="kafka.common.KafkaException">KafkaException</a><span class="delimiter">(</span><span title="String(&quot;Failed to create data directory &quot;)" class="string">&quot;Failed to create data directory &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogManager.createAndValidateLogDirs.$anonfun.dir" title="java.io.File">dir</a>.<span title="()String">getAbsolutePath</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      if<span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.log;LogManager.createAndValidateLogDirs.$anonfun.dir" title="java.io.File">dir</a>.<span title="()Boolean">isDirectory</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#kafka.log;LogManager.createAndValidateLogDirs.$anonfun.dir" title="java.io.File">dir</a>.<span title="()Boolean">canRead</span><span class="delimiter">)</span>
        throw new <a href="../common/KafkaException.scala.html#kafka.common;KafkaException" title="kafka.common.KafkaException">KafkaException</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.createAndValidateLogDirs.$anonfun.dir" title="java.io.File">dir</a>.<span title="()String">getAbsolutePath</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; is not a readable log directory.&quot;)" class="string">&quot; is not a readable log directory.&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Lock all the given directories
   */</span>
  private def <a title="(dirs: Seq[java.io.File])Seq[kafka.utils.FileLock]" id="kafka.log;LogManager.lockLogDirs">lockLogDirs</a><span class="delimiter">(</span><a title="Seq[java.io.File]" id="kafka.log;LogManager.lockLogDirs.dirs">dirs</a>: <span title="Seq[java.io.File]">Seq</span><span class="delimiter">[</span>File<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[kafka.utils.FileLock]">Seq</span><span class="delimiter">[</span>FileLock<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#kafka.log;LogManager.lockLogDirs.dirs" title="Seq[java.io.File]">dirs</a>.<span title="(f: java.io.File =&gt; kafka.utils.FileLock)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[java.io.File],kafka.utils.FileLock,Seq[kafka.utils.FileLock]])Seq[kafka.utils.FileLock]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,kafka.utils.FileLock,Seq[kafka.utils.FileLock]]" class="delimiter">{</span> <a title="java.io.File" id="kafka.log;LogManager.lockLogDirs.$anonfun.dir">dir</a> =&gt;
      val <a title="kafka.utils.FileLock" id="kafka.log;LogManager.lockLogDirs.$anonfun.lock">lock</a> = new <a href="../utils/FileLock.scala.html#kafka.utils;FileLock" title="kafka.utils.FileLock">FileLock</a><span class="delimiter">(</span>new <span title="java.io.File">File</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.lockLogDirs.$anonfun.dir" title="java.io.File">dir</a>, <a href="#kafka.log;LogManager.LockFile" title="=&gt; String">LockFile</a><span class="delimiter">)</span><span class="delimiter">)</span>
      if<span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.log;LogManager.lockLogDirs.$anonfun.lock" title="kafka.utils.FileLock">lock</a>.<a href="../utils/FileLock.scala.html#kafka.utils;FileLock.tryLock" title="()Boolean">tryLock</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
        throw new <a href="../common/KafkaException.scala.html#kafka.common;KafkaException" title="kafka.common.KafkaException">KafkaException</a><span class="delimiter">(</span><span title="String(&quot;Failed to acquire lock on file .lock in &quot;)" class="string">&quot;Failed to acquire lock on file .lock in &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogManager.lockLogDirs.$anonfun.lock" title="kafka.utils.FileLock">lock</a>.<a href="../utils/FileLock.scala.html#kafka.utils;FileLock.file" title="=&gt; java.io.File">file</a>.<span title="()java.io.File">getParentFile</span>.<span title="()String">getAbsolutePath</span> <span title="(x$1: Any)String">+</span> 
                               <span title="String(&quot;. A Kafka instance in another process or thread is using this directory.&quot;)" class="string">&quot;. A Kafka instance in another process or thread is using this directory.&quot;</span><span class="delimiter">)</span>
      <a href="#kafka.log;LogManager.lockLogDirs.$anonfun.lock" title="kafka.utils.FileLock">lock</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Recover and load all logs in the given data directories
   */</span>
  private def <a title="()Unit" id="kafka.log;LogManager.loadLogs">loadLogs</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="String(&quot;Loading logs.&quot;)" class="string">&quot;Loading logs.&quot;</span><span class="delimiter">)</span>

    val <a title="scala.collection.mutable.ArrayBuffer[java.util.concurrent.ExecutorService]" id="kafka.log;LogManager.loadLogs.threadPools">threadPools</a> = mutable.<span title="scala.collection.mutable.ArrayBuffer.type">ArrayBuffer</span>.<span title="[A]=&gt; scala.collection.mutable.ArrayBuffer[A]">empty</span><span title="scala.collection.mutable.ArrayBuffer[java.util.concurrent.ExecutorService]" class="delimiter">[</span><span title="java.util.concurrent.ExecutorService">ExecutorService</span><span class="delimiter">]</span>
    val <a title="scala.collection.mutable.Map[java.io.File,Seq[java.util.concurrent.Future[_]]]" id="kafka.log;LogManager.loadLogs.jobs">jobs</a> = mutable.<span title="scala.collection.mutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.mutable.Map[A,B]">empty</span><span title="scala.collection.mutable.Map[java.io.File,Seq[java.util.concurrent.Future[_]]]" class="delimiter">[</span><span title="java.io.File">File</span>, <span title="Seq[java.util.concurrent.Future[_]]">Seq</span><span class="delimiter">[</span>Future<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>

    for <span class="delimiter">(</span><a title="java.io.File" id="kafka.log;LogManager.loadLogs.$anonfun.dir">dir</a> &lt;- this.<a href="#kafka.log;LogManager.logDirs" title="(f: java.io.File =&gt; Unit)Unit">logDirs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="java.util.concurrent.ExecutorService" id="kafka.log;LogManager.loadLogs.$anonfun.pool">pool</a> = <span title="java.util.concurrent.Executors.type">Executors</span>.<span title="(x$1: Int)java.util.concurrent.ExecutorService">newFixedThreadPool</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.ioThreads" title="Int">ioThreads</a><span class="delimiter">)</span>
      <a href="#kafka.log;LogManager.loadLogs.threadPools" title="scala.collection.mutable.ArrayBuffer[java.util.concurrent.ExecutorService]">threadPools</a>.<span title="(elems: java.util.concurrent.ExecutorService*)Unit">append</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.loadLogs.$anonfun.pool" title="java.util.concurrent.ExecutorService">pool</a><span class="delimiter">)</span>

      val <span title="java.io.File">cleanShutdownFile</span> = new <span title="java.io.File">File</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.loadLogs.$anonfun.dir" title="java.io.File">dir</a>, <a href="Log.scala.html#kafka.log.Log" title="kafka.log.Log.type">Log</a>.<a href="Log.scala.html#kafka.log.Log.CleanShutdownFile" title="=&gt; String">CleanShutdownFile</a><span class="delimiter">)</span>

      if <span class="delimiter">(</span><span title="java.io.File">cleanShutdownFile</span>.<span title="()Boolean">exists</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span>
          <span class="string">&quot;Found clean shutdown file. &quot;</span> <span title="String(&quot;Found clean shutdown file. Skipping recovery for all logs in data directory: &quot;)">+</span>
          <span class="string">&quot;Skipping recovery for all logs in data directory: &quot;</span> <span title="(x$1: Any)String">+</span>
          <a href="#kafka.log;LogManager.loadLogs.$anonfun.dir" title="java.io.File">dir</a>.<span title="()String">getAbsolutePath</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <span class="comment">// log recovery itself is being performed by `Log` class during initialization</span>
        <a href="#kafka.log;LogManager.brokerState" title="=&gt; kafka.server.BrokerState">brokerState</a>.<a href="../server/BrokerStates.scala.html#kafka.server;BrokerState.newState(ab9c491e36)" title="(newState: kafka.server.BrokerStates)Unit">newState</a><span class="delimiter">(</span><a href="../server/BrokerStates.scala.html#kafka.server.RecoveringFromUncleanShutdown" title="kafka.server.RecoveringFromUncleanShutdown.type">RecoveringFromUncleanShutdown</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      val <a title="scala.collection.Map[kafka.common.TopicAndPartition,Long]" id="kafka.log;LogManager.loadLogs.$anonfun.recoveryPoints">recoveryPoints</a> = this.<a href="#kafka.log;LogManager.recoveryPointCheckpoints" title="(key: java.io.File)kafka.server.OffsetCheckpoint">recoveryPointCheckpoints</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.loadLogs.$anonfun.dir" title="java.io.File">dir</a><span class="delimiter">)</span>.<a href="../server/OffsetCheckpoint.scala.html#kafka.server;OffsetCheckpoint.read" title="()scala.collection.Map[kafka.common.TopicAndPartition,Long]">read</a>

      val <a title="List[Runnable]" id="kafka.log;LogManager.loadLogs.$anonfun.jobsForDir">jobsForDir</a> = for <span class="delimiter">{</span>
        <a title="Array[java.io.File]" id="kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.dirContent">dirContent</a> &lt;- <span title="(x: Array[java.io.File])Option[Array[java.io.File]]">Option</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.loadLogs.$anonfun.dir" title="java.io.File">dir</a>.<span title="()Array[java.io.File]">listFiles</span><span class="delimiter">)</span>.<span title="(f: Array[java.io.File] =&gt; scala.collection.GenTraversableOnce[Runnable])(implicit bf: scala.collection.generic.CanBuildFrom[List[Array[java.io.File]],Runnable,List[Runnable]])List[Runnable]">toList</span>
        <a title="java.io.File" id="kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.logDir">logDir</a> &lt;- <a href="#kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.dirContent" title="(f: java.io.File =&gt; Runnable)(implicit bf: scala.collection.generic.CanBuildFrom[Array[java.io.File],Runnable,Array[Runnable]])Array[Runnable]">dirContent</a> if <a href="#kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.logDir" title="java.io.File">logDir</a>.<span title="()Boolean">isDirectory</span>
      <span class="delimiter">}</span> yield <span class="delimiter">{</span>
        <a href="../utils/Utils.scala.html#kafka.utils.Utils" title="kafka.utils.Utils.type">Utils</a>.<a href="../utils/Utils.scala.html#kafka.utils.Utils.runnable" title="(fun: =&gt; Unit)Runnable">runnable</a> <span class="delimiter">{</span>
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Loading log \'&quot;)" class="string">&quot;Loading log '&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.logDir" title="java.io.File">logDir</a>.<span title="()String">getName</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\'&quot;)" class="string">&quot;'&quot;</span><span class="delimiter">)</span>

          val <a title="kafka.common.TopicAndPartition" id="kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.topicPartition">topicPartition</a> = <a href="Log.scala.html#kafka.log.Log" title="kafka.log.Log.type">Log</a>.<a href="Log.scala.html#kafka.log.Log.parseTopicPartitionName" title="(name: String)kafka.common.TopicAndPartition">parseTopicPartitionName</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.logDir" title="java.io.File">logDir</a>.<span title="()String">getName</span><span class="delimiter">)</span>
          val <a title="kafka.log.LogConfig" id="kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.config">config</a> = <a href="#kafka.log;LogManager.topicConfigs" title="=&gt; scala.collection.Map[String,kafka.log.LogConfig]">topicConfigs</a>.<span title="(key: String, default: =&gt; kafka.log.LogConfig)kafka.log.LogConfig">getOrElse</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.topicPartition" title="kafka.common.TopicAndPartition">topicPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.log;LogManager.defaultConfig" title="=&gt; kafka.log.LogConfig">defaultConfig</a><span class="delimiter">)</span>
          val <a title="Long" id="kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.logRecoveryPoint">logRecoveryPoint</a> = <a href="#kafka.log;LogManager.loadLogs.$anonfun.recoveryPoints" title="scala.collection.Map[kafka.common.TopicAndPartition,Long]">recoveryPoints</a>.<span title="(key: kafka.common.TopicAndPartition, default: =&gt; Long)Long">getOrElse</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.topicPartition" title="kafka.common.TopicAndPartition">topicPartition</a>, <span title="Long(0L)" class="long">0L</span><span class="delimiter">)</span>

          val <a title="kafka.log.Log" id="kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.current">current</a> = new <a href="Log.scala.html#kafka.log;Log" title="kafka.log.Log">Log</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.logDir" title="java.io.File">logDir</a>, <a href="#kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.config" title="kafka.log.LogConfig">config</a>, <a href="#kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.logRecoveryPoint" title="Long">logRecoveryPoint</a>, <a href="#kafka.log;LogManager.scheduler" title="kafka.utils.Scheduler">scheduler</a>, <a href="#kafka.log;LogManager.time" title="=&gt; kafka.utils.Time">time</a><span class="delimiter">)</span>
          val <a title="kafka.log.Log" id="kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.previous">previous</a> = this.<a href="#kafka.log;LogManager.logs" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.log.Log]">logs</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.put" title="(k: kafka.common.TopicAndPartition, v: kafka.log.Log)kafka.log.Log">put</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.topicPartition" title="kafka.common.TopicAndPartition">topicPartition</a>, <a href="#kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.current" title="kafka.log.Log">current</a><span class="delimiter">)</span>

          if <span class="delimiter">(</span><a href="#kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.previous" title="kafka.log.Log">previous</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <span class="delimiter">{</span>
            throw new <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span>
              <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Duplicate log directories found: %s, %s!&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span>
              <a href="#kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.current" title="kafka.log.Log">current</a>.<a href="Log.scala.html#kafka.log;Log.dir" title="=&gt; java.io.File">dir</a>.<span title="()String">getAbsolutePath</span>, <a href="#kafka.log;LogManager.loadLogs.$anonfun.jobsForDir.$anonfun.$anonfun.previous" title="kafka.log.Log">previous</a>.<a href="Log.scala.html#kafka.log;Log.dir" title="=&gt; java.io.File">dir</a>.<span title="()String">getAbsolutePath</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#kafka.log;LogManager.loadLogs.jobs" title="(key: java.io.File, value: Seq[java.util.concurrent.Future[_]])Unit">jobs</a><span class="delimiter">(</span><span title="java.io.File">cleanShutdownFile</span><span class="delimiter">)</span> = <a href="#kafka.log;LogManager.loadLogs.$anonfun.jobsForDir" title="List[Runnable]">jobsForDir</a>.<span title="(f: Runnable =&gt; java.util.concurrent.Future[_])(implicit bf: scala.collection.generic.CanBuildFrom[List[Runnable],java.util.concurrent.Future[_],List[java.util.concurrent.Future[_]]])List[java.util.concurrent.Future[_]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,java.util.concurrent.Future[_],List[java.util.concurrent.Future[_]]]" class="delimiter">(</span><a href="#kafka.log;LogManager.loadLogs.$anonfun.pool" title="java.util.concurrent.ExecutorService">pool</a>.<a href="#kafka.log;LogManager.loadLogs.$anonfun.$anonfun.x$1" title="(x$1: Runnable)java.util.concurrent.Future[_]">submit</a><span class="delimiter">)</span>.<span title="=&gt; scala.collection.immutable.Seq[java.util.concurrent.Future[_]]">toSeq</span>
    <span class="delimiter">}</span>


    try <span class="delimiter">{</span>
      for <span class="delimiter">(</span><span class="delimiter">(</span><span title="java.io.File">cleanShutdownFile</span>, <a title="Seq[java.util.concurrent.Future[_]]" id="kafka.log;LogManager.loadLogs.$anonfun.dirJobs">dirJobs</a><span class="delimiter">)</span> &lt;- <a href="#kafka.log;LogManager.loadLogs.jobs" title="(f: ((java.io.File, Seq[java.util.concurrent.Future[_]])) =&gt; Boolean)Unit">jobs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#kafka.log;LogManager.loadLogs.$anonfun.dirJobs" title="Seq[java.util.concurrent.Future[_]]">dirJobs</a>.<span title="(f: java.util.concurrent.Future[_] =&gt; Any)Unit">foreach</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.loadLogs.$anonfun.$anonfun.x$2" title="java.util.concurrent.Future[_]">_</a>.<span title="()_$1">get</span><span class="delimiter">)</span>
        <span title="java.io.File">cleanShutdownFile</span>.<span title="()Boolean">delete</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> catch <span class="delimiter">{</span>
      case <a title="java.util.concurrent.ExecutionException" id="kafka.log;LogManager.loadLogs.e">e</a>: <span title="java.util.concurrent.ExecutionException">ExecutionException</span> =&gt; <span class="delimiter">{</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.error(1729dbc42f)" title="(msg: =&gt; String)Unit">error</a><span class="delimiter">(</span><span title="String(&quot;There was an error in one of the threads during logs loading: &quot;)" class="string">&quot;There was an error in one of the threads during logs loading: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogManager.loadLogs.e" title="java.util.concurrent.ExecutionException">e</a>.<span title="()Throwable">getCause</span><span class="delimiter">)</span>
        throw <a href="#kafka.log;LogManager.loadLogs.e" title="java.util.concurrent.ExecutionException">e</a>.<span title="()Throwable">getCause</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> finally <span class="delimiter">{</span>
      <a href="#kafka.log;LogManager.loadLogs.threadPools" title="scala.collection.mutable.ArrayBuffer[java.util.concurrent.ExecutorService]">threadPools</a>.<span title="(f: java.util.concurrent.ExecutorService =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.loadLogs.$anonfun.x$4" title="java.util.concurrent.ExecutorService">_</a>.<span title="()Unit">shutdown</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="String(&quot;Logs loading complete.&quot;)" class="string">&quot;Logs loading complete.&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   *  Start the background threads to flush logs and do log cleanup
   */</span>
  def <a title="()Unit" id="kafka.log;LogManager.startup">startup</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">/* Schedule the cleanup task to delete old logs */</span>
    if<span class="delimiter">(</span><a href="#kafka.log;LogManager.scheduler" title="kafka.utils.Scheduler">scheduler</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Starting log cleanup with a period of %d ms.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.retentionCheckMs" title="=&gt; Long">retentionCheckMs</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.log;LogManager.scheduler" title="kafka.utils.Scheduler">scheduler</a>.<a href="../utils/KafkaScheduler.scala.html#kafka.utils;Scheduler.schedule" title="(name: String, fun: () =&gt; Unit, delay: Long, period: Long, unit: java.util.concurrent.TimeUnit)Unit">schedule</a><span class="delimiter">(</span><span title="String(&quot;kafka-log-retention&quot;)" class="string">&quot;kafka-log-retention&quot;</span>, 
                         <a href="#kafka.log;LogManager.cleanupLogs" title="()Unit">cleanupLogs</a>, 
                         delay = <a href="#kafka.log;LogManager.InitialTaskDelayMs" title="=&gt; Long">InitialTaskDelayMs</a>, 
                         period = <a href="#kafka.log;LogManager.retentionCheckMs" title="=&gt; Long">retentionCheckMs</a>, 
                         TimeUnit.<span title="java.util.concurrent.TimeUnit(MILLISECONDS)">MILLISECONDS</span><span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Starting log flusher with a default period of %d ms.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.flushCheckMs" title="=&gt; Long">flushCheckMs</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.log;LogManager.scheduler" title="kafka.utils.Scheduler">scheduler</a>.<a href="../utils/KafkaScheduler.scala.html#kafka.utils;Scheduler.schedule" title="(name: String, fun: () =&gt; Unit, delay: Long, period: Long, unit: java.util.concurrent.TimeUnit)Unit">schedule</a><span class="delimiter">(</span><span title="String(&quot;kafka-log-flusher&quot;)" class="string">&quot;kafka-log-flusher&quot;</span>, 
                         <a href="#kafka.log;LogManager.flushDirtyLogs" title="()Unit">flushDirtyLogs</a>, 
                         delay = <a href="#kafka.log;LogManager.InitialTaskDelayMs" title="=&gt; Long">InitialTaskDelayMs</a>, 
                         period = <a href="#kafka.log;LogManager.flushCheckMs" title="=&gt; Long">flushCheckMs</a>, 
                         TimeUnit.<span title="java.util.concurrent.TimeUnit(MILLISECONDS)">MILLISECONDS</span><span class="delimiter">)</span>
      <a href="#kafka.log;LogManager.scheduler" title="kafka.utils.Scheduler">scheduler</a>.<a href="../utils/KafkaScheduler.scala.html#kafka.utils;Scheduler.schedule" title="(name: String, fun: () =&gt; Unit, delay: Long, period: Long, unit: java.util.concurrent.TimeUnit)Unit">schedule</a><span class="delimiter">(</span><span title="String(&quot;kafka-recovery-point-checkpoint&quot;)" class="string">&quot;kafka-recovery-point-checkpoint&quot;</span>,
                         <a href="#kafka.log;LogManager.checkpointRecoveryPointOffsets" title="()Unit">checkpointRecoveryPointOffsets</a>,
                         delay = <a href="#kafka.log;LogManager.InitialTaskDelayMs" title="=&gt; Long">InitialTaskDelayMs</a>,
                         period = <a href="#kafka.log;LogManager.flushCheckpointMs" title="=&gt; Long">flushCheckpointMs</a>,
                         TimeUnit.<span title="java.util.concurrent.TimeUnit(MILLISECONDS)">MILLISECONDS</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    if<span class="delimiter">(</span><a href="#kafka.log;LogManager.cleanerConfig" title="=&gt; kafka.log.CleanerConfig">cleanerConfig</a>.<a href="CleanerConfig.scala.html#kafka.log;CleanerConfig.enableCleaner" title="=&gt; Boolean">enableCleaner</a><span class="delimiter">)</span>
      <a href="#kafka.log;LogManager.cleaner" title="=&gt; kafka.log.LogCleaner">cleaner</a>.<a href="LogCleaner.scala.html#kafka.log;LogCleaner.startup" title="()Unit">startup</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Close all the logs
   */</span>
  def <a title="()Unit" id="kafka.log;LogManager.shutdown">shutdown</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="String(&quot;Shutting down.&quot;)" class="string">&quot;Shutting down.&quot;</span><span class="delimiter">)</span>

    val <a title="scala.collection.mutable.ArrayBuffer[java.util.concurrent.ExecutorService]" id="kafka.log;LogManager.shutdown.threadPools">threadPools</a> = mutable.<span title="scala.collection.mutable.ArrayBuffer.type">ArrayBuffer</span>.<span title="[A]=&gt; scala.collection.mutable.ArrayBuffer[A]">empty</span><span title="scala.collection.mutable.ArrayBuffer[java.util.concurrent.ExecutorService]" class="delimiter">[</span><span title="java.util.concurrent.ExecutorService">ExecutorService</span><span class="delimiter">]</span>
    val <a title="scala.collection.mutable.Map[java.io.File,Seq[java.util.concurrent.Future[_]]]" id="kafka.log;LogManager.shutdown.jobs">jobs</a> = mutable.<span title="scala.collection.mutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.mutable.Map[A,B]">empty</span><span title="scala.collection.mutable.Map[java.io.File,Seq[java.util.concurrent.Future[_]]]" class="delimiter">[</span><span title="java.io.File">File</span>, <span title="Seq[java.util.concurrent.Future[_]]">Seq</span><span class="delimiter">[</span>Future<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>

    <span class="comment">// stop the cleaner first</span>
    if <span class="delimiter">(</span><a href="#kafka.log;LogManager.cleaner" title="=&gt; kafka.log.LogCleaner">cleaner</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../utils/Utils.scala.html#kafka.utils.Utils" title="kafka.utils.Utils.type">Utils</a>.<a href="../utils/Logging.scala.html#kafka.utils;Logging.swallow" title="(action: =&gt; Unit)Unit">swallow</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.cleaner" title="=&gt; kafka.log.LogCleaner">cleaner</a>.<a href="LogCleaner.scala.html#kafka.log;LogCleaner.shutdown" title="()Unit">shutdown</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// close logs in each dir</span>
    for <span class="delimiter">(</span><span title="java.io.File">dir</span> &lt;- this.<a href="#kafka.log;LogManager.logDirs" title="(f: java.io.File =&gt; Unit)Unit">logDirs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Flushing and closing logs at &quot;)" class="string">&quot;Flushing and closing logs at &quot;</span> <span title="(x$1: Any)String">+</span> <span title="java.io.File">dir</span><span class="delimiter">)</span>

      val <a title="java.util.concurrent.ExecutorService" id="kafka.log;LogManager.shutdown.$anonfun.pool">pool</a> = <span title="java.util.concurrent.Executors.type">Executors</span>.<span title="(x$1: Int)java.util.concurrent.ExecutorService">newFixedThreadPool</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.ioThreads" title="Int">ioThreads</a><span class="delimiter">)</span>
      <a href="#kafka.log;LogManager.shutdown.threadPools" title="scala.collection.mutable.ArrayBuffer[java.util.concurrent.ExecutorService]">threadPools</a>.<span title="(elems: java.util.concurrent.ExecutorService*)Unit">append</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.shutdown.$anonfun.pool" title="java.util.concurrent.ExecutorService">pool</a><span class="delimiter">)</span>

      val <a title="Iterable[kafka.log.Log]" id="kafka.log;LogManager.shutdown.$anonfun.logsInDir">logsInDir</a> = <a href="#kafka.log;LogManager.logsByDir" title="=&gt; scala.collection.immutable.Map[String,scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.log.Log]]">logsByDir</a>.<span title="(key: String, default: =&gt; scala.collection.Map[_ &lt;: kafka.common.TopicAndPartition, kafka.log.Log])scala.collection.Map[_ &lt;: kafka.common.TopicAndPartition, kafka.log.Log]">getOrElse</span><span class="delimiter">(</span><span title="java.io.File">dir</span>.<span title="()String">toString</span>, <span title="(elems: (Nothing, Nothing)*)scala.collection.Map[Nothing,Nothing]">Map</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; Iterable[kafka.log.Log]">values</span>

      val jobsForDir = <a href="#kafka.log;LogManager.shutdown.$anonfun.logsInDir" title="Iterable[kafka.log.Log]">logsInDir</a> <a title="Iterable[Runnable]" id="kafka.log;LogManager.shutdown.$anonfun.jobsForDir">map</a> <span class="delimiter">{</span> <a title="kafka.log.Log" id="kafka.log;LogManager.shutdown.$anonfun.jobsForDir.$anonfun.log">log</a> =&gt;
        <a href="../utils/Utils.scala.html#kafka.utils.Utils" title="kafka.utils.Utils.type">Utils</a>.<a href="../utils/Utils.scala.html#kafka.utils.Utils.runnable" title="(fun: =&gt; Unit)Runnable">runnable</a> <span class="delimiter">{</span>
          <span class="comment">// flush the log to ensure latest possible recovery point</span>
          <a href="#kafka.log;LogManager.shutdown.$anonfun.jobsForDir.$anonfun.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.flush(aa97cb1b3d)" title="()Unit">flush</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#kafka.log;LogManager.shutdown.$anonfun.jobsForDir.$anonfun.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.close" title="()Unit">close</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#kafka.log;LogManager.shutdown.jobs" title="(key: java.io.File, value: Seq[java.util.concurrent.Future[_]])Unit">jobs</a><span class="delimiter">(</span><span title="java.io.File">dir</span><span class="delimiter">)</span> = <a href="#kafka.log;LogManager.shutdown.$anonfun.jobsForDir" title="Iterable[Runnable]">jobsForDir</a>.<span title="(f: Runnable =&gt; java.util.concurrent.Future[_])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[Runnable],java.util.concurrent.Future[_],Iterable[java.util.concurrent.Future[_]]])Iterable[java.util.concurrent.Future[_]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,java.util.concurrent.Future[_],Iterable[java.util.concurrent.Future[_]]]" class="delimiter">(</span><a href="#kafka.log;LogManager.shutdown.$anonfun.pool" title="java.util.concurrent.ExecutorService">pool</a>.<a href="#kafka.log;LogManager.shutdown.$anonfun.$anonfun.x$1" title="(x$1: Runnable)java.util.concurrent.Future[_]">submit</a><span class="delimiter">)</span>.<span title="=&gt; Seq[java.util.concurrent.Future[_]]">toSeq</span>
    <span class="delimiter">}</span>


    try <span class="delimiter">{</span>
      for <span class="delimiter">(</span><span class="delimiter">(</span><span title="java.io.File">dir</span>, <a title="Seq[java.util.concurrent.Future[_]]" id="kafka.log;LogManager.shutdown.$anonfun.dirJobs">dirJobs</a><span class="delimiter">)</span> &lt;- <a href="#kafka.log;LogManager.shutdown.jobs" title="(f: ((java.io.File, Seq[java.util.concurrent.Future[_]])) =&gt; Unit)Unit">jobs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#kafka.log;LogManager.shutdown.$anonfun.dirJobs" title="Seq[java.util.concurrent.Future[_]]">dirJobs</a>.<span title="(f: java.util.concurrent.Future[_] =&gt; Any)Unit">foreach</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.shutdown.$anonfun.$anonfun.x$5" title="java.util.concurrent.Future[_]">_</a>.<span title="()_$2">get</span><span class="delimiter">)</span>

        <span class="comment">// update the last flush point</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Updating recovery points at &quot;)" class="string">&quot;Updating recovery points at &quot;</span> <span title="(x$1: Any)String">+</span> <span title="java.io.File">dir</span><span class="delimiter">)</span>
        <a href="#kafka.log;LogManager.checkpointLogsInDir" title="(dir: java.io.File)Unit">checkpointLogsInDir</a><span class="delimiter">(</span><span title="java.io.File">dir</span><span class="delimiter">)</span>

        <span class="comment">// mark that the shutdown was clean by creating marker file</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Writing clean shutdown marker at &quot;)" class="string">&quot;Writing clean shutdown marker at &quot;</span> <span title="(x$1: Any)String">+</span> <span title="java.io.File">dir</span><span class="delimiter">)</span>
        <a href="../utils/Utils.scala.html#kafka.utils.Utils" title="kafka.utils.Utils.type">Utils</a>.<a href="../utils/Logging.scala.html#kafka.utils;Logging.swallow" title="(action: =&gt; Unit)Unit">swallow</a><span class="delimiter">(</span>new <span title="java.io.File">File</span><span class="delimiter">(</span><span title="java.io.File">dir</span>, <a href="Log.scala.html#kafka.log.Log" title="kafka.log.Log.type">Log</a>.<a href="Log.scala.html#kafka.log.Log.CleanShutdownFile" title="=&gt; String">CleanShutdownFile</a><span class="delimiter">)</span>.<span title="()Boolean">createNewFile</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> catch <span class="delimiter">{</span>
      case <a title="java.util.concurrent.ExecutionException" id="kafka.log;LogManager.shutdown.e">e</a>: <span title="java.util.concurrent.ExecutionException">ExecutionException</span> =&gt; <span class="delimiter">{</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.error(1729dbc42f)" title="(msg: =&gt; String)Unit">error</a><span class="delimiter">(</span><span title="String(&quot;There was an error in one of the threads during LogManager shutdown: &quot;)" class="string">&quot;There was an error in one of the threads during LogManager shutdown: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogManager.shutdown.e" title="java.util.concurrent.ExecutionException">e</a>.<span title="()Throwable">getCause</span><span class="delimiter">)</span>
        throw <a href="#kafka.log;LogManager.shutdown.e" title="java.util.concurrent.ExecutionException">e</a>.<span title="()Throwable">getCause</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> finally <span class="delimiter">{</span>
      <a href="#kafka.log;LogManager.shutdown.threadPools" title="scala.collection.mutable.ArrayBuffer[java.util.concurrent.ExecutorService]">threadPools</a>.<span title="(f: java.util.concurrent.ExecutorService =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.shutdown.$anonfun.x$7" title="java.util.concurrent.ExecutorService">_</a>.<span title="()Unit">shutdown</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="comment">// regardless of whether the close succeeded, we need to unlock the data directories</span>
      <a href="#kafka.log;LogManager.dirLocks" title="=&gt; Seq[kafka.utils.FileLock]">dirLocks</a>.<span title="(f: kafka.utils.FileLock =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.shutdown.$anonfun.x$8" title="kafka.utils.FileLock">_</a>.<a href="../utils/FileLock.scala.html#kafka.utils;FileLock.destroy" title="()Unit">destroy</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="String(&quot;Shutdown complete.&quot;)" class="string">&quot;Shutdown complete.&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>


  <span class="comment">/**
   * Truncate the partition logs to the specified offsets and checkpoint the recovery point to this offset
   *
   * @param partitionAndOffsets Partition logs that need to be truncated
   */</span>
  def <a title="(partitionAndOffsets: scala.collection.Map[kafka.common.TopicAndPartition,Long])Unit" id="kafka.log;LogManager.truncateTo">truncateTo</a><span class="delimiter">(</span><a title="scala.collection.Map[kafka.common.TopicAndPartition,Long]" id="kafka.log;LogManager.truncateTo.partitionAndOffsets">partitionAndOffsets</a>: <span title="scala.collection.Map[kafka.common.TopicAndPartition,Long]">Map</span><span class="delimiter">[</span>TopicAndPartition, Long<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    for <span class="delimiter">(</span><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.log;LogManager.truncateTo.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="Long" id="kafka.log;LogManager.truncateTo.$anonfun.truncateOffset">truncateOffset</a><span class="delimiter">)</span> &lt;- <a href="#kafka.log;LogManager.truncateTo.partitionAndOffsets" title="(f: ((kafka.common.TopicAndPartition, Long)) =&gt; Unit)Unit">partitionAndOffsets</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="kafka.log.Log" id="kafka.log;LogManager.truncateTo.$anonfun.log">log</a> = <a href="#kafka.log;LogManager.logs" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.log.Log]">logs</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.get" title="(key: kafka.common.TopicAndPartition)kafka.log.Log">get</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.truncateTo.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
      <span class="comment">// If the log does not exist, skip it</span>
      if <span class="delimiter">(</span><a href="#kafka.log;LogManager.truncateTo.$anonfun.log" title="kafka.log.Log">log</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">//May need to abort and pause the cleaning of the log, and resume after truncation is done.</span>
        val needToStopCleaner: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#kafka.log;LogManager.truncateTo.$anonfun.truncateOffset" title="Long">truncateOffset</a> <a title="Boolean" id="kafka.log;LogManager.truncateTo.$anonfun.needToStopCleaner">&lt;</a> <a href="#kafka.log;LogManager.truncateTo.$anonfun.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.activeSegment" title="=&gt; kafka.log.LogSegment">activeSegment</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.baseOffset" title="=&gt; Long">baseOffset</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#kafka.log;LogManager.truncateTo.$anonfun.needToStopCleaner" title="Boolean">needToStopCleaner</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.log;LogManager.cleaner" title="=&gt; kafka.log.LogCleaner">cleaner</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span>
          <a href="#kafka.log;LogManager.cleaner" title="=&gt; kafka.log.LogCleaner">cleaner</a>.<a href="LogCleaner.scala.html#kafka.log;LogCleaner.abortAndPauseCleaning" title="(topicAndPartition: kafka.common.TopicAndPartition)Unit">abortAndPauseCleaning</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.truncateTo.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
        <a href="#kafka.log;LogManager.truncateTo.$anonfun.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.truncateTo" title="(targetOffset: Long)Unit">truncateTo</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.truncateTo.$anonfun.truncateOffset" title="Long">truncateOffset</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#kafka.log;LogManager.truncateTo.$anonfun.needToStopCleaner" title="Boolean">needToStopCleaner</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.log;LogManager.cleaner" title="=&gt; kafka.log.LogCleaner">cleaner</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span>
          <a href="#kafka.log;LogManager.cleaner" title="=&gt; kafka.log.LogCleaner">cleaner</a>.<a href="LogCleaner.scala.html#kafka.log;LogCleaner.resumeCleaning" title="(topicAndPartition: kafka.common.TopicAndPartition)Unit">resumeCleaning</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.truncateTo.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#kafka.log;LogManager.checkpointRecoveryPointOffsets" title="()Unit">checkpointRecoveryPointOffsets</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   *  Delete all data in a partition and start the log at the new offset
   *  @param newOffset The new offset to start the log with
   */</span>
  def <a title="(topicAndPartition: kafka.common.TopicAndPartition, newOffset: Long)Unit" id="kafka.log;LogManager.truncateFullyAndStartAt">truncateFullyAndStartAt</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.log;LogManager.truncateFullyAndStartAt.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a>, <a title="Long" id="kafka.log;LogManager.truncateFullyAndStartAt.newOffset">newOffset</a>: <span title="Long">Long</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="kafka.log.Log" id="kafka.log;LogManager.truncateFullyAndStartAt.log">log</a> = <a href="#kafka.log;LogManager.logs" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.log.Log]">logs</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.get" title="(key: kafka.common.TopicAndPartition)kafka.log.Log">get</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.truncateFullyAndStartAt.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
    <span class="comment">// If the log does not exist, skip it</span>
    if <span class="delimiter">(</span><a href="#kafka.log;LogManager.truncateFullyAndStartAt.log" title="kafka.log.Log">log</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">//Abort and pause the cleaning of the log, and resume after truncation is done.</span>
      if <span class="delimiter">(</span><a href="#kafka.log;LogManager.cleaner" title="=&gt; kafka.log.LogCleaner">cleaner</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span>
        <a href="#kafka.log;LogManager.cleaner" title="=&gt; kafka.log.LogCleaner">cleaner</a>.<a href="LogCleaner.scala.html#kafka.log;LogCleaner.abortAndPauseCleaning" title="(topicAndPartition: kafka.common.TopicAndPartition)Unit">abortAndPauseCleaning</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.truncateFullyAndStartAt.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
      <a href="#kafka.log;LogManager.truncateFullyAndStartAt.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.truncateFullyAndStartAt" title="(newOffset: Long)Unit">truncateFullyAndStartAt</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.truncateFullyAndStartAt.newOffset" title="Long">newOffset</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#kafka.log;LogManager.cleaner" title="=&gt; kafka.log.LogCleaner">cleaner</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span>
        <a href="#kafka.log;LogManager.cleaner" title="=&gt; kafka.log.LogCleaner">cleaner</a>.<a href="LogCleaner.scala.html#kafka.log;LogCleaner.resumeCleaning" title="(topicAndPartition: kafka.common.TopicAndPartition)Unit">resumeCleaning</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.truncateFullyAndStartAt.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#kafka.log;LogManager.checkpointRecoveryPointOffsets" title="()Unit">checkpointRecoveryPointOffsets</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Write out the current recovery point for all logs to a text file in the log directory 
   * to avoid recovering the whole log on startup.
   */</span>
  def <a title="()Unit" id="kafka.log;LogManager.checkpointRecoveryPointOffsets">checkpointRecoveryPointOffsets</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    this.<a href="#kafka.log;LogManager.logDirs" title="(xs: Array[java.io.File])scala.collection.mutable.ArrayOps[java.io.File]">logDirs</a>.<span title="(f: java.io.File =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.checkpointLogsInDir" title="(dir: java.io.File)Unit">checkpointLogsInDir</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Make a checkpoint for all logs in provided directory.
   */</span>
  private def <a title="(dir: java.io.File)Unit" id="kafka.log;LogManager.checkpointLogsInDir">checkpointLogsInDir</a><span class="delimiter">(</span><a title="java.io.File" id="kafka.log;LogManager.checkpointLogsInDir.dir">dir</a>: <span title="java.io.File">File</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    val <a title="Option[scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.log.Log]]" id="kafka.log;LogManager.checkpointLogsInDir.recoveryPoints">recoveryPoints</a> = this.<a href="#kafka.log;LogManager.logsByDir" title="=&gt; scala.collection.immutable.Map[String,scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.log.Log]]">logsByDir</a>.<span title="(key: String)Option[scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.log.Log]]">get</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.checkpointLogsInDir.dir" title="java.io.File">dir</a>.<span title="()String">toString</span><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#kafka.log;LogManager.checkpointLogsInDir.recoveryPoints" title="Option[scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.log.Log]]">recoveryPoints</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      this.<a href="#kafka.log;LogManager.recoveryPointCheckpoints" title="(key: java.io.File)kafka.server.OffsetCheckpoint">recoveryPointCheckpoints</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.checkpointLogsInDir.dir" title="java.io.File">dir</a><span class="delimiter">)</span>.<a href="../server/OffsetCheckpoint.scala.html#kafka.server;OffsetCheckpoint.write" title="(offsets: scala.collection.Map[kafka.common.TopicAndPartition,Long])Unit">write</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.checkpointLogsInDir.recoveryPoints" title="Option[scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.log.Log]]">recoveryPoints</a>.<span title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.log.Log]">get</span>.<span title="(f: kafka.log.Log =&gt; Long)scala.collection.immutable.Map[kafka.common.TopicAndPartition,Long]">mapValues</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.checkpointLogsInDir.$anonfun.x$10" title="kafka.log.Log">_</a>.<a href="Log.scala.html#kafka.log;Log.recoveryPoint" title="=&gt; Long">recoveryPoint</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Get the log if it exists, otherwise return None
   */</span>
  def <a title="(topicAndPartition: kafka.common.TopicAndPartition)Option[kafka.log.Log]" id="kafka.log;LogManager.getLog">getLog</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.log;LogManager.getLog.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">)</span>: <span title="Option[kafka.log.Log]">Option</span><span class="delimiter">[</span>Log<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="kafka.log.Log" id="kafka.log;LogManager.getLog.log">log</a> = <a href="#kafka.log;LogManager.logs" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.log.Log]">logs</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.get" title="(key: kafka.common.TopicAndPartition)kafka.log.Log">get</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.getLog.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#kafka.log;LogManager.getLog.log" title="kafka.log.Log">log</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span>
      <span title="None.type">None</span>
    else
      <span title="(x: kafka.log.Log)Some[kafka.log.Log]">Some</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.getLog.log" title="kafka.log.Log">log</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Create a log for the given topic and the given partition
   * If the log already exists, just return a copy of the existing log
   */</span>
  def <a title="(topicAndPartition: kafka.common.TopicAndPartition, config: kafka.log.LogConfig)kafka.log.Log" id="kafka.log;LogManager.createLog">createLog</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.log;LogManager.createLog.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a>, <a title="kafka.log.LogConfig" id="kafka.log;LogManager.createLog.config">config</a>: <a href="LogConfig.scala.html#kafka.log;LogConfig" title="kafka.log.LogConfig">LogConfig</a><span class="delimiter">)</span>: <a href="Log.scala.html#kafka.log;Log" title="kafka.log.Log">Log</a> = <span class="delimiter">{</span>
    <a href="#kafka.log;LogManager.logCreationOrDeletionLock" title="=&gt; Object">logCreationOrDeletionLock</a> <span title="(x$1: kafka.log.Log)kafka.log.Log">synchronized</span> <span class="delimiter">{</span>
      var <a title="kafka.log.Log" id="kafka.log;LogManager.createLog.log">log</a> = <a href="#kafka.log;LogManager.logs" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.log.Log]">logs</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.get" title="(key: kafka.common.TopicAndPartition)kafka.log.Log">get</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.createLog.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
      
      <span class="comment">// check if the log has already been created in another thread</span>
      if<span class="delimiter">(</span><a href="#kafka.log;LogManager.createLog.log" title="kafka.log.Log">log</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span>
        return <a href="#kafka.log;LogManager.createLog.log" title="kafka.log.Log">log</a>
      
      <span class="comment">// if not, create it</span>
      val <a title="java.io.File" id="kafka.log;LogManager.createLog.dataDir">dataDir</a> = <a href="#kafka.log;LogManager.nextLogDir" title="()java.io.File">nextLogDir</a><span class="delimiter">(</span><span class="delimiter">)</span>
      val <a title="java.io.File" id="kafka.log;LogManager.createLog.dir">dir</a> = new <span title="java.io.File">File</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.createLog.dataDir" title="java.io.File">dataDir</a>, <a href="#kafka.log;LogManager.createLog.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;-&quot;)" class="string">&quot;-&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogManager.createLog.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a><span class="delimiter">)</span>
      <a href="#kafka.log;LogManager.createLog.dir" title="java.io.File">dir</a>.<span title="()Boolean">mkdirs</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#kafka.log;LogManager.createLog.log" title="kafka.log.Log">log</a> = new <a href="Log.scala.html#kafka.log;Log" title="kafka.log.Log">Log</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.createLog.dir" title="java.io.File">dir</a>, 
                    <a href="#kafka.log;LogManager.createLog.config" title="kafka.log.LogConfig">config</a>,
                    recoveryPoint = <span title="Long(0L)" class="long">0L</span>,
                    <a href="#kafka.log;LogManager.scheduler" title="kafka.utils.Scheduler">scheduler</a>,
                    <a href="#kafka.log;LogManager.time" title="=&gt; kafka.utils.Time">time</a><span class="delimiter">)</span>
      <a href="#kafka.log;LogManager.logs" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.log.Log]">logs</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.put" title="(k: kafka.common.TopicAndPartition, v: kafka.log.Log)kafka.log.Log">put</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.createLog.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.log;LogManager.createLog.log" title="kafka.log.Log">log</a><span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Created log for partition [%s,%d] in %s with properties {%s}.&quot;</span>
           .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.createLog.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, 
                   <a href="#kafka.log;LogManager.createLog.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a>, 
                   <a href="#kafka.log;LogManager.createLog.dataDir" title="java.io.File">dataDir</a>.<span title="()String">getAbsolutePath</span>,
                   <span class="delimiter">{</span>import <span title="scala.collection.JavaConversions.type">JavaConversions</span>._; <a href="#kafka.log;LogManager.createLog.config" title="kafka.log.LogConfig">config</a>.<a href="LogConfig.scala.html#kafka.log;LogConfig.toProps" title="implicit scala.collection.convert.WrapAsScala.propertiesAsScalaMap : (p: java.util.Properties)scala.collection.mutable.Map[String,String]">toProps</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.log;LogManager.createLog.log" title="kafka.log.Log">log</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   *  Delete a log.
   */</span>
  def <a title="(topicAndPartition: kafka.common.TopicAndPartition)Unit" id="kafka.log;LogManager.deleteLog">deleteLog</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.log;LogManager.deleteLog.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    var <a title="kafka.log.Log" id="kafka.log;LogManager.deleteLog.removedLog">removedLog</a>: <a href="Log.scala.html#kafka.log;Log" title="kafka.log.Log">Log</a> = null
    <a href="#kafka.log;LogManager.logCreationOrDeletionLock" title="=&gt; Object">logCreationOrDeletionLock</a> <span title="(x$1: Unit)Unit">synchronized</span> <span class="delimiter">{</span>
      <a href="#kafka.log;LogManager.deleteLog.removedLog" title="kafka.log.Log">removedLog</a> = <a href="#kafka.log;LogManager.logs" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.log.Log]">logs</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.remove" title="(key: kafka.common.TopicAndPartition)kafka.log.Log">remove</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.deleteLog.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    if <span class="delimiter">(</span><a href="#kafka.log;LogManager.deleteLog.removedLog" title="kafka.log.Log">removedLog</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">//We need to wait until there is no more cleaning task on the log to be deleted before actually deleting it.</span>
      if <span class="delimiter">(</span><a href="#kafka.log;LogManager.cleaner" title="=&gt; kafka.log.LogCleaner">cleaner</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#kafka.log;LogManager.cleaner" title="=&gt; kafka.log.LogCleaner">cleaner</a>.<a href="LogCleaner.scala.html#kafka.log;LogCleaner.abortCleaning" title="(topicAndPartition: kafka.common.TopicAndPartition)Unit">abortCleaning</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.deleteLog.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
        <a href="#kafka.log;LogManager.cleaner" title="=&gt; kafka.log.LogCleaner">cleaner</a>.<a href="LogCleaner.scala.html#kafka.log;LogCleaner.updateCheckpoints" title="(dataDir: java.io.File)Unit">updateCheckpoints</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.deleteLog.removedLog" title="kafka.log.Log">removedLog</a>.<a href="Log.scala.html#kafka.log;Log.dir" title="=&gt; java.io.File">dir</a>.<span title="()java.io.File">getParentFile</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#kafka.log;LogManager.deleteLog.removedLog" title="kafka.log.Log">removedLog</a>.<a href="Log.scala.html#kafka.log;Log.delete" title="()Unit">delete</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Deleted log for partition [%s,%d] in %s.&quot;</span>
           .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.deleteLog.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>,
                   <a href="#kafka.log;LogManager.deleteLog.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a>,
                   <a href="#kafka.log;LogManager.deleteLog.removedLog" title="kafka.log.Log">removedLog</a>.<a href="Log.scala.html#kafka.log;Log.dir" title="=&gt; java.io.File">dir</a>.<span title="()String">getAbsolutePath</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Choose the next directory in which to create a log. Currently this is done
   * by calculating the number of partitions in each directory and then choosing the
   * data directory with the fewest partitions.
   */</span>
  private def <a title="()java.io.File" id="kafka.log;LogManager.nextLogDir">nextLogDir</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="java.io.File">File</span> = <span class="delimiter">{</span>
    if<span class="delimiter">(</span><a href="#kafka.log;LogManager.logDirs" title="(xs: Array[java.io.File])scala.collection.mutable.ArrayOps[java.io.File]">logDirs</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.log;LogManager.logDirs" title="(i: Int)java.io.File">logDirs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <span class="comment">// count the number of logs in each parent directory (including 0 for empty directories</span>
      val <a title="scala.collection.immutable.Map[String,Int]" id="kafka.log;LogManager.nextLogDir.logCounts">logCounts</a> = <a href="#kafka.log;LogManager.allLogs" title="()Iterable[kafka.log.Log]">allLogs</a>.<span title="(f: kafka.log.Log =&gt; String)scala.collection.immutable.Map[String,Iterable[kafka.log.Log]]">groupBy</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.nextLogDir.logCounts.$anonfun.x$11" title="kafka.log.Log">_</a>.<a href="Log.scala.html#kafka.log;Log.dir" title="=&gt; java.io.File">dir</a>.<span title="()String">getParent</span><span class="delimiter">)</span>.<span title="(f: Iterable[kafka.log.Log] =&gt; Int)scala.collection.immutable.Map[String,Int]">mapValues</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.nextLogDir.logCounts.$anonfun.x$12" title="Iterable[kafka.log.Log]">_</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>
      val <a title="scala.collection.immutable.Map[String,Int]" id="kafka.log;LogManager.nextLogDir.zeros">zeros</a> = <a href="#kafka.log;LogManager.logDirs" title="(xs: Array[java.io.File])scala.collection.mutable.ArrayOps[java.io.File]">logDirs</a>.<span title="(f: java.io.File =&gt; (String, Int))(implicit bf: scala.collection.generic.CanBuildFrom[Array[java.io.File],(String, Int),Array[(String, Int)]])Array[(String, Int)]">map</span><span title="(xs: Array[(String, Int)])scala.collection.mutable.ArrayOps[(String, Int)]" class="delimiter">(</span><a title="java.io.File" id="kafka.log;LogManager.nextLogDir.zeros.$anonfun.dir">dir</a> =&gt; <span title="(_1: String, _2: Int)(String, Int)" class="delimiter">(</span><a href="#kafka.log;LogManager.nextLogDir.zeros.$anonfun.dir" title="java.io.File">dir</a>.<span title="()String">getPath</span>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: &lt;:&lt;[(String, Int),(String, Int)])scala.collection.immutable.Map[String,Int]">toMap</span>
      var <a title="scala.collection.mutable.Buffer[(String, Int)]" id="kafka.log;LogManager.nextLogDir.dirCounts">dirCounts</a> = <span class="delimiter">(</span><a href="#kafka.log;LogManager.nextLogDir.zeros" title="scala.collection.immutable.Map[String,Int]">zeros</a> <span title="(xs: scala.collection.GenTraversableOnce[(String, Int)])scala.collection.immutable.Map[String,Int]">++</span> <a href="#kafka.log;LogManager.nextLogDir.logCounts" title="scala.collection.immutable.Map[String,Int]">logCounts</a><span class="delimiter">)</span>.<span title="scala.collection.mutable.Buffer[(String, Int)]">toBuffer</span>
    
      <span class="comment">// choose the directory with the least logs in it</span>
      val <a title="(String, Int)" id="kafka.log;LogManager.nextLogDir.leastLoaded">leastLoaded</a> = <a href="#kafka.log;LogManager.nextLogDir.dirCounts" title="scala.collection.mutable.Buffer[(String, Int)]">dirCounts</a>.<span title="(f: ((String, Int)) =&gt; Int)(implicit ord: scala.math.Ordering[Int])scala.collection.mutable.Buffer[(String, Int)]">sortBy</span><span title="scala.math.Ordering.Int.type" class="delimiter">(</span><a href="#kafka.log;LogManager.nextLogDir.leastLoaded.$anonfun.x$13" title="(String, Int)">_</a>.<span title="=&gt; Int">_2</span><span class="delimiter">)</span>.<span title="=&gt; (String, Int)">head</span>
      new <span title="java.io.File">File</span><span class="delimiter">(</span><a href="#kafka.log;LogManager.nextLogDir.leastLoaded" title="(String, Int)">leastLoaded</a>.<span title="=&gt; String">_1</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Runs through the log removing segments older than a certain age
   */</span>
  private def <a title="(log: kafka.log.Log)Int" id="kafka.log;LogManager.cleanupExpiredSegments">cleanupExpiredSegments</a><span class="delimiter">(</span><a title="kafka.log.Log" id="kafka.log;LogManager.cleanupExpiredSegments.log">log</a>: <a href="Log.scala.html#kafka.log;Log" title="kafka.log.Log">Log</a><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
    val <a title="Long" id="kafka.log;LogManager.cleanupExpiredSegments.startMs">startMs</a> = <a href="#kafka.log;LogManager.time" title="=&gt; kafka.utils.Time">time</a>.<a href="../utils/Time.scala.html#kafka.utils;Time.milliseconds" title="=&gt; Long">milliseconds</a>
    <a href="#kafka.log;LogManager.cleanupExpiredSegments.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.deleteOldSegments" title="(predicate: kafka.log.LogSegment =&gt; Boolean)Int">deleteOldSegments</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.cleanupExpiredSegments.startMs" title="Long">startMs</a> <span title="(x: Long)Long">-</span> <a href="#kafka.log;LogManager.cleanupExpiredSegments.$anonfun.x$14" title="kafka.log.LogSegment">_</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.lastModified" title="=&gt; Long">lastModified</a> <span title="(x: Long)Boolean">&gt;</span> <a href="#kafka.log;LogManager.cleanupExpiredSegments.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.config" title="=&gt; kafka.log.LogConfig">config</a>.<a href="LogConfig.scala.html#kafka.log;LogConfig.retentionMs" title="=&gt; Long">retentionMs</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   *  Runs through the log removing segments until the size of the log
   *  is at least logRetentionSize bytes in size
   */</span>
  private def <a title="(log: kafka.log.Log)Int" id="kafka.log;LogManager.cleanupSegmentsToMaintainSize">cleanupSegmentsToMaintainSize</a><span class="delimiter">(</span><a title="kafka.log.Log" id="kafka.log;LogManager.cleanupSegmentsToMaintainSize.log">log</a>: <a href="Log.scala.html#kafka.log;Log" title="kafka.log.Log">Log</a><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
    if<span class="delimiter">(</span><a href="#kafka.log;LogManager.cleanupSegmentsToMaintainSize.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.config" title="=&gt; kafka.log.LogConfig">config</a>.<a href="LogConfig.scala.html#kafka.log;LogConfig.retentionSize" title="=&gt; Long">retentionSize</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#kafka.log;LogManager.cleanupSegmentsToMaintainSize.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.size" title="=&gt; Long">size</a> <span title="(x: Long)Boolean">&lt;</span> <a href="#kafka.log;LogManager.cleanupSegmentsToMaintainSize.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.config" title="=&gt; kafka.log.LogConfig">config</a>.<a href="LogConfig.scala.html#kafka.log;LogConfig.retentionSize" title="=&gt; Long">retentionSize</a><span class="delimiter">)</span>
      return <span title="Int(0)" class="int">0</span>
    var diff = <a href="#kafka.log;LogManager.cleanupSegmentsToMaintainSize.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.size" title="=&gt; Long">size</a> <a title="Long" id="kafka.log;LogManager.cleanupSegmentsToMaintainSize.diff">-</a> <a href="#kafka.log;LogManager.cleanupSegmentsToMaintainSize.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.config" title="=&gt; kafka.log.LogConfig">config</a>.<a href="LogConfig.scala.html#kafka.log;LogConfig.retentionSize" title="=&gt; Long">retentionSize</a>
    def <a title="(segment: kafka.log.LogSegment)Boolean" id="kafka.log;LogManager.cleanupSegmentsToMaintainSize.shouldDelete">shouldDelete</a><span class="delimiter">(</span><a title="kafka.log.LogSegment" id="kafka.log;LogManager.cleanupSegmentsToMaintainSize.shouldDelete.segment">segment</a>: <a href="LogSegment.scala.html#kafka.log;LogSegment" title="kafka.log.LogSegment">LogSegment</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      if<span class="delimiter">(</span><a href="#kafka.log;LogManager.cleanupSegmentsToMaintainSize.diff" title="Long">diff</a> <span title="(x: Long)Long">-</span> <a href="#kafka.log;LogManager.cleanupSegmentsToMaintainSize.shouldDelete.segment" title="kafka.log.LogSegment">segment</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.size" title="=&gt; Long">size</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#kafka.log;LogManager.cleanupSegmentsToMaintainSize.diff" title="Long">diff</a> <span title="(x: Long)Long">-=</span> <a href="#kafka.log;LogManager.cleanupSegmentsToMaintainSize.shouldDelete.segment" title="kafka.log.LogSegment">segment</a>.<a href="LogSegment.scala.html#kafka.log;LogSegment.size" title="=&gt; Long">size</a>
        true
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        false
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#kafka.log;LogManager.cleanupSegmentsToMaintainSize.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.deleteOldSegments" title="(predicate: kafka.log.LogSegment =&gt; Boolean)Int">deleteOldSegments</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.cleanupSegmentsToMaintainSize.shouldDelete" title="(segment: kafka.log.LogSegment)Boolean">shouldDelete</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Delete any eligible logs. Return the number of segments deleted.
   */</span>
  def <a title="()Unit" id="kafka.log;LogManager.cleanupLogs">cleanupLogs</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Beginning log cleanup...&quot;)" class="string">&quot;Beginning log cleanup...&quot;</span><span class="delimiter">)</span>
    var <a title="Int" id="kafka.log;LogManager.cleanupLogs.total">total</a> = <span title="Int(0)" class="int">0</span>
    val <a title="Long" id="kafka.log;LogManager.cleanupLogs.startMs">startMs</a> = <a href="#kafka.log;LogManager.time" title="=&gt; kafka.utils.Time">time</a>.<a href="../utils/Time.scala.html#kafka.utils;Time.milliseconds" title="=&gt; Long">milliseconds</a>
    for<span class="delimiter">(</span><a title="kafka.log.Log" id="kafka.log;LogManager.cleanupLogs.$anonfun.log">log</a> &lt;- <a href="#kafka.log;LogManager.allLogs" title="(f: kafka.log.Log =&gt; Unit)Unit">allLogs</a>; if <span title="=&gt; Boolean">!</span><a href="#kafka.log;LogManager.cleanupLogs.$anonfun.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.config" title="=&gt; kafka.log.LogConfig">config</a>.<a href="LogConfig.scala.html#kafka.log;LogConfig.compact" title="=&gt; Boolean">compact</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Garbage collecting \'&quot;)" class="string">&quot;Garbage collecting '&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogManager.cleanupLogs.$anonfun.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.name" title="=&gt; String">name</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\'&quot;)" class="string">&quot;'&quot;</span><span class="delimiter">)</span>
      <a href="#kafka.log;LogManager.cleanupLogs.total" title="Int">total</a> <span title="(x: Int)Int">+=</span> <a href="#kafka.log;LogManager.cleanupExpiredSegments" title="(log: kafka.log.Log)Int">cleanupExpiredSegments</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.cleanupLogs.$anonfun.log" title="kafka.log.Log">log</a><span class="delimiter">)</span> <span title="(x: Int)Int">+</span> <a href="#kafka.log;LogManager.cleanupSegmentsToMaintainSize" title="(log: kafka.log.Log)Int">cleanupSegmentsToMaintainSize</a><span class="delimiter">(</span><a href="#kafka.log;LogManager.cleanupLogs.$anonfun.log" title="kafka.log.Log">log</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Log cleanup completed. &quot;)" class="string">&quot;Log cleanup completed. &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogManager.cleanupLogs.total" title="Int">total</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; files deleted in &quot;)" class="string">&quot; files deleted in &quot;</span> <span title="(x$1: Any)String">+</span>
                  <span class="delimiter">(</span><a href="#kafka.log;LogManager.time" title="=&gt; kafka.utils.Time">time</a>.<a href="../utils/Time.scala.html#kafka.utils;Time.milliseconds" title="=&gt; Long">milliseconds</a> <span title="(x: Long)Long">-</span> <a href="#kafka.log;LogManager.cleanupLogs.startMs" title="Long">startMs</a><span class="delimiter">)</span> <span title="(x: Int)Long">/</span> <span title="Int(1000)" class="int">1000</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; seconds&quot;)" class="string">&quot; seconds&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Get all the partition logs
   */</span>
  def <a title="()Iterable[kafka.log.Log]" id="kafka.log;LogManager.allLogs">allLogs</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Iterable[kafka.log.Log]">Iterable</span><span class="delimiter">[</span>Log<span class="delimiter">]</span> = <a href="#kafka.log;LogManager.logs" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.log.Log]">logs</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.values" title="=&gt; Iterable[kafka.log.Log]">values</a>

  <span class="comment">/**
   * Get a map of TopicAndPartition =&gt; Log
   */</span>
  def <a title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.log.Log]" id="kafka.log;LogManager.logsByTopicPartition">logsByTopicPartition</a> = <a href="#kafka.log;LogManager.logs" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.log.Log]">logs</a>.<span title="(implicit ev: &lt;:&lt;[(kafka.common.TopicAndPartition, kafka.log.Log),(kafka.common.TopicAndPartition, kafka.log.Log)])scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.log.Log]">toMap</span>

  <span class="comment">/**
   * Map of log dir to logs by topic and partitions in that dir
   */</span>
  private def <a title="=&gt; scala.collection.immutable.Map[String,scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.log.Log]]" id="kafka.log;LogManager.logsByDir">logsByDir</a> = <span class="delimiter">{</span>
    this.<a href="#kafka.log;LogManager.logsByTopicPartition" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.log.Log]">logsByTopicPartition</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.log.Log)) =&gt; String)scala.collection.immutable.Map[String,scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.log.Log]]">groupBy</span> <a href="#kafka.log;LogManager.logsByDir.$anonfun.x0$1" title="String" class="delimiter">{</a>
      case <span class="delimiter">(</span>_, <a title="kafka.log.Log" id="kafka.log;LogManager.logsByDir.$anonfun.log">log</a><span class="delimiter">)</span> =&gt; <a href="#kafka.log;LogManager.logsByDir.$anonfun.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.dir" title="=&gt; java.io.File">dir</a>.<span title="()String">getParent</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Flush any log which has exceeded its flush interval and has unwritten messages.
   */</span>
  private def <a title="()Unit" id="kafka.log;LogManager.flushDirtyLogs">flushDirtyLogs</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Checking for dirty logs to flush...&quot;)" class="string">&quot;Checking for dirty logs to flush...&quot;</span><span class="delimiter">)</span>

    for <span class="delimiter">(</span><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.log;LogManager.flushDirtyLogs.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="kafka.log.Log" id="kafka.log;LogManager.flushDirtyLogs.$anonfun.log">log</a><span class="delimiter">)</span> &lt;- <a href="#kafka.log;LogManager.logs" title="(f: ((kafka.common.TopicAndPartition, kafka.log.Log)) =&gt; Unit)Unit">logs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      try <span class="delimiter">{</span>
        val timeSinceLastFlush = <a href="#kafka.log;LogManager.time" title="=&gt; kafka.utils.Time">time</a>.<a href="../utils/Time.scala.html#kafka.utils;Time.milliseconds" title="=&gt; Long">milliseconds</a> <a title="Long" id="kafka.log;LogManager.flushDirtyLogs.$anonfun.timeSinceLastFlush">-</a> <a href="#kafka.log;LogManager.flushDirtyLogs.$anonfun.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.lastFlushTime" title="()Long">lastFlushTime</a>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Checking if flush is needed on &quot;)" class="string">&quot;Checking if flush is needed on &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogManager.flushDirtyLogs.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; flush interval  &quot;)" class="string">&quot; flush interval  &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogManager.flushDirtyLogs.$anonfun.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.config" title="=&gt; kafka.log.LogConfig">config</a>.<a href="LogConfig.scala.html#kafka.log;LogConfig.flushMs" title="=&gt; Long">flushMs</a> <span title="(x$1: Any)String">+</span>
              <span title="String(&quot; last flushed &quot;)" class="string">&quot; last flushed &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogManager.flushDirtyLogs.$anonfun.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.lastFlushTime" title="()Long">lastFlushTime</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; time since last flush: &quot;)" class="string">&quot; time since last flush: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogManager.flushDirtyLogs.$anonfun.timeSinceLastFlush" title="Long">timeSinceLastFlush</a><span class="delimiter">)</span>
        if<span class="delimiter">(</span><a href="#kafka.log;LogManager.flushDirtyLogs.$anonfun.timeSinceLastFlush" title="Long">timeSinceLastFlush</a> <span title="(x: Long)Boolean">&gt;=</span> <a href="#kafka.log;LogManager.flushDirtyLogs.$anonfun.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.config" title="=&gt; kafka.log.LogConfig">config</a>.<a href="LogConfig.scala.html#kafka.log;LogConfig.flushMs" title="=&gt; Long">flushMs</a><span class="delimiter">)</span>
          <a href="#kafka.log;LogManager.flushDirtyLogs.$anonfun.log" title="kafka.log.Log">log</a>.<a href="Log.scala.html#kafka.log;Log.flush(aa97cb1b3d)" title="()Unit">flush</a>
      <span class="delimiter">}</span> catch <span class="delimiter">{</span>
        case <a title="Throwable" id="kafka.log;LogManager.flushDirtyLogs.$anonfun.e">e</a>: <span title="Throwable">Throwable</span> =&gt;
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.error(cfd112d89b)" title="(msg: =&gt; String, e: =&gt; Throwable)Unit">error</a><span class="delimiter">(</span><span title="String(&quot;Error flushing topic &quot;)" class="string">&quot;Error flushing topic &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.log;LogManager.flushDirtyLogs.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.log;LogManager.flushDirtyLogs.$anonfun.e" title="Throwable">e</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
