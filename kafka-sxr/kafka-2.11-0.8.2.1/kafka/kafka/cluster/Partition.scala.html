<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/cluster/Partition.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>
package kafka.cluster

import kafka.common._
import kafka.admin.AdminUtils
import kafka.utils._
import kafka.api.<span class="delimiter">{</span>PartitionStateInfo, LeaderAndIsr<span class="delimiter">}</span>
import kafka.log.LogConfig
import kafka.server.<span class="delimiter">{</span>LogOffsetMetadata, OffsetManager, ReplicaManager<span class="delimiter">}</span>
import kafka.metrics.KafkaMetricsGroup
import kafka.controller.KafkaController
import kafka.message.ByteBufferMessageSet

import java.io.IOException
import java.util.concurrent.locks.ReentrantReadWriteLock
import kafka.utils.<a href="../utils/Utils.scala.html#kafka.utils.Utils" title="kafka.utils.Utils.type">Utils</a>.<span class="delimiter">{</span>inReadLock,inWriteLock<span class="delimiter">}</span>
import scala.collection.immutable.Set

import com.yammer.metrics.core.Gauge


<span class="comment">/**
 * Data structure that represents a topic partition. The leader maintains the AR, ISR, CUR, RAR
 */</span>
class <a title="class Partition extends AnyRef with kafka.utils.Logging with kafka.metrics.KafkaMetricsGroup" id="kafka.cluster;Partition">Partition</a><a href="#kafka.cluster;Partition" title="kafka.cluster.Partition" class="delimiter">(</a>val <a title="String" id="kafka.cluster;Partition.topic">topic</a>: <span title="String">String</span>,
                val <a title="Int" id="kafka.cluster;Partition.partitionId">partitionId</a>: <span title="Int">Int</span>,
                <a title="kafka.utils.Time" id="kafka.cluster;Partition.time">time</a>: <a href="../utils/Time.scala.html#kafka.utils;Time" title="kafka.utils.Time">Time</a>,
                <a title="kafka.server.ReplicaManager" id="kafka.cluster;Partition.replicaManager">replicaManager</a>: <a href="../server/ReplicaManager.scala.html#kafka.server;ReplicaManager" title="kafka.server.ReplicaManager">ReplicaManager</a><span class="delimiter">)</span> extends <a href="../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> with <a href="../metrics/KafkaMetricsGroup.scala.html#kafka.metrics;KafkaMetricsGroup" title="kafka.metrics.KafkaMetricsGroup">KafkaMetricsGroup</a> <span class="delimiter">{</span>
  private val <a title="Int" id="kafka.cluster;Partition.localBrokerId">localBrokerId</a> = <a href="#kafka.cluster;Partition.replicaManager" title="kafka.server.ReplicaManager">replicaManager</a>.<a href="../server/ReplicaManager.scala.html#kafka.server;ReplicaManager.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="../server/KafkaConfig.scala.html#kafka.server;KafkaConfig.brokerId" title="=&gt; Int">brokerId</a>
  private val <a title="kafka.log.LogManager" id="kafka.cluster;Partition.logManager">logManager</a> = <a href="#kafka.cluster;Partition.replicaManager" title="kafka.server.ReplicaManager">replicaManager</a>.<a href="../server/ReplicaManager.scala.html#kafka.server;ReplicaManager.logManager" title="=&gt; kafka.log.LogManager">logManager</a>
  private val <a title="org.I0Itec.zkclient.ZkClient" id="kafka.cluster;Partition.zkClient">zkClient</a> = <a href="#kafka.cluster;Partition.replicaManager" title="kafka.server.ReplicaManager">replicaManager</a>.<a href="../server/ReplicaManager.scala.html#kafka.server;ReplicaManager.zkClient" title="=&gt; org.I0Itec.zkclient.ZkClient">zkClient</a>
  private val <a title="kafka.utils.Pool[Int,kafka.cluster.Replica]" id="kafka.cluster;Partition.assignedReplicaMap">assignedReplicaMap</a> = new <a href="../utils/Pool.scala.html#kafka.utils;Pool" title="kafka.utils.Pool[Int,kafka.cluster.Replica]">Pool</a><span class="delimiter">[</span>Int, Replica<span class="delimiter">]</span>
  <span class="comment">// The read lock is only required when multiple reads are executed and needs to be in a consistent manner</span>
  private val <a title="java.util.concurrent.locks.ReentrantReadWriteLock" id="kafka.cluster;Partition.leaderIsrUpdateLock">leaderIsrUpdateLock</a> = new <span title="java.util.concurrent.locks.ReentrantReadWriteLock">ReentrantReadWriteLock</span><span class="delimiter">(</span><span class="delimiter">)</span>
  private var <a title="Int" id="kafka.cluster;Partition.zkVersion_=">zkVersion</a>: <span title="Int">Int</span> = <a href="../api/LeaderAndIsrRequest.scala.html#kafka.api.LeaderAndIsr" title="kafka.api.LeaderAndIsr.type">LeaderAndIsr</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api.LeaderAndIsr.initialZKVersion" title="=&gt; Int">initialZKVersion</a>
  @volatile private var leaderEpoch: <span title="Int">Int</span> = <a href="../api/LeaderAndIsrRequest.scala.html#kafka.api.LeaderAndIsr" title="kafka.api.LeaderAndIsr.type">LeaderAndIsr</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api.LeaderAndIsr.initialLeaderEpoch" title="=&gt; Int">initialLeaderEpoch</a> <a title="Int" id="kafka.cluster;Partition.leaderEpoch_=">-</a> <span title="Int(1)" class="int">1</span>
  @volatile var <a title="Option[Int]" id="kafka.cluster;Partition.leaderReplicaIdOpt_=">leaderReplicaIdOpt</a>: <span title="Option[Int]">Option</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> = <span title="None.type">None</span>
  @volatile var <a title="scala.collection.immutable.Set[kafka.cluster.Replica]" id="kafka.cluster;Partition.inSyncReplicas_=">inSyncReplicas</a>: <span title="scala.collection.immutable.Set[kafka.cluster.Replica]">Set</span><span class="delimiter">[</span>Replica<span class="delimiter">]</span> = <span title="scala.collection.immutable.Set.type">Set</span>.<span title="[A]=&gt; scala.collection.immutable.Set[A]">empty</span><span title="scala.collection.immutable.Set[kafka.cluster.Replica]" class="delimiter">[</span><a href="Replica.scala.html#kafka.cluster;Replica" title="kafka.cluster.Replica">Replica</a><span class="delimiter">]</span>
  <span class="comment">/* Epoch of the controller that last changed the leader. This needs to be initialized correctly upon broker startup.
   * One way of doing that is through the controller's start replica state change command. When a new broker starts up
   * the controller sends it a start replica command containing the leader for each partition that the broker hosts.
   * In addition to the leader, the controller can also send the epoch of the controller that elected the leader for
   * each partition. */</span>
  private var controllerEpoch: <span title="Int">Int</span> = <a href="../controller/KafkaController.scala.html#kafka.controller.KafkaController" title="kafka.controller.KafkaController.type">KafkaController</a>.<a href="../controller/KafkaController.scala.html#kafka.controller.KafkaController.InitialControllerEpoch" title="=&gt; Int">InitialControllerEpoch</a> <a title="Int" id="kafka.cluster;Partition.controllerEpoch_=">-</a> <span title="Int(1)" class="int">1</span>
  this.<a href="../utils/Logging.scala.html#kafka.utils;Logging.logIdent_=" title="(x$1: String)Unit">logIdent</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Partition [%s,%d] on broker %d: &quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a>, <a href="#kafka.cluster;Partition.localBrokerId" title="=&gt; Int">localBrokerId</a><span class="delimiter">)</span>

  private def <a title="(replicaId: Int)Boolean" id="kafka.cluster;Partition.isReplicaLocal">isReplicaLocal</a><span class="delimiter">(</span><a title="Int" id="kafka.cluster;Partition.isReplicaLocal.replicaId">replicaId</a>: <span title="Int">Int</span><span class="delimiter">)</span> : <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#kafka.cluster;Partition.isReplicaLocal.replicaId" title="Int">replicaId</a> <span title="(x: Int)Boolean">==</span> <a href="#kafka.cluster;Partition.localBrokerId" title="=&gt; Int">localBrokerId</a><span class="delimiter">)</span>

  <a href="../metrics/KafkaMetricsGroup.scala.html#kafka.metrics;KafkaMetricsGroup.newGauge" title="(name: String, metric: com.yammer.metrics.core.Gauge[Int], tags: scala.collection.Map[String,String])com.yammer.metrics.core.Gauge[Int]">newGauge</a><span class="delimiter">(</span><span title="String(&quot;UnderReplicated&quot;)" class="string">&quot;UnderReplicated&quot;</span>,
    new <a title="&lt;$anon: com.yammer.metrics.core.Gauge[Int]&gt; extends com.yammer.metrics.core.Gauge[Int]" id="kafka.cluster;Partition.<local Partition>;$anon">Gauge</a><span class="delimiter">[</span>Int<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="()Int" id="kafka.cluster;Partition.<local Partition>;$anon.value">value</a> = <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#kafka.cluster;Partition.isUnderReplicated" title="()Boolean">isUnderReplicated</a><span class="delimiter">)</span> <span title="Int(1)" class="int">1</span> else <span title="Int(0)" class="int">0</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>,
    <span title="(elems: (String, String)*)scala.collection.immutable.Map[String,String]">Map</span><span class="delimiter">(</span><span title="(self: String)ArrowAssoc[String]" class="string">&quot;topic&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <span title="(self: String)ArrowAssoc[String]" class="string">&quot;partition&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a>.<span title="()String">toString</span><span class="delimiter">)</span>
  <span class="delimiter">)</span>

  def <a title="()Boolean" id="kafka.cluster;Partition.isUnderReplicated">isUnderReplicated</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <a href="#kafka.cluster;Partition.leaderReplicaIfLocal" title="()Option[kafka.cluster.Replica]">leaderReplicaIfLocal</a><span class="delimiter">(</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case Some<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
        <a href="#kafka.cluster;Partition.inSyncReplicas_=" title="=&gt; scala.collection.immutable.Set[kafka.cluster.Replica]">inSyncReplicas</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&lt;</span> <a href="#kafka.cluster;Partition.assignedReplicas" title="()scala.collection.immutable.Set[kafka.cluster.Replica]">assignedReplicas</a>.<span title="=&gt; Int">size</span>
      case <span title="None.type">None</span> =&gt;
        false
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(replicaId: Int)kafka.cluster.Replica" id="kafka.cluster;Partition.getOrCreateReplica">getOrCreateReplica</a><span class="delimiter">(</span><a title="Int" id="kafka.cluster;Partition.getOrCreateReplica$default$1">replicaId</a>: <span title="Int">Int</span> = <a href="#kafka.cluster;Partition.localBrokerId" title="=&gt; Int">localBrokerId</a><span class="delimiter">)</span>: <a href="Replica.scala.html#kafka.cluster;Replica" title="kafka.cluster.Replica">Replica</a> = <span class="delimiter">{</span>
    val <a title="Option[kafka.cluster.Replica]" id="kafka.cluster;Partition.getOrCreateReplica.replicaOpt">replicaOpt</a> = <a href="#kafka.cluster;Partition.getReplica" title="(replicaId: Int)Option[kafka.cluster.Replica]">getReplica</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.getOrCreateReplica$default$1" title="Int">replicaId</a><span class="delimiter">)</span>
    <a href="#kafka.cluster;Partition.getOrCreateReplica.replicaOpt" title="Option[kafka.cluster.Replica]">replicaOpt</a> match <span class="delimiter">{</span>
      case Some<span class="delimiter">(</span><a title="kafka.cluster.Replica" id="kafka.cluster;Partition.getOrCreateReplica.replica">replica</a><span class="delimiter">)</span> =&gt; <a href="#kafka.cluster;Partition.getOrCreateReplica.replica" title="kafka.cluster.Replica">replica</a>
      case <span title="None.type">None</span> =&gt;
        if <span class="delimiter">(</span><a href="#kafka.cluster;Partition.isReplicaLocal" title="(replicaId: Int)Boolean">isReplicaLocal</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.getOrCreateReplica$default$1" title="Int">replicaId</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          val <a title="kafka.log.LogConfig" id="kafka.cluster;Partition.getOrCreateReplica.config">config</a> = <a href="../log/LogConfig.scala.html#kafka.log.LogConfig" title="kafka.log.LogConfig.type">LogConfig</a>.<a href="../log/LogConfig.scala.html#kafka.log.LogConfig.fromProps(9d0df464c6)" title="(defaults: java.util.Properties, overrides: java.util.Properties)kafka.log.LogConfig">fromProps</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.logManager" title="=&gt; kafka.log.LogManager">logManager</a>.<a href="../log/LogManager.scala.html#kafka.log;LogManager.defaultConfig" title="=&gt; kafka.log.LogConfig">defaultConfig</a>.<a href="../log/LogConfig.scala.html#kafka.log;LogConfig.toProps" title="=&gt; java.util.Properties">toProps</a>, <a href="../admin/AdminUtils.scala.html#kafka.admin.AdminUtils" title="kafka.admin.AdminUtils.type">AdminUtils</a>.<a href="../admin/AdminUtils.scala.html#kafka.admin.AdminUtils.fetchTopicConfig" title="(zkClient: org.I0Itec.zkclient.ZkClient, topic: String)java.util.Properties">fetchTopicConfig</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.zkClient" title="=&gt; org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
          val <a title="kafka.log.Log" id="kafka.cluster;Partition.getOrCreateReplica.log">log</a> = <a href="#kafka.cluster;Partition.logManager" title="=&gt; kafka.log.LogManager">logManager</a>.<a href="../log/LogManager.scala.html#kafka.log;LogManager.createLog" title="(topicAndPartition: kafka.common.TopicAndPartition, config: kafka.log.LogConfig)kafka.log.Log">createLog</a><span class="delimiter">(</span><a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span>, <a href="#kafka.cluster;Partition.getOrCreateReplica.config" title="kafka.log.LogConfig">config</a><span class="delimiter">)</span>
          val <a title="kafka.server.OffsetCheckpoint" id="kafka.cluster;Partition.getOrCreateReplica.checkpoint">checkpoint</a> = <a href="#kafka.cluster;Partition.replicaManager" title="kafka.server.ReplicaManager">replicaManager</a>.<a href="../server/ReplicaManager.scala.html#kafka.server;ReplicaManager.highWatermarkCheckpoints" title="(key: String)kafka.server.OffsetCheckpoint">highWatermarkCheckpoints</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.getOrCreateReplica.log" title="kafka.log.Log">log</a>.<a href="../log/Log.scala.html#kafka.log;Log.dir" title="=&gt; java.io.File">dir</a>.<span title="()java.io.File">getParentFile</span>.<span title="()String">getAbsolutePath</span><span class="delimiter">)</span>
          val <a title="scala.collection.Map[kafka.common.TopicAndPartition,Long]" id="kafka.cluster;Partition.getOrCreateReplica.offsetMap">offsetMap</a> = <a href="#kafka.cluster;Partition.getOrCreateReplica.checkpoint" title="kafka.server.OffsetCheckpoint">checkpoint</a>.<a href="../server/OffsetCheckpoint.scala.html#kafka.server;OffsetCheckpoint.read" title="()scala.collection.Map[kafka.common.TopicAndPartition,Long]">read</a>
          if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.cluster;Partition.getOrCreateReplica.offsetMap" title="scala.collection.Map[kafka.common.TopicAndPartition,Long]">offsetMap</a>.<span title="(key: kafka.common.TopicAndPartition)Boolean">contains</span><span class="delimiter">(</span><a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;No checkpointed highwatermark is found for partition [%s,%d]&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span><span class="delimiter">)</span>
          val <a title="Long" id="kafka.cluster;Partition.getOrCreateReplica.offset">offset</a> = <a href="#kafka.cluster;Partition.getOrCreateReplica.offsetMap" title="scala.collection.Map[kafka.common.TopicAndPartition,Long]">offsetMap</a>.<span title="(key: kafka.common.TopicAndPartition, default: =&gt; Long)Long">getOrElse</span><span title="implicit scala.LowPriorityImplicits.longWrapper : (x: Long)scala.runtime.RichLong" class="delimiter">(</span><a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span>, <span title="Long(0L)" class="long">0L</span><span class="delimiter">)</span>.<span title="(that: Long)Long">min</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.getOrCreateReplica.log" title="kafka.log.Log">log</a>.<a href="../log/Log.scala.html#kafka.log;Log.logEndOffset" title="=&gt; Long">logEndOffset</a><span class="delimiter">)</span>
          val <a title="kafka.cluster.Replica" id="kafka.cluster;Partition.getOrCreateReplica.localReplica">localReplica</a> = new <a href="Replica.scala.html#kafka.cluster;Replica" title="kafka.cluster.Replica">Replica</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.getOrCreateReplica$default$1" title="Int">replicaId</a>, this, <a href="#kafka.cluster;Partition.time" title="kafka.utils.Time">time</a>, <a href="#kafka.cluster;Partition.getOrCreateReplica.offset" title="Long">offset</a>, <span title="(x: kafka.log.Log)Some[kafka.log.Log]">Some</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.getOrCreateReplica.log" title="kafka.log.Log">log</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#kafka.cluster;Partition.addReplicaIfNotExists" title="(replica: kafka.cluster.Replica)kafka.cluster.Replica">addReplicaIfNotExists</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.getOrCreateReplica.localReplica" title="kafka.cluster.Replica">localReplica</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> else <span class="delimiter">{</span>
          val <a title="kafka.cluster.Replica" id="kafka.cluster;Partition.getOrCreateReplica.remoteReplica">remoteReplica</a> = new <a href="Replica.scala.html#kafka.cluster;Replica" title="kafka.cluster.Replica">Replica</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.getOrCreateReplica$default$1" title="Int">replicaId</a>, this, <a href="#kafka.cluster;Partition.time" title="kafka.utils.Time">time</a><span class="delimiter">)</span>
          <a href="#kafka.cluster;Partition.addReplicaIfNotExists" title="(replica: kafka.cluster.Replica)kafka.cluster.Replica">addReplicaIfNotExists</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.getOrCreateReplica.remoteReplica" title="kafka.cluster.Replica">remoteReplica</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#kafka.cluster;Partition.getReplica" title="(replicaId: Int)Option[kafka.cluster.Replica]">getReplica</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.getOrCreateReplica$default$1" title="Int">replicaId</a><span class="delimiter">)</span>.<span title="=&gt; kafka.cluster.Replica">get</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(replicaId: Int)Option[kafka.cluster.Replica]" id="kafka.cluster;Partition.getReplica">getReplica</a><span class="delimiter">(</span><a title="Int" id="kafka.cluster;Partition.getReplica$default$1">replicaId</a>: <span title="Int">Int</span> = <a href="#kafka.cluster;Partition.localBrokerId" title="=&gt; Int">localBrokerId</a><span class="delimiter">)</span>: <span title="Option[kafka.cluster.Replica]">Option</span><span class="delimiter">[</span>Replica<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="kafka.cluster.Replica" id="kafka.cluster;Partition.getReplica.replica">replica</a> = <a href="#kafka.cluster;Partition.assignedReplicaMap" title="=&gt; kafka.utils.Pool[Int,kafka.cluster.Replica]">assignedReplicaMap</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.get" title="(key: Int)kafka.cluster.Replica">get</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.getReplica$default$1" title="Int">replicaId</a><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#kafka.cluster;Partition.getReplica.replica" title="kafka.cluster.Replica">replica</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span>
      <span title="None.type">None</span>
    else
      <span title="(x: kafka.cluster.Replica)Some[kafka.cluster.Replica]">Some</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.getReplica.replica" title="kafka.cluster.Replica">replica</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="()Option[kafka.cluster.Replica]" id="kafka.cluster;Partition.leaderReplicaIfLocal">leaderReplicaIfLocal</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Option[kafka.cluster.Replica]">Option</span><span class="delimiter">[</span>Replica<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#kafka.cluster;Partition.leaderReplicaIdOpt_=" title="=&gt; Option[Int]">leaderReplicaIdOpt</a> match <span class="delimiter">{</span>
      case Some<span class="delimiter">(</span><a title="Int" id="kafka.cluster;Partition.leaderReplicaIfLocal.leaderReplicaId">leaderReplicaId</a><span class="delimiter">)</span> =&gt;
        if <span class="delimiter">(</span><a href="#kafka.cluster;Partition.leaderReplicaIfLocal.leaderReplicaId" title="Int">leaderReplicaId</a> <span title="(x: Int)Boolean">==</span> <a href="#kafka.cluster;Partition.localBrokerId" title="=&gt; Int">localBrokerId</a><span class="delimiter">)</span>
          <a href="#kafka.cluster;Partition.getReplica" title="(replicaId: Int)Option[kafka.cluster.Replica]">getReplica</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.localBrokerId" title="=&gt; Int">localBrokerId</a><span class="delimiter">)</span>
        else
          <span title="None.type">None</span>
      case <span title="None.type">None</span> =&gt; <span title="None.type">None</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(replica: kafka.cluster.Replica)kafka.cluster.Replica" id="kafka.cluster;Partition.addReplicaIfNotExists">addReplicaIfNotExists</a><span class="delimiter">(</span><a title="kafka.cluster.Replica" id="kafka.cluster;Partition.addReplicaIfNotExists.replica">replica</a>: <a href="Replica.scala.html#kafka.cluster;Replica" title="kafka.cluster.Replica">Replica</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#kafka.cluster;Partition.assignedReplicaMap" title="=&gt; kafka.utils.Pool[Int,kafka.cluster.Replica]">assignedReplicaMap</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.putIfNotExists" title="(k: Int, v: kafka.cluster.Replica)kafka.cluster.Replica">putIfNotExists</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.addReplicaIfNotExists.replica" title="kafka.cluster.Replica">replica</a>.<a href="Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a>, <a href="#kafka.cluster;Partition.addReplicaIfNotExists.replica" title="kafka.cluster.Replica">replica</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="()scala.collection.immutable.Set[kafka.cluster.Replica]" id="kafka.cluster;Partition.assignedReplicas">assignedReplicas</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="scala.collection.immutable.Set[kafka.cluster.Replica]">Set</span><span class="delimiter">[</span>Replica<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#kafka.cluster;Partition.assignedReplicaMap" title="=&gt; kafka.utils.Pool[Int,kafka.cluster.Replica]">assignedReplicaMap</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.values" title="=&gt; Iterable[kafka.cluster.Replica]">values</a>.<span title="scala.collection.immutable.Set[kafka.cluster.Replica]">toSet</span>
  <span class="delimiter">}</span>

  def <a title="(replicaId: Int)Unit" id="kafka.cluster;Partition.removeReplica">removeReplica</a><span class="delimiter">(</span><a title="Int" id="kafka.cluster;Partition.removeReplica.replicaId">replicaId</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.cluster;Partition.assignedReplicaMap" title="=&gt; kafka.utils.Pool[Int,kafka.cluster.Replica]">assignedReplicaMap</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.remove" title="(key: Int)kafka.cluster.Replica">remove</a><span title="Unit" class="delimiter">(</span><a href="#kafka.cluster;Partition.removeReplica.replicaId" title="Int">replicaId</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="()Unit" id="kafka.cluster;Partition.delete">delete</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">// need to hold the lock to prevent appendMessagesToLeader() from hitting I/O exceptions due to log being deleted</span>
    <a href="../utils/Utils.scala.html#kafka.utils.Utils.inWriteLock" title="(lock: java.util.concurrent.locks.ReadWriteLock)(fun: =&gt; Unit)Unit">inWriteLock</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.leaderIsrUpdateLock" title="=&gt; java.util.concurrent.locks.ReentrantReadWriteLock">leaderIsrUpdateLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.cluster;Partition.assignedReplicaMap" title="=&gt; kafka.utils.Pool[Int,kafka.cluster.Replica]">assignedReplicaMap</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.clear" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#kafka.cluster;Partition.inSyncReplicas_=" title="(x$1: scala.collection.immutable.Set[kafka.cluster.Replica])Unit">inSyncReplicas</a> = <span title="scala.collection.immutable.Set.type">Set</span>.<span title="[A]=&gt; scala.collection.immutable.Set[A]">empty</span><span title="scala.collection.immutable.Set[kafka.cluster.Replica]" class="delimiter">[</span><a href="Replica.scala.html#kafka.cluster;Replica" title="kafka.cluster.Replica">Replica</a><span class="delimiter">]</span>
      <a href="#kafka.cluster;Partition.leaderReplicaIdOpt_=" title="(x$1: Option[Int])Unit">leaderReplicaIdOpt</a> = <span title="None.type">None</span>
      try <span class="delimiter">{</span>
        <a href="#kafka.cluster;Partition.logManager" title="=&gt; kafka.log.LogManager">logManager</a>.<a href="../log/LogManager.scala.html#kafka.log;LogManager.deleteLog" title="(topicAndPartition: kafka.common.TopicAndPartition)Unit">deleteLog</a><span class="delimiter">(</span><a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> catch <span class="delimiter">{</span>
        case <a title="java.io.IOException" id="kafka.cluster;Partition.delete.e">e</a>: <span title="java.io.IOException">IOException</span> =&gt;
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.fatal(cfd112d89b)" title="(msg: =&gt; String, e: =&gt; Throwable)Unit">fatal</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Error deleting the log for partition [%s,%d]&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span>, <a href="#kafka.cluster;Partition.delete.e" title="java.io.IOException">e</a><span class="delimiter">)</span>
          <span title="Runtime.type">Runtime</span>.<span title="()Runtime">getRuntime</span><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="(x$1: Int)Unit">halt</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="()Int" id="kafka.cluster;Partition.getLeaderEpoch">getLeaderEpoch</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
    return this.<a href="#kafka.cluster;Partition.leaderEpoch_=" title="=&gt; Int">leaderEpoch</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Make the local replica the leader by resetting LogEndOffset for remote replicas (there could be old LogEndOffset from the time when this broker was the leader last time)
   *  and setting the new leader and ISR
   */</span>
  def <a title="(controllerId: Int, partitionStateInfo: kafka.api.PartitionStateInfo, correlationId: Int, offsetManager: kafka.server.OffsetManager)Boolean" id="kafka.cluster;Partition.makeLeader">makeLeader</a><span class="delimiter">(</span><a title="Int" id="kafka.cluster;Partition.makeLeader.controllerId">controllerId</a>: <span title="Int">Int</span>,
                 <a title="kafka.api.PartitionStateInfo" id="kafka.cluster;Partition.makeLeader.partitionStateInfo">partitionStateInfo</a>: <a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;PartitionStateInfo" title="kafka.api.PartitionStateInfo">PartitionStateInfo</a>, <a title="Int" id="kafka.cluster;Partition.makeLeader.correlationId">correlationId</a>: <span title="Int">Int</span>,
                 <a title="kafka.server.OffsetManager" id="kafka.cluster;Partition.makeLeader.offsetManager">offsetManager</a>: <a href="../server/OffsetManager.scala.html#kafka.server;OffsetManager" title="kafka.server.OffsetManager">OffsetManager</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <a href="../utils/Utils.scala.html#kafka.utils.Utils.inWriteLock" title="(lock: java.util.concurrent.locks.ReadWriteLock)(fun: =&gt; Boolean)Boolean">inWriteLock</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.leaderIsrUpdateLock" title="=&gt; java.util.concurrent.locks.ReentrantReadWriteLock">leaderIsrUpdateLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="scala.collection.Set[Int]" id="kafka.cluster;Partition.makeLeader.allReplicas">allReplicas</a> = <a href="#kafka.cluster;Partition.makeLeader.partitionStateInfo" title="kafka.api.PartitionStateInfo">partitionStateInfo</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;PartitionStateInfo.allReplicas" title="=&gt; scala.collection.Set[Int]">allReplicas</a>
      val <a title="kafka.controller.LeaderIsrAndControllerEpoch" id="kafka.cluster;Partition.makeLeader.leaderIsrAndControllerEpoch">leaderIsrAndControllerEpoch</a> = <a href="#kafka.cluster;Partition.makeLeader.partitionStateInfo" title="kafka.api.PartitionStateInfo">partitionStateInfo</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;PartitionStateInfo.leaderIsrAndControllerEpoch" title="=&gt; kafka.controller.LeaderIsrAndControllerEpoch">leaderIsrAndControllerEpoch</a>
      val <a title="kafka.api.LeaderAndIsr" id="kafka.cluster;Partition.makeLeader.leaderAndIsr">leaderAndIsr</a> = <a href="#kafka.cluster;Partition.makeLeader.leaderIsrAndControllerEpoch" title="kafka.controller.LeaderIsrAndControllerEpoch">leaderIsrAndControllerEpoch</a>.<a href="../controller/KafkaController.scala.html#kafka.controller;LeaderIsrAndControllerEpoch.leaderAndIsr" title="=&gt; kafka.api.LeaderAndIsr">leaderAndIsr</a>
      <span class="comment">// record the epoch of the controller that made the leadership decision. This is useful while updating the isr</span>
      <span class="comment">// to maintain the decision maker controller's epoch in the zookeeper path</span>
      <a href="#kafka.cluster;Partition.controllerEpoch_=" title="(x$1: Int)Unit">controllerEpoch</a> = <a href="#kafka.cluster;Partition.makeLeader.leaderIsrAndControllerEpoch" title="kafka.controller.LeaderIsrAndControllerEpoch">leaderIsrAndControllerEpoch</a>.<a href="../controller/KafkaController.scala.html#kafka.controller;LeaderIsrAndControllerEpoch.controllerEpoch" title="=&gt; Int">controllerEpoch</a>
      <span class="comment">// add replicas that are new</span>
      <a href="#kafka.cluster;Partition.makeLeader.allReplicas" title="scala.collection.Set[Int]">allReplicas</a>.<span title="(f: Int =&gt; kafka.cluster.Replica)Unit">foreach</span><span class="delimiter">(</span><a title="Int" id="kafka.cluster;Partition.makeLeader.$anonfun.replica">replica</a> =&gt; <a href="#kafka.cluster;Partition.getOrCreateReplica" title="(replicaId: Int)kafka.cluster.Replica">getOrCreateReplica</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.makeLeader.$anonfun.replica" title="Int">replica</a><span class="delimiter">)</span><span class="delimiter">)</span>
      val <a title="scala.collection.immutable.Set[kafka.cluster.Replica]" id="kafka.cluster;Partition.makeLeader.newInSyncReplicas">newInSyncReplicas</a> = <a href="#kafka.cluster;Partition.makeLeader.leaderAndIsr" title="kafka.api.LeaderAndIsr">leaderAndIsr</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;LeaderAndIsr.isr" title="=&gt; List[Int]">isr</a>.<span title="(f: Int =&gt; kafka.cluster.Replica)(implicit bf: scala.collection.generic.CanBuildFrom[List[Int],kafka.cluster.Replica,List[kafka.cluster.Replica]])List[kafka.cluster.Replica]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,kafka.cluster.Replica,List[kafka.cluster.Replica]]" class="delimiter">(</span><a title="Int" id="kafka.cluster;Partition.makeLeader.newInSyncReplicas.$anonfun.r">r</a> =&gt; <a href="#kafka.cluster;Partition.getOrCreateReplica" title="(replicaId: Int)kafka.cluster.Replica">getOrCreateReplica</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.makeLeader.newInSyncReplicas.$anonfun.r" title="Int">r</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[kafka.cluster.Replica]">toSet</span>
      <span class="comment">// remove assigned replicas that have been removed by the controller</span>
      <span class="delimiter">(</span><a href="#kafka.cluster;Partition.assignedReplicas" title="()scala.collection.immutable.Set[kafka.cluster.Replica]">assignedReplicas</a><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="(f: kafka.cluster.Replica =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[kafka.cluster.Replica],Int,scala.collection.immutable.Set[Int]])scala.collection.immutable.Set[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,Int,scala.collection.immutable.Set[Int]]" class="delimiter">(</span><a href="#kafka.cluster;Partition.makeLeader.$anonfun.x$1" title="kafka.cluster.Replica">_</a>.<a href="Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span> <span title="(xs: scala.collection.GenTraversableOnce[Int])scala.collection.immutable.Set[Int]">--</span> <a href="#kafka.cluster;Partition.makeLeader.allReplicas" title="scala.collection.Set[Int]">allReplicas</a><span class="delimiter">)</span>.<span title="(f: Int =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.removeReplica" title="(replicaId: Int)Unit">removeReplica</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.makeLeader.$anonfun.x$2" title="Int">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.cluster;Partition.inSyncReplicas_=" title="(x$1: scala.collection.immutable.Set[kafka.cluster.Replica])Unit">inSyncReplicas</a> = <a href="#kafka.cluster;Partition.makeLeader.newInSyncReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">newInSyncReplicas</a>
      <a href="#kafka.cluster;Partition.leaderEpoch_=" title="(x$1: Int)Unit">leaderEpoch</a> = <a href="#kafka.cluster;Partition.makeLeader.leaderAndIsr" title="kafka.api.LeaderAndIsr">leaderAndIsr</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;LeaderAndIsr.leaderEpoch" title="=&gt; Int">leaderEpoch</a>
      <a href="#kafka.cluster;Partition.zkVersion_=" title="(x$1: Int)Unit">zkVersion</a> = <a href="#kafka.cluster;Partition.makeLeader.leaderAndIsr" title="kafka.api.LeaderAndIsr">leaderAndIsr</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;LeaderAndIsr.zkVersion" title="=&gt; Int">zkVersion</a>
      <a href="#kafka.cluster;Partition.leaderReplicaIdOpt_=" title="(x$1: Option[Int])Unit">leaderReplicaIdOpt</a> = <span title="(x: Int)Some[Int]">Some</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.localBrokerId" title="=&gt; Int">localBrokerId</a><span class="delimiter">)</span>
      <span class="comment">// construct the high watermark metadata for the new leader replica</span>
      val <a title="kafka.cluster.Replica" id="kafka.cluster;Partition.makeLeader.newLeaderReplica">newLeaderReplica</a> = <a href="#kafka.cluster;Partition.getReplica" title="(replicaId: Int)Option[kafka.cluster.Replica]">getReplica</a><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="=&gt; kafka.cluster.Replica">get</span>
      <a href="#kafka.cluster;Partition.makeLeader.newLeaderReplica" title="kafka.cluster.Replica">newLeaderReplica</a>.<a href="Replica.scala.html#kafka.cluster;Replica.convertHWToLocalOffsetMetadata" title="()Unit">convertHWToLocalOffsetMetadata</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="comment">// reset log end offset for remote replicas</span>
      <a href="#kafka.cluster;Partition.assignedReplicas" title="()scala.collection.immutable.Set[kafka.cluster.Replica]">assignedReplicas</a>.<span title="(f: kafka.cluster.Replica =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a title="kafka.cluster.Replica" id="kafka.cluster;Partition.makeLeader.$anonfun.r">r</a> =&gt; if <span class="delimiter">(</span><a href="#kafka.cluster;Partition.makeLeader.$anonfun.r" title="kafka.cluster.Replica">r</a>.<a href="Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a> <span title="(x: Int)Boolean">!=</span> <a href="#kafka.cluster;Partition.localBrokerId" title="=&gt; Int">localBrokerId</a><span class="delimiter">)</span> <a href="#kafka.cluster;Partition.makeLeader.$anonfun.r" title="kafka.cluster.Replica">r</a>.<a href="Replica.scala.html#kafka.cluster;Replica.logEndOffset_=" title="(newLogEndOffset: kafka.server.LogOffsetMetadata)Unit">logEndOffset</a> = <a href="../server/LogOffsetMetadata.scala.html#kafka.server.LogOffsetMetadata" title="kafka.server.LogOffsetMetadata.type">LogOffsetMetadata</a>.<a href="../server/LogOffsetMetadata.scala.html#kafka.server.LogOffsetMetadata.UnknownOffsetMetadata" title="=&gt; kafka.server.LogOffsetMetadata">UnknownOffsetMetadata</a><span class="delimiter">)</span>
      <span class="comment">// we may need to increment high watermark since ISR could be down to 1</span>
      <a href="#kafka.cluster;Partition.maybeIncrementLeaderHW" title="(leaderReplica: kafka.cluster.Replica)Unit">maybeIncrementLeaderHW</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.makeLeader.newLeaderReplica" title="kafka.cluster.Replica">newLeaderReplica</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a> <span title="(x$1: Any)Boolean">==</span> <a href="../server/OffsetManager.scala.html#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="../server/OffsetManager.scala.html#kafka.server.OffsetManager.OffsetsTopicName" title="=&gt; String">OffsetsTopicName</a><span class="delimiter">)</span>
        <a href="#kafka.cluster;Partition.makeLeader.offsetManager" title="kafka.server.OffsetManager">offsetManager</a>.<a href="../server/OffsetManager.scala.html#kafka.server;OffsetManager.loadOffsetsFromLog" title="(offsetsPartition: Int)Unit">loadOffsetsFromLog</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span>
      true
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   *  Make the local replica the follower by setting the new leader and ISR to empty
   *  If the leader replica id does not change, return false to indicate the replica manager
   */</span>
  def <a title="(controllerId: Int, partitionStateInfo: kafka.api.PartitionStateInfo, correlationId: Int, offsetManager: kafka.server.OffsetManager)Boolean" id="kafka.cluster;Partition.makeFollower">makeFollower</a><span class="delimiter">(</span><a title="Int" id="kafka.cluster;Partition.makeFollower.controllerId">controllerId</a>: <span title="Int">Int</span>,
                   <a title="kafka.api.PartitionStateInfo" id="kafka.cluster;Partition.makeFollower.partitionStateInfo">partitionStateInfo</a>: <a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;PartitionStateInfo" title="kafka.api.PartitionStateInfo">PartitionStateInfo</a>,
                   <a title="Int" id="kafka.cluster;Partition.makeFollower.correlationId">correlationId</a>: <span title="Int">Int</span>, <a title="kafka.server.OffsetManager" id="kafka.cluster;Partition.makeFollower.offsetManager">offsetManager</a>: <a href="../server/OffsetManager.scala.html#kafka.server;OffsetManager" title="kafka.server.OffsetManager">OffsetManager</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <a href="../utils/Utils.scala.html#kafka.utils.Utils.inWriteLock" title="(lock: java.util.concurrent.locks.ReadWriteLock)(fun: =&gt; Boolean)Boolean">inWriteLock</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.leaderIsrUpdateLock" title="=&gt; java.util.concurrent.locks.ReentrantReadWriteLock">leaderIsrUpdateLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="scala.collection.Set[Int]" id="kafka.cluster;Partition.makeFollower.allReplicas">allReplicas</a> = <a href="#kafka.cluster;Partition.makeFollower.partitionStateInfo" title="kafka.api.PartitionStateInfo">partitionStateInfo</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;PartitionStateInfo.allReplicas" title="=&gt; scala.collection.Set[Int]">allReplicas</a>
      val <a title="kafka.controller.LeaderIsrAndControllerEpoch" id="kafka.cluster;Partition.makeFollower.leaderIsrAndControllerEpoch">leaderIsrAndControllerEpoch</a> = <a href="#kafka.cluster;Partition.makeFollower.partitionStateInfo" title="kafka.api.PartitionStateInfo">partitionStateInfo</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;PartitionStateInfo.leaderIsrAndControllerEpoch" title="=&gt; kafka.controller.LeaderIsrAndControllerEpoch">leaderIsrAndControllerEpoch</a>
      val <a title="kafka.api.LeaderAndIsr" id="kafka.cluster;Partition.makeFollower.leaderAndIsr">leaderAndIsr</a> = <a href="#kafka.cluster;Partition.makeFollower.leaderIsrAndControllerEpoch" title="kafka.controller.LeaderIsrAndControllerEpoch">leaderIsrAndControllerEpoch</a>.<a href="../controller/KafkaController.scala.html#kafka.controller;LeaderIsrAndControllerEpoch.leaderAndIsr" title="=&gt; kafka.api.LeaderAndIsr">leaderAndIsr</a>
      val <a title="Int" id="kafka.cluster;Partition.makeFollower.newLeaderBrokerId">newLeaderBrokerId</a>: <span title="Int">Int</span> = <a href="#kafka.cluster;Partition.makeFollower.leaderAndIsr" title="kafka.api.LeaderAndIsr">leaderAndIsr</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;LeaderAndIsr.leader" title="=&gt; Int">leader</a>
      <span class="comment">// record the epoch of the controller that made the leadership decision. This is useful while updating the isr</span>
      <span class="comment">// to maintain the decision maker controller's epoch in the zookeeper path</span>
      <a href="#kafka.cluster;Partition.controllerEpoch_=" title="(x$1: Int)Unit">controllerEpoch</a> = <a href="#kafka.cluster;Partition.makeFollower.leaderIsrAndControllerEpoch" title="kafka.controller.LeaderIsrAndControllerEpoch">leaderIsrAndControllerEpoch</a>.<a href="../controller/KafkaController.scala.html#kafka.controller;LeaderIsrAndControllerEpoch.controllerEpoch" title="=&gt; Int">controllerEpoch</a>
      <span class="comment">// add replicas that are new</span>
      <a href="#kafka.cluster;Partition.makeFollower.allReplicas" title="scala.collection.Set[Int]">allReplicas</a>.<span title="(f: Int =&gt; kafka.cluster.Replica)Unit">foreach</span><span class="delimiter">(</span><a title="Int" id="kafka.cluster;Partition.makeFollower.$anonfun.r">r</a> =&gt; <a href="#kafka.cluster;Partition.getOrCreateReplica" title="(replicaId: Int)kafka.cluster.Replica">getOrCreateReplica</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.makeFollower.$anonfun.r" title="Int">r</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="comment">// remove assigned replicas that have been removed by the controller</span>
      <span class="delimiter">(</span><a href="#kafka.cluster;Partition.assignedReplicas" title="()scala.collection.immutable.Set[kafka.cluster.Replica]">assignedReplicas</a><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="(f: kafka.cluster.Replica =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[kafka.cluster.Replica],Int,scala.collection.immutable.Set[Int]])scala.collection.immutable.Set[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,Int,scala.collection.immutable.Set[Int]]" class="delimiter">(</span><a href="#kafka.cluster;Partition.makeFollower.$anonfun.x$3" title="kafka.cluster.Replica">_</a>.<a href="Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span> <span title="(xs: scala.collection.GenTraversableOnce[Int])scala.collection.immutable.Set[Int]">--</span> <a href="#kafka.cluster;Partition.makeFollower.allReplicas" title="scala.collection.Set[Int]">allReplicas</a><span class="delimiter">)</span>.<span title="(f: Int =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.removeReplica" title="(replicaId: Int)Unit">removeReplica</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.makeFollower.$anonfun.x$4" title="Int">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.cluster;Partition.inSyncReplicas_=" title="(x$1: scala.collection.immutable.Set[kafka.cluster.Replica])Unit">inSyncReplicas</a> = <span title="scala.collection.immutable.Set.type">Set</span>.<span title="[A]=&gt; scala.collection.immutable.Set[A]">empty</span><span title="scala.collection.immutable.Set[kafka.cluster.Replica]" class="delimiter">[</span><a href="Replica.scala.html#kafka.cluster;Replica" title="kafka.cluster.Replica">Replica</a><span class="delimiter">]</span>
      <a href="#kafka.cluster;Partition.leaderEpoch_=" title="(x$1: Int)Unit">leaderEpoch</a> = <a href="#kafka.cluster;Partition.makeFollower.leaderAndIsr" title="kafka.api.LeaderAndIsr">leaderAndIsr</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;LeaderAndIsr.leaderEpoch" title="=&gt; Int">leaderEpoch</a>
      <a href="#kafka.cluster;Partition.zkVersion_=" title="(x$1: Int)Unit">zkVersion</a> = <a href="#kafka.cluster;Partition.makeFollower.leaderAndIsr" title="kafka.api.LeaderAndIsr">leaderAndIsr</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;LeaderAndIsr.zkVersion" title="=&gt; Int">zkVersion</a>

      <a href="#kafka.cluster;Partition.leaderReplicaIdOpt_=" title="=&gt; Option[Int]">leaderReplicaIdOpt</a>.<span title="(f: Int =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="Int" id="kafka.cluster;Partition.makeFollower.$anonfun.leaderReplica">leaderReplica</a> =&gt;
        if <span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a> <span title="(x$1: Any)Boolean">==</span> <a href="../server/OffsetManager.scala.html#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="../server/OffsetManager.scala.html#kafka.server.OffsetManager.OffsetsTopicName" title="=&gt; String">OffsetsTopicName</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
           <span class="comment">/* if we are making a leader-&gt;follower transition */</span>
           <a href="#kafka.cluster;Partition.makeFollower.$anonfun.leaderReplica" title="Int">leaderReplica</a> <span title="(x: Int)Boolean">==</span> <a href="#kafka.cluster;Partition.localBrokerId" title="=&gt; Int">localBrokerId</a><span class="delimiter">)</span>
          <a href="#kafka.cluster;Partition.makeFollower.offsetManager" title="kafka.server.OffsetManager">offsetManager</a>.<a href="../server/OffsetManager.scala.html#kafka.server;OffsetManager.clearOffsetsInPartition" title="(offsetsPartition: Int)Unit">clearOffsetsInPartition</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      if <span class="delimiter">(</span><a href="#kafka.cluster;Partition.leaderReplicaIdOpt_=" title="=&gt; Option[Int]">leaderReplicaIdOpt</a>.<span title="=&gt; Boolean">isDefined</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.cluster;Partition.leaderReplicaIdOpt_=" title="=&gt; Option[Int]">leaderReplicaIdOpt</a>.<span title="=&gt; Int">get</span> <span title="(x: Int)Boolean">==</span> <a href="#kafka.cluster;Partition.makeFollower.newLeaderBrokerId" title="Int">newLeaderBrokerId</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        false
      <span class="delimiter">}</span>
      else <span class="delimiter">{</span>
        <a href="#kafka.cluster;Partition.leaderReplicaIdOpt_=" title="(x$1: Option[Int])Unit">leaderReplicaIdOpt</a> = <span title="(x: Int)Some[Int]">Some</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.makeFollower.newLeaderBrokerId" title="Int">newLeaderBrokerId</a><span class="delimiter">)</span>
        true
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(replicaId: Int)Unit" id="kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr">updateLeaderHWAndMaybeExpandIsr</a><span class="delimiter">(</span><a title="Int" id="kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.replicaId">replicaId</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Utils.scala.html#kafka.utils.Utils.inWriteLock" title="(lock: java.util.concurrent.locks.ReadWriteLock)(fun: =&gt; Unit)Unit">inWriteLock</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.leaderIsrUpdateLock" title="=&gt; java.util.concurrent.locks.ReentrantReadWriteLock">leaderIsrUpdateLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// check if this replica needs to be added to the ISR</span>
      <a href="#kafka.cluster;Partition.leaderReplicaIfLocal" title="()Option[kafka.cluster.Replica]">leaderReplicaIfLocal</a><span class="delimiter">(</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case Some<span class="delimiter">(</span><a title="kafka.cluster.Replica" id="kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.leaderReplica">leaderReplica</a><span class="delimiter">)</span> =&gt;
          val <a title="kafka.cluster.Replica" id="kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.replica">replica</a> = <a href="#kafka.cluster;Partition.getReplica" title="(replicaId: Int)Option[kafka.cluster.Replica]">getReplica</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.replicaId" title="Int">replicaId</a><span class="delimiter">)</span>.<span title="=&gt; kafka.cluster.Replica">get</span>
          val <a title="kafka.server.LogOffsetMetadata" id="kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.leaderHW">leaderHW</a> = <a href="#kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.leaderReplica" title="kafka.cluster.Replica">leaderReplica</a>.<a href="Replica.scala.html#kafka.cluster;Replica.highWatermark" title="=&gt; kafka.server.LogOffsetMetadata">highWatermark</a>
          <span class="comment">// For a replica to get added back to ISR, it has to satisfy 3 conditions-</span>
          <span class="comment">// 1. It is not already in the ISR</span>
          <span class="comment">// 2. It is part of the assigned replica list. See KAFKA-1097</span>
          <span class="comment">// 3. It's log end offset &gt;= leader's high watermark</span>
          if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.cluster;Partition.inSyncReplicas_=" title="=&gt; scala.collection.immutable.Set[kafka.cluster.Replica]">inSyncReplicas</a>.<span title="(elem: kafka.cluster.Replica)Boolean">contains</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.replica" title="kafka.cluster.Replica">replica</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#kafka.cluster;Partition.assignedReplicas" title="()scala.collection.immutable.Set[kafka.cluster.Replica]">assignedReplicas</a>.<span title="(f: kafka.cluster.Replica =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[kafka.cluster.Replica],Int,scala.collection.immutable.Set[Int]])scala.collection.immutable.Set[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,Int,scala.collection.immutable.Set[Int]]" class="delimiter">(</span><a href="#kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.$anonfun.x$5" title="kafka.cluster.Replica">_</a>.<a href="Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span>.<span title="(elem: Int)Boolean">contains</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.replicaId" title="Int">replicaId</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.replica" title="kafka.cluster.Replica">replica</a>.<a href="Replica.scala.html#kafka.cluster;Replica.logEndOffset" title="=&gt; kafka.server.LogOffsetMetadata">logEndOffset</a>.<a href="../server/LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.offsetDiff" title="(that: kafka.server.LogOffsetMetadata)Long">offsetDiff</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.leaderHW" title="kafka.server.LogOffsetMetadata">leaderHW</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="comment">// expand ISR</span>
            val newInSyncReplicas = <a href="#kafka.cluster;Partition.inSyncReplicas_=" title="=&gt; scala.collection.immutable.Set[kafka.cluster.Replica]">inSyncReplicas</a> <a title="scala.collection.immutable.Set[kafka.cluster.Replica]" id="kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.newInSyncReplicas">+</a> <a href="#kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.replica" title="kafka.cluster.Replica">replica</a>
            <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Expanding ISR for partition [%s,%d] from %s to %s&quot;</span>
                 .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a>, <a href="#kafka.cluster;Partition.inSyncReplicas_=" title="=&gt; scala.collection.immutable.Set[kafka.cluster.Replica]">inSyncReplicas</a>.<span title="(f: kafka.cluster.Replica =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[kafka.cluster.Replica],Int,scala.collection.immutable.Set[Int]])scala.collection.immutable.Set[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,Int,scala.collection.immutable.Set[Int]]" class="delimiter">(</span><a href="#kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.$anonfun.x$6" title="kafka.cluster.Replica">_</a>.<a href="Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>, <a href="#kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.newInSyncReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">newInSyncReplicas</a>.<span title="(f: kafka.cluster.Replica =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[kafka.cluster.Replica],Int,scala.collection.immutable.Set[Int]])scala.collection.immutable.Set[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,Int,scala.collection.immutable.Set[Int]]" class="delimiter">(</span><a href="#kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.$anonfun.x$7" title="kafka.cluster.Replica">_</a>.<a href="Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="comment">// update ISR in ZK and cache</span>
            <a href="#kafka.cluster;Partition.updateIsr" title="(newIsr: scala.collection.immutable.Set[kafka.cluster.Replica])Unit">updateIsr</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.newInSyncReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">newInSyncReplicas</a><span class="delimiter">)</span>
            <a href="#kafka.cluster;Partition.replicaManager" title="kafka.server.ReplicaManager">replicaManager</a>.<a href="../server/ReplicaManager.scala.html#kafka.server;ReplicaManager.isrExpandRate" title="=&gt; com.yammer.metrics.core.Meter">isrExpandRate</a>.<span title="()Unit">mark</span><span class="delimiter">(</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <a href="#kafka.cluster;Partition.maybeIncrementLeaderHW" title="(leaderReplica: kafka.cluster.Replica)Unit">maybeIncrementLeaderHW</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.updateLeaderHWAndMaybeExpandIsr.leaderReplica" title="kafka.cluster.Replica">leaderReplica</a><span class="delimiter">)</span>
        case <span title="None.type">None</span> =&gt; <span class="comment">// nothing to do if no longer leader</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(requiredOffset: Long, requiredAcks: Int)(Boolean, Short)" id="kafka.cluster;Partition.checkEnoughReplicasReachOffset">checkEnoughReplicasReachOffset</a><span class="delimiter">(</span><a title="Long" id="kafka.cluster;Partition.checkEnoughReplicasReachOffset.requiredOffset">requiredOffset</a>: <span title="Long">Long</span>, <a title="Int" id="kafka.cluster;Partition.checkEnoughReplicasReachOffset.requiredAcks">requiredAcks</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="(Boolean, Short)" class="delimiter">(</span>Boolean, Short<span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#kafka.cluster;Partition.leaderReplicaIfLocal" title="()Option[kafka.cluster.Replica]">leaderReplicaIfLocal</a><span class="delimiter">(</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case Some<span class="delimiter">(</span><a title="kafka.cluster.Replica" id="kafka.cluster;Partition.checkEnoughReplicasReachOffset.leaderReplica">leaderReplica</a><span class="delimiter">)</span> =&gt;
        <span class="comment">// keep the current immutable replica list reference</span>
        val <a title="scala.collection.immutable.Set[kafka.cluster.Replica]" id="kafka.cluster;Partition.checkEnoughReplicasReachOffset.curInSyncReplicas">curInSyncReplicas</a> = <a href="#kafka.cluster;Partition.inSyncReplicas_=" title="=&gt; scala.collection.immutable.Set[kafka.cluster.Replica]">inSyncReplicas</a>
        val <a title="Int" id="kafka.cluster;Partition.checkEnoughReplicasReachOffset.numAcks">numAcks</a> = <a href="#kafka.cluster;Partition.checkEnoughReplicasReachOffset.curInSyncReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">curInSyncReplicas</a>.<span title="(p: kafka.cluster.Replica =&gt; Boolean)Int">count</span><span class="delimiter">(</span><a title="kafka.cluster.Replica" id="kafka.cluster;Partition.checkEnoughReplicasReachOffset.numAcks.$anonfun.r">r</a> =&gt; <span class="delimiter">{</span>
          if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.cluster;Partition.checkEnoughReplicasReachOffset.numAcks.$anonfun.r" title="kafka.cluster.Replica">r</a>.<a href="Replica.scala.html#kafka.cluster;Replica.isLocal" title="=&gt; Boolean">isLocal</a><span class="delimiter">)</span>
            <a href="#kafka.cluster;Partition.checkEnoughReplicasReachOffset.numAcks.$anonfun.r" title="kafka.cluster.Replica">r</a>.<a href="Replica.scala.html#kafka.cluster;Replica.logEndOffset" title="=&gt; kafka.server.LogOffsetMetadata">logEndOffset</a>.<a href="../server/LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="=&gt; Long">messageOffset</a> <span title="(x: Long)Boolean">&gt;=</span> <a href="#kafka.cluster;Partition.checkEnoughReplicasReachOffset.requiredOffset" title="Long">requiredOffset</a>
          else
            true <span class="comment">/* also count the local (leader) replica */</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>
        val <a title="Int" id="kafka.cluster;Partition.checkEnoughReplicasReachOffset.minIsr">minIsr</a> = <a href="#kafka.cluster;Partition.checkEnoughReplicasReachOffset.leaderReplica" title="kafka.cluster.Replica">leaderReplica</a>.<a href="Replica.scala.html#kafka.cluster;Replica.log" title="=&gt; Option[kafka.log.Log]">log</a>.<span title="=&gt; kafka.log.Log">get</span>.<a href="../log/Log.scala.html#kafka.log;Log.config" title="=&gt; kafka.log.LogConfig">config</a>.<a href="../log/LogConfig.scala.html#kafka.log;LogConfig.minInSyncReplicas" title="=&gt; Int">minInSyncReplicas</a>

        <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%d/%d acks satisfied for %s-%d&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.checkEnoughReplicasReachOffset.numAcks" title="Int">numAcks</a>, <a href="#kafka.cluster;Partition.checkEnoughReplicasReachOffset.requiredAcks" title="Int">requiredAcks</a>, <a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#kafka.cluster;Partition.checkEnoughReplicasReachOffset.requiredAcks" title="Int">requiredAcks</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.cluster;Partition.checkEnoughReplicasReachOffset.leaderReplica" title="kafka.cluster.Replica">leaderReplica</a>.<a href="Replica.scala.html#kafka.cluster;Replica.highWatermark" title="=&gt; kafka.server.LogOffsetMetadata">highWatermark</a>.<a href="../server/LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="=&gt; Long">messageOffset</a> <span title="(x: Long)Boolean">&gt;=</span> <a href="#kafka.cluster;Partition.checkEnoughReplicasReachOffset.requiredOffset" title="Long">requiredOffset</a> <span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="comment">/*
          * requiredAcks &lt; 0 means acknowledge after all replicas in ISR
          * are fully caught up to the (local) leader's offset
          * corresponding to this produce request.
          *
          * minIsr means that the topic is configured not to accept messages
          * if there are not enough replicas in ISR
          * in this scenario the request was already appended locally and
          * then added to the purgatory before the ISR was shrunk
          */</span>
          if <span class="delimiter">(</span><a href="#kafka.cluster;Partition.checkEnoughReplicasReachOffset.minIsr" title="Int">minIsr</a> <span title="(x: Int)Boolean">&lt;=</span> <a href="#kafka.cluster;Partition.checkEnoughReplicasReachOffset.curInSyncReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">curInSyncReplicas</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="(_1: Boolean, _2: Short)(Boolean, Short)" class="delimiter">(</span>true, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> else <span class="delimiter">{</span>
            <span title="(_1: Boolean, _2: Short)(Boolean, Short)" class="delimiter">(</span>true, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NotEnoughReplicasAfterAppendCode" title="=&gt; Short">NotEnoughReplicasAfterAppendCode</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#kafka.cluster;Partition.checkEnoughReplicasReachOffset.requiredAcks" title="Int">requiredAcks</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.cluster;Partition.checkEnoughReplicasReachOffset.numAcks" title="Int">numAcks</a> <span title="(x: Int)Boolean">&gt;=</span> <a href="#kafka.cluster;Partition.checkEnoughReplicasReachOffset.requiredAcks" title="Int">requiredAcks</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="(_1: Boolean, _2: Short)(Boolean, Short)" class="delimiter">(</span>true, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> else
          <span title="(_1: Boolean, _2: Short)(Boolean, Short)" class="delimiter">(</span>false, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span>
      case <span title="None.type">None</span> =&gt;
        <span title="(_1: Boolean, _2: Short)(Boolean, Short)" class="delimiter">(</span>false, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NotLeaderForPartitionCode" title="=&gt; Short">NotLeaderForPartitionCode</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * There is no need to acquire the leaderIsrUpdate lock here since all callers of this private API acquire that lock
   * @param leaderReplica
   */</span>
  private def <a title="(leaderReplica: kafka.cluster.Replica)Unit" id="kafka.cluster;Partition.maybeIncrementLeaderHW">maybeIncrementLeaderHW</a><span class="delimiter">(</span><a title="kafka.cluster.Replica" id="kafka.cluster;Partition.maybeIncrementLeaderHW.leaderReplica">leaderReplica</a>: <a href="Replica.scala.html#kafka.cluster;Replica" title="kafka.cluster.Replica">Replica</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="scala.collection.immutable.Set[kafka.server.LogOffsetMetadata]" id="kafka.cluster;Partition.maybeIncrementLeaderHW.allLogEndOffsets">allLogEndOffsets</a> = <a href="#kafka.cluster;Partition.inSyncReplicas_=" title="=&gt; scala.collection.immutable.Set[kafka.cluster.Replica]">inSyncReplicas</a>.<span title="(f: kafka.cluster.Replica =&gt; kafka.server.LogOffsetMetadata)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[kafka.cluster.Replica],kafka.server.LogOffsetMetadata,scala.collection.immutable.Set[kafka.server.LogOffsetMetadata]])scala.collection.immutable.Set[kafka.server.LogOffsetMetadata]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,kafka.server.LogOffsetMetadata,scala.collection.immutable.Set[kafka.server.LogOffsetMetadata]]" class="delimiter">(</span><a href="#kafka.cluster;Partition.maybeIncrementLeaderHW.allLogEndOffsets.$anonfun.x$8" title="kafka.cluster.Replica">_</a>.<a href="Replica.scala.html#kafka.cluster;Replica.logEndOffset" title="=&gt; kafka.server.LogOffsetMetadata">logEndOffset</a><span class="delimiter">)</span>
    val <a title="kafka.server.LogOffsetMetadata" id="kafka.cluster;Partition.maybeIncrementLeaderHW.newHighWatermark">newHighWatermark</a> = <a href="#kafka.cluster;Partition.maybeIncrementLeaderHW.allLogEndOffsets" title="scala.collection.immutable.Set[kafka.server.LogOffsetMetadata]">allLogEndOffsets</a>.<span title="(implicit cmp: Ordering[kafka.server.LogOffsetMetadata])kafka.server.LogOffsetMetadata">min</span><span class="delimiter">(</span>new <a href="../server/LogOffsetMetadata.scala.html#kafka.server.LogOffsetMetadata" title="kafka.server.LogOffsetMetadata.type">LogOffsetMetadata</a>.<a href="../server/LogOffsetMetadata.scala.html#kafka.server.LogOffsetMetadata;OffsetOrdering" title="kafka.server.LogOffsetMetadata.OffsetOrdering">OffsetOrdering</a><span class="delimiter">)</span>
    val <a title="kafka.server.LogOffsetMetadata" id="kafka.cluster;Partition.maybeIncrementLeaderHW.oldHighWatermark">oldHighWatermark</a> = <a href="#kafka.cluster;Partition.maybeIncrementLeaderHW.leaderReplica" title="kafka.cluster.Replica">leaderReplica</a>.<a href="Replica.scala.html#kafka.cluster;Replica.highWatermark" title="=&gt; kafka.server.LogOffsetMetadata">highWatermark</a>
    if<span class="delimiter">(</span><a href="#kafka.cluster;Partition.maybeIncrementLeaderHW.oldHighWatermark" title="kafka.server.LogOffsetMetadata">oldHighWatermark</a>.<a href="../server/LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.precedes" title="(that: kafka.server.LogOffsetMetadata)Boolean">precedes</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.maybeIncrementLeaderHW.newHighWatermark" title="kafka.server.LogOffsetMetadata">newHighWatermark</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.cluster;Partition.maybeIncrementLeaderHW.leaderReplica" title="kafka.cluster.Replica">leaderReplica</a>.<a href="Replica.scala.html#kafka.cluster;Replica.highWatermark_=" title="(newHighWatermark: kafka.server.LogOffsetMetadata)Unit">highWatermark</a> = <a href="#kafka.cluster;Partition.maybeIncrementLeaderHW.newHighWatermark" title="kafka.server.LogOffsetMetadata">newHighWatermark</a>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;High watermark for partition [%s,%d] updated to %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a>, <a href="#kafka.cluster;Partition.maybeIncrementLeaderHW.newHighWatermark" title="kafka.server.LogOffsetMetadata">newHighWatermark</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="comment">// some delayed requests may be unblocked after HW changed</span>
      val <a title="kafka.common.TopicAndPartition" id="kafka.cluster;Partition.maybeIncrementLeaderHW.requestKey">requestKey</a> = new <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span>this.<a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, this.<a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span>
      <a href="#kafka.cluster;Partition.replicaManager" title="kafka.server.ReplicaManager">replicaManager</a>.<a href="../server/ReplicaManager.scala.html#kafka.server;ReplicaManager.unblockDelayedFetchRequests" title="(key: kafka.common.TopicAndPartition)Unit">unblockDelayedFetchRequests</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.maybeIncrementLeaderHW.requestKey" title="kafka.common.TopicAndPartition">requestKey</a><span class="delimiter">)</span>
      <a href="#kafka.cluster;Partition.replicaManager" title="kafka.server.ReplicaManager">replicaManager</a>.<a href="../server/ReplicaManager.scala.html#kafka.server;ReplicaManager.unblockDelayedProduceRequests" title="(key: kafka.common.TopicAndPartition)Unit">unblockDelayedProduceRequests</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.maybeIncrementLeaderHW.requestKey" title="kafka.common.TopicAndPartition">requestKey</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Skipping update high watermark since Old hw %s is larger than new hw %s for partition [%s,%d]. All leo's are %s&quot;</span>
        .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.maybeIncrementLeaderHW.oldHighWatermark" title="kafka.server.LogOffsetMetadata">oldHighWatermark</a>, <a href="#kafka.cluster;Partition.maybeIncrementLeaderHW.newHighWatermark" title="kafka.server.LogOffsetMetadata">newHighWatermark</a>, <a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a>, <a href="#kafka.cluster;Partition.maybeIncrementLeaderHW.allLogEndOffsets" title="scala.collection.immutable.Set[kafka.server.LogOffsetMetadata]">allLogEndOffsets</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(replicaMaxLagTimeMs: Long, replicaMaxLagMessages: Long)Unit" id="kafka.cluster;Partition.maybeShrinkIsr">maybeShrinkIsr</a><span class="delimiter">(</span><a title="Long" id="kafka.cluster;Partition.maybeShrinkIsr.replicaMaxLagTimeMs">replicaMaxLagTimeMs</a>: <span title="Long">Long</span>,  <a title="Long" id="kafka.cluster;Partition.maybeShrinkIsr.replicaMaxLagMessages">replicaMaxLagMessages</a>: <span title="Long">Long</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Utils.scala.html#kafka.utils.Utils.inWriteLock" title="(lock: java.util.concurrent.locks.ReadWriteLock)(fun: =&gt; Unit)Unit">inWriteLock</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.leaderIsrUpdateLock" title="=&gt; java.util.concurrent.locks.ReentrantReadWriteLock">leaderIsrUpdateLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.cluster;Partition.leaderReplicaIfLocal" title="()Option[kafka.cluster.Replica]">leaderReplicaIfLocal</a><span class="delimiter">(</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case Some<span class="delimiter">(</span><a title="kafka.cluster.Replica" id="kafka.cluster;Partition.maybeShrinkIsr.leaderReplica">leaderReplica</a><span class="delimiter">)</span> =&gt;
          val <a title="scala.collection.immutable.Set[kafka.cluster.Replica]" id="kafka.cluster;Partition.maybeShrinkIsr.outOfSyncReplicas">outOfSyncReplicas</a> = <a href="#kafka.cluster;Partition.getOutOfSyncReplicas" title="(leaderReplica: kafka.cluster.Replica, keepInSyncTimeMs: Long, keepInSyncMessages: Long)scala.collection.immutable.Set[kafka.cluster.Replica]">getOutOfSyncReplicas</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.maybeShrinkIsr.leaderReplica" title="kafka.cluster.Replica">leaderReplica</a>, <a href="#kafka.cluster;Partition.maybeShrinkIsr.replicaMaxLagTimeMs" title="Long">replicaMaxLagTimeMs</a>, <a href="#kafka.cluster;Partition.maybeShrinkIsr.replicaMaxLagMessages" title="Long">replicaMaxLagMessages</a><span class="delimiter">)</span>
          if<span class="delimiter">(</span><a href="#kafka.cluster;Partition.maybeShrinkIsr.outOfSyncReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">outOfSyncReplicas</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            val newInSyncReplicas = <a href="#kafka.cluster;Partition.inSyncReplicas_=" title="=&gt; scala.collection.immutable.Set[kafka.cluster.Replica]">inSyncReplicas</a> <a title="scala.collection.immutable.Set[kafka.cluster.Replica]" id="kafka.cluster;Partition.maybeShrinkIsr.newInSyncReplicas">--</a> <a href="#kafka.cluster;Partition.maybeShrinkIsr.outOfSyncReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">outOfSyncReplicas</a>
            <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.maybeShrinkIsr.newInSyncReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">newInSyncReplicas</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
            <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Shrinking ISR for partition [%s,%d] from %s to %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a>,
              <a href="#kafka.cluster;Partition.inSyncReplicas_=" title="=&gt; scala.collection.immutable.Set[kafka.cluster.Replica]">inSyncReplicas</a>.<span title="(f: kafka.cluster.Replica =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[kafka.cluster.Replica],Int,scala.collection.immutable.Set[Int]])scala.collection.immutable.Set[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,Int,scala.collection.immutable.Set[Int]]" class="delimiter">(</span><a href="#kafka.cluster;Partition.maybeShrinkIsr.$anonfun.x$9" title="kafka.cluster.Replica">_</a>.<a href="Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>, <a href="#kafka.cluster;Partition.maybeShrinkIsr.newInSyncReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">newInSyncReplicas</a>.<span title="(f: kafka.cluster.Replica =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[kafka.cluster.Replica],Int,scala.collection.immutable.Set[Int]])scala.collection.immutable.Set[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,Int,scala.collection.immutable.Set[Int]]" class="delimiter">(</span><a href="#kafka.cluster;Partition.maybeShrinkIsr.$anonfun.x$10" title="kafka.cluster.Replica">_</a>.<a href="Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="comment">// update ISR in zk and in cache</span>
            <a href="#kafka.cluster;Partition.updateIsr" title="(newIsr: scala.collection.immutable.Set[kafka.cluster.Replica])Unit">updateIsr</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.maybeShrinkIsr.newInSyncReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">newInSyncReplicas</a><span class="delimiter">)</span>
            <span class="comment">// we may need to increment high watermark since ISR could be down to 1</span>
            <a href="#kafka.cluster;Partition.maybeIncrementLeaderHW" title="(leaderReplica: kafka.cluster.Replica)Unit">maybeIncrementLeaderHW</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.maybeShrinkIsr.leaderReplica" title="kafka.cluster.Replica">leaderReplica</a><span class="delimiter">)</span>
            <a href="#kafka.cluster;Partition.replicaManager" title="kafka.server.ReplicaManager">replicaManager</a>.<a href="../server/ReplicaManager.scala.html#kafka.server;ReplicaManager.isrShrinkRate" title="=&gt; com.yammer.metrics.core.Meter">isrShrinkRate</a>.<span title="()Unit">mark</span><span class="delimiter">(</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        case <span title="None.type">None</span> =&gt; <span class="comment">// do nothing if no longer leader</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(leaderReplica: kafka.cluster.Replica, keepInSyncTimeMs: Long, keepInSyncMessages: Long)scala.collection.immutable.Set[kafka.cluster.Replica]" id="kafka.cluster;Partition.getOutOfSyncReplicas">getOutOfSyncReplicas</a><span class="delimiter">(</span><a title="kafka.cluster.Replica" id="kafka.cluster;Partition.getOutOfSyncReplicas.leaderReplica">leaderReplica</a>: <a href="Replica.scala.html#kafka.cluster;Replica" title="kafka.cluster.Replica">Replica</a>, <a title="Long" id="kafka.cluster;Partition.getOutOfSyncReplicas.keepInSyncTimeMs">keepInSyncTimeMs</a>: <span title="Long">Long</span>, <a title="Long" id="kafka.cluster;Partition.getOutOfSyncReplicas.keepInSyncMessages">keepInSyncMessages</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="scala.collection.immutable.Set[kafka.cluster.Replica]">Set</span><span class="delimiter">[</span>Replica<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">/**
     * there are two cases that need to be handled here -
     * 1. Stuck followers: If the leo of the replica hasn't been updated for keepInSyncTimeMs ms,
     *                     the follower is stuck and should be removed from the ISR
     * 2. Slow followers: If the leo of the slowest follower is behind the leo of the leader by keepInSyncMessages, the
     *                     follower is not catching up and should be removed from the ISR
     **/</span>
    val <a title="kafka.server.LogOffsetMetadata" id="kafka.cluster;Partition.getOutOfSyncReplicas.leaderLogEndOffset">leaderLogEndOffset</a> = <a href="#kafka.cluster;Partition.getOutOfSyncReplicas.leaderReplica" title="kafka.cluster.Replica">leaderReplica</a>.<a href="Replica.scala.html#kafka.cluster;Replica.logEndOffset" title="=&gt; kafka.server.LogOffsetMetadata">logEndOffset</a>
    val candidateReplicas = <a href="#kafka.cluster;Partition.inSyncReplicas_=" title="=&gt; scala.collection.immutable.Set[kafka.cluster.Replica]">inSyncReplicas</a> <a title="scala.collection.immutable.Set[kafka.cluster.Replica]" id="kafka.cluster;Partition.getOutOfSyncReplicas.candidateReplicas">-</a> <a href="#kafka.cluster;Partition.getOutOfSyncReplicas.leaderReplica" title="kafka.cluster.Replica">leaderReplica</a>
    <span class="comment">// Case 1 above</span>
    val <a title="scala.collection.immutable.Set[kafka.cluster.Replica]" id="kafka.cluster;Partition.getOutOfSyncReplicas.stuckReplicas">stuckReplicas</a> = <a href="#kafka.cluster;Partition.getOutOfSyncReplicas.candidateReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">candidateReplicas</a>.<span title="(p: kafka.cluster.Replica =&gt; Boolean)scala.collection.immutable.Set[kafka.cluster.Replica]">filter</span><span class="delimiter">(</span><a title="kafka.cluster.Replica" id="kafka.cluster;Partition.getOutOfSyncReplicas.stuckReplicas.$anonfun.r">r</a> =&gt; <span class="delimiter">(</span><a href="#kafka.cluster;Partition.time" title="kafka.utils.Time">time</a>.<a href="../utils/Time.scala.html#kafka.utils;Time.milliseconds" title="=&gt; Long">milliseconds</a> <span title="(x: Long)Long">-</span> <a href="#kafka.cluster;Partition.getOutOfSyncReplicas.stuckReplicas.$anonfun.r" title="kafka.cluster.Replica">r</a>.<a href="Replica.scala.html#kafka.cluster;Replica.logEndOffsetUpdateTimeMs" title="=&gt; Long">logEndOffsetUpdateTimeMs</a><span class="delimiter">)</span> <span title="(x: Long)Boolean">&gt;</span> <a href="#kafka.cluster;Partition.getOutOfSyncReplicas.keepInSyncTimeMs" title="Long">keepInSyncTimeMs</a><span class="delimiter">)</span>
    if<span class="delimiter">(</span><a href="#kafka.cluster;Partition.getOutOfSyncReplicas.stuckReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">stuckReplicas</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Stuck replicas for partition [%s,%d] are %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a>, <a href="#kafka.cluster;Partition.getOutOfSyncReplicas.stuckReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">stuckReplicas</a>.<span title="(f: kafka.cluster.Replica =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[kafka.cluster.Replica],Int,scala.collection.immutable.Set[Int]])scala.collection.immutable.Set[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,Int,scala.collection.immutable.Set[Int]]" class="delimiter">(</span><a href="#kafka.cluster;Partition.getOutOfSyncReplicas.$anonfun.x$11" title="kafka.cluster.Replica">_</a>.<a href="Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="comment">// Case 2 above</span>
    val <a title="scala.collection.immutable.Set[kafka.cluster.Replica]" id="kafka.cluster;Partition.getOutOfSyncReplicas.slowReplicas">slowReplicas</a> = <a href="#kafka.cluster;Partition.getOutOfSyncReplicas.candidateReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">candidateReplicas</a>.<span title="(p: kafka.cluster.Replica =&gt; Boolean)scala.collection.immutable.Set[kafka.cluster.Replica]">filter</span><span class="delimiter">(</span><a title="kafka.cluster.Replica" id="kafka.cluster;Partition.getOutOfSyncReplicas.slowReplicas.$anonfun.r">r</a> =&gt;
      <a href="#kafka.cluster;Partition.getOutOfSyncReplicas.slowReplicas.$anonfun.r" title="kafka.cluster.Replica">r</a>.<a href="Replica.scala.html#kafka.cluster;Replica.logEndOffset" title="=&gt; kafka.server.LogOffsetMetadata">logEndOffset</a>.<a href="../server/LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="=&gt; Long">messageOffset</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <a href="#kafka.cluster;Partition.getOutOfSyncReplicas.leaderLogEndOffset" title="kafka.server.LogOffsetMetadata">leaderLogEndOffset</a>.<a href="../server/LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="=&gt; Long">messageOffset</a> <span title="(x: Long)Long">-</span> <a href="#kafka.cluster;Partition.getOutOfSyncReplicas.slowReplicas.$anonfun.r" title="kafka.cluster.Replica">r</a>.<a href="Replica.scala.html#kafka.cluster;Replica.logEndOffset" title="=&gt; kafka.server.LogOffsetMetadata">logEndOffset</a>.<a href="../server/LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="=&gt; Long">messageOffset</a> <span title="(x: Long)Boolean">&gt;</span> <a href="#kafka.cluster;Partition.getOutOfSyncReplicas.keepInSyncMessages" title="Long">keepInSyncMessages</a><span class="delimiter">)</span>
    if<span class="delimiter">(</span><a href="#kafka.cluster;Partition.getOutOfSyncReplicas.slowReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">slowReplicas</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Slow replicas for partition [%s,%d] are %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a>, <a href="#kafka.cluster;Partition.getOutOfSyncReplicas.slowReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">slowReplicas</a>.<span title="(f: kafka.cluster.Replica =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[kafka.cluster.Replica],Int,scala.collection.immutable.Set[Int]])scala.collection.immutable.Set[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,Int,scala.collection.immutable.Set[Int]]" class="delimiter">(</span><a href="#kafka.cluster;Partition.getOutOfSyncReplicas.$anonfun.x$12" title="kafka.cluster.Replica">_</a>.<a href="Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.cluster;Partition.getOutOfSyncReplicas.stuckReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">stuckReplicas</a> <span title="(elems: scala.collection.GenTraversableOnce[kafka.cluster.Replica])scala.collection.immutable.Set[kafka.cluster.Replica]">++</span> <a href="#kafka.cluster;Partition.getOutOfSyncReplicas.slowReplicas" title="scala.collection.immutable.Set[kafka.cluster.Replica]">slowReplicas</a>
  <span class="delimiter">}</span>

  def <a title="(messages: kafka.message.ByteBufferMessageSet, requiredAcks: Int)kafka.log.Log#LogAppendInfo" id="kafka.cluster;Partition.appendMessagesToLeader">appendMessagesToLeader</a><span class="delimiter">(</span><a title="kafka.message.ByteBufferMessageSet" id="kafka.cluster;Partition.appendMessagesToLeader.messages">messages</a>: <a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet">ByteBufferMessageSet</a>, <a title="Int" id="kafka.cluster;Partition.appendMessagesToLeader$default$2">requiredAcks</a>: <span title="Int">Int</span>=<span title="Int(0)" class="int">0</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="../utils/Utils.scala.html#kafka.utils.Utils.inReadLock" title="(lock: java.util.concurrent.locks.ReadWriteLock)(fun: =&gt; kafka.log.Log#LogAppendInfo)kafka.log.Log#LogAppendInfo">inReadLock</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.leaderIsrUpdateLock" title="=&gt; java.util.concurrent.locks.ReentrantReadWriteLock">leaderIsrUpdateLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="Option[kafka.cluster.Replica]" id="kafka.cluster;Partition.appendMessagesToLeader.leaderReplicaOpt">leaderReplicaOpt</a> = <a href="#kafka.cluster;Partition.leaderReplicaIfLocal" title="()Option[kafka.cluster.Replica]">leaderReplicaIfLocal</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#kafka.cluster;Partition.appendMessagesToLeader.leaderReplicaOpt" title="Option[kafka.cluster.Replica]">leaderReplicaOpt</a> match <span class="delimiter">{</span>
        case Some<span class="delimiter">(</span><a title="kafka.cluster.Replica" id="kafka.cluster;Partition.appendMessagesToLeader.leaderReplica">leaderReplica</a><span class="delimiter">)</span> =&gt;
          val <a title="kafka.log.Log" id="kafka.cluster;Partition.appendMessagesToLeader.log">log</a> = <a href="#kafka.cluster;Partition.appendMessagesToLeader.leaderReplica" title="kafka.cluster.Replica">leaderReplica</a>.<a href="Replica.scala.html#kafka.cluster;Replica.log" title="=&gt; Option[kafka.log.Log]">log</a>.<span title="=&gt; kafka.log.Log">get</span>
          val <a title="Int" id="kafka.cluster;Partition.appendMessagesToLeader.minIsr">minIsr</a> = <a href="#kafka.cluster;Partition.appendMessagesToLeader.log" title="kafka.log.Log">log</a>.<a href="../log/Log.scala.html#kafka.log;Log.config" title="=&gt; kafka.log.LogConfig">config</a>.<a href="../log/LogConfig.scala.html#kafka.log;LogConfig.minInSyncReplicas" title="=&gt; Int">minInSyncReplicas</a>
          val <a title="Int" id="kafka.cluster;Partition.appendMessagesToLeader.inSyncSize">inSyncSize</a> = <a href="#kafka.cluster;Partition.inSyncReplicas_=" title="=&gt; scala.collection.immutable.Set[kafka.cluster.Replica]">inSyncReplicas</a>.<span title="=&gt; Int">size</span>

          <span class="comment">// Avoid writing to leader if there are not enough insync replicas to make it safe</span>
          if <span class="delimiter">(</span><a href="#kafka.cluster;Partition.appendMessagesToLeader.inSyncSize" title="Int">inSyncSize</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#kafka.cluster;Partition.appendMessagesToLeader.minIsr" title="Int">minIsr</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.cluster;Partition.appendMessagesToLeader$default$2" title="Int">requiredAcks</a> <span title="(x: Int)Boolean">==</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            throw new <a href="../common/NotEnoughReplicasException.scala.html#kafka.common;NotEnoughReplicasException" title="kafka.common.NotEnoughReplicasException">NotEnoughReplicasException</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Number of insync replicas for partition [%s,%d] is [%d], below required minimum [%d]&quot;</span>
              .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>,<a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a>,<a href="#kafka.cluster;Partition.appendMessagesToLeader.minIsr" title="Int">minIsr</a>,<a href="#kafka.cluster;Partition.appendMessagesToLeader.inSyncSize" title="Int">inSyncSize</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>

          val <a title="log.LogAppendInfo" id="kafka.cluster;Partition.appendMessagesToLeader.info">info</a> = <a href="#kafka.cluster;Partition.appendMessagesToLeader.log" title="kafka.log.Log">log</a>.<a href="../log/Log.scala.html#kafka.log;Log.append" title="(messages: kafka.message.ByteBufferMessageSet, assignOffsets: Boolean)log.LogAppendInfo">append</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.appendMessagesToLeader.messages" title="kafka.message.ByteBufferMessageSet">messages</a>, assignOffsets = true<span class="delimiter">)</span>
          <span class="comment">// probably unblock some follower fetch requests since log end offset has been updated</span>
          <a href="#kafka.cluster;Partition.replicaManager" title="kafka.server.ReplicaManager">replicaManager</a>.<a href="../server/ReplicaManager.scala.html#kafka.server;ReplicaManager.unblockDelayedFetchRequests" title="(key: kafka.common.TopicAndPartition)Unit">unblockDelayedFetchRequests</a><span class="delimiter">(</span>new <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span>this.<a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, this.<a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="comment">// we may need to increment high watermark since ISR could be down to 1</span>
          <a href="#kafka.cluster;Partition.maybeIncrementLeaderHW" title="(leaderReplica: kafka.cluster.Replica)Unit">maybeIncrementLeaderHW</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.appendMessagesToLeader.leaderReplica" title="kafka.cluster.Replica">leaderReplica</a><span class="delimiter">)</span>
          <a href="#kafka.cluster;Partition.appendMessagesToLeader.info" title="log.LogAppendInfo">info</a>
        case <span title="None.type">None</span> =&gt;
          throw new <a href="../common/NotLeaderForPartitionException.scala.html#kafka.common;NotLeaderForPartitionException" title="kafka.common.NotLeaderForPartitionException">NotLeaderForPartitionException</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Leader not local for partition [%s,%d] on broker %d&quot;</span>
            .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a>, <a href="#kafka.cluster;Partition.localBrokerId" title="=&gt; Int">localBrokerId</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  private def <a title="(newIsr: scala.collection.immutable.Set[kafka.cluster.Replica])Unit" id="kafka.cluster;Partition.updateIsr">updateIsr</a><span class="delimiter">(</span><a title="scala.collection.immutable.Set[kafka.cluster.Replica]" id="kafka.cluster;Partition.updateIsr.newIsr">newIsr</a>: <span title="scala.collection.immutable.Set[kafka.cluster.Replica]">Set</span><span class="delimiter">[</span>Replica<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="kafka.api.LeaderAndIsr" id="kafka.cluster;Partition.updateIsr.newLeaderAndIsr">newLeaderAndIsr</a> = new <a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;LeaderAndIsr" title="kafka.api.LeaderAndIsr">LeaderAndIsr</a><span class="delimiter">(</span><a href="#kafka.cluster;Partition.localBrokerId" title="=&gt; Int">localBrokerId</a>, <a href="#kafka.cluster;Partition.leaderEpoch_=" title="=&gt; Int">leaderEpoch</a>, <a href="#kafka.cluster;Partition.updateIsr.newIsr" title="scala.collection.immutable.Set[kafka.cluster.Replica]">newIsr</a>.<span title="(f: kafka.cluster.Replica =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[kafka.cluster.Replica],Int,scala.collection.immutable.Set[Int]])scala.collection.immutable.Set[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,Int,scala.collection.immutable.Set[Int]]" class="delimiter">(</span><a title="kafka.cluster.Replica" id="kafka.cluster;Partition.updateIsr.newLeaderAndIsr.$anonfun.r">r</a> =&gt; <a href="#kafka.cluster;Partition.updateIsr.newLeaderAndIsr.$anonfun.r" title="kafka.cluster.Replica">r</a>.<a href="Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span>.<span title="=&gt; List[Int]">toList</span>, <a href="#kafka.cluster;Partition.zkVersion_=" title="=&gt; Int">zkVersion</a><span class="delimiter">)</span>
    val <a href="#kafka.cluster;Partition.updateIsr.updateSucceeded" title="(Boolean, Int)" class="delimiter">(</a><a href="#kafka.cluster;Partition.updateIsr.x$13" title="Boolean" id="kafka.cluster;Partition.updateIsr.updateSucceeded">updateSucceeded</a>,<a href="#kafka.cluster;Partition.updateIsr.x$13" title="Int" id="kafka.cluster;Partition.updateIsr.newVersion">newVersion</a><span class="delimiter">)</span> = <a href="../utils/ReplicationUtils.scala.html#kafka.utils.ReplicationUtils" title="kafka.utils.ReplicationUtils.type">ReplicationUtils</a>.<a href="../utils/ReplicationUtils.scala.html#kafka.utils.ReplicationUtils.updateLeaderAndIsr" title="(zkClient: org.I0Itec.zkclient.ZkClient, topic: String, partitionId: Int, newLeaderAndIsr: kafka.api.LeaderAndIsr, controllerEpoch: Int, zkVersion: Int)(Boolean, Int)">updateLeaderAndIsr</a><span title="(Boolean, Int) @unchecked" class="delimiter">(</span><a href="#kafka.cluster;Partition.zkClient" title="=&gt; org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>, <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a>,
      <a href="#kafka.cluster;Partition.updateIsr.newLeaderAndIsr" title="kafka.api.LeaderAndIsr">newLeaderAndIsr</a>, <a href="#kafka.cluster;Partition.controllerEpoch_=" title="=&gt; Int">controllerEpoch</a>, <a href="#kafka.cluster;Partition.zkVersion_=" title="=&gt; Int">zkVersion</a><span class="delimiter">)</span>
    if<span class="delimiter">(</span><a href="#kafka.cluster;Partition.updateIsr.updateSucceeded" title="Boolean">updateSucceeded</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.cluster;Partition.inSyncReplicas_=" title="(x$1: scala.collection.immutable.Set[kafka.cluster.Replica])Unit">inSyncReplicas</a> = <a href="#kafka.cluster;Partition.updateIsr.newIsr" title="scala.collection.immutable.Set[kafka.cluster.Replica]">newIsr</a>
      <a href="#kafka.cluster;Partition.zkVersion_=" title="(x$1: Int)Unit">zkVersion</a> = <a href="#kafka.cluster;Partition.updateIsr.newVersion" title="Int">newVersion</a>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;ISR updated to [%s] and zkVersion updated to [%d]&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.updateIsr.newIsr" title="scala.collection.immutable.Set[kafka.cluster.Replica]">newIsr</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>, <a href="#kafka.cluster;Partition.zkVersion_=" title="=&gt; Int">zkVersion</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Cached zkVersion [%d] not equal to that in zookeeper, skip updating ISR&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.zkVersion_=" title="=&gt; Int">zkVersion</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  override def <a title="(that: Any)Boolean" id="kafka.cluster;Partition.equals">equals</a><span class="delimiter">(</span><a title="Any" id="kafka.cluster;Partition.equals.that">that</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    if<span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.equals.that" title="Any">that</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#kafka.cluster;Partition" title="kafka.cluster.Partition">Partition</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>
      return false
    val <a title="kafka.cluster.Partition" id="kafka.cluster;Partition.equals.other">other</a> = <a href="#kafka.cluster;Partition.equals.that" title="Any">that</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.cluster.Partition" class="delimiter">[</span><a href="#kafka.cluster;Partition" title="kafka.cluster.Partition">Partition</a><span class="delimiter">]</span>
    if<span class="delimiter">(</span><a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>.<span title="(x$1: Any)Boolean">equals</span><span class="delimiter">(</span><a href="#kafka.cluster;Partition.equals.other" title="kafka.cluster.Partition">other</a>.<a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a> <span title="(x: Int)Boolean">==</span> <a href="#kafka.cluster;Partition.equals.other" title="kafka.cluster.Partition">other</a>.<a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span>
      return true
    false
  <span class="delimiter">}</span>

  override def <a title="()Int" id="kafka.cluster;Partition.hashCode">hashCode</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
    <span title="Int(31)" class="int">31</span> <span title="(x: Int)Int">+</span> <a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a>.<span title="()Int">hashCode</span><span class="delimiter">(</span><span class="delimiter">)</span> <span title="(x: Int)Int">+</span> <span title="Int(17)" class="int">17</span><span title="(x: Int)Int">*</span><a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a>
  <span class="delimiter">}</span>

  override def <a title="()String" id="kafka.cluster;Partition.toString">toString</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    val <a title="StringBuilder" id="kafka.cluster;Partition.toString.partitionString">partitionString</a> = new <span title="StringBuilder">StringBuilder</span>
    <a href="#kafka.cluster;Partition.toString.partitionString" title="StringBuilder">partitionString</a>.<span title="(s: String)StringBuilder">append</span><span class="delimiter">(</span><span title="String(&quot;Topic: &quot;)" class="string">&quot;Topic: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.cluster;Partition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>
    <a href="#kafka.cluster;Partition.toString.partitionString" title="StringBuilder">partitionString</a>.<span title="(s: String)StringBuilder">append</span><span class="delimiter">(</span><span title="String(&quot;; Partition: &quot;)" class="string">&quot;; Partition: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.cluster;Partition.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span>
    <a href="#kafka.cluster;Partition.toString.partitionString" title="StringBuilder">partitionString</a>.<span title="(s: String)StringBuilder">append</span><span class="delimiter">(</span><span title="String(&quot;; Leader: &quot;)" class="string">&quot;; Leader: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.cluster;Partition.leaderReplicaIdOpt_=" title="=&gt; Option[Int]">leaderReplicaIdOpt</a><span class="delimiter">)</span>
    <a href="#kafka.cluster;Partition.toString.partitionString" title="StringBuilder">partitionString</a>.<span title="(s: String)StringBuilder">append</span><span class="delimiter">(</span><span title="String(&quot;; AssignedReplicas: &quot;)" class="string">&quot;; AssignedReplicas: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.cluster;Partition.assignedReplicaMap" title="=&gt; kafka.utils.Pool[Int,kafka.cluster.Replica]">assignedReplicaMap</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.keys" title="=&gt; scala.collection.mutable.Set[Int]">keys</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.cluster;Partition.toString.partitionString" title="StringBuilder">partitionString</a>.<span title="(s: String)StringBuilder">append</span><span class="delimiter">(</span><span title="String(&quot;; InSyncReplicas: &quot;)" class="string">&quot;; InSyncReplicas: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.cluster;Partition.inSyncReplicas_=" title="=&gt; scala.collection.immutable.Set[kafka.cluster.Replica]">inSyncReplicas</a>.<span title="(f: kafka.cluster.Replica =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[kafka.cluster.Replica],Int,scala.collection.immutable.Set[Int]])scala.collection.immutable.Set[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,Int,scala.collection.immutable.Set[Int]]" class="delimiter">(</span><a href="#kafka.cluster;Partition.toString.$anonfun.x$14" title="kafka.cluster.Replica">_</a>.<a href="Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.cluster;Partition.toString.partitionString" title="StringBuilder">partitionString</a>.<span title="()String">toString</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
