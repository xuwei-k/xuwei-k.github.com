<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/controller/TopicDeletionManager.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>
package kafka.controller

import collection.mutable
import kafka.utils.<span class="delimiter">{</span>ShutdownableThread, Logging, ZkUtils<span class="delimiter">}</span>
import kafka.utils.<a href="../utils/Utils.scala.html#kafka.utils.Utils" title="kafka.utils.Utils.type">Utils</a>._
import collection.Set
import kafka.common.<span class="delimiter">{</span>ErrorMapping, TopicAndPartition<span class="delimiter">}</span>
import kafka.api.<span class="delimiter">{</span>StopReplicaResponse, RequestOrResponse<span class="delimiter">}</span>
import java.util.concurrent.locks.ReentrantLock
import java.util.concurrent.atomic.AtomicBoolean

<span class="comment">/**
 * This manages the state machine for topic deletion.
 * 1. TopicCommand issues topic deletion by creating a new admin path /admin/delete_topics/&lt;topic&gt;
 * 2. The controller listens for child changes on /admin/delete_topic and starts topic deletion for the respective topics
 * 3. The controller has a background thread that handles topic deletion. The purpose of having this background thread
 *    is to accommodate the TTL feature, when we have it. This thread is signaled whenever deletion for a topic needs to
 *    be started or resumed. Currently, a topic's deletion can be started only by the onPartitionDeletion callback on the
 *    controller. In the future, it can be triggered based on the configured TTL for the topic. A topic will be ineligible
 *    for deletion in the following scenarios -
 *    3.1 broker hosting one of the replicas for that topic goes down
 *    3.2 partition reassignment for partitions of that topic is in progress
 *    3.3 preferred replica election for partitions of that topic is in progress
 *    (though this is not strictly required since it holds the controller lock for the entire duration from start to end)
 * 4. Topic deletion is resumed when -
 *    4.1 broker hosting one of the replicas for that topic is started
 *    4.2 preferred replica election for partitions of that topic completes
 *    4.3 partition reassignment for partitions of that topic completes
 * 5. Every replica for a topic being deleted is in either of the 3 states -
 *    5.1 TopicDeletionStarted (Replica enters TopicDeletionStarted phase when the onPartitionDeletion callback is invoked.
 *        This happens when the child change watch for /admin/delete_topics fires on the controller. As part of this state
 *        change, the controller sends StopReplicaRequests to all replicas. It registers a callback for the
 *        StopReplicaResponse when deletePartition=true thereby invoking a callback when a response for delete replica
 *        is received from every replica)
 *    5.2 TopicDeletionSuccessful (deleteTopicStopReplicaCallback() moves replicas from
 *        TopicDeletionStarted-&gt;TopicDeletionSuccessful depending on the error codes in StopReplicaResponse)
 *    5.3 TopicDeletionFailed. (deleteTopicStopReplicaCallback() moves replicas from
 *        TopicDeletionStarted-&gt;TopicDeletionFailed depending on the error codes in StopReplicaResponse.
 *        In general, if a broker dies and if it hosted replicas for topics being deleted, the controller marks the
 *        respective replicas in TopicDeletionFailed state in the onBrokerFailure callback. The reason is that if a
 *        broker fails before the request is sent and after the replica is in TopicDeletionStarted state,
 *        it is possible that the replica will mistakenly remain in TopicDeletionStarted state and topic deletion
 *        will not be retried when the broker comes back up.)
 * 6. The delete topic thread marks a topic successfully deleted only if all replicas are in TopicDeletionSuccessful
 *    state and it starts the topic deletion teardown mode where it deletes all topic state from the controllerContext
 *    as well as from zookeeper. This is the only time the /brokers/topics/&lt;topic&gt; path gets deleted. On the other hand,
 *    if no replica is in TopicDeletionStarted state and at least one replica is in TopicDeletionFailed state, then
 *    it marks the topic for deletion retry.
 * @param controller
 * @param initialTopicsToBeDeleted The topics that are queued up for deletion in zookeeper at the time of controller failover
 * @param initialTopicsIneligibleForDeletion The topics ineligible for deletion due to any of the conditions mentioned in #3 above
 */</span>
class <a title="class TopicDeletionManager extends AnyRef with kafka.utils.Logging" id="kafka.controller.TopicDeletionManager">TopicDeletionManager</a><a href="#kafka.controller.TopicDeletionManager" title="kafka.controller.TopicDeletionManager" class="delimiter">(</a><a title="kafka.controller.KafkaController" id="kafka.controller;TopicDeletionManager.controller">controller</a>: <a href="KafkaController.scala.html#kafka.controller;KafkaController" title="kafka.controller.KafkaController">KafkaController</a>,
                           <a title="scala.collection.Set[String]" id="kafka.controller.TopicDeletionManager.<init>$default$2">initialTopicsToBeDeleted</a>: <span title="scala.collection.Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span title="scala.collection.Set.type">Set</span>.<span title="scala.collection.Set[String]">empty</span>,
                           <a title="scala.collection.Set[String]" id="kafka.controller.TopicDeletionManager.<init>$default$3">initialTopicsIneligibleForDeletion</a>: <span title="scala.collection.Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span title="scala.collection.Set.type">Set</span>.<span title="scala.collection.Set[String]">empty</span><span class="delimiter">)</span> extends <a href="../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> <span class="delimiter">{</span>
  this.<a href="../utils/Logging.scala.html#kafka.utils;Logging.logIdent_=" title="(x$1: String)Unit">logIdent</a> = <span title="String(&quot;[Topic Deletion Manager &quot;)" class="string">&quot;[Topic Deletion Manager &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="../server/KafkaConfig.scala.html#kafka.server;KafkaConfig.brokerId" title="=&gt; Int">brokerId</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;], &quot;)" class="string">&quot;], &quot;</span>
  val <a title="kafka.controller.ControllerContext" id="kafka.controller;TopicDeletionManager.controllerContext">controllerContext</a> = <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>
  val <a title="kafka.controller.PartitionStateMachine" id="kafka.controller;TopicDeletionManager.partitionStateMachine">partitionStateMachine</a> = <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.partitionStateMachine" title="=&gt; kafka.controller.PartitionStateMachine">partitionStateMachine</a>
  val <a title="kafka.controller.ReplicaStateMachine" id="kafka.controller;TopicDeletionManager.replicaStateMachine">replicaStateMachine</a> = <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>
  val topicsToBeDeleted: mutable.<span title="scala.collection.mutable.Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = mutable.<span title="scala.collection.mutable.Set.type">Set</span>.<span title="[A]=&gt; scala.collection.mutable.Set[A]">empty</span><span title="scala.collection.mutable.Set[String]" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span> <a title="scala.collection.mutable.Set[String]" id="kafka.controller;TopicDeletionManager.topicsToBeDeleted">++</a> <a href="#kafka.controller.TopicDeletionManager.<init>$default$2" title="scala.collection.Set[String]">initialTopicsToBeDeleted</a>
  val <a title="scala.collection.mutable.Set[kafka.common.TopicAndPartition]" id="kafka.controller;TopicDeletionManager.partitionsToBeDeleted">partitionsToBeDeleted</a>: mutable.<span title="scala.collection.mutable.Set[kafka.common.TopicAndPartition]">Set</span><span class="delimiter">[</span>TopicAndPartition<span class="delimiter">]</span> = <a href="#kafka.controller;TopicDeletionManager.topicsToBeDeleted" title="=&gt; scala.collection.mutable.Set[String]">topicsToBeDeleted</a>.<span title="(f: String =&gt; scala.collection.GenTraversableOnce[kafka.common.TopicAndPartition])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.Set[String],kafka.common.TopicAndPartition,scala.collection.mutable.Set[kafka.common.TopicAndPartition]])scala.collection.mutable.Set[kafka.common.TopicAndPartition]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.mutable.Set.Coll,kafka.common.TopicAndPartition,scala.collection.mutable.Set[kafka.common.TopicAndPartition]]" class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>.<a href="KafkaController.scala.html#kafka.controller;ControllerContext.partitionsForTopic" title="(topic: String)scala.collection.Set[kafka.common.TopicAndPartition]">partitionsForTopic</a><span class="delimiter">)</span>
  val <a title="java.util.concurrent.locks.ReentrantLock" id="kafka.controller;TopicDeletionManager.deleteLock">deleteLock</a> = new <span title="java.util.concurrent.locks.ReentrantLock">ReentrantLock</span><span class="delimiter">(</span><span class="delimiter">)</span>
  val topicsIneligibleForDeletion: mutable.<span title="scala.collection.mutable.Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = mutable.<span title="scala.collection.mutable.Set.type">Set</span>.<span title="[A]=&gt; scala.collection.mutable.Set[A]">empty</span><span title="scala.collection.mutable.Set[String]" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span> <a title="scala.collection.mutable.Set[String]" id="kafka.controller;TopicDeletionManager.topicsIneligibleForDeletion">++</a>
    <span class="delimiter">(</span><a href="#kafka.controller.TopicDeletionManager.<init>$default$3" title="scala.collection.Set[String]">initialTopicsIneligibleForDeletion</a> <span title="(that: scala.collection.GenSet[String])scala.collection.Set[String]">&amp;</span> <a href="#kafka.controller.TopicDeletionManager.<init>$default$2" title="scala.collection.Set[String]">initialTopicsToBeDeleted</a><span class="delimiter">)</span>
  val <a title="java.util.concurrent.locks.Condition" id="kafka.controller;TopicDeletionManager.deleteTopicsCond">deleteTopicsCond</a> = <a href="#kafka.controller;TopicDeletionManager.deleteLock" title="=&gt; java.util.concurrent.locks.ReentrantLock">deleteLock</a>.<span title="()java.util.concurrent.locks.Condition">newCondition</span><span class="delimiter">(</span><span class="delimiter">)</span>
  val <a title="java.util.concurrent.atomic.AtomicBoolean" id="kafka.controller;TopicDeletionManager.deleteTopicStateChanged">deleteTopicStateChanged</a>: <span title="java.util.concurrent.atomic.AtomicBoolean">AtomicBoolean</span> = new <span title="java.util.concurrent.atomic.AtomicBoolean">AtomicBoolean</span><span class="delimiter">(</span>false<span class="delimiter">)</span>
  var <a title="TopicDeletionManager.this.DeleteTopicsThread" id="kafka.controller;TopicDeletionManager.deleteTopicsThread_=">deleteTopicsThread</a>: <a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread" title="TopicDeletionManager.this.DeleteTopicsThread">DeleteTopicsThread</a> = null
  val <a title="Boolean" id="kafka.controller;TopicDeletionManager.isDeleteTopicEnabled">isDeleteTopicEnabled</a> = <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="../server/KafkaConfig.scala.html#kafka.server;KafkaConfig.deleteTopicEnable" title="=&gt; Boolean">deleteTopicEnable</a>

  <span class="comment">/**
   * Invoked at the end of new controller initiation
   */</span>
  def <a title="()Unit" id="kafka.controller;TopicDeletionManager.start">start</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isDeleteTopicEnabled" title="=&gt; Boolean">isDeleteTopicEnabled</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.controller;TopicDeletionManager.deleteTopicsThread_=" title="(x$1: TopicDeletionManager.this.DeleteTopicsThread)Unit">deleteTopicsThread</a> = new <a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread" title="TopicDeletionManager.this.DeleteTopicsThread">DeleteTopicsThread</a><span class="delimiter">(</span><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.topicsToBeDeleted" title="=&gt; scala.collection.mutable.Set[String]">topicsToBeDeleted</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
        <a href="#kafka.controller;TopicDeletionManager.deleteTopicStateChanged" title="=&gt; java.util.concurrent.atomic.AtomicBoolean">deleteTopicStateChanged</a>.<span title="(x$1: Boolean)Unit">set</span><span class="delimiter">(</span>true<span class="delimiter">)</span>
      <a href="#kafka.controller;TopicDeletionManager.deleteTopicsThread_=" title="=&gt; TopicDeletionManager.this.DeleteTopicsThread">deleteTopicsThread</a>.<span title="()Unit">start</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Invoked when the current controller resigns. At this time, all state for topic deletion should be cleared.
   */</span>
  def <a title="()Unit" id="kafka.controller;TopicDeletionManager.shutdown">shutdown</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">// Only allow one shutdown to go through</span>
    if <span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isDeleteTopicEnabled" title="=&gt; Boolean">isDeleteTopicEnabled</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.controller;TopicDeletionManager.deleteTopicsThread_=" title="=&gt; TopicDeletionManager.this.DeleteTopicsThread">deleteTopicsThread</a>.<a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread.initiateShutdown" title="()Boolean">initiateShutdown</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// Resume the topic deletion so it doesn't block on the condition</span>
      <a href="#kafka.controller;TopicDeletionManager.resumeTopicDeletionThread" title="()Unit">resumeTopicDeletionThread</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="comment">// Await delete topic thread to exit</span>
      <a href="#kafka.controller;TopicDeletionManager.deleteTopicsThread_=" title="=&gt; TopicDeletionManager.this.DeleteTopicsThread">deleteTopicsThread</a>.<a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread.awaitShutdown" title="()Unit">awaitShutdown</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#kafka.controller;TopicDeletionManager.topicsToBeDeleted" title="=&gt; scala.collection.mutable.Set[String]">topicsToBeDeleted</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#kafka.controller;TopicDeletionManager.partitionsToBeDeleted" title="=&gt; scala.collection.mutable.Set[kafka.common.TopicAndPartition]">partitionsToBeDeleted</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#kafka.controller;TopicDeletionManager.topicsIneligibleForDeletion" title="=&gt; scala.collection.mutable.Set[String]">topicsIneligibleForDeletion</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Invoked by the child change listener on /admin/delete_topics to queue up the topics for deletion. The topic gets added
   * to the topicsToBeDeleted list and only gets removed from the list when the topic deletion has completed successfully
   * i.e. all replicas of all partitions of that topic are deleted successfully.
   * @param topics Topics that should be deleted
   */</span>
  def <a title="(topics: scala.collection.Set[String])Unit" id="kafka.controller;TopicDeletionManager.enqueueTopicsForDeletion">enqueueTopicsForDeletion</a><span class="delimiter">(</span><a title="scala.collection.Set[String]" id="kafka.controller;TopicDeletionManager.enqueueTopicsForDeletion.topics">topics</a>: <span title="scala.collection.Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isDeleteTopicEnabled" title="=&gt; Boolean">isDeleteTopicEnabled</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.controller;TopicDeletionManager.topicsToBeDeleted" title="=&gt; scala.collection.mutable.Set[String]">topicsToBeDeleted</a> <span title="(xs: scala.collection.TraversableOnce[String])TopicDeletionManager.this.topicsToBeDeleted.type">++=</span> <a href="#kafka.controller;TopicDeletionManager.enqueueTopicsForDeletion.topics" title="scala.collection.Set[String]">topics</a>
      <a href="#kafka.controller;TopicDeletionManager.partitionsToBeDeleted" title="=&gt; scala.collection.mutable.Set[kafka.common.TopicAndPartition]">partitionsToBeDeleted</a> <span title="(xs: scala.collection.TraversableOnce[kafka.common.TopicAndPartition])TopicDeletionManager.this.partitionsToBeDeleted.type">++=</span> <a href="#kafka.controller;TopicDeletionManager.enqueueTopicsForDeletion.topics" title="scala.collection.Set[String]">topics</a>.<span title="(f: String =&gt; scala.collection.GenTraversableOnce[kafka.common.TopicAndPartition])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.Set[String],kafka.common.TopicAndPartition,scala.collection.TraversableOnce[kafka.common.TopicAndPartition]])scala.collection.TraversableOnce[kafka.common.TopicAndPartition]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Set.Coll,kafka.common.TopicAndPartition,scala.collection.Set[kafka.common.TopicAndPartition]]" class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>.<a href="KafkaController.scala.html#kafka.controller;ControllerContext.partitionsForTopic" title="(topic: String)scala.collection.Set[kafka.common.TopicAndPartition]">partitionsForTopic</a><span class="delimiter">)</span>
      <a href="#kafka.controller;TopicDeletionManager.resumeTopicDeletionThread" title="()Unit">resumeTopicDeletionThread</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Invoked when any event that can possibly resume topic deletion occurs. These events include -
   * 1. New broker starts up. Any replicas belonging to topics queued up for deletion can be deleted since the broker is up
   * 2. Partition reassignment completes. Any partitions belonging to topics queued up for deletion finished reassignment
   * 3. Preferred replica election completes. Any partitions belonging to topics queued up for deletion finished
   *    preferred replica election
   * @param topics Topics for which deletion can be resumed
   */</span>
  def <a title="(topics: scala.collection.Set[String])Unit" id="kafka.controller;TopicDeletionManager.resumeDeletionForTopics">resumeDeletionForTopics</a><span class="delimiter">(</span><a title="scala.collection.Set[String]" id="kafka.controller;TopicDeletionManager.resumeDeletionForTopics$default$1">topics</a>: <span title="scala.collection.Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span title="scala.collection.Set.type">Set</span>.<span title="scala.collection.Set[String]">empty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isDeleteTopicEnabled" title="=&gt; Boolean">isDeleteTopicEnabled</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val topicsToResumeDeletion = <a href="#kafka.controller;TopicDeletionManager.resumeDeletionForTopics$default$1" title="scala.collection.Set[String]">topics</a> <a title="scala.collection.Set[String]" id="kafka.controller;TopicDeletionManager.resumeDeletionForTopics.topicsToResumeDeletion">&amp;</a> <a href="#kafka.controller;TopicDeletionManager.topicsToBeDeleted" title="=&gt; scala.collection.mutable.Set[String]">topicsToBeDeleted</a>
      if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.resumeDeletionForTopics.topicsToResumeDeletion" title="scala.collection.Set[String]">topicsToResumeDeletion</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#kafka.controller;TopicDeletionManager.topicsIneligibleForDeletion" title="=&gt; scala.collection.mutable.Set[String]">topicsIneligibleForDeletion</a> <span title="(xs: scala.collection.TraversableOnce[String])TopicDeletionManager.this.topicsIneligibleForDeletion.type">--=</span> <a href="#kafka.controller;TopicDeletionManager.resumeDeletionForTopics.topicsToResumeDeletion" title="scala.collection.Set[String]">topicsToResumeDeletion</a>
        <a href="#kafka.controller;TopicDeletionManager.resumeTopicDeletionThread" title="()Unit">resumeTopicDeletionThread</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Invoked when a broker that hosts replicas for topics to be deleted goes down. Also invoked when the callback for
   * StopReplicaResponse receives an error code for the replicas of a topic to be deleted. As part of this, the replicas
   * are moved from ReplicaDeletionStarted to ReplicaDeletionIneligible state. Also, the topic is added to the list of topics
   * ineligible for deletion until further notice. The delete topic thread is notified so it can retry topic deletion
   * if it has received a response for all replicas of a topic to be deleted
   * @param replicas Replicas for which deletion has failed
   */</span>
  def <a title="(replicas: scala.collection.Set[kafka.controller.PartitionAndReplica])Unit" id="kafka.controller;TopicDeletionManager.failReplicaDeletion">failReplicaDeletion</a><span class="delimiter">(</span><a title="scala.collection.Set[kafka.controller.PartitionAndReplica]" id="kafka.controller;TopicDeletionManager.failReplicaDeletion.replicas">replicas</a>: <span title="scala.collection.Set[kafka.controller.PartitionAndReplica]">Set</span><span class="delimiter">[</span>PartitionAndReplica<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isDeleteTopicEnabled" title="=&gt; Boolean">isDeleteTopicEnabled</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="scala.collection.Set[kafka.controller.PartitionAndReplica]" id="kafka.controller;TopicDeletionManager.failReplicaDeletion.replicasThatFailedToDelete">replicasThatFailedToDelete</a> = <a href="#kafka.controller;TopicDeletionManager.failReplicaDeletion.replicas" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">replicas</a>.<span title="(p: kafka.controller.PartitionAndReplica =&gt; Boolean)scala.collection.Set[kafka.controller.PartitionAndReplica]">filter</span><span class="delimiter">(</span><a title="kafka.controller.PartitionAndReplica" id="kafka.controller;TopicDeletionManager.failReplicaDeletion.replicasThatFailedToDelete.$anonfun.r">r</a> =&gt; <a href="#kafka.controller;TopicDeletionManager.isTopicQueuedUpForDeletion" title="(topic: String)Boolean">isTopicQueuedUpForDeletion</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.failReplicaDeletion.replicasThatFailedToDelete.$anonfun.r" title="kafka.controller.PartitionAndReplica">r</a>.<a href="KafkaController.scala.html#kafka.controller;PartitionAndReplica.topic" title="=&gt; String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
      if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.failReplicaDeletion.replicasThatFailedToDelete" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasThatFailedToDelete</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="scala.collection.Set[String]" id="kafka.controller;TopicDeletionManager.failReplicaDeletion.topics">topics</a> = <a href="#kafka.controller;TopicDeletionManager.failReplicaDeletion.replicasThatFailedToDelete" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasThatFailedToDelete</a>.<span title="(f: kafka.controller.PartitionAndReplica =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.Set[kafka.controller.PartitionAndReplica],String,scala.collection.Set[String]])scala.collection.Set[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Set.Coll,String,scala.collection.Set[String]]" class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.failReplicaDeletion.topics.$anonfun.x$1" title="kafka.controller.PartitionAndReplica">_</a>.<a href="KafkaController.scala.html#kafka.controller;PartitionAndReplica.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Deletion failed for replicas %s. Halting deletion for topics %s&quot;</span>
          .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.failReplicaDeletion.replicasThatFailedToDelete" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasThatFailedToDelete</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>, <a href="#kafka.controller;TopicDeletionManager.failReplicaDeletion.topics" title="scala.collection.Set[String]">topics</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>.<a href="ReplicaStateMachine.scala.html#kafka.controller;ReplicaStateMachine.handleStateChanges" title="(replicas: scala.collection.Set[kafka.controller.PartitionAndReplica], targetState: kafka.controller.ReplicaState, callbacks: kafka.controller.Callbacks)Unit">handleStateChanges</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.failReplicaDeletion.replicasThatFailedToDelete" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasThatFailedToDelete</a>, <a href="ReplicaStateMachine.scala.html#kafka.controller.ReplicaDeletionIneligible" title="kafka.controller.ReplicaDeletionIneligible.type">ReplicaDeletionIneligible</a><span class="delimiter">)</span>
        <a href="#kafka.controller;TopicDeletionManager.markTopicIneligibleForDeletion" title="(topics: scala.collection.Set[String])Unit">markTopicIneligibleForDeletion</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.failReplicaDeletion.topics" title="scala.collection.Set[String]">topics</a><span class="delimiter">)</span>
        <a href="#kafka.controller;TopicDeletionManager.resumeTopicDeletionThread" title="()Unit">resumeTopicDeletionThread</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Halt delete topic if -
   * 1. replicas being down
   * 2. partition reassignment in progress for some partitions of the topic
   * 3. preferred replica election in progress for some partitions of the topic
   * @param topics Topics that should be marked ineligible for deletion. No op if the topic is was not previously queued up for deletion
   */</span>
  def <a title="(topics: scala.collection.Set[String])Unit" id="kafka.controller;TopicDeletionManager.markTopicIneligibleForDeletion">markTopicIneligibleForDeletion</a><span class="delimiter">(</span><a title="scala.collection.Set[String]" id="kafka.controller;TopicDeletionManager.markTopicIneligibleForDeletion.topics">topics</a>: <span title="scala.collection.Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isDeleteTopicEnabled" title="=&gt; Boolean">isDeleteTopicEnabled</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val newTopicsToHaltDeletion = <a href="#kafka.controller;TopicDeletionManager.topicsToBeDeleted" title="=&gt; scala.collection.mutable.Set[String]">topicsToBeDeleted</a> <a title="scala.collection.mutable.Set[String]" id="kafka.controller;TopicDeletionManager.markTopicIneligibleForDeletion.newTopicsToHaltDeletion">&amp;</a> <a href="#kafka.controller;TopicDeletionManager.markTopicIneligibleForDeletion.topics" title="scala.collection.Set[String]">topics</a>
      <a href="#kafka.controller;TopicDeletionManager.topicsIneligibleForDeletion" title="=&gt; scala.collection.mutable.Set[String]">topicsIneligibleForDeletion</a> <span title="(xs: scala.collection.TraversableOnce[String])TopicDeletionManager.this.topicsIneligibleForDeletion.type">++=</span> <a href="#kafka.controller;TopicDeletionManager.markTopicIneligibleForDeletion.newTopicsToHaltDeletion" title="scala.collection.mutable.Set[String]">newTopicsToHaltDeletion</a>
      if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.markTopicIneligibleForDeletion.newTopicsToHaltDeletion" title="scala.collection.mutable.Set[String]">newTopicsToHaltDeletion</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Halted deletion of topics %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.markTopicIneligibleForDeletion.newTopicsToHaltDeletion" title="scala.collection.mutable.Set[String]">newTopicsToHaltDeletion</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(topic: String)Boolean" id="kafka.controller;TopicDeletionManager.isTopicIneligibleForDeletion">isTopicIneligibleForDeletion</a><span class="delimiter">(</span><a title="String" id="kafka.controller;TopicDeletionManager.isTopicIneligibleForDeletion.topic">topic</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isDeleteTopicEnabled" title="=&gt; Boolean">isDeleteTopicEnabled</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.controller;TopicDeletionManager.topicsIneligibleForDeletion" title="=&gt; scala.collection.mutable.Set[String]">topicsIneligibleForDeletion</a>.<span title="(elem: String)Boolean">contains</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isTopicIneligibleForDeletion.topic" title="String">topic</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else
      true
  <span class="delimiter">}</span>

  def <a title="(topic: String)Boolean" id="kafka.controller;TopicDeletionManager.isTopicDeletionInProgress">isTopicDeletionInProgress</a><span class="delimiter">(</span><a title="String" id="kafka.controller;TopicDeletionManager.isTopicDeletionInProgress.topic">topic</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isDeleteTopicEnabled" title="=&gt; Boolean">isDeleteTopicEnabled</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>.<a href="ReplicaStateMachine.scala.html#kafka.controller;ReplicaStateMachine.isAtLeastOneReplicaInDeletionStartedState" title="(topic: String)Boolean">isAtLeastOneReplicaInDeletionStartedState</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isTopicDeletionInProgress.topic" title="String">topic</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else
      false
  <span class="delimiter">}</span>

  def <a title="(topicAndPartition: kafka.common.TopicAndPartition)Boolean" id="kafka.controller;TopicDeletionManager.isPartitionToBeDeleted">isPartitionToBeDeleted</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.controller;TopicDeletionManager.isPartitionToBeDeleted.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isDeleteTopicEnabled" title="=&gt; Boolean">isDeleteTopicEnabled</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.controller;TopicDeletionManager.partitionsToBeDeleted" title="=&gt; scala.collection.mutable.Set[kafka.common.TopicAndPartition]">partitionsToBeDeleted</a>.<span title="(elem: kafka.common.TopicAndPartition)Boolean">contains</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isPartitionToBeDeleted.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else
      false
  <span class="delimiter">}</span>

  def <a title="(topic: String)Boolean" id="kafka.controller;TopicDeletionManager.isTopicQueuedUpForDeletion">isTopicQueuedUpForDeletion</a><span class="delimiter">(</span><a title="String" id="kafka.controller;TopicDeletionManager.isTopicQueuedUpForDeletion.topic">topic</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isDeleteTopicEnabled" title="=&gt; Boolean">isDeleteTopicEnabled</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.controller;TopicDeletionManager.topicsToBeDeleted" title="=&gt; scala.collection.mutable.Set[String]">topicsToBeDeleted</a>.<span title="(elem: String)Boolean">contains</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isTopicQueuedUpForDeletion.topic" title="String">topic</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else
      false
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Invoked by the delete-topic-thread to wait until events that either trigger, restart or halt topic deletion occur.
   * controllerLock should be acquired before invoking this API
   */</span>
  private def <a title="()Unit" id="kafka.controller;TopicDeletionManager.awaitTopicDeletionNotification">awaitTopicDeletionNotification</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Utils.scala.html#kafka.utils.Utils.inLock" title="(lock: java.util.concurrent.locks.Lock)(fun: =&gt; Unit)Unit">inLock</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.deleteLock" title="=&gt; java.util.concurrent.locks.ReentrantLock">deleteLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      while<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.deleteTopicsThread_=" title="=&gt; TopicDeletionManager.this.DeleteTopicsThread">deleteTopicsThread</a>.<a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread.isRunning" title="=&gt; java.util.concurrent.atomic.AtomicBoolean">isRunning</a>.<span title="()Boolean">get</span><span class="delimiter">(</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#kafka.controller;TopicDeletionManager.deleteTopicStateChanged" title="=&gt; java.util.concurrent.atomic.AtomicBoolean">deleteTopicStateChanged</a>.<span title="(x$1: Boolean, x$2: Boolean)Boolean">compareAndSet</span><span class="delimiter">(</span>true, false<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#kafka.controller;TopicDeletionManager.awaitTopicDeletionNotification.while$1" title="()Unit" class="delimiter">{</a>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Waiting for signal to start or continue topic deletion&quot;)" class="string">&quot;Waiting for signal to start or continue topic deletion&quot;</span><span class="delimiter">)</span>
        <a href="#kafka.controller;TopicDeletionManager.deleteTopicsCond" title="=&gt; java.util.concurrent.locks.Condition">deleteTopicsCond</a>.<span title="()Unit">await</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Signals the delete-topic-thread to process topic deletion
   */</span>
  private def <a title="()Unit" id="kafka.controller;TopicDeletionManager.resumeTopicDeletionThread">resumeTopicDeletionThread</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.controller;TopicDeletionManager.deleteTopicStateChanged" title="=&gt; java.util.concurrent.atomic.AtomicBoolean">deleteTopicStateChanged</a>.<span title="(x$1: Boolean)Unit">set</span><span class="delimiter">(</span>true<span class="delimiter">)</span>
    <a href="../utils/Utils.scala.html#kafka.utils.Utils.inLock" title="(lock: java.util.concurrent.locks.Lock)(fun: =&gt; Unit)Unit">inLock</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.deleteLock" title="=&gt; java.util.concurrent.locks.ReentrantLock">deleteLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.controller;TopicDeletionManager.deleteTopicsCond" title="=&gt; java.util.concurrent.locks.Condition">deleteTopicsCond</a>.<span title="()Unit">signal</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Invoked by the StopReplicaResponse callback when it receives no error code for a replica of a topic to be deleted.
   * As part of this, the replicas are moved from ReplicaDeletionStarted to ReplicaDeletionSuccessful state. The delete
   * topic thread is notified so it can tear down the topic if all replicas of a topic have been successfully deleted
   * @param replicas Replicas that were successfully deleted by the broker
   */</span>
  private def <a title="(replicas: scala.collection.Set[kafka.controller.PartitionAndReplica])Unit" id="kafka.controller;TopicDeletionManager.completeReplicaDeletion">completeReplicaDeletion</a><span class="delimiter">(</span><a title="scala.collection.Set[kafka.controller.PartitionAndReplica]" id="kafka.controller;TopicDeletionManager.completeReplicaDeletion.replicas">replicas</a>: <span title="scala.collection.Set[kafka.controller.PartitionAndReplica]">Set</span><span class="delimiter">[</span>PartitionAndReplica<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="scala.collection.Set[kafka.controller.PartitionAndReplica]" id="kafka.controller;TopicDeletionManager.completeReplicaDeletion.successfullyDeletedReplicas">successfullyDeletedReplicas</a> = <a href="#kafka.controller;TopicDeletionManager.completeReplicaDeletion.replicas" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">replicas</a>.<span title="(p: kafka.controller.PartitionAndReplica =&gt; Boolean)scala.collection.Set[kafka.controller.PartitionAndReplica]">filter</span><span class="delimiter">(</span><a title="kafka.controller.PartitionAndReplica" id="kafka.controller;TopicDeletionManager.completeReplicaDeletion.successfullyDeletedReplicas.$anonfun.r">r</a> =&gt; <a href="#kafka.controller;TopicDeletionManager.isTopicQueuedUpForDeletion" title="(topic: String)Boolean">isTopicQueuedUpForDeletion</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.completeReplicaDeletion.successfullyDeletedReplicas.$anonfun.r" title="kafka.controller.PartitionAndReplica">r</a>.<a href="KafkaController.scala.html#kafka.controller;PartitionAndReplica.topic" title="=&gt; String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Deletion successfully completed for replicas %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.completeReplicaDeletion.successfullyDeletedReplicas" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">successfullyDeletedReplicas</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>.<a href="ReplicaStateMachine.scala.html#kafka.controller;ReplicaStateMachine.handleStateChanges" title="(replicas: scala.collection.Set[kafka.controller.PartitionAndReplica], targetState: kafka.controller.ReplicaState, callbacks: kafka.controller.Callbacks)Unit">handleStateChanges</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.completeReplicaDeletion.successfullyDeletedReplicas" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">successfullyDeletedReplicas</a>, <a href="ReplicaStateMachine.scala.html#kafka.controller.ReplicaDeletionSuccessful" title="kafka.controller.ReplicaDeletionSuccessful.type">ReplicaDeletionSuccessful</a><span class="delimiter">)</span>
    <a href="#kafka.controller;TopicDeletionManager.resumeTopicDeletionThread" title="()Unit">resumeTopicDeletionThread</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Topic deletion can be retried if -
   * 1. Topic deletion is not already complete
   * 2. Topic deletion is currently not in progress for that topic
   * 3. Topic is currently marked ineligible for deletion
   * @param topic Topic
   * @return Whether or not deletion can be retried for the topic
   */</span>
  private def <a title="(topic: String)Boolean" id="kafka.controller;TopicDeletionManager.isTopicEligibleForDeletion">isTopicEligibleForDeletion</a><span class="delimiter">(</span><a title="String" id="kafka.controller;TopicDeletionManager.isTopicEligibleForDeletion.topic">topic</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <a href="#kafka.controller;TopicDeletionManager.topicsToBeDeleted" title="=&gt; scala.collection.mutable.Set[String]">topicsToBeDeleted</a>.<span title="(elem: String)Boolean">contains</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isTopicEligibleForDeletion.topic" title="String">topic</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.controller;TopicDeletionManager.isTopicDeletionInProgress" title="(topic: String)Boolean">isTopicDeletionInProgress</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isTopicEligibleForDeletion.topic" title="String">topic</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#kafka.controller;TopicDeletionManager.isTopicIneligibleForDeletion" title="(topic: String)Boolean">isTopicIneligibleForDeletion</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isTopicEligibleForDeletion.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * If the topic is queued for deletion but deletion is not currently under progress, then deletion is retried for that topic
   * To ensure a successful retry, reset states for respective replicas from ReplicaDeletionIneligible to OfflineReplica state
   *@param topic Topic for which deletion should be retried
   */</span>
  private def <a title="(topic: String)Unit" id="kafka.controller;TopicDeletionManager.markTopicForDeletionRetry">markTopicForDeletionRetry</a><span class="delimiter">(</span><a title="String" id="kafka.controller;TopicDeletionManager.markTopicForDeletionRetry.topic">topic</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">// reset replica states from ReplicaDeletionIneligible to OfflineReplica</span>
    val <a title="scala.collection.Set[kafka.controller.PartitionAndReplica]" id="kafka.controller;TopicDeletionManager.markTopicForDeletionRetry.failedReplicas">failedReplicas</a> = <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>.<a href="ReplicaStateMachine.scala.html#kafka.controller;ReplicaStateMachine.replicasInState" title="(topic: String, state: kafka.controller.ReplicaState)scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasInState</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.markTopicForDeletionRetry.topic" title="String">topic</a>, <a href="ReplicaStateMachine.scala.html#kafka.controller.ReplicaDeletionIneligible" title="kafka.controller.ReplicaDeletionIneligible.type">ReplicaDeletionIneligible</a><span class="delimiter">)</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Retrying delete topic for topic %s since replicas %s were not successfully deleted&quot;</span>
      .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.markTopicForDeletionRetry.topic" title="String">topic</a>, <a href="#kafka.controller;TopicDeletionManager.markTopicForDeletionRetry.failedReplicas" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">failedReplicas</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>.<a href="ReplicaStateMachine.scala.html#kafka.controller;ReplicaStateMachine.handleStateChanges" title="(replicas: scala.collection.Set[kafka.controller.PartitionAndReplica], targetState: kafka.controller.ReplicaState, callbacks: kafka.controller.Callbacks)Unit">handleStateChanges</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.markTopicForDeletionRetry.failedReplicas" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">failedReplicas</a>, <a href="ReplicaStateMachine.scala.html#kafka.controller.OfflineReplica" title="kafka.controller.OfflineReplica.type">OfflineReplica</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private def <a title="(topic: String)Unit" id="kafka.controller;TopicDeletionManager.completeDeleteTopic">completeDeleteTopic</a><span class="delimiter">(</span><a title="String" id="kafka.controller;TopicDeletionManager.completeDeleteTopic.topic">topic</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">// deregister partition change listener on the deleted topic. This is to prevent the partition change listener</span>
    <span class="comment">// firing before the new topic listener when a deleted topic gets auto created</span>
    <a href="#kafka.controller;TopicDeletionManager.partitionStateMachine" title="=&gt; kafka.controller.PartitionStateMachine">partitionStateMachine</a>.<a href="PartitionStateMachine.scala.html#kafka.controller;PartitionStateMachine.deregisterPartitionChangeListener" title="(topic: String)Option[TopicDeletionManager.this.partitionStateMachine.AddPartitionsListener]">deregisterPartitionChangeListener</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.completeDeleteTopic.topic" title="String">topic</a><span class="delimiter">)</span>
    val <a title="scala.collection.Set[kafka.controller.PartitionAndReplica]" id="kafka.controller;TopicDeletionManager.completeDeleteTopic.replicasForDeletedTopic">replicasForDeletedTopic</a> = <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>.<a href="ReplicaStateMachine.scala.html#kafka.controller;ReplicaStateMachine.replicasInState" title="(topic: String, state: kafka.controller.ReplicaState)scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasInState</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.completeDeleteTopic.topic" title="String">topic</a>, <a href="ReplicaStateMachine.scala.html#kafka.controller.ReplicaDeletionSuccessful" title="kafka.controller.ReplicaDeletionSuccessful.type">ReplicaDeletionSuccessful</a><span class="delimiter">)</span>
    <span class="comment">// controller will remove this replica from the state machine as well as its partition assignment cache</span>
    <a href="#kafka.controller;TopicDeletionManager.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>.<a href="ReplicaStateMachine.scala.html#kafka.controller;ReplicaStateMachine.handleStateChanges" title="(replicas: scala.collection.Set[kafka.controller.PartitionAndReplica], targetState: kafka.controller.ReplicaState, callbacks: kafka.controller.Callbacks)Unit">handleStateChanges</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.completeDeleteTopic.replicasForDeletedTopic" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasForDeletedTopic</a>, <a href="ReplicaStateMachine.scala.html#kafka.controller.NonExistentReplica" title="kafka.controller.NonExistentReplica.type">NonExistentReplica</a><span class="delimiter">)</span>
    val <a title="scala.collection.Set[kafka.common.TopicAndPartition]" id="kafka.controller;TopicDeletionManager.completeDeleteTopic.partitionsForDeletedTopic">partitionsForDeletedTopic</a> = <a href="#kafka.controller;TopicDeletionManager.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>.<a href="KafkaController.scala.html#kafka.controller;ControllerContext.partitionsForTopic" title="(topic: String)scala.collection.Set[kafka.common.TopicAndPartition]">partitionsForTopic</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.completeDeleteTopic.topic" title="String">topic</a><span class="delimiter">)</span>
    <span class="comment">// move respective partition to OfflinePartition and NonExistentPartition state</span>
    <a href="#kafka.controller;TopicDeletionManager.partitionStateMachine" title="=&gt; kafka.controller.PartitionStateMachine">partitionStateMachine</a>.<a href="PartitionStateMachine.scala.html#kafka.controller;PartitionStateMachine.handleStateChanges" title="(partitions: scala.collection.Set[kafka.common.TopicAndPartition], targetState: kafka.controller.PartitionState, leaderSelector: kafka.controller.PartitionLeaderSelector, callbacks: kafka.controller.Callbacks)Unit">handleStateChanges</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.completeDeleteTopic.partitionsForDeletedTopic" title="scala.collection.Set[kafka.common.TopicAndPartition]">partitionsForDeletedTopic</a>, <a href="PartitionStateMachine.scala.html#kafka.controller.OfflinePartition" title="kafka.controller.OfflinePartition.type">OfflinePartition</a><span class="delimiter">)</span>
    <a href="#kafka.controller;TopicDeletionManager.partitionStateMachine" title="=&gt; kafka.controller.PartitionStateMachine">partitionStateMachine</a>.<a href="PartitionStateMachine.scala.html#kafka.controller;PartitionStateMachine.handleStateChanges" title="(partitions: scala.collection.Set[kafka.common.TopicAndPartition], targetState: kafka.controller.PartitionState, leaderSelector: kafka.controller.PartitionLeaderSelector, callbacks: kafka.controller.Callbacks)Unit">handleStateChanges</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.completeDeleteTopic.partitionsForDeletedTopic" title="scala.collection.Set[kafka.common.TopicAndPartition]">partitionsForDeletedTopic</a>, <a href="PartitionStateMachine.scala.html#kafka.controller.NonExistentPartition" title="kafka.controller.NonExistentPartition.type">NonExistentPartition</a><span class="delimiter">)</span>
    <a href="#kafka.controller;TopicDeletionManager.topicsToBeDeleted" title="=&gt; scala.collection.mutable.Set[String]">topicsToBeDeleted</a> <span title="(elem: String)TopicDeletionManager.this.topicsToBeDeleted.type">-=</span> <a href="#kafka.controller;TopicDeletionManager.completeDeleteTopic.topic" title="String">topic</a>
    <a href="#kafka.controller;TopicDeletionManager.partitionsToBeDeleted" title="=&gt; scala.collection.mutable.Set[kafka.common.TopicAndPartition]">partitionsToBeDeleted</a>.<span title="(p: kafka.common.TopicAndPartition =&gt; Boolean)Unit">retain</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.completeDeleteTopic.$anonfun.x$2" title="kafka.common.TopicAndPartition">_</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#kafka.controller;TopicDeletionManager.completeDeleteTopic.topic" title="String">topic</a><span class="delimiter">)</span>
    <a href="#kafka.controller;TopicDeletionManager.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>.<a href="KafkaController.scala.html#kafka.controller;ControllerContext.zkClient" title="=&gt; org.I0Itec.zkclient.ZkClient">zkClient</a>.<span title="(x$1: String)Boolean">deleteRecursive</span><span class="delimiter">(</span><a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.getTopicPath" title="(topic: String)String">getTopicPath</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.completeDeleteTopic.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.controller;TopicDeletionManager.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>.<a href="KafkaController.scala.html#kafka.controller;ControllerContext.zkClient" title="=&gt; org.I0Itec.zkclient.ZkClient">zkClient</a>.<span title="(x$1: String)Boolean">deleteRecursive</span><span class="delimiter">(</span><a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.getTopicConfigPath" title="(topic: String)String">getTopicConfigPath</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.completeDeleteTopic.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.controller;TopicDeletionManager.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>.<a href="KafkaController.scala.html#kafka.controller;ControllerContext.zkClient" title="=&gt; org.I0Itec.zkclient.ZkClient">zkClient</a>.<span title="(x$1: String)Boolean">delete</span><span class="delimiter">(</span><a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.getDeleteTopicPath" title="(topic: String)String">getDeleteTopicPath</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.completeDeleteTopic.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.controller;TopicDeletionManager.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>.<a href="KafkaController.scala.html#kafka.controller;ControllerContext.removeTopic" title="(topic: String)Unit">removeTopic</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.completeDeleteTopic.topic" title="String">topic</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This callback is invoked by the DeleteTopics thread with the list of topics to be deleted
   * It invokes the delete partition callback for all partitions of a topic.
   * The updateMetadataRequest is also going to set the leader for the topics being deleted to
   * {@link LeaderAndIsr#LeaderDuringDelete}. This lets each broker know that this topic is being deleted and can be
   * removed from their caches.
   */</span>
  private def <a title="(topics: scala.collection.Set[String])Unit" id="kafka.controller;TopicDeletionManager.onTopicDeletion">onTopicDeletion</a><span class="delimiter">(</span><a title="scala.collection.Set[String]" id="kafka.controller;TopicDeletionManager.onTopicDeletion.topics">topics</a>: <span title="scala.collection.Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Topic deletion callback for %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.onTopicDeletion.topics" title="scala.collection.Set[String]">topics</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="comment">// send update metadata so that brokers stop serving data for topics to be deleted</span>
    val <a title="scala.collection.Set[kafka.common.TopicAndPartition]" id="kafka.controller;TopicDeletionManager.onTopicDeletion.partitions">partitions</a> = <a href="#kafka.controller;TopicDeletionManager.onTopicDeletion.topics" title="scala.collection.Set[String]">topics</a>.<span title="(f: String =&gt; scala.collection.GenTraversableOnce[kafka.common.TopicAndPartition])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.Set[String],kafka.common.TopicAndPartition,scala.collection.Set[kafka.common.TopicAndPartition]])scala.collection.Set[kafka.common.TopicAndPartition]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Set.Coll,kafka.common.TopicAndPartition,scala.collection.Set[kafka.common.TopicAndPartition]]" class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>.<a href="KafkaController.scala.html#kafka.controller;ControllerContext.partitionsForTopic" title="(topic: String)scala.collection.Set[kafka.common.TopicAndPartition]">partitionsForTopic</a><span class="delimiter">)</span>
    <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.sendUpdateMetadataRequest" title="(brokers: Seq[Int], partitions: scala.collection.Set[kafka.common.TopicAndPartition])Unit">sendUpdateMetadataRequest</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>.<a href="KafkaController.scala.html#kafka.controller;ControllerContext.liveOrShuttingDownBrokerIds" title="=&gt; scala.collection.Set[Int]">liveOrShuttingDownBrokerIds</a>.<span title="=&gt; Seq[Int]">toSeq</span>, <a href="#kafka.controller;TopicDeletionManager.onTopicDeletion.partitions" title="scala.collection.Set[kafka.common.TopicAndPartition]">partitions</a><span class="delimiter">)</span>
    val <a title="scala.collection.immutable.Map[String,scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[Int]]]" id="kafka.controller;TopicDeletionManager.onTopicDeletion.partitionReplicaAssignmentByTopic">partitionReplicaAssignmentByTopic</a> = <a href="#kafka.controller;TopicDeletionManager.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>.<a href="KafkaController.scala.html#kafka.controller;ControllerContext.partitionReplicaAssignment" title="=&gt; scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[Int]]">partitionReplicaAssignment</a>.<span title="(f: ((kafka.common.TopicAndPartition, Seq[Int])) =&gt; String)scala.collection.immutable.Map[String,scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[Int]]]">groupBy</span><span class="delimiter">(</span><a title="(kafka.common.TopicAndPartition, Seq[Int])" id="kafka.controller;TopicDeletionManager.onTopicDeletion.partitionReplicaAssignmentByTopic.$anonfun.p">p</a> =&gt; <a href="#kafka.controller;TopicDeletionManager.onTopicDeletion.partitionReplicaAssignmentByTopic.$anonfun.p" title="(kafka.common.TopicAndPartition, Seq[Int])">p</a>.<span title="=&gt; kafka.common.TopicAndPartition">_1</span>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>
    <a href="#kafka.controller;TopicDeletionManager.onTopicDeletion.topics" title="scala.collection.Set[String]">topics</a>.<span title="(f: String =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="String" id="kafka.controller;TopicDeletionManager.onTopicDeletion.$anonfun.topic">topic</a> =&gt;
      <a href="#kafka.controller;TopicDeletionManager.onPartitionDeletion" title="(partitionsToBeDeleted: scala.collection.Set[kafka.common.TopicAndPartition])Unit">onPartitionDeletion</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.onTopicDeletion.partitionReplicaAssignmentByTopic" title="(key: String)scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[Int]]">partitionReplicaAssignmentByTopic</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.onTopicDeletion.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span>.<span title="(f: ((kafka.common.TopicAndPartition, Seq[Int])) =&gt; kafka.common.TopicAndPartition)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.Map[kafka.common.TopicAndPartition,Seq[Int]],kafka.common.TopicAndPartition,scala.collection.mutable.Iterable[kafka.common.TopicAndPartition]])scala.collection.mutable.Iterable[kafka.common.TopicAndPartition]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.mutable.Iterable.Coll,kafka.common.TopicAndPartition,scala.collection.mutable.Iterable[kafka.common.TopicAndPartition]]" class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.onTopicDeletion.$anonfun.$anonfun.x$3" title="(kafka.common.TopicAndPartition, Seq[Int])">_</a>.<span title="=&gt; kafka.common.TopicAndPartition">_1</span><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[kafka.common.TopicAndPartition]">toSet</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Invoked by the onPartitionDeletion callback. It is the 2nd step of topic deletion, the first being sending
   * UpdateMetadata requests to all brokers to start rejecting requests for deleted topics. As part of starting deletion,
   * the topics are added to the in progress list. As long as a topic is in the in progress list, deletion for that topic
   * is never retried. A topic is removed from the in progress list when
   * 1. Either the topic is successfully deleted OR
   * 2. No replica for the topic is in ReplicaDeletionStarted state and at least one replica is in ReplicaDeletionIneligible state
   * If the topic is queued for deletion but deletion is not currently under progress, then deletion is retried for that topic
   * As part of starting deletion, all replicas are moved to the ReplicaDeletionStarted state where the controller sends
   * the replicas a StopReplicaRequest (delete=true)
   * This callback does the following things -
   * 1. Move all dead replicas directly to ReplicaDeletionIneligible state. Also mark the respective topics ineligible
   *    for deletion if some replicas are dead since it won't complete successfully anyway
   * 2. Move all alive replicas to ReplicaDeletionStarted state so they can be deleted successfully
   *@param replicasForTopicsToBeDeleted
   */</span>
  private def <a title="(replicasForTopicsToBeDeleted: scala.collection.Set[kafka.controller.PartitionAndReplica])Unit" id="kafka.controller;TopicDeletionManager.startReplicaDeletion">startReplicaDeletion</a><span class="delimiter">(</span><a title="scala.collection.Set[kafka.controller.PartitionAndReplica]" id="kafka.controller;TopicDeletionManager.startReplicaDeletion.replicasForTopicsToBeDeleted">replicasForTopicsToBeDeleted</a>: <span title="scala.collection.Set[kafka.controller.PartitionAndReplica]">Set</span><span class="delimiter">[</span>PartitionAndReplica<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.replicasForTopicsToBeDeleted" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasForTopicsToBeDeleted</a>.<span title="(f: kafka.controller.PartitionAndReplica =&gt; String)scala.collection.immutable.Map[String,scala.collection.Set[kafka.controller.PartitionAndReplica]]">groupBy</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.x$4" title="kafka.controller.PartitionAndReplica">_</a>.<a href="KafkaController.scala.html#kafka.controller;PartitionAndReplica.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>.<span title="(f: ((String, scala.collection.Set[kafka.controller.PartitionAndReplica])) =&gt; Unit)Unit">foreach</span> <a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.x0$1" title="Unit" class="delimiter">{</a> case<span class="delimiter">(</span><a title="String" id="kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.topic">topic</a>, <a title="scala.collection.Set[kafka.controller.PartitionAndReplica]" id="kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.replicas">replicas</a><span class="delimiter">)</span> =&gt;
      var <a title="scala.collection.Set[kafka.controller.PartitionAndReplica]" id="kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.aliveReplicasForTopic">aliveReplicasForTopic</a> = <a href="#kafka.controller;TopicDeletionManager.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>.<a href="KafkaController.scala.html#kafka.controller;ControllerContext.allLiveReplicas" title="()scala.collection.Set[kafka.controller.PartitionAndReplica]">allLiveReplicas</a><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="(p: kafka.controller.PartitionAndReplica =&gt; Boolean)scala.collection.Set[kafka.controller.PartitionAndReplica]">filter</span><span class="delimiter">(</span><a title="kafka.controller.PartitionAndReplica" id="kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.aliveReplicasForTopic.$anonfun.p">p</a> =&gt; <a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.aliveReplicasForTopic.$anonfun.p" title="kafka.controller.PartitionAndReplica">p</a>.<a href="KafkaController.scala.html#kafka.controller;PartitionAndReplica.topic" title="=&gt; String">topic</a>.<span title="(x$1: Any)Boolean">equals</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
      val deadReplicasForTopic = <a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.replicasForTopicsToBeDeleted" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasForTopicsToBeDeleted</a> <a title="scala.collection.Set[kafka.controller.PartitionAndReplica]" id="kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.deadReplicasForTopic">--</a> <a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.aliveReplicasForTopic" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">aliveReplicasForTopic</a>
      val <a title="scala.collection.Set[kafka.controller.PartitionAndReplica]" id="kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.successfullyDeletedReplicas">successfullyDeletedReplicas</a> = <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>.<a href="ReplicaStateMachine.scala.html#kafka.controller;ReplicaStateMachine.replicasInState" title="(topic: String, state: kafka.controller.ReplicaState)scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasInState</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.topic" title="String">topic</a>, <a href="ReplicaStateMachine.scala.html#kafka.controller.ReplicaDeletionSuccessful" title="kafka.controller.ReplicaDeletionSuccessful.type">ReplicaDeletionSuccessful</a><span class="delimiter">)</span>
      val replicasForDeletionRetry = <a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.aliveReplicasForTopic" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">aliveReplicasForTopic</a> <a title="scala.collection.Set[kafka.controller.PartitionAndReplica]" id="kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.replicasForDeletionRetry">--</a> <a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.successfullyDeletedReplicas" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">successfullyDeletedReplicas</a>
      <span class="comment">// move dead replicas directly to failed state</span>
      <a href="#kafka.controller;TopicDeletionManager.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>.<a href="ReplicaStateMachine.scala.html#kafka.controller;ReplicaStateMachine.handleStateChanges" title="(replicas: scala.collection.Set[kafka.controller.PartitionAndReplica], targetState: kafka.controller.ReplicaState, callbacks: kafka.controller.Callbacks)Unit">handleStateChanges</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.deadReplicasForTopic" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">deadReplicasForTopic</a>, <a href="ReplicaStateMachine.scala.html#kafka.controller.ReplicaDeletionIneligible" title="kafka.controller.ReplicaDeletionIneligible.type">ReplicaDeletionIneligible</a><span class="delimiter">)</span>
      <span class="comment">// send stop replica to all followers that are not in the OfflineReplica state so they stop sending fetch requests to the leader</span>
      <a href="#kafka.controller;TopicDeletionManager.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>.<a href="ReplicaStateMachine.scala.html#kafka.controller;ReplicaStateMachine.handleStateChanges" title="(replicas: scala.collection.Set[kafka.controller.PartitionAndReplica], targetState: kafka.controller.ReplicaState, callbacks: kafka.controller.Callbacks)Unit">handleStateChanges</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.replicasForDeletionRetry" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasForDeletionRetry</a>, <a href="ReplicaStateMachine.scala.html#kafka.controller.OfflineReplica" title="kafka.controller.OfflineReplica.type">OfflineReplica</a><span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Deletion started for replicas %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.replicasForDeletionRetry" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasForDeletionRetry</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>.<a href="ReplicaStateMachine.scala.html#kafka.controller;ReplicaStateMachine.handleStateChanges" title="(replicas: scala.collection.Set[kafka.controller.PartitionAndReplica], targetState: kafka.controller.ReplicaState, callbacks: kafka.controller.Callbacks)Unit">handleStateChanges</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.replicasForDeletionRetry" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasForDeletionRetry</a>, <a href="ReplicaStateMachine.scala.html#kafka.controller.ReplicaDeletionStarted" title="kafka.controller.ReplicaDeletionStarted.type">ReplicaDeletionStarted</a>,
        new <a href="ControllerChannelManager.scala.html#kafka.controller.Callbacks" title="kafka.controller.Callbacks.type">Callbacks</a>.<a href="ControllerChannelManager.scala.html#kafka.controller.Callbacks;CallbackBuilder" title="kafka.controller.Callbacks.CallbackBuilder">CallbackBuilder</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="ControllerChannelManager.scala.html#kafka.controller.Callbacks;CallbackBuilder.stopReplicaCallback" title="(cbk: (kafka.api.RequestOrResponse, Int) =&gt; Unit)kafka.controller.Callbacks.CallbackBuilder">stopReplicaCallback</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback" title="(stopReplicaResponseObj: kafka.api.RequestOrResponse, replicaId: Int)Unit">deleteTopicStopReplicaCallback</a><span class="delimiter">)</span>.<a href="ControllerChannelManager.scala.html#kafka.controller.Callbacks;CallbackBuilder.build" title="=&gt; kafka.controller.Callbacks">build</a><span class="delimiter">)</span>
      if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.deadReplicasForTopic" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">deadReplicasForTopic</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Dead Replicas (%s) found for topic %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.deadReplicasForTopic" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">deadReplicasForTopic</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>, <a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#kafka.controller;TopicDeletionManager.markTopicIneligibleForDeletion" title="(topics: scala.collection.Set[String])Unit">markTopicIneligibleForDeletion</a><span class="delimiter">(</span><span title="(elems: String*)scala.collection.Set[String]">Set</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This callback is invoked by the delete topic callback with the list of partitions for topics to be deleted
   * It does the following -
   * 1. Send UpdateMetadataRequest to all live brokers (that are not shutting down) for partitions that are being
   *    deleted. The brokers start rejecting all client requests with UnknownTopicOrPartitionException
   * 2. Move all replicas for the partitions to OfflineReplica state. This will send StopReplicaRequest to the replicas
   *    and LeaderAndIsrRequest to the leader with the shrunk ISR. When the leader replica itself is moved to OfflineReplica state,
   *    it will skip sending the LeaderAndIsrRequest since the leader will be updated to -1
   * 3. Move all replicas to ReplicaDeletionStarted state. This will send StopReplicaRequest with deletePartition=true. And
   *    will delete all persistent data from all replicas of the respective partitions
   */</span>
  private def <a title="(partitionsToBeDeleted: scala.collection.Set[kafka.common.TopicAndPartition])Unit" id="kafka.controller;TopicDeletionManager.onPartitionDeletion">onPartitionDeletion</a><span class="delimiter">(</span><a title="scala.collection.Set[kafka.common.TopicAndPartition]" id="kafka.controller;TopicDeletionManager.onPartitionDeletion.partitionsToBeDeleted">partitionsToBeDeleted</a>: <span title="scala.collection.Set[kafka.common.TopicAndPartition]">Set</span><span class="delimiter">[</span>TopicAndPartition<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Partition deletion callback for %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.onPartitionDeletion.partitionsToBeDeleted" title="scala.collection.Set[kafka.common.TopicAndPartition]">partitionsToBeDeleted</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    val <a title="scala.collection.Set[kafka.controller.PartitionAndReplica]" id="kafka.controller;TopicDeletionManager.onPartitionDeletion.replicasPerPartition">replicasPerPartition</a> = <a href="#kafka.controller;TopicDeletionManager.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>.<a href="KafkaController.scala.html#kafka.controller;ControllerContext.replicasForPartition" title="(partitions: scala.collection.Set[kafka.common.TopicAndPartition])scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasForPartition</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.onPartitionDeletion.partitionsToBeDeleted" title="scala.collection.Set[kafka.common.TopicAndPartition]">partitionsToBeDeleted</a><span class="delimiter">)</span>
    <a href="#kafka.controller;TopicDeletionManager.startReplicaDeletion" title="(replicasForTopicsToBeDeleted: scala.collection.Set[kafka.controller.PartitionAndReplica])Unit">startReplicaDeletion</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.onPartitionDeletion.replicasPerPartition" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasPerPartition</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private def <a title="(stopReplicaResponseObj: kafka.api.RequestOrResponse, replicaId: Int)Unit" id="kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback">deleteTopicStopReplicaCallback</a><span class="delimiter">(</span><a title="kafka.api.RequestOrResponse" id="kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.stopReplicaResponseObj">stopReplicaResponseObj</a>: <a href="../api/RequestOrResponse.scala.html#kafka.api;RequestOrResponse" title="kafka.api.RequestOrResponse">RequestOrResponse</a>, <a title="Int" id="kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.replicaId">replicaId</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="kafka.api.StopReplicaResponse" id="kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.stopReplicaResponse">stopReplicaResponse</a> = <a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.stopReplicaResponseObj" title="kafka.api.RequestOrResponse">stopReplicaResponseObj</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.api.StopReplicaResponse" class="delimiter">[</span><a href="../api/StopReplicaResponse.scala.html#kafka.api;StopReplicaResponse" title="kafka.api.StopReplicaResponse">StopReplicaResponse</a><span class="delimiter">]</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Delete topic callback invoked for %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.stopReplicaResponse" title="kafka.api.StopReplicaResponse">stopReplicaResponse</a><span class="delimiter">)</span><span class="delimiter">)</span>
    val <a title="scala.collection.immutable.Set[kafka.common.TopicAndPartition]" id="kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.partitionsInError">partitionsInError</a> = if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.stopReplicaResponse" title="kafka.api.StopReplicaResponse">stopReplicaResponse</a>.<a href="../api/StopReplicaResponse.scala.html#kafka.api;StopReplicaResponse.errorCode" title="=&gt; Short">errorCode</a> <span title="(x: Short)Boolean">!=</span> <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.stopReplicaResponse" title="kafka.api.StopReplicaResponse">stopReplicaResponse</a>.<a href="../api/StopReplicaResponse.scala.html#kafka.api;StopReplicaResponse.responseMap" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,Short]">responseMap</a>.<span title="=&gt; scala.collection.immutable.Set[kafka.common.TopicAndPartition]">keySet</span>
    <span class="delimiter">}</span> else
      <a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.stopReplicaResponse" title="kafka.api.StopReplicaResponse">stopReplicaResponse</a>.<a href="../api/StopReplicaResponse.scala.html#kafka.api;StopReplicaResponse.responseMap" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,Short]">responseMap</a>.<span title="(p: ((kafka.common.TopicAndPartition, Short)) =&gt; Boolean)scala.collection.immutable.Map[kafka.common.TopicAndPartition,Short]">filter</span><span class="delimiter">(</span><a title="(kafka.common.TopicAndPartition, Short)" id="kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.partitionsInError.$anonfun.p">p</a> =&gt; <a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.partitionsInError.$anonfun.p" title="(kafka.common.TopicAndPartition, Short)">p</a>.<span title="=&gt; Short">_2</span> <span title="(x: Short)Boolean">!=</span> <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span>.<span title="(f: ((kafka.common.TopicAndPartition, Short)) =&gt; kafka.common.TopicAndPartition)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[kafka.common.TopicAndPartition,Short],kafka.common.TopicAndPartition,scala.collection.immutable.Iterable[kafka.common.TopicAndPartition]])scala.collection.immutable.Iterable[kafka.common.TopicAndPartition]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Iterable.Coll,kafka.common.TopicAndPartition,scala.collection.immutable.Iterable[kafka.common.TopicAndPartition]]" class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.partitionsInError.$anonfun.x$5" title="(kafka.common.TopicAndPartition, Short)">_</a>.<span title="=&gt; kafka.common.TopicAndPartition">_1</span><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[kafka.common.TopicAndPartition]">toSet</span>
    val <a title="scala.collection.immutable.Set[kafka.controller.PartitionAndReplica]" id="kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.replicasInError">replicasInError</a> = <a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.partitionsInError" title="scala.collection.immutable.Set[kafka.common.TopicAndPartition]">partitionsInError</a>.<span title="(f: kafka.common.TopicAndPartition =&gt; kafka.controller.PartitionAndReplica)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[kafka.common.TopicAndPartition],kafka.controller.PartitionAndReplica,scala.collection.immutable.Set[kafka.controller.PartitionAndReplica]])scala.collection.immutable.Set[kafka.controller.PartitionAndReplica]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,kafka.controller.PartitionAndReplica,scala.collection.immutable.Set[kafka.controller.PartitionAndReplica]]" class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.replicasInError.$anonfun.p">p</a> =&gt; <a href="KafkaController.scala.html#kafka.controller;PartitionAndReplica" title="(topic: String, partition: Int, replica: Int)kafka.controller.PartitionAndReplica">PartitionAndReplica</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.replicasInError.$anonfun.p" title="kafka.common.TopicAndPartition">p</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.replicasInError.$anonfun.p" title="kafka.common.TopicAndPartition">p</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a>, <a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.replicaId" title="Int">replicaId</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="../utils/Utils.scala.html#kafka.utils.Utils.inLock" title="(lock: java.util.concurrent.locks.Lock)(fun: =&gt; Unit)Unit">inLock</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>.<a href="KafkaController.scala.html#kafka.controller;ControllerContext.controllerLock" title="=&gt; java.util.concurrent.locks.ReentrantLock">controllerLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// move all the failed replicas to ReplicaDeletionIneligible</span>
      <a href="#kafka.controller;TopicDeletionManager.failReplicaDeletion" title="(replicas: scala.collection.Set[kafka.controller.PartitionAndReplica])Unit">failReplicaDeletion</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.replicasInError" title="scala.collection.immutable.Set[kafka.controller.PartitionAndReplica]">replicasInError</a><span class="delimiter">)</span>
      if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.replicasInError" title="scala.collection.immutable.Set[kafka.controller.PartitionAndReplica]">replicasInError</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">!=</span> <a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.stopReplicaResponse" title="kafka.api.StopReplicaResponse">stopReplicaResponse</a>.<a href="../api/StopReplicaResponse.scala.html#kafka.api;StopReplicaResponse.responseMap" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,Short]">responseMap</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// some replicas could have been successfully deleted</span>
        val deletedReplicas = <a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.stopReplicaResponse" title="kafka.api.StopReplicaResponse">stopReplicaResponse</a>.<a href="../api/StopReplicaResponse.scala.html#kafka.api;StopReplicaResponse.responseMap" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,Short]">responseMap</a>.<span title="=&gt; scala.collection.immutable.Set[kafka.common.TopicAndPartition]">keySet</span> <a title="scala.collection.immutable.Set[kafka.common.TopicAndPartition]" id="kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.deletedReplicas">--</a> <a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.partitionsInError" title="scala.collection.immutable.Set[kafka.common.TopicAndPartition]">partitionsInError</a>
        <a href="#kafka.controller;TopicDeletionManager.completeReplicaDeletion" title="(replicas: scala.collection.Set[kafka.controller.PartitionAndReplica])Unit">completeReplicaDeletion</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.deletedReplicas" title="scala.collection.immutable.Set[kafka.common.TopicAndPartition]">deletedReplicas</a>.<span title="(f: kafka.common.TopicAndPartition =&gt; kafka.controller.PartitionAndReplica)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[kafka.common.TopicAndPartition],kafka.controller.PartitionAndReplica,scala.collection.Set[kafka.controller.PartitionAndReplica]])scala.collection.Set[kafka.controller.PartitionAndReplica]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,kafka.controller.PartitionAndReplica,scala.collection.immutable.Set[kafka.controller.PartitionAndReplica]]" class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.$anonfun.p">p</a> =&gt; <a href="KafkaController.scala.html#kafka.controller;PartitionAndReplica" title="(topic: String, partition: Int, replica: Int)kafka.controller.PartitionAndReplica">PartitionAndReplica</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.$anonfun.p" title="kafka.common.TopicAndPartition">p</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.$anonfun.p" title="kafka.common.TopicAndPartition">p</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a>, <a href="#kafka.controller;TopicDeletionManager.deleteTopicStopReplicaCallback.replicaId" title="Int">replicaId</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  class <a title="class DeleteTopicsThread extends kafka.utils.ShutdownableThread" id="kafka.controller;TopicDeletionManager;DeleteTopicsThread">DeleteTopicsThread</a><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread" title="TopicDeletionManager.this.DeleteTopicsThread" class="delimiter">(</a><span class="delimiter">)</span> extends <a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread" title="kafka.utils.ShutdownableThread">ShutdownableThread</a><span class="delimiter">(</span>name = <span title="String(&quot;delete-topics-thread-&quot;)" class="string">&quot;delete-topics-thread-&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="../server/KafkaConfig.scala.html#kafka.server;KafkaConfig.brokerId" title="=&gt; Int">brokerId</a>, isInterruptible = false<span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="org.I0Itec.zkclient.ZkClient" id="kafka.controller;TopicDeletionManager;DeleteTopicsThread.zkClient">zkClient</a> = <a href="#kafka.controller;TopicDeletionManager.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>.<a href="KafkaController.scala.html#kafka.controller;ControllerContext.zkClient" title="=&gt; org.I0Itec.zkclient.ZkClient">zkClient</a>
    override def <a title="()Unit" id="kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork">doWork</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.controller;TopicDeletionManager.awaitTopicDeletionNotification" title="()Unit">awaitTopicDeletionNotification</a><span class="delimiter">(</span><span class="delimiter">)</span>

      if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread.isRunning" title="=&gt; java.util.concurrent.atomic.AtomicBoolean">isRunning</a>.<span title="()Boolean">get</span><span class="delimiter">)</span>
        return

      <a href="../utils/Utils.scala.html#kafka.utils.Utils.inLock" title="(lock: java.util.concurrent.locks.Lock)(fun: =&gt; Unit)Unit">inLock</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.controllerContext" title="=&gt; kafka.controller.ControllerContext">controllerContext</a>.<a href="KafkaController.scala.html#kafka.controller;ControllerContext.controllerLock" title="=&gt; java.util.concurrent.locks.ReentrantLock">controllerLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val topicsQueuedForDeletion = <span title="scala.collection.Set.type">Set</span>.<span title="[A]=&gt; scala.collection.Set[A]">empty</span><span title="scala.collection.Set[String]" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span> <a title="scala.collection.Set[String]" id="kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.topicsQueuedForDeletion">++</a> <a href="#kafka.controller;TopicDeletionManager.topicsToBeDeleted" title="=&gt; scala.collection.mutable.Set[String]">topicsToBeDeleted</a>

        if<span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.topicsQueuedForDeletion" title="scala.collection.Set[String]">topicsQueuedForDeletion</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="String(&quot;Handling deletion for topics &quot;)" class="string">&quot;Handling deletion for topics &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.topicsQueuedForDeletion" title="scala.collection.Set[String]">topicsQueuedForDeletion</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

        <a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.topicsQueuedForDeletion" title="scala.collection.Set[String]">topicsQueuedForDeletion</a>.<span title="(f: String =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="String" id="kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.topic">topic</a> =&gt;
        <span class="comment">// if all replicas are marked as deleted successfully, then topic deletion is done</span>
          if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>.<a href="ReplicaStateMachine.scala.html#kafka.controller;ReplicaStateMachine.areAllReplicasForTopicDeleted" title="(topic: String)Boolean">areAllReplicasForTopicDeleted</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="comment">// clear up all state for this topic from controller cache and zookeeper</span>
            <a href="#kafka.controller;TopicDeletionManager.completeDeleteTopic" title="(topic: String)Unit">completeDeleteTopic</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span>
            <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Deletion of topic %s successfully completed&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span> else <span class="delimiter">{</span>
            if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>.<a href="ReplicaStateMachine.scala.html#kafka.controller;ReplicaStateMachine.isAtLeastOneReplicaInDeletionStartedState" title="(topic: String)Boolean">isAtLeastOneReplicaInDeletionStartedState</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="comment">// ignore since topic deletion is in progress</span>
              val <a title="scala.collection.Set[kafka.controller.PartitionAndReplica]" id="kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.replicasInDeletionStartedState">replicasInDeletionStartedState</a> = <a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>.<a href="ReplicaStateMachine.scala.html#kafka.controller;ReplicaStateMachine.replicasInState" title="(topic: String, state: kafka.controller.ReplicaState)scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasInState</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.topic" title="String">topic</a>, <a href="ReplicaStateMachine.scala.html#kafka.controller.ReplicaDeletionStarted" title="kafka.controller.ReplicaDeletionStarted.type">ReplicaDeletionStarted</a><span class="delimiter">)</span>
              val <a title="scala.collection.Set[Int]" id="kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.replicaIds">replicaIds</a> = <a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.replicasInDeletionStartedState" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasInDeletionStartedState</a>.<span title="(f: kafka.controller.PartitionAndReplica =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.Set[kafka.controller.PartitionAndReplica],Int,scala.collection.Set[Int]])scala.collection.Set[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Set.Coll,Int,scala.collection.Set[Int]]" class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.replicaIds.$anonfun.x$6" title="kafka.controller.PartitionAndReplica">_</a>.<a href="KafkaController.scala.html#kafka.controller;PartitionAndReplica.replica" title="=&gt; Int">replica</a><span class="delimiter">)</span>
              val <a title="scala.collection.Set[kafka.common.TopicAndPartition]" id="kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.partitions">partitions</a> = <a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.replicasInDeletionStartedState" title="scala.collection.Set[kafka.controller.PartitionAndReplica]">replicasInDeletionStartedState</a>.<span title="(f: kafka.controller.PartitionAndReplica =&gt; kafka.common.TopicAndPartition)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.Set[kafka.controller.PartitionAndReplica],kafka.common.TopicAndPartition,scala.collection.Set[kafka.common.TopicAndPartition]])scala.collection.Set[kafka.common.TopicAndPartition]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Set.Coll,kafka.common.TopicAndPartition,scala.collection.Set[kafka.common.TopicAndPartition]]" class="delimiter">(</span><a title="kafka.controller.PartitionAndReplica" id="kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.partitions.$anonfun.r">r</a> =&gt; <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.partitions.$anonfun.r" title="kafka.controller.PartitionAndReplica">r</a>.<a href="KafkaController.scala.html#kafka.controller;PartitionAndReplica.topic" title="=&gt; String">topic</a>, <a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.partitions.$anonfun.r" title="kafka.controller.PartitionAndReplica">r</a>.<a href="KafkaController.scala.html#kafka.controller;PartitionAndReplica.partition" title="=&gt; Int">partition</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Deletion for replicas %s for partition %s of topic %s in progress&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.replicaIds" title="scala.collection.Set[Int]">replicaIds</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>,
                <a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.partitions" title="scala.collection.Set[kafka.common.TopicAndPartition]">partitions</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>, <a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span> else <span class="delimiter">{</span>
              <span class="comment">// if you come here, then no replica is in TopicDeletionStarted and all replicas are not in</span>
              <span class="comment">// TopicDeletionSuccessful. That means, that either given topic haven't initiated deletion</span>
              <span class="comment">// or there is at least one failed replica (which means topic deletion should be retried).</span>
              if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.controller" title="kafka.controller.KafkaController">controller</a>.<a href="KafkaController.scala.html#kafka.controller;KafkaController.replicaStateMachine" title="=&gt; kafka.controller.ReplicaStateMachine">replicaStateMachine</a>.<a href="ReplicaStateMachine.scala.html#kafka.controller;ReplicaStateMachine.isAnyReplicaInState" title="(topic: String, state: kafka.controller.ReplicaState)Boolean">isAnyReplicaInState</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.topic" title="String">topic</a>, <a href="ReplicaStateMachine.scala.html#kafka.controller.ReplicaDeletionIneligible" title="kafka.controller.ReplicaDeletionIneligible.type">ReplicaDeletionIneligible</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="comment">// mark topic for deletion retry</span>
                <a href="#kafka.controller;TopicDeletionManager.markTopicForDeletionRetry" title="(topic: String)Unit">markTopicForDeletionRetry</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span class="comment">// Try delete topic if it is eligible for deletion.</span>
          if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isTopicEligibleForDeletion" title="(topic: String)Boolean">isTopicEligibleForDeletion</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Deletion of topic %s (re)started&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="comment">// topic deletion will be kicked off</span>
            <a href="#kafka.controller;TopicDeletionManager.onTopicDeletion" title="(topics: scala.collection.Set[String])Unit">onTopicDeletion</a><span class="delimiter">(</span><span title="(elems: String*)scala.collection.Set[String]">Set</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span> else if<span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager.isTopicIneligibleForDeletion" title="(topic: String)Boolean">isTopicIneligibleForDeletion</a><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Not retrying deletion of topic %s at this time since it is marked ineligible for deletion&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.controller;TopicDeletionManager;DeleteTopicsThread.doWork.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
