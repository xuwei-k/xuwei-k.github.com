<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/server/ReplicaFetcherThread.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package kafka.server

import kafka.admin.AdminUtils
import kafka.cluster.Broker
import kafka.log.LogConfig
import kafka.message.ByteBufferMessageSet
import kafka.api.<span class="delimiter">{</span>OffsetRequest, FetchResponsePartitionData<span class="delimiter">}</span>
import kafka.common.<span class="delimiter">{</span>KafkaStorageException, TopicAndPartition<span class="delimiter">}</span>

class <a title="class ReplicaFetcherThread extends kafka.server.AbstractFetcherThread" id="kafka.server;ReplicaFetcherThread">ReplicaFetcherThread</a><a href="#kafka.server;ReplicaFetcherThread" title="kafka.server.ReplicaFetcherThread" class="delimiter">(</a><a title="String" id="kafka.server;ReplicaFetcherThread.name">name</a>:<span title="String">String</span>,
                           <a title="kafka.cluster.Broker" id="kafka.server;ReplicaFetcherThread.sourceBroker">sourceBroker</a>: <a href="../cluster/Broker.scala.html#kafka.cluster;Broker" title="kafka.cluster.Broker">Broker</a>,
                           <a title="kafka.server.KafkaConfig" id="kafka.server;ReplicaFetcherThread.brokerConfig">brokerConfig</a>: <a href="KafkaConfig.scala.html#kafka.server;KafkaConfig" title="kafka.server.KafkaConfig">KafkaConfig</a>,
                           <a title="kafka.server.ReplicaManager" id="kafka.server;ReplicaFetcherThread.replicaMgr">replicaMgr</a>: <a href="ReplicaManager.scala.html#kafka.server;ReplicaManager" title="kafka.server.ReplicaManager">ReplicaManager</a><span class="delimiter">)</span>
  extends <a href="AbstractFetcherThread.scala.html#kafka.server;AbstractFetcherThread" title="kafka.server.AbstractFetcherThread">AbstractFetcherThread</a><span class="delimiter">(</span>name = <a href="#kafka.server;ReplicaFetcherThread.name" title="String">name</a>,
                                clientId = <a href="#kafka.server;ReplicaFetcherThread.name" title="String">name</a>,
                                sourceBroker = <a href="#kafka.server;ReplicaFetcherThread.sourceBroker" title="kafka.cluster.Broker">sourceBroker</a>,
                                socketTimeout = <a href="#kafka.server;ReplicaFetcherThread.brokerConfig" title="kafka.server.KafkaConfig">brokerConfig</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.replicaSocketTimeoutMs" title="=&gt; Int">replicaSocketTimeoutMs</a>,
                                socketBufferSize = <a href="#kafka.server;ReplicaFetcherThread.brokerConfig" title="kafka.server.KafkaConfig">brokerConfig</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.replicaSocketReceiveBufferBytes" title="=&gt; Int">replicaSocketReceiveBufferBytes</a>,
                                fetchSize = <a href="#kafka.server;ReplicaFetcherThread.brokerConfig" title="kafka.server.KafkaConfig">brokerConfig</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.replicaFetchMaxBytes" title="=&gt; Int">replicaFetchMaxBytes</a>,
                                fetcherBrokerId = <a href="#kafka.server;ReplicaFetcherThread.brokerConfig" title="kafka.server.KafkaConfig">brokerConfig</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.brokerId" title="=&gt; Int">brokerId</a>,
                                maxWait = <a href="#kafka.server;ReplicaFetcherThread.brokerConfig" title="kafka.server.KafkaConfig">brokerConfig</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.replicaFetchWaitMaxMs" title="=&gt; Int">replicaFetchWaitMaxMs</a>,
                                minBytes = <a href="#kafka.server;ReplicaFetcherThread.brokerConfig" title="kafka.server.KafkaConfig">brokerConfig</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.replicaFetchMinBytes" title="=&gt; Int">replicaFetchMinBytes</a>,
                                isInterruptible = false<span class="delimiter">)</span> <span class="delimiter">{</span>

  <span class="comment">// process fetched data</span>
  def <a title="(topicAndPartition: kafka.common.TopicAndPartition, fetchOffset: Long, partitionData: kafka.api.FetchResponsePartitionData)Unit" id="kafka.server;ReplicaFetcherThread.processPartitionData">processPartitionData</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;ReplicaFetcherThread.processPartitionData.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a>, <a title="Long" id="kafka.server;ReplicaFetcherThread.processPartitionData.fetchOffset">fetchOffset</a>: <span title="Long">Long</span>, <a title="kafka.api.FetchResponsePartitionData" id="kafka.server;ReplicaFetcherThread.processPartitionData.partitionData">partitionData</a>: <a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData" title="kafka.api.FetchResponsePartitionData">FetchResponsePartitionData</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    try <span class="delimiter">{</span>
      val <a title="String" id="kafka.server;ReplicaFetcherThread.processPartitionData.topic">topic</a> = <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>
      val <a title="Int" id="kafka.server;ReplicaFetcherThread.processPartitionData.partitionId">partitionId</a> = <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a>
      val <a title="kafka.cluster.Replica" id="kafka.server;ReplicaFetcherThread.processPartitionData.replica">replica</a> = <a href="#kafka.server;ReplicaFetcherThread.replicaMgr" title="kafka.server.ReplicaManager">replicaMgr</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.getReplica" title="(topic: String, partitionId: Int, replicaId: Int)Option[kafka.cluster.Replica]">getReplica</a><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.processPartitionData.topic" title="String">topic</a>, <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.partitionId" title="Int">partitionId</a><span class="delimiter">)</span>.<span title="=&gt; kafka.cluster.Replica">get</span>
      val <a title="kafka.message.ByteBufferMessageSet" id="kafka.server;ReplicaFetcherThread.processPartitionData.messageSet">messageSet</a> = <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.partitionData" title="kafka.api.FetchResponsePartitionData">partitionData</a>.<a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData.messages" title="=&gt; kafka.message.MessageSet">messages</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.message.ByteBufferMessageSet" class="delimiter">[</span><a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet">ByteBufferMessageSet</a><span class="delimiter">]</span>

      if <span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.processPartitionData.fetchOffset" title="Long">fetchOffset</a> <span title="(x: Long)Boolean">!=</span> <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.replica" title="kafka.cluster.Replica">replica</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.logEndOffset" title="=&gt; kafka.server.LogOffsetMetadata">logEndOffset</a>.<a href="LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="=&gt; Long">messageOffset</a><span class="delimiter">)</span>
        throw new <span title="RuntimeException">RuntimeException</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Offset mismatch: fetched offset = %d, log end offset = %d.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.processPartitionData.fetchOffset" title="Long">fetchOffset</a>, <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.replica" title="kafka.cluster.Replica">replica</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.logEndOffset" title="=&gt; kafka.server.LogOffsetMetadata">logEndOffset</a>.<a href="LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="=&gt; Long">messageOffset</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Follower %d has replica log end offset %d for partition %s. Received %d messages and leader hw %d&quot;</span>
            .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.processPartitionData.replica" title="kafka.cluster.Replica">replica</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a>, <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.replica" title="kafka.cluster.Replica">replica</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.logEndOffset" title="=&gt; kafka.server.LogOffsetMetadata">logEndOffset</a>.<a href="LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="=&gt; Long">messageOffset</a>, <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.messageSet" title="kafka.message.ByteBufferMessageSet">messageSet</a>.<a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet.sizeInBytes" title="=&gt; Int">sizeInBytes</a>, <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.partitionData" title="kafka.api.FetchResponsePartitionData">partitionData</a>.<a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData.hw" title="=&gt; Long">hw</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.replica" title="kafka.cluster.Replica">replica</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.log" title="=&gt; Option[kafka.log.Log]">log</a>.<span title="=&gt; kafka.log.Log">get</span>.<a href="../log/Log.scala.html#kafka.log;Log.append" title="(messages: kafka.message.ByteBufferMessageSet, assignOffsets: Boolean)kafka.log.Log#LogAppendInfo">append</a><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.processPartitionData.messageSet" title="kafka.message.ByteBufferMessageSet">messageSet</a>, assignOffsets = false<span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Follower %d has replica log end offset %d after appending %d bytes of messages for partition %s&quot;</span>
            .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.processPartitionData.replica" title="kafka.cluster.Replica">replica</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a>, <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.replica" title="kafka.cluster.Replica">replica</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.logEndOffset" title="=&gt; kafka.server.LogOffsetMetadata">logEndOffset</a>.<a href="LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="=&gt; Long">messageOffset</a>, <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.messageSet" title="kafka.message.ByteBufferMessageSet">messageSet</a>.<a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet.sizeInBytes" title="=&gt; Int">sizeInBytes</a>, <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span><span class="delimiter">)</span>
      val <a title="Long" id="kafka.server;ReplicaFetcherThread.processPartitionData.followerHighWatermark">followerHighWatermark</a> = <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.replica" title="kafka.cluster.Replica">replica</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.logEndOffset" title="=&gt; kafka.server.LogOffsetMetadata">logEndOffset</a>.<a href="LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="implicit scala.LowPriorityImplicits.longWrapper : (x: Long)scala.runtime.RichLong">messageOffset</a>.<span title="(that: Long)Long">min</span><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.processPartitionData.partitionData" title="kafka.api.FetchResponsePartitionData">partitionData</a>.<a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData.hw" title="=&gt; Long">hw</a><span class="delimiter">)</span>
      <span class="comment">// for the follower replica, we do not need to keep</span>
      <span class="comment">// its segment base offset the physical position,</span>
      <span class="comment">// these values will be computed upon making the leader</span>
      <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.replica" title="kafka.cluster.Replica">replica</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.highWatermark_=" title="(newHighWatermark: kafka.server.LogOffsetMetadata)Unit">highWatermark</a> = new <a href="LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata" title="kafka.server.LogOffsetMetadata">LogOffsetMetadata</a><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.processPartitionData.followerHighWatermark" title="Long">followerHighWatermark</a><span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Follower %d set replica high watermark for partition [%s,%d] to %s&quot;</span>
            .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.processPartitionData.replica" title="kafka.cluster.Replica">replica</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.brokerId" title="=&gt; Int">brokerId</a>, <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.topic" title="String">topic</a>, <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.partitionId" title="Int">partitionId</a>, <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.followerHighWatermark" title="Long">followerHighWatermark</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> catch <span class="delimiter">{</span>
      case <a title="kafka.common.KafkaStorageException" id="kafka.server;ReplicaFetcherThread.processPartitionData.e">e</a>: <a href="../common/KafkaStorageException.scala.html#kafka.common;KafkaStorageException" title="kafka.common.KafkaStorageException">KafkaStorageException</a> =&gt;
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.fatal(cfd112d89b)" title="(msg: =&gt; String, e: =&gt; Throwable)Unit">fatal</a><span class="delimiter">(</span><span title="String(&quot;Disk error while replicating data.&quot;)" class="string">&quot;Disk error while replicating data.&quot;</span>, <a href="#kafka.server;ReplicaFetcherThread.processPartitionData.e" title="kafka.common.KafkaStorageException">e</a><span class="delimiter">)</span>
        <span title="Runtime.type">Runtime</span>.<span title="()Runtime">getRuntime</span>.<span title="(x$1: Int)Unit">halt</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Handle a partition whose offset is out of range and return a new fetch offset.
   */</span>
  def <a title="(topicAndPartition: kafka.common.TopicAndPartition)Long" id="kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange">handleOffsetOutOfRange</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">)</span>: <span title="Long">Long</span> = <span class="delimiter">{</span>
    val <a title="kafka.cluster.Replica" id="kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.replica">replica</a> = <a href="#kafka.server;ReplicaFetcherThread.replicaMgr" title="kafka.server.ReplicaManager">replicaMgr</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.getReplica" title="(topic: String, partitionId: Int, replicaId: Int)Option[kafka.cluster.Replica]">getReplica</a><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a><span class="delimiter">)</span>.<span title="=&gt; kafka.cluster.Replica">get</span>

    <span class="comment">/**
     * Unclean leader election: A follower goes down, in the meanwhile the leader keeps appending messages. The follower comes back up
     * and before it has completely caught up with the leader's logs, all replicas in the ISR go down. The follower is now uncleanly
     * elected as the new leader, and it starts appending messages from the client. The old leader comes back up, becomes a follower
     * and it may discover that the current leader's end offset is behind its own end offset.
     *
     * In such a case, truncate the current follower's log to the current leader's end offset and continue fetching.
     *
     * There is a potential for a mismatch between the logs of the two replicas here. We don't fix this mismatch as of now.
     */</span>
    val <a title="Long" id="kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.leaderEndOffset">leaderEndOffset</a> = <a href="AbstractFetcherThread.scala.html#kafka.server;AbstractFetcherThread.simpleConsumer" title="=&gt; kafka.consumer.SimpleConsumer">simpleConsumer</a>.<a href="../consumer/SimpleConsumer.scala.html#kafka.consumer;SimpleConsumer.earliestOrLatestOffset" title="(topicAndPartition: kafka.common.TopicAndPartition, earliestOrLatest: Long, consumerId: Int)Long">earliestOrLatestOffset</a><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="../api/OffsetRequest.scala.html#kafka.api.OffsetRequest" title="kafka.api.OffsetRequest.type">OffsetRequest</a>.<a href="../api/OffsetRequest.scala.html#kafka.api.OffsetRequest.LatestTime" title="=&gt; Long">LatestTime</a>, <a href="#kafka.server;ReplicaFetcherThread.brokerConfig" title="kafka.server.KafkaConfig">brokerConfig</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.leaderEndOffset" title="Long">leaderEndOffset</a> <span title="(x: Long)Boolean">&lt;</span> <a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.replica" title="kafka.cluster.Replica">replica</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.logEndOffset" title="=&gt; kafka.server.LogOffsetMetadata">logEndOffset</a>.<a href="LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="=&gt; Long">messageOffset</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// Prior to truncating the follower's log, ensure that doing so is not disallowed by the configuration for unclean leader election.</span>
      <span class="comment">// This situation could only happen if the unclean election configuration for a topic changes while a replica is down. Otherwise,</span>
      <span class="comment">// we should never encounter this situation since a non-ISR leader cannot be elected if disallowed by the broker configuration.</span>
      if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="../log/LogConfig.scala.html#kafka.log.LogConfig" title="kafka.log.LogConfig.type">LogConfig</a>.<a href="../log/LogConfig.scala.html#kafka.log.LogConfig.fromProps(9d0df464c6)" title="(defaults: java.util.Properties, overrides: java.util.Properties)kafka.log.LogConfig">fromProps</a><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.brokerConfig" title="kafka.server.KafkaConfig">brokerConfig</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.props" title="=&gt; kafka.utils.VerifiableProperties">props</a>.<a href="../utils/VerifiableProperties.scala.html#kafka.utils;VerifiableProperties.props" title="=&gt; java.util.Properties">props</a>, <a href="../admin/AdminUtils.scala.html#kafka.admin.AdminUtils" title="kafka.admin.AdminUtils.type">AdminUtils</a>.<a href="../admin/AdminUtils.scala.html#kafka.admin.AdminUtils.fetchTopicConfig" title="(zkClient: org.I0Itec.zkclient.ZkClient, topic: String)java.util.Properties">fetchTopicConfig</a><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.replicaMgr" title="kafka.server.ReplicaManager">replicaMgr</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.zkClient" title="=&gt; org.I0Itec.zkclient.ZkClient">zkClient</a>,
        <a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../log/LogConfig.scala.html#kafka.log;LogConfig.uncleanLeaderElectionEnable" title="=&gt; Boolean">uncleanLeaderElectionEnable</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// Log a fatal error and shutdown the broker to ensure that data loss does not unexpectedly occur.</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.fatal(1729dbc42f)" title="(msg: =&gt; String)Unit">fatal</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Halting because log truncation is not allowed for topic %s,&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span>
          <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot; Current leader %d's latest offset %d is less than replica %d's latest offset %d&quot;</span>
          .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.sourceBroker" title="kafka.cluster.Broker">sourceBroker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.id" title="=&gt; Int">id</a>, <a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.leaderEndOffset" title="Long">leaderEndOffset</a>, <a href="#kafka.server;ReplicaFetcherThread.brokerConfig" title="kafka.server.KafkaConfig">brokerConfig</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.brokerId" title="=&gt; Int">brokerId</a>, <a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.replica" title="kafka.cluster.Replica">replica</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.logEndOffset" title="=&gt; kafka.server.LogOffsetMetadata">logEndOffset</a>.<a href="LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="=&gt; Long">messageOffset</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="Runtime.type">Runtime</span>.<span title="()Runtime">getRuntime</span>.<span title="(x$1: Int)Unit">halt</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <a href="#kafka.server;ReplicaFetcherThread.replicaMgr" title="kafka.server.ReplicaManager">replicaMgr</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.logManager" title="=&gt; kafka.log.LogManager">logManager</a>.<a href="../log/LogManager.scala.html#kafka.log;LogManager.truncateTo" title="(partitionAndOffsets: scala.collection.Map[kafka.common.TopicAndPartition,Long])Unit">truncateTo</a><span class="delimiter">(</span><span title="(elems: (kafka.common.TopicAndPartition, Long)*)scala.collection.immutable.Map[kafka.common.TopicAndPartition,Long]">Map</span><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.topicAndPartition" title="(self: kafka.common.TopicAndPartition)ArrowAssoc[kafka.common.TopicAndPartition]">topicAndPartition</a> <span title="(y: Long)(kafka.common.TopicAndPartition, Long)">-&gt;</span> <a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.leaderEndOffset" title="Long">leaderEndOffset</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Replica %d for partition %s reset its fetch offset from %d to current leader %d's latest offset %d&quot;</span>
        .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.brokerConfig" title="kafka.server.KafkaConfig">brokerConfig</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.brokerId" title="=&gt; Int">brokerId</a>, <a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.replica" title="kafka.cluster.Replica">replica</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.logEndOffset" title="=&gt; kafka.server.LogOffsetMetadata">logEndOffset</a>.<a href="LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="=&gt; Long">messageOffset</a>, <a href="#kafka.server;ReplicaFetcherThread.sourceBroker" title="kafka.cluster.Broker">sourceBroker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.id" title="=&gt; Int">id</a>, <a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.leaderEndOffset" title="Long">leaderEndOffset</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.leaderEndOffset" title="Long">leaderEndOffset</a>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <span class="comment">/**
       * The follower could have been down for a long time and when it starts up, its end offset could be smaller than the leader's
       * start offset because the leader has deleted old logs (log.logEndOffset &lt; leaderStartOffset).
       *
       * Roll out a new log at the follower with the start offset equal to the current leader's start offset and continue fetching.
       */</span>
      val <a title="Long" id="kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.leaderStartOffset">leaderStartOffset</a> = <a href="AbstractFetcherThread.scala.html#kafka.server;AbstractFetcherThread.simpleConsumer" title="=&gt; kafka.consumer.SimpleConsumer">simpleConsumer</a>.<a href="../consumer/SimpleConsumer.scala.html#kafka.consumer;SimpleConsumer.earliestOrLatestOffset" title="(topicAndPartition: kafka.common.TopicAndPartition, earliestOrLatest: Long, consumerId: Int)Long">earliestOrLatestOffset</a><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="../api/OffsetRequest.scala.html#kafka.api.OffsetRequest" title="kafka.api.OffsetRequest.type">OffsetRequest</a>.<a href="../api/OffsetRequest.scala.html#kafka.api.OffsetRequest.EarliestTime" title="=&gt; Long">EarliestTime</a>, <a href="#kafka.server;ReplicaFetcherThread.brokerConfig" title="kafka.server.KafkaConfig">brokerConfig</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span>
      <a href="#kafka.server;ReplicaFetcherThread.replicaMgr" title="kafka.server.ReplicaManager">replicaMgr</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.logManager" title="=&gt; kafka.log.LogManager">logManager</a>.<a href="../log/LogManager.scala.html#kafka.log;LogManager.truncateFullyAndStartAt" title="(topicAndPartition: kafka.common.TopicAndPartition, newOffset: Long)Unit">truncateFullyAndStartAt</a><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.leaderStartOffset" title="Long">leaderStartOffset</a><span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Replica %d for partition %s reset its fetch offset from %d to current leader %d's start offset %d&quot;</span>
        .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;ReplicaFetcherThread.brokerConfig" title="kafka.server.KafkaConfig">brokerConfig</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.brokerId" title="=&gt; Int">brokerId</a>, <a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.replica" title="kafka.cluster.Replica">replica</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.logEndOffset" title="=&gt; kafka.server.LogOffsetMetadata">logEndOffset</a>.<a href="LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="=&gt; Long">messageOffset</a>, <a href="#kafka.server;ReplicaFetcherThread.sourceBroker" title="kafka.cluster.Broker">sourceBroker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.id" title="=&gt; Int">id</a>, <a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.leaderStartOffset" title="Long">leaderStartOffset</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.server;ReplicaFetcherThread.handleOffsetOutOfRange.leaderStartOffset" title="Long">leaderStartOffset</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">// any logic for partitions whose leader has changed</span>
  def <a title="(partitions: Iterable[kafka.common.TopicAndPartition])Unit" id="kafka.server;ReplicaFetcherThread.handlePartitionsWithErrors">handlePartitionsWithErrors</a><span class="delimiter">(</span><a title="Iterable[kafka.common.TopicAndPartition]" id="kafka.server;ReplicaFetcherThread.handlePartitionsWithErrors.partitions">partitions</a>: <span title="Iterable[kafka.common.TopicAndPartition]">Iterable</span><span class="delimiter">[</span>TopicAndPartition<span class="delimiter">]</span><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span>
    <span class="comment">// no handler needed since the controller will make the changes accordingly</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
