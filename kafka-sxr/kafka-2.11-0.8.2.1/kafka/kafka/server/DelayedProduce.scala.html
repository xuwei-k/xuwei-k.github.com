<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/server/DelayedProduce.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package kafka.server

import kafka.api._
import kafka.common.ErrorMapping
import kafka.common.TopicAndPartition
import kafka.utils.Logging
import kafka.network.RequestChannel

import scala.Some
import scala.collection.immutable.Map
import scala.collection.Seq

<span class="comment">/** A delayed produce request, which is satisfied (or more
  * accurately, unblocked) -- if for every partition it produce to:
  * Case A: This broker is not the leader: unblock - should return error.
  * Case B: This broker is the leader:
  *   B.1 - If there was a localError (when writing to the local log): unblock - should return error
  *   B.2 - else, at least requiredAcks replicas should be caught up to this request.
  */</span>

class <a title="class DelayedProduce extends kafka.server.DelayedRequest with kafka.utils.Logging" id="kafka.server.DelayedProduce">DelayedProduce</a><a href="#kafka.server.DelayedProduce" title="kafka.server.DelayedProduce" class="delimiter">(</a>override val <a title="Seq[kafka.common.TopicAndPartition]" id="kafka.server;DelayedProduce.keys">keys</a>: <span title="Seq[kafka.common.TopicAndPartition]">Seq</span><span class="delimiter">[</span>TopicAndPartition<span class="delimiter">]</span>,
                     override val <a title="kafka.network.RequestChannel.Request" id="kafka.server;DelayedProduce.request">request</a>: RequestChannel.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request" title="kafka.network.RequestChannel.Request">Request</a>,
                     override val <a title="Long" id="kafka.server;DelayedProduce.delayMs">delayMs</a>: <span title="Long">Long</span>,
                     val <a title="kafka.api.ProducerRequest" id="kafka.server;DelayedProduce.produce">produce</a>: <a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest" title="kafka.api.ProducerRequest">ProducerRequest</a>,
                     val <a title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.DelayedProduceResponseStatus]" id="kafka.server;DelayedProduce.partitionStatus">partitionStatus</a>: <span title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.DelayedProduceResponseStatus]">Map</span><span class="delimiter">[</span>TopicAndPartition, DelayedProduceResponseStatus<span class="delimiter">]</span>,
                     val <a title="Option[kafka.api.OffsetCommitRequest]" id="kafka.server.DelayedProduce.<init>$default$6">offsetCommitRequestOpt</a>: <span title="Option[kafka.api.OffsetCommitRequest]">Option</span><span class="delimiter">[</span>OffsetCommitRequest<span class="delimiter">]</span> = <span title="None.type">None</span><span class="delimiter">)</span>
  extends <a href="RequestPurgatory.scala.html#kafka.server;DelayedRequest" title="kafka.server.DelayedRequest">DelayedRequest</a><span class="delimiter">(</span><a href="#kafka.server;DelayedProduce.keys" title="Seq[kafka.common.TopicAndPartition]">keys</a>, <a href="#kafka.server;DelayedProduce.request" title="kafka.network.RequestChannel.Request">request</a>, <a href="#kafka.server;DelayedProduce.delayMs" title="Long">delayMs</a><span class="delimiter">)</span> with <a href="../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> <span class="delimiter">{</span>

  <span class="comment">// first update the acks pending variable according to the error code</span>
  <a href="#kafka.server;DelayedProduce.partitionStatus" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.DelayedProduceResponseStatus]">partitionStatus</a> <span title="(f: ((kafka.common.TopicAndPartition, kafka.server.DelayedProduceResponseStatus)) =&gt; Unit)Unit">foreach</span> <a href="#kafka.server;DelayedProduce.<local DelayedProduce>.$anonfun.x0$1" title="Unit" class="delimiter">{</a> case <span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;DelayedProduce.<local DelayedProduce>.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="kafka.server.DelayedProduceResponseStatus" id="kafka.server;DelayedProduce.<local DelayedProduce>.$anonfun.delayedStatus">delayedStatus</a><span class="delimiter">)</span> =&gt;
    if <span class="delimiter">(</span><a href="#kafka.server;DelayedProduce.<local DelayedProduce>.$anonfun.delayedStatus" title="kafka.server.DelayedProduceResponseStatus">delayedStatus</a>.<a href="#kafka.server;DelayedProduceResponseStatus.responseStatus" title="=&gt; kafka.api.ProducerResponseStatus">responseStatus</a>.<a href="../api/ProducerResponse.scala.html#kafka.api;ProducerResponseStatus.error" title="=&gt; Short">error</a> <span title="(x: Short)Boolean">==</span> <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// Timeout error state will be cleared when required acks are received</span>
      <a href="#kafka.server;DelayedProduce.<local DelayedProduce>.$anonfun.delayedStatus" title="kafka.server.DelayedProduceResponseStatus">delayedStatus</a>.<a href="#kafka.server;DelayedProduceResponseStatus.acksPending_=" title="(x$1: Boolean)Unit">acksPending</a> = true
      <a href="#kafka.server;DelayedProduce.<local DelayedProduce>.$anonfun.delayedStatus" title="kafka.server.DelayedProduceResponseStatus">delayedStatus</a>.<a href="#kafka.server;DelayedProduceResponseStatus.responseStatus" title="=&gt; kafka.api.ProducerResponseStatus">responseStatus</a>.<a href="../api/ProducerResponse.scala.html#kafka.api;ProducerResponseStatus.error_=" title="(x$1: Short)Unit">error</a> = <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.RequestTimedOutCode" title="=&gt; Short">RequestTimedOutCode</a>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <a href="#kafka.server;DelayedProduce.<local DelayedProduce>.$anonfun.delayedStatus" title="kafka.server.DelayedProduceResponseStatus">delayedStatus</a>.<a href="#kafka.server;DelayedProduceResponseStatus.acksPending_=" title="(x$1: Boolean)Unit">acksPending</a> = false
    <span class="delimiter">}</span>

    <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Initial partition status for %s is %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;DelayedProduce.<local DelayedProduce>.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;DelayedProduce.<local DelayedProduce>.$anonfun.delayedStatus" title="kafka.server.DelayedProduceResponseStatus">delayedStatus</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(offsetManager: kafka.server.OffsetManager)kafka.api.RequestOrResponse" id="kafka.server;DelayedProduce.respond">respond</a><span class="delimiter">(</span><a title="kafka.server.OffsetManager" id="kafka.server;DelayedProduce.respond.offsetManager">offsetManager</a>: <a href="OffsetManager.scala.html#kafka.server;OffsetManager" title="kafka.server.OffsetManager">OffsetManager</a><span class="delimiter">)</span>: <a href="../api/RequestOrResponse.scala.html#kafka.api;RequestOrResponse" title="kafka.api.RequestOrResponse">RequestOrResponse</a> = <span class="delimiter">{</span>
    val <a title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus]" id="kafka.server;DelayedProduce.respond.responseStatus">responseStatus</a> = <a href="#kafka.server;DelayedProduce.partitionStatus" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.DelayedProduceResponseStatus]">partitionStatus</a>.<span title="(f: kafka.server.DelayedProduceResponseStatus =&gt; kafka.api.ProducerResponseStatus)scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus]">mapValues</span><span class="delimiter">(</span><a title="kafka.server.DelayedProduceResponseStatus" id="kafka.server;DelayedProduce.respond.responseStatus.$anonfun.status">status</a> =&gt; <a href="#kafka.server;DelayedProduce.respond.responseStatus.$anonfun.status" title="kafka.server.DelayedProduceResponseStatus">status</a>.<a href="#kafka.server;DelayedProduceResponseStatus.responseStatus" title="=&gt; kafka.api.ProducerResponseStatus">responseStatus</a><span class="delimiter">)</span>

    val <a title="Short" id="kafka.server;DelayedProduce.respond.errorCode">errorCode</a> = <a href="#kafka.server;DelayedProduce.respond.responseStatus" title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus]">responseStatus</a>.<span title="(p: ((kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)) =&gt; Boolean)Option[(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)]">find</span> <a href="#kafka.server;DelayedProduce.respond.errorCode.$anonfun.x0$2" title="Boolean" class="delimiter">{</a> case <span class="delimiter">(</span>_, <a title="kafka.api.ProducerResponseStatus" id="kafka.server;DelayedProduce.respond.errorCode.$anonfun.status">status</a><span class="delimiter">)</span> =&gt;
      <a href="#kafka.server;DelayedProduce.respond.errorCode.$anonfun.status" title="kafka.api.ProducerResponseStatus">status</a>.<a href="../api/ProducerResponse.scala.html#kafka.api;ProducerResponseStatus.error" title="=&gt; Short">error</a> <span title="(x: Short)Boolean">!=</span> <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a>
    <span class="delimiter">}</span>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)) =&gt; Short)Option[Short]">map</span><span class="delimiter">(</span><a href="#kafka.server;DelayedProduce.respond.errorCode.$anonfun.x$1" title="(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)">_</a>.<span title="=&gt; kafka.api.ProducerResponseStatus">_2</span>.<a href="../api/ProducerResponse.scala.html#kafka.api;ProducerResponseStatus.error" title="=&gt; Short">error</a><span class="delimiter">)</span>.<span title="(default: =&gt; Short)Short">getOrElse</span><span class="delimiter">(</span><a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span>

    if <span class="delimiter">(</span><a href="#kafka.server;DelayedProduce.respond.errorCode" title="Short">errorCode</a> <span title="(x: Short)Boolean">==</span> <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.server.DelayedProduce.<init>$default$6" title="=&gt; Option[kafka.api.OffsetCommitRequest]">offsetCommitRequestOpt</a>.<span title="(f: kafka.api.OffsetCommitRequest =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a title="kafka.api.OffsetCommitRequest" id="kafka.server;DelayedProduce.respond.$anonfun.ocr">ocr</a> =&gt; <a href="#kafka.server;DelayedProduce.respond.offsetManager" title="kafka.server.OffsetManager">offsetManager</a>.<a href="OffsetManager.scala.html#kafka.server;OffsetManager.putOffsets" title="(group: String, offsets: scala.collection.Map[kafka.common.TopicAndPartition,kafka.common.OffsetAndMetadata])Unit">putOffsets</a><span class="delimiter">(</span><a href="#kafka.server;DelayedProduce.respond.$anonfun.ocr" title="kafka.api.OffsetCommitRequest">ocr</a>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.groupId" title="=&gt; String">groupId</a>, <a href="#kafka.server;DelayedProduce.respond.$anonfun.ocr" title="kafka.api.OffsetCommitRequest">ocr</a>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.requestInfo" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetAndMetadata]">requestInfo</a><span class="delimiter">)</span> <span class="delimiter">)</span>
    <span class="delimiter">}</span>

    val <a title="&lt;refinement of kafka.api.RequestOrResponse with Product&gt; extends kafka.api.RequestOrResponse with Product with Serializable" id="kafka.server;DelayedProduce.respond.response">response</a> = <a href="#kafka.server.DelayedProduce.<init>$default$6" title="=&gt; Option[kafka.api.OffsetCommitRequest]">offsetCommitRequestOpt</a>.<span title="(f: kafka.api.OffsetCommitRequest =&gt; kafka.api.OffsetCommitResponse)Option[kafka.api.OffsetCommitResponse]">map</span><span class="delimiter">(</span><a href="#kafka.server;DelayedProduce.respond.response.$anonfun.x$2" title="kafka.api.OffsetCommitRequest">_</a>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.responseFor" title="(errorCode: Short, offsetMetadataMaxSize: Int)kafka.api.OffsetCommitResponse">responseFor</a><span class="delimiter">(</span><a href="#kafka.server;DelayedProduce.respond.errorCode" title="Short">errorCode</a>, <a href="#kafka.server;DelayedProduce.respond.offsetManager" title="kafka.server.OffsetManager">offsetManager</a>.<a href="OffsetManager.scala.html#kafka.server;OffsetManager.config" title="=&gt; kafka.server.OffsetManagerConfig">config</a>.<a href="OffsetManager.scala.html#kafka.server;OffsetManagerConfig.maxMetadataSize" title="=&gt; Int">maxMetadataSize</a><span class="delimiter">)</span><span class="delimiter">)</span>
      .<span title="(default: =&gt; kafka.api.RequestOrResponse with Product with Serializable)kafka.api.RequestOrResponse with Product with Serializable">getOrElse</span><span class="delimiter">(</span><a href="../api/ProducerResponse.scala.html#kafka.api;ProducerResponse" title="(correlationId: Int, status: scala.collection.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus])kafka.api.ProducerResponse">ProducerResponse</a><span class="delimiter">(</span><a href="#kafka.server;DelayedProduce.produce" title="=&gt; kafka.api.ProducerRequest">produce</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;DelayedProduce.respond.responseStatus" title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus]">responseStatus</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <a href="#kafka.server;DelayedProduce.respond.response" title="&lt;refinement of kafka.api.RequestOrResponse with Product&gt; extends kafka.api.RequestOrResponse with Product with Serializable">response</a>
  <span class="delimiter">}</span>

  def <a title="(replicaManager: kafka.server.ReplicaManager)Boolean" id="kafka.server;DelayedProduce.isSatisfied">isSatisfied</a><span class="delimiter">(</span><a title="kafka.server.ReplicaManager" id="kafka.server;DelayedProduce.isSatisfied.replicaManager">replicaManager</a>: <a href="ReplicaManager.scala.html#kafka.server;ReplicaManager" title="kafka.server.ReplicaManager">ReplicaManager</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="comment">// check for each partition if it still has pending acks</span>
    <a href="#kafka.server;DelayedProduce.partitionStatus" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.DelayedProduceResponseStatus]">partitionStatus</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.server.DelayedProduceResponseStatus)) =&gt; Unit)Unit">foreach</span> <a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.x0$3" title="Unit" class="delimiter">{</a> case <span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;DelayedProduce.isSatisfied.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="kafka.server.DelayedProduceResponseStatus" id="kafka.server;DelayedProduce.isSatisfied.$anonfun.fetchPartitionStatus">fetchPartitionStatus</a><span class="delimiter">)</span> =&gt;
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Checking producer request satisfaction for %s, acksPending = %b&quot;</span>
        .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.fetchPartitionStatus" title="kafka.server.DelayedProduceResponseStatus">fetchPartitionStatus</a>.<a href="#kafka.server;DelayedProduceResponseStatus.acksPending_=" title="=&gt; Boolean">acksPending</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="comment">// skip those partitions that have already been satisfied</span>
      if <span class="delimiter">(</span><a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.fetchPartitionStatus" title="kafka.server.DelayedProduceResponseStatus">fetchPartitionStatus</a>.<a href="#kafka.server;DelayedProduceResponseStatus.acksPending_=" title="=&gt; Boolean">acksPending</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="Option[kafka.cluster.Partition]" id="kafka.server;DelayedProduce.isSatisfied.$anonfun.partitionOpt">partitionOpt</a> = <a href="#kafka.server;DelayedProduce.isSatisfied.replicaManager" title="kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.getPartition" title="(topic: String, partitionId: Int)Option[kafka.cluster.Partition]">getPartition</a><span class="delimiter">(</span><a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a><span class="delimiter">)</span>
        val <a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.hasEnough" title="(Boolean, Short)" class="delimiter">(</a><a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.x$3" title="Boolean" id="kafka.server;DelayedProduce.isSatisfied.$anonfun.hasEnough">hasEnough</a>, <a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.x$3" title="Short" id="kafka.server;DelayedProduce.isSatisfied.$anonfun.errorCode">errorCode</a><span class="delimiter">)</span> = <a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.partitionOpt" title="Option[kafka.cluster.Partition]">partitionOpt</a> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><a title="kafka.cluster.Partition" id="kafka.server;DelayedProduce.isSatisfied.$anonfun.x$3.partition">partition</a><span class="delimiter">)</span> =&gt;
            <a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.x$3.partition" title="kafka.cluster.Partition">partition</a>.<a href="../cluster/Partition.scala.html#kafka.cluster;Partition.checkEnoughReplicasReachOffset" title="(requiredOffset: Long, requiredAcks: Int)(Boolean, Short)">checkEnoughReplicasReachOffset</a><span class="delimiter">(</span>
              <a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.fetchPartitionStatus" title="kafka.server.DelayedProduceResponseStatus">fetchPartitionStatus</a>.<a href="#kafka.server;DelayedProduceResponseStatus.requiredOffset" title="=&gt; Long">requiredOffset</a>,
              <a href="#kafka.server;DelayedProduce.produce" title="=&gt; kafka.api.ProducerRequest">produce</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.requiredAcks" title="=&gt; Int">requiredAcks</a><span class="delimiter">)</span>
          case <span title="None.type">None</span> =&gt;
            <span title="(_1: Boolean, _2: Short)(Boolean, Short)" class="delimiter">(</span>false, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.UnknownTopicOrPartitionCode" title="=&gt; Short">UnknownTopicOrPartitionCode</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        if <span class="delimiter">(</span><a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.errorCode" title="Short">errorCode</a> <span title="(x: Short)Boolean">!=</span> <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.fetchPartitionStatus" title="kafka.server.DelayedProduceResponseStatus">fetchPartitionStatus</a>.<a href="#kafka.server;DelayedProduceResponseStatus.acksPending_=" title="(x$1: Boolean)Unit">acksPending</a> = false
          <a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.fetchPartitionStatus" title="kafka.server.DelayedProduceResponseStatus">fetchPartitionStatus</a>.<a href="#kafka.server;DelayedProduceResponseStatus.responseStatus" title="=&gt; kafka.api.ProducerResponseStatus">responseStatus</a>.<a href="../api/ProducerResponse.scala.html#kafka.api;ProducerResponseStatus.error_=" title="(x$1: Short)Unit">error</a> = <a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.errorCode" title="Short">errorCode</a>
        <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.hasEnough" title="Boolean">hasEnough</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.fetchPartitionStatus" title="kafka.server.DelayedProduceResponseStatus">fetchPartitionStatus</a>.<a href="#kafka.server;DelayedProduceResponseStatus.acksPending_=" title="(x$1: Boolean)Unit">acksPending</a> = false
          <a href="#kafka.server;DelayedProduce.isSatisfied.$anonfun.fetchPartitionStatus" title="kafka.server.DelayedProduceResponseStatus">fetchPartitionStatus</a>.<a href="#kafka.server;DelayedProduceResponseStatus.responseStatus" title="=&gt; kafka.api.ProducerResponseStatus">responseStatus</a>.<a href="../api/ProducerResponse.scala.html#kafka.api;ProducerResponseStatus.error_=" title="(x$1: Short)Unit">error</a> = <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">// unblocked if there are no partitions with pending acks</span>
    val <a title="Boolean" id="kafka.server;DelayedProduce.isSatisfied.satisfied">satisfied</a> = <span title="=&gt; Boolean">!</span> <a href="#kafka.server;DelayedProduce.partitionStatus" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.DelayedProduceResponseStatus]">partitionStatus</a>.<span title="(p: ((kafka.common.TopicAndPartition, kafka.server.DelayedProduceResponseStatus)) =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a title="(kafka.common.TopicAndPartition, kafka.server.DelayedProduceResponseStatus)" id="kafka.server;DelayedProduce.isSatisfied.satisfied.$anonfun.p">p</a> =&gt; <a href="#kafka.server;DelayedProduce.isSatisfied.satisfied.$anonfun.p" title="(kafka.common.TopicAndPartition, kafka.server.DelayedProduceResponseStatus)">p</a>.<span title="=&gt; kafka.server.DelayedProduceResponseStatus">_2</span>.<a href="#kafka.server;DelayedProduceResponseStatus.acksPending_=" title="=&gt; Boolean">acksPending</a><span class="delimiter">)</span>
    <a href="#kafka.server;DelayedProduce.isSatisfied.satisfied" title="Boolean">satisfied</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

case class <a title="class DelayedProduceResponseStatus extends AnyRef with Product with Serializable" id="kafka.server.DelayedProduceResponseStatus.readResolve">DelayedProduceResponseStatus</a><a href="#kafka.server.DelayedProduceResponseStatus.readResolve" title="Product" class="delimiter">(</a>val <a title="Long" id="kafka.server;DelayedProduceResponseStatus.requiredOffset">requiredOffset</a>: <span title="Long">Long</span>,
                                        val <a title="kafka.api.ProducerResponseStatus" id="kafka.server;DelayedProduceResponseStatus.responseStatus">responseStatus</a>: <a href="../api/ProducerResponse.scala.html#kafka.api;ProducerResponseStatus" title="kafka.api.ProducerResponseStatus">ProducerResponseStatus</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  @volatile var <a title="Boolean" id="kafka.server;DelayedProduceResponseStatus.acksPending_=">acksPending</a> = false

  override def <a title="()String" id="kafka.server;DelayedProduceResponseStatus.toString">toString</a> =
    <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;acksPending:%b, error: %d, startOffset: %d, requiredOffset: %d&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span>
      <a href="#kafka.server;DelayedProduceResponseStatus.acksPending_=" title="=&gt; Boolean">acksPending</a>, <a href="#kafka.server;DelayedProduceResponseStatus.responseStatus" title="=&gt; kafka.api.ProducerResponseStatus">responseStatus</a>.<a href="../api/ProducerResponse.scala.html#kafka.api;ProducerResponseStatus.error" title="=&gt; Short">error</a>, <a href="#kafka.server;DelayedProduceResponseStatus.responseStatus" title="=&gt; kafka.api.ProducerResponseStatus">responseStatus</a>.<a href="../api/ProducerResponse.scala.html#kafka.api;ProducerResponseStatus.offset" title="=&gt; Long">offset</a>, <a href="#kafka.server;DelayedProduceResponseStatus.requiredOffset" title="=&gt; Long">requiredOffset</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
