<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/server/AbstractFetcherThread.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package kafka.server

import kafka.cluster.Broker
import kafka.utils.<span class="delimiter">{</span>Pool, ShutdownableThread<span class="delimiter">}</span>
import kafka.consumer.<span class="delimiter">{</span>PartitionTopicInfo, SimpleConsumer<span class="delimiter">}</span>
import kafka.api.<span class="delimiter">{</span>FetchRequest, FetchResponse, FetchResponsePartitionData, FetchRequestBuilder<span class="delimiter">}</span>
import kafka.common.<span class="delimiter">{</span>KafkaException, ClientIdAndBroker, TopicAndPartition, ErrorMapping<span class="delimiter">}</span>
import kafka.utils.<a href="../utils/Utils.scala.html#kafka.utils.Utils" title="kafka.utils.Utils.type">Utils</a>.inLock
import kafka.message.<span class="delimiter">{</span>InvalidMessageException, ByteBufferMessageSet, MessageAndOffset<span class="delimiter">}</span>
import kafka.metrics.KafkaMetricsGroup

import scala.collection.<span class="delimiter">{</span>mutable, Set, Map<span class="delimiter">}</span>
import java.util.concurrent.TimeUnit
import java.util.concurrent.locks.ReentrantLock
import java.util.concurrent.atomic.AtomicLong

import com.yammer.metrics.core.Gauge

<span class="comment">/**
 *  Abstract class for fetching data from multiple partitions from the same broker.
 */</span>
abstract class <a title="class AbstractFetcherThread extends kafka.utils.ShutdownableThread" id="kafka.server.AbstractFetcherThread">AbstractFetcherThread</a><a href="#kafka.server.AbstractFetcherThread" title="kafka.server.AbstractFetcherThread" class="delimiter">(</a><a title="String" id="kafka.server;AbstractFetcherThread.name">name</a>: <span title="String">String</span>, <a title="String" id="kafka.server;AbstractFetcherThread.clientId">clientId</a>: <span title="String">String</span>, <a title="kafka.cluster.Broker" id="kafka.server;AbstractFetcherThread.sourceBroker">sourceBroker</a>: <a href="../cluster/Broker.scala.html#kafka.cluster;Broker" title="kafka.cluster.Broker">Broker</a>, <a title="Int" id="kafka.server;AbstractFetcherThread.socketTimeout">socketTimeout</a>: <span title="Int">Int</span>, <a title="Int" id="kafka.server;AbstractFetcherThread.socketBufferSize">socketBufferSize</a>: <span title="Int">Int</span>,
                                     <a title="Int" id="kafka.server;AbstractFetcherThread.fetchSize">fetchSize</a>: <span title="Int">Int</span>, <a title="Int" id="kafka.server.AbstractFetcherThread.<init>$default$7">fetcherBrokerId</a>: <span title="Int">Int</span> = -<span title="Int(-1)" class="int">1</span>, <a title="Int" id="kafka.server.AbstractFetcherThread.<init>$default$8">maxWait</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>, <a title="Int" id="kafka.server.AbstractFetcherThread.<init>$default$9">minBytes</a>: <span title="Int">Int</span> = <span title="Int(1)" class="int">1</span>,
                                     <a title="Boolean" id="kafka.server.AbstractFetcherThread.<init>$default$10">isInterruptible</a>: <span title="Boolean">Boolean</span> = true<span class="delimiter">)</span>
  extends <a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread" title="kafka.utils.ShutdownableThread">ShutdownableThread</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.name" title="String">name</a>, <a href="#kafka.server.AbstractFetcherThread.<init>$default$10" title="Boolean">isInterruptible</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  private val <a title="scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Long]" id="kafka.server;AbstractFetcherThread.partitionMap">partitionMap</a> = new mutable.<span title="scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Long]">HashMap</span><span class="delimiter">[</span>TopicAndPartition, Long<span class="delimiter">]</span> <span class="comment">// a (topic, partition) -&gt; offset map</span>
  private val <a title="java.util.concurrent.locks.ReentrantLock" id="kafka.server;AbstractFetcherThread.partitionMapLock">partitionMapLock</a> = new <span title="java.util.concurrent.locks.ReentrantLock">ReentrantLock</span>
  private val <a title="java.util.concurrent.locks.Condition" id="kafka.server;AbstractFetcherThread.partitionMapCond">partitionMapCond</a> = <a href="#kafka.server;AbstractFetcherThread.partitionMapLock" title="=&gt; java.util.concurrent.locks.ReentrantLock">partitionMapLock</a>.<span title="()java.util.concurrent.locks.Condition">newCondition</span><span class="delimiter">(</span><span class="delimiter">)</span>
  val <a title="kafka.consumer.SimpleConsumer" id="kafka.server;AbstractFetcherThread.simpleConsumer">simpleConsumer</a> = new <a href="../consumer/SimpleConsumer.scala.html#kafka.consumer;SimpleConsumer" title="kafka.consumer.SimpleConsumer">SimpleConsumer</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.sourceBroker" title="kafka.cluster.Broker">sourceBroker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.host" title="=&gt; String">host</a>, <a href="#kafka.server;AbstractFetcherThread.sourceBroker" title="kafka.cluster.Broker">sourceBroker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.port" title="=&gt; Int">port</a>, <a href="#kafka.server;AbstractFetcherThread.socketTimeout" title="Int">socketTimeout</a>, <a href="#kafka.server;AbstractFetcherThread.socketBufferSize" title="Int">socketBufferSize</a>, <a href="#kafka.server;AbstractFetcherThread.clientId" title="String">clientId</a><span class="delimiter">)</span>
  private val <a title="kafka.common.ClientIdAndBroker" id="kafka.server;AbstractFetcherThread.metricId">metricId</a> = new <a href="../common/ClientIdAndBroker.scala.html#kafka.common;ClientIdAndBroker" title="kafka.common.ClientIdAndBroker">ClientIdAndBroker</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.clientId" title="String">clientId</a>, <a href="#kafka.server;AbstractFetcherThread.sourceBroker" title="kafka.cluster.Broker">sourceBroker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.host" title="=&gt; String">host</a>, <a href="#kafka.server;AbstractFetcherThread.sourceBroker" title="kafka.cluster.Broker">sourceBroker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.port" title="=&gt; Int">port</a><span class="delimiter">)</span>
  val <a title="kafka.server.FetcherStats" id="kafka.server;AbstractFetcherThread.fetcherStats">fetcherStats</a> = new <a href="#kafka.server;FetcherStats" title="kafka.server.FetcherStats">FetcherStats</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.metricId" title="=&gt; kafka.common.ClientIdAndBroker">metricId</a><span class="delimiter">)</span>
  val <a title="kafka.server.FetcherLagStats" id="kafka.server;AbstractFetcherThread.fetcherLagStats">fetcherLagStats</a> = new <a href="#kafka.server;FetcherLagStats" title="kafka.server.FetcherLagStats">FetcherLagStats</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.metricId" title="=&gt; kafka.common.ClientIdAndBroker">metricId</a><span class="delimiter">)</span>
  val <a title="kafka.api.FetchRequestBuilder" id="kafka.server;AbstractFetcherThread.fetchRequestBuilder">fetchRequestBuilder</a> = new <a href="../api/FetchRequest.scala.html#kafka.api;FetchRequestBuilder" title="kafka.api.FetchRequestBuilder">FetchRequestBuilder</a><span class="delimiter">(</span><span class="delimiter">)</span>.
          <a href="../api/FetchRequest.scala.html#kafka.api;FetchRequestBuilder.clientId(17e2242513)" title="(clientId: String)kafka.api.FetchRequestBuilder">clientId</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.clientId" title="String">clientId</a><span class="delimiter">)</span>.
          <a href="../api/FetchRequest.scala.html#kafka.api;FetchRequestBuilder.replicaId(7eb26614fa)" title="(replicaId: Int)kafka.api.FetchRequestBuilder">replicaId</a><span class="delimiter">(</span><a href="#kafka.server.AbstractFetcherThread.<init>$default$7" title="Int">fetcherBrokerId</a><span class="delimiter">)</span>.
          <a href="../api/FetchRequest.scala.html#kafka.api;FetchRequestBuilder.maxWait(d4d9aed259)" title="(maxWait: Int)kafka.api.FetchRequestBuilder">maxWait</a><span class="delimiter">(</span><a href="#kafka.server.AbstractFetcherThread.<init>$default$8" title="Int">maxWait</a><span class="delimiter">)</span>.
          <a href="../api/FetchRequest.scala.html#kafka.api;FetchRequestBuilder.minBytes(2fa6b5486f)" title="(minBytes: Int)kafka.api.FetchRequestBuilder">minBytes</a><span class="delimiter">(</span><a href="#kafka.server.AbstractFetcherThread.<init>$default$9" title="Int">minBytes</a><span class="delimiter">)</span>

  <span class="comment">/* callbacks to be defined in subclass */</span>

  <span class="comment">// process fetched data</span>
  def <a title="(topicAndPartition: kafka.common.TopicAndPartition, fetchOffset: Long, partitionData: kafka.api.FetchResponsePartitionData)Unit" id="kafka.server;AbstractFetcherThread.processPartitionData">processPartitionData</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;AbstractFetcherThread.processPartitionData.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a>, <a title="Long" id="kafka.server;AbstractFetcherThread.processPartitionData.fetchOffset">fetchOffset</a>: <span title="Long">Long</span>,
                           <a title="kafka.api.FetchResponsePartitionData" id="kafka.server;AbstractFetcherThread.processPartitionData.partitionData">partitionData</a>: <a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData" title="kafka.api.FetchResponsePartitionData">FetchResponsePartitionData</a><span class="delimiter">)</span>

  <span class="comment">// handle a partition whose offset is out of range and return a new fetch offset</span>
  def <a title="(topicAndPartition: kafka.common.TopicAndPartition)Long" id="kafka.server;AbstractFetcherThread.handleOffsetOutOfRange">handleOffsetOutOfRange</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;AbstractFetcherThread.handleOffsetOutOfRange.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">)</span>: <span title="Long">Long</span>

  <span class="comment">// deal with partitions with errors, potentially due to leadership changes</span>
  def <a title="(partitions: Iterable[kafka.common.TopicAndPartition])Unit" id="kafka.server;AbstractFetcherThread.handlePartitionsWithErrors">handlePartitionsWithErrors</a><span class="delimiter">(</span><a title="Iterable[kafka.common.TopicAndPartition]" id="kafka.server;AbstractFetcherThread.handlePartitionsWithErrors.partitions">partitions</a>: <span title="Iterable[kafka.common.TopicAndPartition]">Iterable</span><span class="delimiter">[</span>TopicAndPartition<span class="delimiter">]</span><span class="delimiter">)</span>

  override def <a title="()Unit" id="kafka.server;AbstractFetcherThread.shutdown">shutdown</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">{</span>
    super.<a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread.shutdown" title="()Unit">shutdown</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#kafka.server;AbstractFetcherThread.simpleConsumer" title="=&gt; kafka.consumer.SimpleConsumer">simpleConsumer</a>.<a href="../consumer/SimpleConsumer.scala.html#kafka.consumer;SimpleConsumer.close" title="()Unit">close</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  override def <a title="()Unit" id="kafka.server;AbstractFetcherThread.doWork">doWork</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Utils.scala.html#kafka.utils.Utils.inLock" title="(lock: java.util.concurrent.locks.Lock)(fun: =&gt; Unit)Unit">inLock</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.partitionMapLock" title="=&gt; java.util.concurrent.locks.ReentrantLock">partitionMapLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.partitionMap" title="=&gt; scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Long]">partitionMap</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
        <a href="#kafka.server;AbstractFetcherThread.partitionMapCond" title="=&gt; java.util.concurrent.locks.Condition">partitionMapCond</a>.<span title="(x$1: Long, x$2: java.util.concurrent.TimeUnit)Boolean">await</span><span class="delimiter">(</span><span title="Long(200L)" class="long">200L</span>, TimeUnit.<span title="java.util.concurrent.TimeUnit(MILLISECONDS)">MILLISECONDS</span><span class="delimiter">)</span>
      <a href="#kafka.server;AbstractFetcherThread.partitionMap" title="=&gt; scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Long]">partitionMap</a>.<span title="(f: ((kafka.common.TopicAndPartition, Long)) =&gt; kafka.api.FetchRequestBuilder)Unit">foreach</span> <a href="#kafka.server;AbstractFetcherThread.doWork.$anonfun.x0$1" title="kafka.api.FetchRequestBuilder" class="delimiter">{</a>
        case<span class="delimiter">(</span><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;AbstractFetcherThread.doWork.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="Long" id="kafka.server;AbstractFetcherThread.doWork.$anonfun.offset">offset</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
          <a href="#kafka.server;AbstractFetcherThread.fetchRequestBuilder" title="=&gt; kafka.api.FetchRequestBuilder">fetchRequestBuilder</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequestBuilder.addFetch" title="(topic: String, partition: Int, offset: Long, fetchSize: Int)kafka.api.FetchRequestBuilder">addFetch</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.doWork.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.server;AbstractFetcherThread.doWork.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a>,
                           <a href="#kafka.server;AbstractFetcherThread.doWork.$anonfun.offset" title="Long">offset</a>, <a href="#kafka.server;AbstractFetcherThread.fetchSize" title="Int">fetchSize</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    val <a title="kafka.api.FetchRequest" id="kafka.server;AbstractFetcherThread.doWork.fetchRequest">fetchRequest</a> = <a href="#kafka.server;AbstractFetcherThread.fetchRequestBuilder" title="=&gt; kafka.api.FetchRequestBuilder">fetchRequestBuilder</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequestBuilder.build" title="()kafka.api.FetchRequest">build</a><span class="delimiter">(</span><span class="delimiter">)</span>
    if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.server;AbstractFetcherThread.doWork.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest.requestInfo" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.PartitionFetchInfo]">requestInfo</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
      <a href="#kafka.server;AbstractFetcherThread.processFetchRequest" title="(fetchRequest: kafka.api.FetchRequest)Unit">processFetchRequest</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.doWork.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private def <a title="(fetchRequest: kafka.api.FetchRequest)Unit" id="kafka.server;AbstractFetcherThread.processFetchRequest">processFetchRequest</a><span class="delimiter">(</span><a title="kafka.api.FetchRequest" id="kafka.server;AbstractFetcherThread.processFetchRequest.fetchRequest">fetchRequest</a>: <a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest" title="kafka.api.FetchRequest">FetchRequest</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="scala.collection.mutable.HashSet[kafka.common.TopicAndPartition]" id="kafka.server;AbstractFetcherThread.processFetchRequest.partitionsWithError">partitionsWithError</a> = new mutable.<span title="scala.collection.mutable.HashSet[kafka.common.TopicAndPartition]">HashSet</span><span class="delimiter">[</span>TopicAndPartition<span class="delimiter">]</span>
    var <a title="kafka.api.FetchResponse" id="kafka.server;AbstractFetcherThread.processFetchRequest.response">response</a>: <a href="../api/FetchResponse.scala.html#kafka.api;FetchResponse" title="kafka.api.FetchResponse">FetchResponse</a> = null
    try <span class="delimiter">{</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Issuing to broker %d of fetch request %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.sourceBroker" title="kafka.cluster.Broker">sourceBroker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.id" title="=&gt; Int">id</a>, <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.response" title="kafka.api.FetchResponse">response</a> = <a href="#kafka.server;AbstractFetcherThread.simpleConsumer" title="=&gt; kafka.consumer.SimpleConsumer">simpleConsumer</a>.<a href="../consumer/SimpleConsumer.scala.html#kafka.consumer;SimpleConsumer.fetch" title="(request: kafka.api.FetchRequest)kafka.api.FetchResponse">fetch</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> catch <span class="delimiter">{</span>
      case <a title="Throwable" id="kafka.server;AbstractFetcherThread.processFetchRequest.t">t</a>: <span title="Throwable">Throwable</span> =&gt;
        if <span class="delimiter">(</span><a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread.isRunning" title="=&gt; java.util.concurrent.atomic.AtomicBoolean">isRunning</a>.<span title="()Boolean">get</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Error in fetch %s. Possible cause: %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>, <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.t" title="Throwable">t</a>.<span title="()String">toString</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#kafka.server;AbstractFetcherThread.partitionMapLock" title="=&gt; java.util.concurrent.locks.ReentrantLock">partitionMapLock</a> <span title="(x$1: scala.collection.mutable.HashSet[kafka.common.TopicAndPartition])scala.collection.mutable.HashSet[kafka.common.TopicAndPartition]">synchronized</span> <span class="delimiter">{</span>
            <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.partitionsWithError" title="scala.collection.mutable.HashSet[kafka.common.TopicAndPartition]">partitionsWithError</a> <span title="(xs: scala.collection.TraversableOnce[kafka.common.TopicAndPartition])partitionsWithError.type">++=</span> <a href="#kafka.server;AbstractFetcherThread.partitionMap" title="=&gt; scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Long]">partitionMap</a>.<span title="=&gt; Iterable[kafka.common.TopicAndPartition]">keys</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#kafka.server;AbstractFetcherThread.fetcherStats" title="=&gt; kafka.server.FetcherStats">fetcherStats</a>.<a href="#kafka.server;FetcherStats.requestRate" title="=&gt; com.yammer.metrics.core.Meter">requestRate</a>.<span title="()Unit">mark</span><span class="delimiter">(</span><span class="delimiter">)</span>

    if <span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.response" title="kafka.api.FetchResponse">response</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// process fetched data</span>
      <a href="../utils/Utils.scala.html#kafka.utils.Utils.inLock" title="(lock: java.util.concurrent.locks.Lock)(fun: =&gt; Unit)Unit">inLock</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.partitionMapLock" title="=&gt; java.util.concurrent.locks.ReentrantLock">partitionMapLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.response" title="kafka.api.FetchResponse">response</a>.<a href="../api/FetchResponse.scala.html#kafka.api;FetchResponse.data" title="=&gt; Map[kafka.common.TopicAndPartition,kafka.api.FetchResponsePartitionData]">data</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.api.FetchResponsePartitionData)) =&gt; Any)Unit">foreach</span> <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.x0$2" title="Any" class="delimiter">{</a>
          case<span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="kafka.api.FetchResponsePartitionData" id="kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.partitionData">partitionData</a><span class="delimiter">)</span> =&gt;
            val <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topic" title="(String, Int)" class="delimiter">(</a><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.x$1" title="String" id="kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topic">topic</a>, <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.x$1" title="Int" id="kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.partitionId">partitionId</a><span class="delimiter">)</span> = <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.asTuple" title="=&gt; (String, Int)">asTuple</a>
            val <a title="Option[Long]" id="kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.currentOffset">currentOffset</a> = <a href="#kafka.server;AbstractFetcherThread.partitionMap" title="=&gt; scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Long]">partitionMap</a>.<span title="(key: kafka.common.TopicAndPartition)Option[Long]">get</span><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
            <span class="comment">// we append to the log if the current offset is defined and it is the same as the offset requested during fetch</span>
            if <span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.currentOffset" title="Option[Long]">currentOffset</a>.<span title="=&gt; Boolean">isDefined</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest.requestInfo" title="(key: kafka.common.TopicAndPartition)kafka.api.PartitionFetchInfo">requestInfo</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>.<a href="../api/FetchRequest.scala.html#kafka.api;PartitionFetchInfo.offset" title="=&gt; Long">offset</a> <span title="(x: Long)Boolean">==</span> <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.currentOffset" title="Option[Long]">currentOffset</a>.<span title="=&gt; Long">get</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.partitionData" title="kafka.api.FetchResponsePartitionData">partitionData</a>.<a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData.error" title="=&gt; Short">error</a> match <span class="delimiter">{</span>
                case <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a> =&gt;
                  try <span class="delimiter">{</span>
                    val <a title="kafka.message.ByteBufferMessageSet" id="kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.messages">messages</a> = <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.partitionData" title="kafka.api.FetchResponsePartitionData">partitionData</a>.<a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData.messages" title="=&gt; kafka.message.MessageSet">messages</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.message.ByteBufferMessageSet" class="delimiter">[</span><a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet">ByteBufferMessageSet</a><span class="delimiter">]</span>
                    val <a title="Int" id="kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.validBytes">validBytes</a> = <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.messages" title="kafka.message.ByteBufferMessageSet">messages</a>.<a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet.validBytes" title="=&gt; Int">validBytes</a>
                    val <span title="Long">newOffset</span> = <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.messages" title="kafka.message.ByteBufferMessageSet">messages</a>.<a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet.shallowIterator" title="=&gt; Iterator[kafka.message.MessageAndOffset]">shallowIterator</a>.<span title="=&gt; Seq[kafka.message.MessageAndOffset]">toSeq</span>.<span title="=&gt; Option[kafka.message.MessageAndOffset]">lastOption</span> match <span class="delimiter">{</span>
                      case Some<span class="delimiter">(</span><a title="kafka.message.MessageAndOffset" id="kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.newOffset.m">m</a>: <a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset" title="kafka.message.MessageAndOffset">MessageAndOffset</a><span class="delimiter">)</span> =&gt; <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.newOffset.m" title="kafka.message.MessageAndOffset">m</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.nextOffset" title="=&gt; Long">nextOffset</a>
                      case <span title="None.type">None</span> =&gt; <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.currentOffset" title="Option[Long]">currentOffset</a>.<span title="=&gt; Long">get</span>
                    <span class="delimiter">}</span>
                    <a href="#kafka.server;AbstractFetcherThread.partitionMap" title="=&gt; scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Long]">partitionMap</a>.<span title="(key: kafka.common.TopicAndPartition, value: Long)Option[Long]">put</span><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <span title="Long">newOffset</span><span class="delimiter">)</span>
                    <a href="#kafka.server;AbstractFetcherThread.fetcherLagStats" title="=&gt; kafka.server.FetcherLagStats">fetcherLagStats</a>.<a href="#kafka.server;FetcherLagStats.getFetcherLagStats" title="(topic: String, partitionId: Int)kafka.server.FetcherLagMetrics">getFetcherLagStats</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topic" title="String">topic</a>, <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.partitionId" title="Int">partitionId</a><span class="delimiter">)</span>.<a href="#kafka.server;FetcherLagMetrics.lag_=" title="(newLag: Long)Unit">lag</a> = <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.partitionData" title="kafka.api.FetchResponsePartitionData">partitionData</a>.<a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData.hw" title="=&gt; Long">hw</a> <span title="(x: Long)Long">-</span> <span title="Long">newOffset</span>
                    <a href="#kafka.server;AbstractFetcherThread.fetcherStats" title="=&gt; kafka.server.FetcherStats">fetcherStats</a>.<a href="#kafka.server;FetcherStats.byteRate" title="=&gt; com.yammer.metrics.core.Meter">byteRate</a>.<span title="(x$1: Long)Unit">mark</span><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.validBytes" title="=&gt; Long">validBytes</a><span class="delimiter">)</span>
                    <span class="comment">// Once we hand off the partition data to the subclass, we can't mess with it any more in this thread</span>
                    <a href="#kafka.server;AbstractFetcherThread.processPartitionData" title="(topicAndPartition: kafka.common.TopicAndPartition, fetchOffset: Long, partitionData: kafka.api.FetchResponsePartitionData)Unit">processPartitionData</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.currentOffset" title="Option[Long]">currentOffset</a>.<span title="=&gt; Long">get</span>, <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.partitionData" title="kafka.api.FetchResponsePartitionData">partitionData</a><span class="delimiter">)</span>
                  <span class="delimiter">}</span> catch <span class="delimiter">{</span>
                    case <a title="kafka.message.InvalidMessageException" id="kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.ime">ime</a>: <a href="../message/InvalidMessageException.scala.html#kafka.message;InvalidMessageException" title="kafka.message.InvalidMessageException">InvalidMessageException</a> =&gt;
                      <span class="comment">// we log the error and continue. This ensures two things</span>
                      <span class="comment">// 1. If there is a corrupt message in a topic partition, it does not bring the fetcher thread down and cause other topic partition to also lag</span>
                      <span class="comment">// 2. If the message is corrupt due to a transient state in the log (truncation, partial writes can cause this), we simply continue and</span>
                      <span class="comment">//    should get fixed in the subsequent fetches</span>
                      <a href="../utils/Logging.scala.html#kafka.utils;Logging.logger" title="=&gt; org.apache.log4j.Logger">logger</a>.<span title="(x$1: Any)Unit">error</span><span class="delimiter">(</span><span title="String(&quot;Found invalid messages during fetch for partition [&quot;)" class="string">&quot;Found invalid messages during fetch for partition [&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topic" title="String">topic</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.partitionId" title="Int">partitionId</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;] offset &quot;)" class="string">&quot;] offset &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.currentOffset" title="Option[Long]">currentOffset</a>.<span title="=&gt; Long">get</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; error &quot;)" class="string">&quot; error &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.ime" title="kafka.message.InvalidMessageException">ime</a>.<span title="()String">getMessage</span><span class="delimiter">)</span>
                    case <span title="Throwable">e</span>: <span title="Throwable">Throwable</span> =&gt;
                      throw new <a href="../common/KafkaException.scala.html#kafka.common;KafkaException" title="kafka.common.KafkaException">KafkaException</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;error processing data for partition [%s,%d] offset %d&quot;</span>
                                               .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topic" title="String">topic</a>, <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.partitionId" title="Int">partitionId</a>, <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.currentOffset" title="Option[Long]">currentOffset</a>.<span title="=&gt; Long">get</span><span class="delimiter">)</span>, <span title="Throwable">e</span><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
                case <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.OffsetOutOfRangeCode" title="=&gt; Short">OffsetOutOfRangeCode</a> =&gt;
                  try <span class="delimiter">{</span>
                    val <span title="Long">newOffset</span> = <a href="#kafka.server;AbstractFetcherThread.handleOffsetOutOfRange" title="(topicAndPartition: kafka.common.TopicAndPartition)Long">handleOffsetOutOfRange</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
                    <a href="#kafka.server;AbstractFetcherThread.partitionMap" title="=&gt; scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Long]">partitionMap</a>.<span title="(key: kafka.common.TopicAndPartition, value: Long)Option[Long]">put</span><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <span title="Long">newOffset</span><span class="delimiter">)</span>
                    <a href="../utils/Logging.scala.html#kafka.utils;Logging.error(1729dbc42f)" title="(msg: =&gt; String)Unit">error</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Current offset %d for partition [%s,%d] out of range; reset offset to %d&quot;</span>
                      .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.currentOffset" title="Option[Long]">currentOffset</a>.<span title="=&gt; Long">get</span>, <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topic" title="String">topic</a>, <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.partitionId" title="Int">partitionId</a>, <span title="Long">newOffset</span><span class="delimiter">)</span><span class="delimiter">)</span>
                  <span class="delimiter">}</span> catch <span class="delimiter">{</span>
                    case <span title="Throwable">e</span>: <span title="Throwable">Throwable</span> =&gt;
                      <a href="../utils/Logging.scala.html#kafka.utils;Logging.error(cfd112d89b)" title="(msg: =&gt; String, e: =&gt; Throwable)Unit">error</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Error getting offset for partition [%s,%d] to broker %d&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topic" title="String">topic</a>, <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.partitionId" title="Int">partitionId</a>, <a href="#kafka.server;AbstractFetcherThread.sourceBroker" title="kafka.cluster.Broker">sourceBroker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.id" title="=&gt; Int">id</a><span class="delimiter">)</span>, <span title="Throwable">e</span><span class="delimiter">)</span>
                      <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.partitionsWithError" title="scala.collection.mutable.HashSet[kafka.common.TopicAndPartition]">partitionsWithError</a> <span title="(elem: kafka.common.TopicAndPartition)partitionsWithError.type">+=</span> <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>
                  <span class="delimiter">}</span>
                case _ =&gt;
                  if <span class="delimiter">(</span><a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread.isRunning" title="=&gt; java.util.concurrent.atomic.AtomicBoolean">isRunning</a>.<span title="()Boolean">get</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="../utils/Logging.scala.html#kafka.utils;Logging.error(1729dbc42f)" title="(msg: =&gt; String)Unit">error</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Error for partition [%s,%d] to broker %d:%s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topic" title="String">topic</a>, <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.partitionId" title="Int">partitionId</a>, <a href="#kafka.server;AbstractFetcherThread.sourceBroker" title="kafka.cluster.Broker">sourceBroker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.id" title="=&gt; Int">id</a>,
                      <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.exceptionFor" title="(code: Short)Throwable">exceptionFor</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.partitionData" title="kafka.api.FetchResponsePartitionData">partitionData</a>.<a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData.error" title="=&gt; Short">error</a><span class="delimiter">)</span>.<span title="()Class[_]">getClass</span><span class="delimiter">)</span><span class="delimiter">)</span>
                    <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.partitionsWithError" title="scala.collection.mutable.HashSet[kafka.common.TopicAndPartition]">partitionsWithError</a> <span title="(elem: kafka.common.TopicAndPartition)partitionsWithError.type">+=</span> <a href="#kafka.server;AbstractFetcherThread.processFetchRequest.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>
                  <span class="delimiter">}</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    if<span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.partitionsWithError" title="scala.collection.mutable.HashSet[kafka.common.TopicAndPartition]">partitionsWithError</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;handling partitions with error for %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.partitionsWithError" title="scala.collection.mutable.HashSet[kafka.common.TopicAndPartition]">partitionsWithError</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.server;AbstractFetcherThread.handlePartitionsWithErrors" title="(partitions: Iterable[kafka.common.TopicAndPartition])Unit">handlePartitionsWithErrors</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.processFetchRequest.partitionsWithError" title="scala.collection.mutable.HashSet[kafka.common.TopicAndPartition]">partitionsWithError</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(partitionAndOffsets: scala.collection.Map[kafka.common.TopicAndPartition,Long])Unit" id="kafka.server;AbstractFetcherThread.addPartitions">addPartitions</a><span class="delimiter">(</span><a title="scala.collection.Map[kafka.common.TopicAndPartition,Long]" id="kafka.server;AbstractFetcherThread.addPartitions.partitionAndOffsets">partitionAndOffsets</a>: <span title="scala.collection.Map[kafka.common.TopicAndPartition,Long]">Map</span><span class="delimiter">[</span>TopicAndPartition, Long<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.server;AbstractFetcherThread.partitionMapLock" title="=&gt; java.util.concurrent.locks.ReentrantLock">partitionMapLock</a>.<span title="()Unit">lockInterruptibly</span><span class="delimiter">(</span><span class="delimiter">)</span>
    try <span class="delimiter">{</span>
      for <span class="delimiter">(</span><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;AbstractFetcherThread.addPartitions.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="Long" id="kafka.server;AbstractFetcherThread.addPartitions.$anonfun.offset">offset</a><span class="delimiter">)</span> &lt;- <a href="#kafka.server;AbstractFetcherThread.addPartitions.partitionAndOffsets" title="(f: ((kafka.common.TopicAndPartition, Long)) =&gt; Any)Unit">partitionAndOffsets</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// If the partitionMap already has the topic/partition, then do not update the map with the old offset</span>
        if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.server;AbstractFetcherThread.partitionMap" title="=&gt; scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Long]">partitionMap</a>.<span title="(key: kafka.common.TopicAndPartition)Boolean">contains</span><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.addPartitions.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#kafka.server;AbstractFetcherThread.partitionMap" title="=&gt; scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Long]">partitionMap</a>.<span title="(key: kafka.common.TopicAndPartition, value: Long)Option[Long]">put</span><span class="delimiter">(</span>
            <a href="#kafka.server;AbstractFetcherThread.addPartitions.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>,
            if <span class="delimiter">(</span><a href="../consumer/PartitionTopicInfo.scala.html#kafka.consumer.PartitionTopicInfo" title="kafka.consumer.PartitionTopicInfo.type">PartitionTopicInfo</a>.<a href="../consumer/PartitionTopicInfo.scala.html#kafka.consumer.PartitionTopicInfo.isOffsetInvalid" title="(offset: Long)Boolean">isOffsetInvalid</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.addPartitions.$anonfun.offset" title="Long">offset</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#kafka.server;AbstractFetcherThread.handleOffsetOutOfRange" title="(topicAndPartition: kafka.common.TopicAndPartition)Long">handleOffsetOutOfRange</a><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.addPartitions.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span> else <a href="#kafka.server;AbstractFetcherThread.addPartitions.$anonfun.offset" title="Long">offset</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#kafka.server;AbstractFetcherThread.partitionMapCond" title="=&gt; java.util.concurrent.locks.Condition">partitionMapCond</a>.<span title="()Unit">signalAll</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> finally <span class="delimiter">{</span>
      <a href="#kafka.server;AbstractFetcherThread.partitionMapLock" title="=&gt; java.util.concurrent.locks.ReentrantLock">partitionMapLock</a>.<span title="()Unit">unlock</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(topicAndPartitions: scala.collection.Set[kafka.common.TopicAndPartition])Unit" id="kafka.server;AbstractFetcherThread.removePartitions">removePartitions</a><span class="delimiter">(</span><a title="scala.collection.Set[kafka.common.TopicAndPartition]" id="kafka.server;AbstractFetcherThread.removePartitions.topicAndPartitions">topicAndPartitions</a>: <span title="scala.collection.Set[kafka.common.TopicAndPartition]">Set</span><span class="delimiter">[</span>TopicAndPartition<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.server;AbstractFetcherThread.partitionMapLock" title="=&gt; java.util.concurrent.locks.ReentrantLock">partitionMapLock</a>.<span title="()Unit">lockInterruptibly</span><span class="delimiter">(</span><span class="delimiter">)</span>
    try <span class="delimiter">{</span>
      <a href="#kafka.server;AbstractFetcherThread.removePartitions.topicAndPartitions" title="scala.collection.Set[kafka.common.TopicAndPartition]">topicAndPartitions</a>.<span title="(f: kafka.common.TopicAndPartition =&gt; Option[Long])Unit">foreach</span><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;AbstractFetcherThread.removePartitions.$anonfun.tp">tp</a> =&gt; <a href="#kafka.server;AbstractFetcherThread.partitionMap" title="=&gt; scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Long]">partitionMap</a>.<span title="(key: kafka.common.TopicAndPartition)Option[Long]">remove</span><span class="delimiter">(</span><a href="#kafka.server;AbstractFetcherThread.removePartitions.$anonfun.tp" title="kafka.common.TopicAndPartition">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> finally <span class="delimiter">{</span>
      <a href="#kafka.server;AbstractFetcherThread.partitionMapLock" title="=&gt; java.util.concurrent.locks.ReentrantLock">partitionMapLock</a>.<span title="()Unit">unlock</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="()Int" id="kafka.server;AbstractFetcherThread.partitionCount">partitionCount</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#kafka.server;AbstractFetcherThread.partitionMapLock" title="=&gt; java.util.concurrent.locks.ReentrantLock">partitionMapLock</a>.<span title="()Unit">lockInterruptibly</span><span class="delimiter">(</span><span class="delimiter">)</span>
    try <span class="delimiter">{</span>
      <a href="#kafka.server;AbstractFetcherThread.partitionMap" title="=&gt; scala.collection.mutable.HashMap[kafka.common.TopicAndPartition,Long]">partitionMap</a>.<span title="=&gt; Int">size</span>
    <span class="delimiter">}</span> finally <span class="delimiter">{</span>
      <a href="#kafka.server;AbstractFetcherThread.partitionMapLock" title="=&gt; java.util.concurrent.locks.ReentrantLock">partitionMapLock</a>.<span title="()Unit">unlock</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

class <a title="class FetcherLagMetrics extends AnyRef with kafka.metrics.KafkaMetricsGroup" id="kafka.server;FetcherLagMetrics">FetcherLagMetrics</a><a href="#kafka.server;FetcherLagMetrics" title="kafka.server.FetcherLagMetrics" class="delimiter">(</a><a title="kafka.server.ClientIdTopicPartition" id="kafka.server;FetcherLagMetrics.metricId">metricId</a>: <a href="#kafka.server.ClientIdTopicPartition.readResolve" title="kafka.server.ClientIdTopicPartition">ClientIdTopicPartition</a><span class="delimiter">)</span> extends <a href="../metrics/KafkaMetricsGroup.scala.html#kafka.metrics;KafkaMetricsGroup" title="kafka.metrics.KafkaMetricsGroup">KafkaMetricsGroup</a> <span class="delimiter">{</span>
  private<span class="delimiter">[</span>this<span class="delimiter">]</span> val <a title="java.util.concurrent.atomic.AtomicLong" id="kafka.server;FetcherLagMetrics.lagVal">lagVal</a> = new <span title="java.util.concurrent.atomic.AtomicLong">AtomicLong</span><span class="delimiter">(</span>-<span title="Long(-1L)" class="long">1L</span><span class="delimiter">)</span>
  <a href="../metrics/KafkaMetricsGroup.scala.html#kafka.metrics;KafkaMetricsGroup.newGauge" title="(name: String, metric: com.yammer.metrics.core.Gauge[Long], tags: scala.collection.Map[String,String])com.yammer.metrics.core.Gauge[Long]">newGauge</a><span class="delimiter">(</span><span title="String(&quot;ConsumerLag&quot;)" class="string">&quot;ConsumerLag&quot;</span>,
    new <a title="&lt;$anon: com.yammer.metrics.core.Gauge[Long]&gt; extends com.yammer.metrics.core.Gauge[Long]" id="kafka.server;FetcherLagMetrics.<local FetcherLagMetrics>;$anon">Gauge</a><span class="delimiter">[</span>Long<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="()Long" id="kafka.server;FetcherLagMetrics.<local FetcherLagMetrics>;$anon.value">value</a> = <a href="#kafka.server;FetcherLagMetrics.lagVal" title="java.util.concurrent.atomic.AtomicLong">lagVal</a>.<span title="()Long">get</span>
    <span class="delimiter">}</span>,
    <span title="(elems: (String, String)*)scala.collection.Map[String,String]">Map</span><span class="delimiter">(</span><span title="(self: String)ArrowAssoc[String]" class="string">&quot;clientId&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <a href="#kafka.server;FetcherLagMetrics.metricId" title="kafka.server.ClientIdTopicPartition">metricId</a>.<a href="#kafka.server;ClientIdTopicPartition.clientId" title="=&gt; String">clientId</a>,
      <span title="(self: String)ArrowAssoc[String]" class="string">&quot;topic&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <a href="#kafka.server;FetcherLagMetrics.metricId" title="kafka.server.ClientIdTopicPartition">metricId</a>.<a href="#kafka.server;ClientIdTopicPartition.topic" title="=&gt; String">topic</a>,
      <span title="(self: String)ArrowAssoc[String]" class="string">&quot;partition&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <a href="#kafka.server;FetcherLagMetrics.metricId" title="kafka.server.ClientIdTopicPartition">metricId</a>.<a href="#kafka.server;ClientIdTopicPartition.partitionId" title="=&gt; Int">partitionId</a>.<span title="()String">toString</span><span class="delimiter">)</span>
  <span class="delimiter">)</span>

  def <a title="(newLag: Long)Unit" id="kafka.server;FetcherLagMetrics.lag_=">lag_=</a><span class="delimiter">(</span><a title="Long" id="kafka.server;FetcherLagMetrics.lag_=.newLag">newLag</a>: <span title="Long">Long</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.server;FetcherLagMetrics.lagVal" title="java.util.concurrent.atomic.AtomicLong">lagVal</a>.<span title="(x$1: Long)Unit">set</span><span class="delimiter">(</span><a href="#kafka.server;FetcherLagMetrics.lag_=.newLag" title="Long">newLag</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="=&gt; Long" id="kafka.server;FetcherLagMetrics.lag">lag</a> = <a href="#kafka.server;FetcherLagMetrics.lagVal" title="java.util.concurrent.atomic.AtomicLong">lagVal</a>.<span title="()Long">get</span>
<span class="delimiter">}</span>

class <a title="class FetcherLagStats extends AnyRef" id="kafka.server;FetcherLagStats">FetcherLagStats</a><a href="#kafka.server;FetcherLagStats" title="kafka.server.FetcherLagStats" class="delimiter">(</a><a title="kafka.common.ClientIdAndBroker" id="kafka.server;FetcherLagStats.metricId">metricId</a>: <a href="../common/ClientIdAndBroker.scala.html#kafka.common;ClientIdAndBroker" title="kafka.common.ClientIdAndBroker">ClientIdAndBroker</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  private val <a title="kafka.server.ClientIdTopicPartition =&gt; kafka.server.FetcherLagMetrics" id="kafka.server;FetcherLagStats.valueFactory">valueFactory</a> = <span class="delimiter">(</span>k: <a href="#kafka.server.ClientIdTopicPartition.readResolve" title="kafka.server.ClientIdTopicPartition">ClientIdTopicPartition</a><span class="delimiter">)</span> =&gt; new <a href="#kafka.server;FetcherLagMetrics" title="kafka.server.FetcherLagMetrics">FetcherLagMetrics</a><span class="delimiter">(</span><a href="#kafka.server;FetcherLagStats.valueFactory.$anonfun.k" title="kafka.server.ClientIdTopicPartition">k</a><span class="delimiter">)</span>
  val <a title="kafka.utils.Pool[kafka.server.ClientIdTopicPartition,kafka.server.FetcherLagMetrics]" id="kafka.server;FetcherLagStats.stats">stats</a> = new <a href="../utils/Pool.scala.html#kafka.utils;Pool" title="kafka.utils.Pool[kafka.server.ClientIdTopicPartition,kafka.server.FetcherLagMetrics]">Pool</a><span class="delimiter">[</span>ClientIdTopicPartition, FetcherLagMetrics<span class="delimiter">]</span><span class="delimiter">(</span><span title="(x: kafka.server.ClientIdTopicPartition =&gt; kafka.server.FetcherLagMetrics)Some[kafka.server.ClientIdTopicPartition =&gt; kafka.server.FetcherLagMetrics]">Some</span><span class="delimiter">(</span><a href="#kafka.server;FetcherLagStats.valueFactory" title="=&gt; kafka.server.ClientIdTopicPartition =&gt; kafka.server.FetcherLagMetrics">valueFactory</a><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="(topic: String, partitionId: Int)kafka.server.FetcherLagMetrics" id="kafka.server;FetcherLagStats.getFetcherLagStats">getFetcherLagStats</a><span class="delimiter">(</span><a title="String" id="kafka.server;FetcherLagStats.getFetcherLagStats.topic">topic</a>: <span title="String">String</span>, <a title="Int" id="kafka.server;FetcherLagStats.getFetcherLagStats.partitionId">partitionId</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#kafka.server;FetcherLagMetrics" title="kafka.server.FetcherLagMetrics">FetcherLagMetrics</a> = <span class="delimiter">{</span>
    <a href="#kafka.server;FetcherLagStats.stats" title="=&gt; kafka.utils.Pool[kafka.server.ClientIdTopicPartition,kafka.server.FetcherLagMetrics]">stats</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.getAndMaybePut" title="(key: kafka.server.ClientIdTopicPartition)kafka.server.FetcherLagMetrics">getAndMaybePut</a><span class="delimiter">(</span>new <a href="#kafka.server.ClientIdTopicPartition.readResolve" title="kafka.server.ClientIdTopicPartition">ClientIdTopicPartition</a><span class="delimiter">(</span><a href="#kafka.server;FetcherLagStats.metricId" title="kafka.common.ClientIdAndBroker">metricId</a>.<a href="../common/ClientIdAndBroker.scala.html#kafka.common;ClientIdAndBroker.clientId" title="=&gt; String">clientId</a>, <a href="#kafka.server;FetcherLagStats.getFetcherLagStats.topic" title="String">topic</a>, <a href="#kafka.server;FetcherLagStats.getFetcherLagStats.partitionId" title="Int">partitionId</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

class <a title="class FetcherStats extends AnyRef with kafka.metrics.KafkaMetricsGroup" id="kafka.server;FetcherStats">FetcherStats</a><a href="#kafka.server;FetcherStats" title="kafka.server.FetcherStats" class="delimiter">(</a><a title="kafka.common.ClientIdAndBroker" id="kafka.server;FetcherStats.metricId">metricId</a>: <a href="../common/ClientIdAndBroker.scala.html#kafka.common;ClientIdAndBroker" title="kafka.common.ClientIdAndBroker">ClientIdAndBroker</a><span class="delimiter">)</span> extends <a href="../metrics/KafkaMetricsGroup.scala.html#kafka.metrics;KafkaMetricsGroup" title="kafka.metrics.KafkaMetricsGroup">KafkaMetricsGroup</a> <span class="delimiter">{</span>
  val <a title="scala.collection.Map[String,String]" id="kafka.server;FetcherStats.tags">tags</a> = <span title="(elems: (String, String)*)scala.collection.Map[String,String]">Map</span><span class="delimiter">(</span><span title="(self: String)ArrowAssoc[String]" class="string">&quot;clientId&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <a href="#kafka.server;FetcherStats.metricId" title="kafka.common.ClientIdAndBroker">metricId</a>.<a href="../common/ClientIdAndBroker.scala.html#kafka.common;ClientIdAndBroker.clientId" title="=&gt; String">clientId</a>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;brokerHost&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <a href="#kafka.server;FetcherStats.metricId" title="kafka.common.ClientIdAndBroker">metricId</a>.<a href="../common/ClientIdAndBroker.scala.html#kafka.common;ClientIdAndBroker.brokerHost" title="=&gt; String">brokerHost</a>,
    <span title="(self: String)ArrowAssoc[String]" class="string">&quot;brokerPort&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <a href="#kafka.server;FetcherStats.metricId" title="kafka.common.ClientIdAndBroker">metricId</a>.<a href="../common/ClientIdAndBroker.scala.html#kafka.common;ClientIdAndBroker.brokerPort" title="=&gt; Int">brokerPort</a>.<span title="()String">toString</span><span class="delimiter">)</span>

  val <a title="com.yammer.metrics.core.Meter" id="kafka.server;FetcherStats.requestRate">requestRate</a> = <a href="../metrics/KafkaMetricsGroup.scala.html#kafka.metrics;KafkaMetricsGroup.newMeter" title="(name: String, eventType: String, timeUnit: java.util.concurrent.TimeUnit, tags: scala.collection.Map[String,String])com.yammer.metrics.core.Meter">newMeter</a><span class="delimiter">(</span><span title="String(&quot;RequestsPerSec&quot;)" class="string">&quot;RequestsPerSec&quot;</span>, <span title="String(&quot;requests&quot;)" class="string">&quot;requests&quot;</span>, TimeUnit.<span title="java.util.concurrent.TimeUnit(SECONDS)">SECONDS</span>, <a href="#kafka.server;FetcherStats.tags" title="=&gt; scala.collection.Map[String,String]">tags</a><span class="delimiter">)</span>

  val <a title="com.yammer.metrics.core.Meter" id="kafka.server;FetcherStats.byteRate">byteRate</a> = <a href="../metrics/KafkaMetricsGroup.scala.html#kafka.metrics;KafkaMetricsGroup.newMeter" title="(name: String, eventType: String, timeUnit: java.util.concurrent.TimeUnit, tags: scala.collection.Map[String,String])com.yammer.metrics.core.Meter">newMeter</a><span class="delimiter">(</span><span title="String(&quot;BytesPerSec&quot;)" class="string">&quot;BytesPerSec&quot;</span>, <span title="String(&quot;bytes&quot;)" class="string">&quot;bytes&quot;</span>, TimeUnit.<span title="java.util.concurrent.TimeUnit(SECONDS)">SECONDS</span>, <a href="#kafka.server;FetcherStats.tags" title="=&gt; scala.collection.Map[String,String]">tags</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

case class <a title="class ClientIdTopicPartition extends AnyRef with Product with Serializable" id="kafka.server.ClientIdTopicPartition.readResolve">ClientIdTopicPartition</a><a href="#kafka.server.ClientIdTopicPartition.readResolve" title="Product" class="delimiter">(</a><a title="String" id="kafka.server;ClientIdTopicPartition.clientId">clientId</a>: <span title="String">String</span>, <a title="String" id="kafka.server;ClientIdTopicPartition.topic">topic</a>: <span title="String">String</span>, <a title="Int" id="kafka.server;ClientIdTopicPartition.partitionId">partitionId</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  override def <a title="()String" id="kafka.server;ClientIdTopicPartition.toString">toString</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%s-%s-%d&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;ClientIdTopicPartition.clientId" title="=&gt; String">clientId</a>, <a href="#kafka.server;ClientIdTopicPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.server;ClientIdTopicPartition.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>
