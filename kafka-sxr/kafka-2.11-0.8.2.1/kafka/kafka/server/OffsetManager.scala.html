<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/server/OffsetManager.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package kafka.server

import org.apache.kafka.common.protocol.types.<span class="delimiter">{</span>Struct, Schema, Field<span class="delimiter">}</span>
import org.apache.kafka.common.protocol.types.<span title="org.apache.kafka.common.protocol.types.Type.type">Type</span>.STRING
import org.apache.kafka.common.protocol.types.<span title="org.apache.kafka.common.protocol.types.Type.type">Type</span>.INT32
import org.apache.kafka.common.protocol.types.<span title="org.apache.kafka.common.protocol.types.Type.type">Type</span>.INT64

import kafka.utils._
import kafka.common._
import kafka.log.<span class="delimiter">{</span>FileMessageSet, LogConfig<span class="delimiter">}</span>
import kafka.message._
import kafka.metrics.KafkaMetricsGroup
import kafka.common.TopicAndPartition
import kafka.tools.MessageFormatter

import scala.Some
import scala.collection._
import java.io.PrintStream
import java.util.concurrent.atomic.AtomicBoolean
import java.nio.ByteBuffer
import java.util.Properties
import java.util.concurrent.TimeUnit

import com.yammer.metrics.core.Gauge
import org.I0Itec.zkclient.ZkClient


<span class="comment">/**
 * Configuration settings for in-built offset management
 * @param maxMetadataSize The maximum allowed metadata for any offset commit.
 * @param loadBufferSize Batch size for reading from the offsets segments when loading offsets into the cache.
 * @param offsetsRetentionMs Offsets older than this retention period will be discarded.
 * @param offsetsRetentionCheckIntervalMs Frequency at which to check for stale offsets.
 * @param offsetsTopicNumPartitions The number of partitions for the offset commit topic (should not change after deployment).
 * @param offsetsTopicSegmentBytes The offsets topic segment bytes should be kept relatively small to facilitate faster
 *                                 log compaction and faster offset loads
 * @param offsetsTopicReplicationFactor The replication factor for the offset commit topic (set higher to ensure availability).
 * @param offsetsTopicCompressionCodec Compression codec for the offsets topic - compression should be turned on in
 *                                     order to achieve &quot;atomic&quot; commits.
 * @param offsetCommitTimeoutMs The offset commit will be delayed until all replicas for the offsets topic receive the
 *                              commit or this timeout is reached. (Similar to the producer request timeout.)
 * @param offsetCommitRequiredAcks The required acks before the commit can be accepted. In general, the default (-1)
 *                                 should not be overridden.
 */</span>
case class <a title="class OffsetManagerConfig extends AnyRef with Product with Serializable" id="kafka.server;OffsetManagerConfig">OffsetManagerConfig</a><a href="#kafka.server;OffsetManagerConfig" title="Product" class="delimiter">(</a><a title="Int" id="kafka.server.OffsetManagerConfig.<init>$default$1">maxMetadataSize</a>: <span title="Int">Int</span> = <a href="#kafka.server.OffsetManagerConfig.readResolve" title="kafka.server.OffsetManagerConfig.type">OffsetManagerConfig</a>.<a href="#kafka.server.OffsetManagerConfig.DefaultMaxMetadataSize" title="=&gt; Int">DefaultMaxMetadataSize</a>,
                               <a title="Int" id="kafka.server.OffsetManagerConfig.<init>$default$2">loadBufferSize</a>: <span title="Int">Int</span> = <a href="#kafka.server.OffsetManagerConfig.readResolve" title="kafka.server.OffsetManagerConfig.type">OffsetManagerConfig</a>.<a href="#kafka.server.OffsetManagerConfig.DefaultLoadBufferSize" title="=&gt; Int">DefaultLoadBufferSize</a>,
                               <a title="Long" id="kafka.server.OffsetManagerConfig.<init>$default$3">offsetsRetentionMs</a>: <span title="Long">Long</span> = <span class="int">24</span>*<span class="int">60</span><span title="Long(86400000L)">*</span><span class="long">60000L</span>,
                               <a title="Long" id="kafka.server.OffsetManagerConfig.<init>$default$4">offsetsRetentionCheckIntervalMs</a>: <span title="Long">Long</span> = <a href="#kafka.server.OffsetManagerConfig.readResolve" title="kafka.server.OffsetManagerConfig.type">OffsetManagerConfig</a>.<a href="#kafka.server.OffsetManagerConfig.DefaultOffsetsRetentionCheckIntervalMs" title="=&gt; Long">DefaultOffsetsRetentionCheckIntervalMs</a>,
                               <a title="Int" id="kafka.server.OffsetManagerConfig.<init>$default$5">offsetsTopicNumPartitions</a>: <span title="Int">Int</span> = <a href="#kafka.server.OffsetManagerConfig.readResolve" title="kafka.server.OffsetManagerConfig.type">OffsetManagerConfig</a>.<a href="#kafka.server.OffsetManagerConfig.DefaultOffsetsTopicNumPartitions" title="=&gt; Int">DefaultOffsetsTopicNumPartitions</a>,
                               <a title="Int" id="kafka.server.OffsetManagerConfig.<init>$default$6">offsetsTopicSegmentBytes</a>: <span title="Int">Int</span> = <a href="#kafka.server.OffsetManagerConfig.readResolve" title="kafka.server.OffsetManagerConfig.type">OffsetManagerConfig</a>.<a href="#kafka.server.OffsetManagerConfig.DefaultOffsetsTopicSegmentBytes" title="=&gt; Int">DefaultOffsetsTopicSegmentBytes</a>,
                               <a title="Short" id="kafka.server.OffsetManagerConfig.<init>$default$7">offsetsTopicReplicationFactor</a>: <span title="Short">Short</span> = <a href="#kafka.server.OffsetManagerConfig.readResolve" title="kafka.server.OffsetManagerConfig.type">OffsetManagerConfig</a>.<a href="#kafka.server.OffsetManagerConfig.DefaultOffsetsTopicReplicationFactor" title="=&gt; Short">DefaultOffsetsTopicReplicationFactor</a>,
                               <a title="kafka.message.CompressionCodec" id="kafka.server.OffsetManagerConfig.<init>$default$8">offsetsTopicCompressionCodec</a>: <a href="../message/CompressionCodec.scala.html#kafka.message;CompressionCodec" title="kafka.message.CompressionCodec">CompressionCodec</a> = <a href="#kafka.server.OffsetManagerConfig.readResolve" title="kafka.server.OffsetManagerConfig.type">OffsetManagerConfig</a>.<a href="#kafka.server.OffsetManagerConfig.DefaultOffsetsTopicCompressionCodec" title="=&gt; kafka.message.NoCompressionCodec.type">DefaultOffsetsTopicCompressionCodec</a>,
                               <a title="Int" id="kafka.server.OffsetManagerConfig.<init>$default$9">offsetCommitTimeoutMs</a>: <span title="Int">Int</span> = <a href="#kafka.server.OffsetManagerConfig.readResolve" title="kafka.server.OffsetManagerConfig.type">OffsetManagerConfig</a>.<a href="#kafka.server.OffsetManagerConfig.DefaultOffsetCommitTimeoutMs" title="=&gt; Int">DefaultOffsetCommitTimeoutMs</a>,
                               <a title="Short" id="kafka.server.OffsetManagerConfig.<init>$default$10">offsetCommitRequiredAcks</a>: <span title="Short">Short</span> = <a href="#kafka.server.OffsetManagerConfig.readResolve" title="kafka.server.OffsetManagerConfig.type">OffsetManagerConfig</a>.<a href="#kafka.server.OffsetManagerConfig.DefaultOffsetCommitRequiredAcks" title="=&gt; Short">DefaultOffsetCommitRequiredAcks</a><span class="delimiter">)</span>

object <a title="kafka.server.OffsetManagerConfig.type" id="kafka.server.OffsetManagerConfig.readResolve">OffsetManagerConfig</a> <a href="#kafka.server.OffsetManagerConfig.readResolve" title="kafka.server.OffsetManagerConfig.type" class="delimiter">{</a>
  val <a title="Int" id="kafka.server.OffsetManagerConfig.DefaultMaxMetadataSize">DefaultMaxMetadataSize</a> = <span title="Int(4096)" class="int">4096</span>
  val DefaultLoadBufferSize = <span class="int">5</span>*<span class="int">1024</span><a title="Int" id="kafka.server.OffsetManagerConfig.DefaultLoadBufferSize">*</a><span class="int">1024</span>
  val <a title="Long" id="kafka.server.OffsetManagerConfig.DefaultOffsetsRetentionCheckIntervalMs">DefaultOffsetsRetentionCheckIntervalMs</a> = <span title="Long(600000L)" class="long">600000L</span>
  val <a title="Int" id="kafka.server.OffsetManagerConfig.DefaultOffsetsTopicNumPartitions">DefaultOffsetsTopicNumPartitions</a> = <span title="Int(50)" class="int">50</span>
  val DefaultOffsetsTopicSegmentBytes = <span class="int">100</span>*<span class="int">1024</span><a title="Int" id="kafka.server.OffsetManagerConfig.DefaultOffsetsTopicSegmentBytes">*</a><span class="int">1024</span>
  val <a title="Short" id="kafka.server.OffsetManagerConfig.DefaultOffsetsTopicReplicationFactor">DefaultOffsetsTopicReplicationFactor</a> = <span title="Int(3)" class="int">3</span>.<span title="=&gt; Short">toShort</span>
  val <a title="kafka.message.NoCompressionCodec.type" id="kafka.server.OffsetManagerConfig.DefaultOffsetsTopicCompressionCodec">DefaultOffsetsTopicCompressionCodec</a> = <a href="../message/CompressionCodec.scala.html#kafka.message.NoCompressionCodec" title="kafka.message.NoCompressionCodec.type">NoCompressionCodec</a>
  val <a title="Int" id="kafka.server.OffsetManagerConfig.DefaultOffsetCommitTimeoutMs">DefaultOffsetCommitTimeoutMs</a> = <span title="Int(5000)" class="int">5000</span>
  val <a title="Short" id="kafka.server.OffsetManagerConfig.DefaultOffsetCommitRequiredAcks">DefaultOffsetCommitRequiredAcks</a> = <span class="delimiter">(</span>-<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span>.<span title="=&gt; Short">toShort</span>
<span class="delimiter">}</span>

class <a title="class OffsetManager extends AnyRef with kafka.utils.Logging with kafka.metrics.KafkaMetricsGroup" id="kafka.server;OffsetManager">OffsetManager</a><a href="#kafka.server;OffsetManager" title="kafka.server.OffsetManager" class="delimiter">(</a>val <a title="kafka.server.OffsetManagerConfig" id="kafka.server;OffsetManager.config">config</a>: <a href="#kafka.server;OffsetManagerConfig" title="kafka.server.OffsetManagerConfig">OffsetManagerConfig</a>,
                    <a title="kafka.server.ReplicaManager" id="kafka.server;OffsetManager.replicaManager">replicaManager</a>: <a href="ReplicaManager.scala.html#kafka.server;ReplicaManager" title="kafka.server.ReplicaManager">ReplicaManager</a>,
                    <a title="org.I0Itec.zkclient.ZkClient" id="kafka.server;OffsetManager.zkClient">zkClient</a>: <span title="org.I0Itec.zkclient.ZkClient">ZkClient</span>,
                    <a title="kafka.utils.Scheduler" id="kafka.server;OffsetManager.scheduler">scheduler</a>: <a href="../utils/KafkaScheduler.scala.html#kafka.utils;Scheduler" title="kafka.utils.Scheduler">Scheduler</a><span class="delimiter">)</span> extends <a href="../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> with <a href="../metrics/KafkaMetricsGroup.scala.html#kafka.metrics;KafkaMetricsGroup" title="kafka.metrics.KafkaMetricsGroup">KafkaMetricsGroup</a> <span class="delimiter">{</span>

  <span class="comment">/* offsets and metadata cache */</span>
  private val <a title="kafka.utils.Pool[kafka.server.GroupTopicPartition,kafka.common.OffsetAndMetadata]" id="kafka.server;OffsetManager.offsetsCache">offsetsCache</a> = new <a href="../utils/Pool.scala.html#kafka.utils;Pool" title="kafka.utils.Pool[kafka.server.GroupTopicPartition,kafka.common.OffsetAndMetadata]">Pool</a><span class="delimiter">[</span>GroupTopicPartition, OffsetAndMetadata<span class="delimiter">]</span>
  private val <a title="Object" id="kafka.server;OffsetManager.followerTransitionLock">followerTransitionLock</a> = new <span title="Object">Object</span>

  private val <a title="scala.collection.mutable.Set[Int]" id="kafka.server;OffsetManager.loadingPartitions">loadingPartitions</a>: mutable.<span title="scala.collection.mutable.Set[Int]">Set</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> = mutable.<span title="(elems: Int*)scala.collection.mutable.Set[Int]">Set</span><span class="delimiter">(</span><span class="delimiter">)</span>

  private val <a title="java.util.concurrent.atomic.AtomicBoolean" id="kafka.server;OffsetManager.shuttingDown">shuttingDown</a> = new <span title="java.util.concurrent.atomic.AtomicBoolean">AtomicBoolean</span><span class="delimiter">(</span>false<span class="delimiter">)</span>

  <a href="#kafka.server;OffsetManager.scheduler" title="kafka.utils.Scheduler">scheduler</a>.<a href="../utils/KafkaScheduler.scala.html#kafka.utils;Scheduler.schedule$default$3" title="Long" id="kafka.server;OffsetManager.<local OffsetManager>.x$10">schedule</a><span class="delimiter">(</span>name = <a title="String" id="kafka.server;OffsetManager.<local OffsetManager>.x$6" class="string">&quot;offsets-cache-compactor&quot;</a>,
                     fun = <a href="#kafka.server;OffsetManager.compact" title="() =&gt; Unit" id="kafka.server;OffsetManager.<local OffsetManager>.x$7">compact</a>,
                     period = <a href="#kafka.server;OffsetManager.config" title="=&gt; kafka.server.OffsetManagerConfig">config</a>.<a href="#kafka.server.OffsetManagerConfig.<init>$default$4" title="Long" id="kafka.server;OffsetManager.<local OffsetManager>.x$8">offsetsRetentionCheckIntervalMs</a>,
                     unit = TimeUnit.<a title="java.util.concurrent.TimeUnit" id="kafka.server;OffsetManager.<local OffsetManager>.x$9">MILLISECONDS</a><span class="delimiter">)</span>

  <a href="../metrics/KafkaMetricsGroup.scala.html#kafka.metrics;KafkaMetricsGroup.newGauge" title="(name: String, metric: com.yammer.metrics.core.Gauge[Int], tags: scala.collection.Map[String,String])com.yammer.metrics.core.Gauge[Int]">newGauge</a><span class="delimiter">(</span><span title="String(&quot;NumOffsets&quot;)" class="string">&quot;NumOffsets&quot;</span>,
    new <span title="&lt;$anon: com.yammer.metrics.core.Gauge[Int]&gt; extends com.yammer.metrics.core.Gauge[Int]">Gauge</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <span title="()Int">value</span> = <a href="#kafka.server;OffsetManager.offsetsCache" title="=&gt; kafka.utils.Pool[kafka.server.GroupTopicPartition,kafka.common.OffsetAndMetadata]">offsetsCache</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.size" title="=&gt; Int">size</a>
    <span class="delimiter">}</span>
  <span class="delimiter">)</span>

  <a href="../metrics/KafkaMetricsGroup.scala.html#kafka.metrics;KafkaMetricsGroup.newGauge" title="(name: String, metric: com.yammer.metrics.core.Gauge[Int], tags: scala.collection.Map[String,String])com.yammer.metrics.core.Gauge[Int]">newGauge</a><span class="delimiter">(</span><span title="String(&quot;NumGroups&quot;)" class="string">&quot;NumGroups&quot;</span>,
    new <span title="&lt;$anon: com.yammer.metrics.core.Gauge[Int]&gt; extends com.yammer.metrics.core.Gauge[Int]">Gauge</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <span title="()Int">value</span> = <a href="#kafka.server;OffsetManager.offsetsCache" title="=&gt; kafka.utils.Pool[kafka.server.GroupTopicPartition,kafka.common.OffsetAndMetadata]">offsetsCache</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.keys" title="=&gt; scala.collection.mutable.Set[kafka.server.GroupTopicPartition]">keys</a>.<span title="(f: kafka.server.GroupTopicPartition =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.Set[kafka.server.GroupTopicPartition],String,scala.collection.mutable.Set[String]])scala.collection.mutable.Set[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.mutable.Set.Coll,String,scala.collection.mutable.Set[String]]" class="delimiter">(</span><a href="#kafka.server;OffsetManager.<local OffsetManager>;$anon.value.$anonfun.x$1" title="kafka.server.GroupTopicPartition">_</a>.<a href="#kafka.server;GroupTopicPartition.group" title="=&gt; String">group</a><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[String]">toSet</span>.<span title="=&gt; Int">size</span>
    <span class="delimiter">}</span>
  <span class="delimiter">)</span>

  private def <a title="()Unit" id="kafka.server;OffsetManager.compact">compact</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Compacting offsets cache.&quot;)" class="string">&quot;Compacting offsets cache.&quot;</span><span class="delimiter">)</span>
    val <a title="Long" id="kafka.server;OffsetManager.compact.startMs">startMs</a> = <a href="../utils/Time.scala.html#kafka.utils.SystemTime" title="kafka.utils.SystemTime.type">SystemTime</a>.<a href="../utils/Time.scala.html#kafka.utils.SystemTime.milliseconds" title="=&gt; Long">milliseconds</a>

    val <a title="Iterable[(kafka.server.GroupTopicPartition, kafka.common.OffsetAndMetadata)]" id="kafka.server;OffsetManager.compact.staleOffsets">staleOffsets</a> = <a href="#kafka.server;OffsetManager.offsetsCache" title="=&gt; kafka.utils.Pool[kafka.server.GroupTopicPartition,kafka.common.OffsetAndMetadata]">offsetsCache</a>.<span title="(p: ((kafka.server.GroupTopicPartition, kafka.common.OffsetAndMetadata)) =&gt; Boolean)Iterable[(kafka.server.GroupTopicPartition, kafka.common.OffsetAndMetadata)]">filter</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.compact.startMs" title="Long">startMs</a> <span title="(x: Long)Long">-</span> <a href="#kafka.server;OffsetManager.compact.staleOffsets.$anonfun.x$2" title="(kafka.server.GroupTopicPartition, kafka.common.OffsetAndMetadata)">_</a>.<span title="=&gt; kafka.common.OffsetAndMetadata">_2</span>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata.timestamp" title="=&gt; Long">timestamp</a> <span title="(x: Long)Boolean">&gt;</span> <a href="#kafka.server;OffsetManager.config" title="=&gt; kafka.server.OffsetManagerConfig">config</a>.<a href="#kafka.server.OffsetManagerConfig.<init>$default$3" title="=&gt; Long">offsetsRetentionMs</a><span class="delimiter">)</span>

    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Found %d stale offsets (older than %d ms).&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.compact.staleOffsets" title="Iterable[(kafka.server.GroupTopicPartition, kafka.common.OffsetAndMetadata)]">staleOffsets</a>.<span title="=&gt; Int">size</span>, <a href="#kafka.server;OffsetManager.config" title="=&gt; kafka.server.OffsetManagerConfig">config</a>.<a href="#kafka.server.OffsetManagerConfig.<init>$default$3" title="=&gt; Long">offsetsRetentionMs</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">// delete the stale offsets from the table and generate tombstone messages to remove them from the log</span>
    val <a title="scala.collection.immutable.Map[Int,Iterable[(Int, kafka.message.Message)]]" id="kafka.server;OffsetManager.compact.tombstonesForPartition">tombstonesForPartition</a> = <a href="#kafka.server;OffsetManager.compact.staleOffsets" title="Iterable[(kafka.server.GroupTopicPartition, kafka.common.OffsetAndMetadata)]">staleOffsets</a>.<span title="(f: ((kafka.server.GroupTopicPartition, kafka.common.OffsetAndMetadata)) =&gt; (Int, kafka.message.Message))(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[(kafka.server.GroupTopicPartition, kafka.common.OffsetAndMetadata)],(Int, kafka.message.Message),Iterable[(Int, kafka.message.Message)]])Iterable[(Int, kafka.message.Message)]">map</span> <a href="#kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.x0$1" title="(Int, kafka.message.Message)" class="delimiter">{</a> case<span class="delimiter">(</span><a title="kafka.server.GroupTopicPartition" id="kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.groupTopicAndPartition">groupTopicAndPartition</a>, <a title="kafka.common.OffsetAndMetadata" id="kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.offsetAndMetadata">offsetAndMetadata</a><span class="delimiter">)</span> =&gt;
      val <a title="Int" id="kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.offsetsPartition">offsetsPartition</a> = <a href="#kafka.server;OffsetManager.partitionFor" title="(group: String)Int">partitionFor</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.groupTopicAndPartition" title="kafka.server.GroupTopicPartition">groupTopicAndPartition</a>.<a href="#kafka.server;GroupTopicPartition.group" title="=&gt; String">group</a><span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Removing stale offset and metadata for %s: %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.groupTopicAndPartition" title="kafka.server.GroupTopicPartition">groupTopicAndPartition</a>, <a href="#kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.offsetAndMetadata" title="kafka.common.OffsetAndMetadata">offsetAndMetadata</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="#kafka.server;OffsetManager.offsetsCache" title="=&gt; kafka.utils.Pool[kafka.server.GroupTopicPartition,kafka.common.OffsetAndMetadata]">offsetsCache</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.remove" title="(key: kafka.server.GroupTopicPartition)kafka.common.OffsetAndMetadata">remove</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.groupTopicAndPartition" title="kafka.server.GroupTopicPartition">groupTopicAndPartition</a><span class="delimiter">)</span>

      val <a title="Array[Byte]" id="kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.commitKey">commitKey</a> = <a href="#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="#kafka.server.OffsetManager.offsetCommitKey" title="(group: String, topic: String, partition: Int, versionId: Short)Array[Byte]">offsetCommitKey</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.groupTopicAndPartition" title="kafka.server.GroupTopicPartition">groupTopicAndPartition</a>.<a href="#kafka.server;GroupTopicPartition.group" title="=&gt; String">group</a>,
        <a href="#kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.groupTopicAndPartition" title="kafka.server.GroupTopicPartition">groupTopicAndPartition</a>.<a href="#kafka.server;GroupTopicPartition.topicPartition" title="=&gt; kafka.common.TopicAndPartition">topicPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.groupTopicAndPartition" title="kafka.server.GroupTopicPartition">groupTopicAndPartition</a>.<a href="#kafka.server;GroupTopicPartition.topicPartition" title="=&gt; kafka.common.TopicAndPartition">topicPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a><span class="delimiter">)</span>

      <span title="(_1: Int, _2: kafka.message.Message)(Int, kafka.message.Message)" class="delimiter">(</span><a href="#kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.offsetsPartition" title="Int">offsetsPartition</a>, new <a href="../message/Message.scala.html#kafka.message;Message" title="kafka.message.Message">Message</a><span class="delimiter">(</span>bytes = null, key = <a href="#kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.commitKey" title="Array[Byte]">commitKey</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>.<span title="(f: ((Int, kafka.message.Message)) =&gt; Int)scala.collection.immutable.Map[Int,Iterable[(Int, kafka.message.Message)]]">groupBy</span><a href="#kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.x0$2" title="Int" class="delimiter">{</a> case <span class="delimiter">(</span><a title="Int" id="kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.partition">partition</a>, <a title="kafka.message.Message" id="kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.tombstone">tombstone</a><span class="delimiter">)</span> =&gt; <a href="#kafka.server;OffsetManager.compact.tombstonesForPartition.$anonfun.partition" title="Int">partition</a> <span class="delimiter">}</span>

    <span class="comment">// Append the tombstone messages to the offset partitions. It is okay if the replicas don't receive these (say,</span>
    <span class="comment">// if we crash or leaders move) since the new leaders will get rid of stale offsets during their own purge cycles.</span>
    val <a title="Int" id="kafka.server;OffsetManager.compact.numRemoved">numRemoved</a> = <a href="#kafka.server;OffsetManager.compact.tombstonesForPartition" title="scala.collection.immutable.Map[Int,Iterable[(Int, kafka.message.Message)]]">tombstonesForPartition</a>.<span title="(f: ((Int, Iterable[(Int, kafka.message.Message)])) =&gt; scala.collection.GenTraversableOnce[Int])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[Int,Iterable[(Int, kafka.message.Message)]],Int,scala.collection.immutable.Iterable[Int]])scala.collection.immutable.Iterable[Int]">flatMap</span> <a href="#kafka.server;OffsetManager.compact.numRemoved.$anonfun.x0$3" title="Iterable[Int]" class="delimiter">{</a> case<span class="delimiter">(</span><a title="Int" id="kafka.server;OffsetManager.compact.numRemoved.$anonfun.offsetsPartition">offsetsPartition</a>, <a title="Iterable[(Int, kafka.message.Message)]" id="kafka.server;OffsetManager.compact.numRemoved.$anonfun.tombstones">tombstones</a><span class="delimiter">)</span> =&gt;
      val <a title="Option[kafka.cluster.Partition]" id="kafka.server;OffsetManager.compact.numRemoved.$anonfun.partitionOpt">partitionOpt</a> = <a href="#kafka.server;OffsetManager.replicaManager" title="kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.getPartition" title="(topic: String, partitionId: Int)Option[kafka.cluster.Partition]">getPartition</a><span class="delimiter">(</span><a href="#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="#kafka.server.OffsetManager.OffsetsTopicName" title="=&gt; String">OffsetsTopicName</a>, <a href="#kafka.server;OffsetManager.compact.numRemoved.$anonfun.offsetsPartition" title="Int">offsetsPartition</a><span class="delimiter">)</span>
      <a href="#kafka.server;OffsetManager.compact.numRemoved.$anonfun.partitionOpt" title="Option[kafka.cluster.Partition]">partitionOpt</a>.<span title="(f: kafka.cluster.Partition =&gt; Int)Option[Int]">map</span> <span title="(xo: Option[Int])Iterable[Int]" class="delimiter">{</span> <a title="kafka.cluster.Partition" id="kafka.server;OffsetManager.compact.numRemoved.$anonfun.$anonfun.partition">partition</a> =&gt;
        val <a title="kafka.common.TopicAndPartition" id="kafka.server;OffsetManager.compact.numRemoved.$anonfun.$anonfun.appendPartition">appendPartition</a> = <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="#kafka.server.OffsetManager.OffsetsTopicName" title="=&gt; String">OffsetsTopicName</a>, <a href="#kafka.server;OffsetManager.compact.numRemoved.$anonfun.offsetsPartition" title="Int">offsetsPartition</a><span class="delimiter">)</span>
        val <a title="Seq[kafka.message.Message]" id="kafka.server;OffsetManager.compact.numRemoved.$anonfun.$anonfun.messages">messages</a> = <a href="#kafka.server;OffsetManager.compact.numRemoved.$anonfun.tombstones" title="Iterable[(Int, kafka.message.Message)]">tombstones</a>.<span title="(f: ((Int, kafka.message.Message)) =&gt; kafka.message.Message)(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[(Int, kafka.message.Message)],kafka.message.Message,Iterable[kafka.message.Message]])Iterable[kafka.message.Message]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,kafka.message.Message,Iterable[kafka.message.Message]]" class="delimiter">(</span><a href="#kafka.server;OffsetManager.compact.numRemoved.$anonfun.$anonfun.messages.$anonfun.x$3" title="(Int, kafka.message.Message)">_</a>.<span title="=&gt; kafka.message.Message">_2</span><span class="delimiter">)</span>.<span title="=&gt; Seq[kafka.message.Message]">toSeq</span>

        <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Marked %d offsets in %s for deletion.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.compact.numRemoved.$anonfun.$anonfun.messages" title="Seq[kafka.message.Message]">messages</a>.<span title="=&gt; Int">size</span>, <a href="#kafka.server;OffsetManager.compact.numRemoved.$anonfun.$anonfun.appendPartition" title="kafka.common.TopicAndPartition">appendPartition</a><span class="delimiter">)</span><span class="delimiter">)</span>

        try <span class="delimiter">{</span>
          <a href="#kafka.server;OffsetManager.compact.numRemoved.$anonfun.$anonfun.partition" title="kafka.cluster.Partition">partition</a>.<a href="../cluster/Partition.scala.html#kafka.cluster;Partition.appendMessagesToLeader" title="(messages: kafka.message.ByteBufferMessageSet, requiredAcks: Int)kafka.log.Log#LogAppendInfo">appendMessagesToLeader</a><span class="delimiter">(</span>new <a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet">ByteBufferMessageSet</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.config" title="=&gt; kafka.server.OffsetManagerConfig">config</a>.<a href="#kafka.server.OffsetManagerConfig.<init>$default$8" title="=&gt; kafka.message.CompressionCodec">offsetsTopicCompressionCodec</a>, <a href="#kafka.server;OffsetManager.compact.numRemoved.$anonfun.$anonfun.messages" title="Seq[kafka.message.Message]">messages</a>:_*<span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#kafka.server;OffsetManager.compact.numRemoved.$anonfun.tombstones" title="Iterable[(Int, kafka.message.Message)]">tombstones</a>.<span title="=&gt; Int">size</span>
        <span class="delimiter">}</span>
        catch <span class="delimiter">{</span>
          case <a title="Throwable" id="kafka.server;OffsetManager.compact.numRemoved.$anonfun.$anonfun.t">t</a>: <span title="Throwable">Throwable</span> =&gt;
            <a href="../utils/Logging.scala.html#kafka.utils;Logging.error(cfd112d89b)" title="(msg: =&gt; String, e: =&gt; Throwable)Unit">error</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Failed to mark %d stale offsets for deletion in %s.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.compact.numRemoved.$anonfun.$anonfun.messages" title="Seq[kafka.message.Message]">messages</a>.<span title="=&gt; Int">size</span>, <a href="#kafka.server;OffsetManager.compact.numRemoved.$anonfun.$anonfun.appendPartition" title="kafka.common.TopicAndPartition">appendPartition</a><span class="delimiter">)</span>, <a href="#kafka.server;OffsetManager.compact.numRemoved.$anonfun.$anonfun.t" title="Throwable">t</a><span class="delimiter">)</span>
            <span class="comment">// ignore and continue</span>
            <span title="Int(0)" class="int">0</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>.<span title="(implicit num: Numeric[Int])Int">sum</span>

    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Removed %d stale offsets in %d milliseconds.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.compact.numRemoved" title="Int">numRemoved</a>, <a href="../utils/Time.scala.html#kafka.utils.SystemTime" title="kafka.utils.SystemTime.type">SystemTime</a>.<a href="../utils/Time.scala.html#kafka.utils.SystemTime.milliseconds" title="=&gt; Long">milliseconds</a> <span title="(x: Long)Long">-</span> <a href="#kafka.server;OffsetManager.compact.startMs" title="Long">startMs</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="=&gt; java.util.Properties" id="kafka.server;OffsetManager.offsetsTopicConfig">offsetsTopicConfig</a>: <span title="java.util.Properties">Properties</span> = <span class="delimiter">{</span>
    val <a title="java.util.Properties" id="kafka.server;OffsetManager.offsetsTopicConfig.props">props</a> = new <span title="java.util.Properties">Properties</span>
    <a href="#kafka.server;OffsetManager.offsetsTopicConfig.props" title="java.util.Properties">props</a>.<span title="(x$1: Object, x$2: Object)Object">put</span><span class="delimiter">(</span><a href="../log/LogConfig.scala.html#kafka.log.LogConfig" title="kafka.log.LogConfig.type">LogConfig</a>.<a href="../log/LogConfig.scala.html#kafka.log.LogConfig.SegmentBytesProp" title="=&gt; String">SegmentBytesProp</a>, <a href="#kafka.server;OffsetManager.config" title="=&gt; kafka.server.OffsetManagerConfig">config</a>.<a href="#kafka.server.OffsetManagerConfig.<init>$default$6" title="=&gt; Int">offsetsTopicSegmentBytes</a>.<span title="()String">toString</span><span class="delimiter">)</span>
    <a href="#kafka.server;OffsetManager.offsetsTopicConfig.props" title="java.util.Properties">props</a>.<span title="(x$1: Object, x$2: Object)Object">put</span><span class="delimiter">(</span><a href="../log/LogConfig.scala.html#kafka.log.LogConfig" title="kafka.log.LogConfig.type">LogConfig</a>.<a href="../log/LogConfig.scala.html#kafka.log.LogConfig.CleanupPolicyProp" title="=&gt; String">CleanupPolicyProp</a>, <span title="String(&quot;compact&quot;)" class="string">&quot;compact&quot;</span><span class="delimiter">)</span>
    <a href="#kafka.server;OffsetManager.offsetsTopicConfig.props" title="java.util.Properties">props</a>
  <span class="delimiter">}</span>

  def <a title="(group: String)Int" id="kafka.server;OffsetManager.partitionFor">partitionFor</a><span class="delimiter">(</span><a title="String" id="kafka.server;OffsetManager.partitionFor.group">group</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="../utils/Utils.scala.html#kafka.utils.Utils" title="kafka.utils.Utils.type">Utils</a>.<a href="../utils/Utils.scala.html#kafka.utils.Utils.abs" title="(n: Int)Int">abs</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.partitionFor.group" title="String">group</a>.<span title="()Int">hashCode</span><span class="delimiter">)</span> <span title="(x: Int)Int">%</span> <a href="#kafka.server;OffsetManager.config" title="=&gt; kafka.server.OffsetManagerConfig">config</a>.<a href="#kafka.server.OffsetManagerConfig.<init>$default$5" title="=&gt; Int">offsetsTopicNumPartitions</a>

  <span class="comment">/**
   * Fetch the current offset for the given group/topic/partition from the underlying offsets storage.
   *
   * @param key The requested group-topic-partition
   * @return If the key is present, return the offset and metadata; otherwise return None
   */</span>
  private def <a title="(key: kafka.server.GroupTopicPartition)kafka.common.OffsetMetadataAndError" id="kafka.server;OffsetManager.getOffset">getOffset</a><span class="delimiter">(</span><a title="kafka.server.GroupTopicPartition" id="kafka.server;OffsetManager.getOffset.key">key</a>: <a href="#kafka.server.GroupTopicPartition.readResolve" title="kafka.server.GroupTopicPartition">GroupTopicPartition</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val <a title="kafka.common.OffsetAndMetadata" id="kafka.server;OffsetManager.getOffset.offsetAndMetadata">offsetAndMetadata</a> = <a href="#kafka.server;OffsetManager.offsetsCache" title="=&gt; kafka.utils.Pool[kafka.server.GroupTopicPartition,kafka.common.OffsetAndMetadata]">offsetsCache</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.get" title="(key: kafka.server.GroupTopicPartition)kafka.common.OffsetAndMetadata">get</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getOffset.key" title="kafka.server.GroupTopicPartition">key</a><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getOffset.offsetAndMetadata" title="kafka.common.OffsetAndMetadata">offsetAndMetadata</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span>
      <a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetMetadataAndError" title="kafka.common.OffsetMetadataAndError.type">OffsetMetadataAndError</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetMetadataAndError.NoOffset" title="=&gt; kafka.common.OffsetMetadataAndError">NoOffset</a>
    else
      <a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetMetadataAndError" title="(offset: Long, metadata: String, error: Short)kafka.common.OffsetMetadataAndError">OffsetMetadataAndError</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getOffset.offsetAndMetadata" title="kafka.common.OffsetAndMetadata">offsetAndMetadata</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata.offset" title="=&gt; Long">offset</a>, <a href="#kafka.server;OffsetManager.getOffset.offsetAndMetadata" title="kafka.common.OffsetAndMetadata">offsetAndMetadata</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata.metadata" title="=&gt; String">metadata</a>, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Put the (already committed) offset for the given group/topic/partition into the cache.
   *
   * @param key The group-topic-partition
   * @param offsetAndMetadata The offset/metadata to be stored
   */</span>
  private def <a title="(key: kafka.server.GroupTopicPartition, offsetAndMetadata: kafka.common.OffsetAndMetadata)Unit" id="kafka.server;OffsetManager.putOffset">putOffset</a><span class="delimiter">(</span><a title="kafka.server.GroupTopicPartition" id="kafka.server;OffsetManager.putOffset.key">key</a>: <a href="#kafka.server.GroupTopicPartition.readResolve" title="kafka.server.GroupTopicPartition">GroupTopicPartition</a>, <a title="kafka.common.OffsetAndMetadata" id="kafka.server;OffsetManager.putOffset.offsetAndMetadata">offsetAndMetadata</a>: <a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata" title="kafka.common.OffsetAndMetadata">OffsetAndMetadata</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.server;OffsetManager.offsetsCache" title="=&gt; kafka.utils.Pool[kafka.server.GroupTopicPartition,kafka.common.OffsetAndMetadata]">offsetsCache</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.put" title="(k: kafka.server.GroupTopicPartition, v: kafka.common.OffsetAndMetadata)kafka.common.OffsetAndMetadata">put</a><span title="Unit" class="delimiter">(</span><a href="#kafka.server;OffsetManager.putOffset.key" title="kafka.server.GroupTopicPartition">key</a>, <a href="#kafka.server;OffsetManager.putOffset.offsetAndMetadata" title="kafka.common.OffsetAndMetadata">offsetAndMetadata</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(group: String, offsets: scala.collection.Map[kafka.common.TopicAndPartition,kafka.common.OffsetAndMetadata])Unit" id="kafka.server;OffsetManager.putOffsets">putOffsets</a><span class="delimiter">(</span><a title="String" id="kafka.server;OffsetManager.putOffsets.group">group</a>: <span title="String">String</span>, <a title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.common.OffsetAndMetadata]" id="kafka.server;OffsetManager.putOffsets.offsets">offsets</a>: <span title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.common.OffsetAndMetadata]">Map</span><span class="delimiter">[</span>TopicAndPartition, OffsetAndMetadata<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">// this method is called _after_ the offsets have been durably appended to the commit log, so there is no need to</span>
    <span class="comment">// check for current leadership as we do for the offset fetch</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Putting offsets %s for group %s in offsets partition %d.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.putOffsets.offsets" title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.common.OffsetAndMetadata]">offsets</a>, <a href="#kafka.server;OffsetManager.putOffsets.group" title="String">group</a>, <a href="#kafka.server;OffsetManager.partitionFor" title="(group: String)Int">partitionFor</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.putOffsets.group" title="String">group</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.server;OffsetManager.putOffsets.offsets" title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.common.OffsetAndMetadata]">offsets</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.common.OffsetAndMetadata)) =&gt; Unit)Unit">foreach</span> <a href="#kafka.server;OffsetManager.putOffsets.$anonfun.x0$4" title="Unit" class="delimiter">{</a> case <span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;OffsetManager.putOffsets.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="kafka.common.OffsetAndMetadata" id="kafka.server;OffsetManager.putOffsets.$anonfun.offsetAndMetadata">offsetAndMetadata</a><span class="delimiter">)</span> =&gt;
      <a href="#kafka.server;OffsetManager.putOffset" title="(key: kafka.server.GroupTopicPartition, offsetAndMetadata: kafka.common.OffsetAndMetadata)Unit">putOffset</a><span class="delimiter">(</span><a href="#kafka.server.GroupTopicPartition.readResolve" title="(group: String, topicPartition: kafka.common.TopicAndPartition)kafka.server.GroupTopicPartition">GroupTopicPartition</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.putOffsets.group" title="String">group</a>, <a href="#kafka.server;OffsetManager.putOffsets.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>, <a href="#kafka.server;OffsetManager.putOffsets.$anonfun.offsetAndMetadata" title="kafka.common.OffsetAndMetadata">offsetAndMetadata</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * The most important guarantee that this API provides is that it should never return a stale offset. i.e., it either
   * returns the current offset or it begins to sync the cache from the log (and returns an error code).
   */</span>
  def <a title="(group: String, topicPartitions: Seq[kafka.common.TopicAndPartition])scala.collection.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]" id="kafka.server;OffsetManager.getOffsets">getOffsets</a><span class="delimiter">(</span><a title="String" id="kafka.server;OffsetManager.getOffsets.group">group</a>: <span title="String">String</span>, <a title="Seq[kafka.common.TopicAndPartition]" id="kafka.server;OffsetManager.getOffsets.topicPartitions">topicPartitions</a>: <span title="Seq[kafka.common.TopicAndPartition]">Seq</span><span class="delimiter">[</span>TopicAndPartition<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]">Map</span><span class="delimiter">[</span>TopicAndPartition, OffsetMetadataAndError<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Getting offsets %s for group %s.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getOffsets.topicPartitions" title="Seq[kafka.common.TopicAndPartition]">topicPartitions</a>, <a href="#kafka.server;OffsetManager.getOffsets.group" title="String">group</a><span class="delimiter">)</span><span class="delimiter">)</span>

    val <a title="Int" id="kafka.server;OffsetManager.getOffsets.offsetsPartition">offsetsPartition</a> = <a href="#kafka.server;OffsetManager.partitionFor" title="(group: String)Int">partitionFor</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getOffsets.group" title="String">group</a><span class="delimiter">)</span>

    <span class="comment">/**
     * followerTransitionLock protects against fetching from an empty/cleared offset cache (i.e., cleared due to a
     * leader-&gt;follower transition). i.e., even if leader-is-local is true a follower transition can occur right after
     * the check and clear the cache. i.e., we would read from the empty cache and incorrectly return NoOffset.
     */</span>
    <a href="#kafka.server;OffsetManager.followerTransitionLock" title="=&gt; Object">followerTransitionLock</a> <span title="(x$1: scala.collection.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError])scala.collection.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]">synchronized</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#kafka.server;OffsetManager.leaderIsLocal" title="(partition: Int)Boolean">leaderIsLocal</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getOffsets.offsetsPartition" title="Int">offsetsPartition</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadingPartitions" title="=&gt; scala.collection.mutable.Set[Int]">loadingPartitions</a> <span title="(x$1: Boolean)Boolean">synchronized</span> <a href="#kafka.server;OffsetManager.loadingPartitions" title="=&gt; scala.collection.mutable.Set[Int]">loadingPartitions</a>.<span title="(elem: Int)Boolean">contains</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getOffsets.offsetsPartition" title="Int">offsetsPartition</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Cannot fetch offsets for group %s due to ongoing offset load.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getOffsets.group" title="String">group</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#kafka.server;OffsetManager.getOffsets.topicPartitions" title="Seq[kafka.common.TopicAndPartition]">topicPartitions</a>.<span title="(f: kafka.common.TopicAndPartition =&gt; (kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.common.TopicAndPartition],(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]])Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]]" class="delimiter">{</span> <span title="kafka.common.TopicAndPartition">topicAndPartition</span> =&gt;
            val <span title="kafka.server.GroupTopicPartition">groupTopicPartition</span> = <a href="#kafka.server.GroupTopicPartition.readResolve" title="(group: String, topicPartition: kafka.common.TopicAndPartition)kafka.server.GroupTopicPartition">GroupTopicPartition</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getOffsets.group" title="String">group</a>, <span title="kafka.common.TopicAndPartition">topicAndPartition</span><span class="delimiter">)</span>
            <span title="(_1: kafka.common.TopicAndPartition, _2: kafka.common.OffsetMetadataAndError)(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)" class="delimiter">(</span><span title="kafka.server.GroupTopicPartition">groupTopicPartition</span>.<a href="#kafka.server;GroupTopicPartition.topicPartition" title="=&gt; kafka.common.TopicAndPartition">topicPartition</a>, <a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetMetadataAndError" title="kafka.common.OffsetMetadataAndError.type">OffsetMetadataAndError</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetMetadataAndError.OffsetsLoading" title="=&gt; kafka.common.OffsetMetadataAndError">OffsetsLoading</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>.<span title="(implicit ev: &lt;:&lt;[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)])scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]">toMap</span>
        <span class="delimiter">}</span> else <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getOffsets.topicPartitions" title="Seq[kafka.common.TopicAndPartition]">topicPartitions</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
           <span class="comment">// Return offsets for all partitions owned by this consumer group. (this only applies to consumers that commit offsets to Kafka.)</span>
            <a href="#kafka.server;OffsetManager.offsetsCache" title="=&gt; kafka.utils.Pool[kafka.server.GroupTopicPartition,kafka.common.OffsetAndMetadata]">offsetsCache</a>.<span title="(p: ((kafka.server.GroupTopicPartition, kafka.common.OffsetAndMetadata)) =&gt; Boolean)Iterable[(kafka.server.GroupTopicPartition, kafka.common.OffsetAndMetadata)]">filter</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getOffsets.$anonfun.x$4" title="(kafka.server.GroupTopicPartition, kafka.common.OffsetAndMetadata)">_</a>.<span title="=&gt; kafka.server.GroupTopicPartition">_1</span>.<a href="#kafka.server;GroupTopicPartition.group" title="=&gt; String">group</a> <span title="(x$1: Any)Boolean">==</span> <a href="#kafka.server;OffsetManager.getOffsets.group" title="String">group</a><span class="delimiter">)</span>.<span title="(f: ((kafka.server.GroupTopicPartition, kafka.common.OffsetAndMetadata)) =&gt; (kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError))(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[(kafka.server.GroupTopicPartition, kafka.common.OffsetAndMetadata)],(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),Iterable[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]])Iterable[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]">map</span> <a href="#kafka.server;OffsetManager.getOffsets.$anonfun.x0$5" title="(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)" class="delimiter">{</a> case<span class="delimiter">(</span><span title="kafka.server.GroupTopicPartition">groupTopicPartition</span>, <a title="kafka.common.OffsetAndMetadata" id="kafka.server;OffsetManager.getOffsets.$anonfun.offsetAndMetadata">offsetAndMetadata</a><span class="delimiter">)</span> =&gt;
              <span title="(_1: kafka.common.TopicAndPartition, _2: kafka.common.OffsetMetadataAndError)(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)" class="delimiter">(</span><span title="kafka.server.GroupTopicPartition">groupTopicPartition</span>.<a href="#kafka.server;GroupTopicPartition.topicPartition" title="=&gt; kafka.common.TopicAndPartition">topicPartition</a>, <a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetMetadataAndError" title="(offset: Long, metadata: String, error: Short)kafka.common.OffsetMetadataAndError">OffsetMetadataAndError</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getOffsets.$anonfun.offsetAndMetadata" title="kafka.common.OffsetAndMetadata">offsetAndMetadata</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata.offset" title="=&gt; Long">offset</a>, <a href="#kafka.server;OffsetManager.getOffsets.$anonfun.offsetAndMetadata" title="kafka.common.OffsetAndMetadata">offsetAndMetadata</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata.metadata" title="=&gt; String">metadata</a>, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>.<span title="(implicit ev: &lt;:&lt;[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)])scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]">toMap</span>
          <span class="delimiter">}</span> else <span class="delimiter">{</span>
            <a href="#kafka.server;OffsetManager.getOffsets.topicPartitions" title="Seq[kafka.common.TopicAndPartition]">topicPartitions</a>.<span title="(f: kafka.common.TopicAndPartition =&gt; (kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.common.TopicAndPartition],(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]])Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]]" class="delimiter">{</span> <span title="kafka.common.TopicAndPartition">topicAndPartition</span> =&gt;
              val <span title="kafka.server.GroupTopicPartition">groupTopicPartition</span> = <a href="#kafka.server.GroupTopicPartition.readResolve" title="(group: String, topicPartition: kafka.common.TopicAndPartition)kafka.server.GroupTopicPartition">GroupTopicPartition</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getOffsets.group" title="String">group</a>, <span title="kafka.common.TopicAndPartition">topicAndPartition</span><span class="delimiter">)</span>
              <span title="(_1: kafka.common.TopicAndPartition, _2: kafka.common.OffsetMetadataAndError)(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)" class="delimiter">(</span><span title="kafka.server.GroupTopicPartition">groupTopicPartition</span>.<a href="#kafka.server;GroupTopicPartition.topicPartition" title="=&gt; kafka.common.TopicAndPartition">topicPartition</a>, <a href="#kafka.server;OffsetManager.getOffset" title="(key: kafka.server.GroupTopicPartition)kafka.common.OffsetMetadataAndError">getOffset</a><span class="delimiter">(</span><span title="kafka.server.GroupTopicPartition">groupTopicPartition</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>.<span title="(implicit ev: &lt;:&lt;[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)])scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]">toMap</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Could not fetch offsets for group %s (not offset coordinator).&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getOffsets.group" title="String">group</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#kafka.server;OffsetManager.getOffsets.topicPartitions" title="Seq[kafka.common.TopicAndPartition]">topicPartitions</a>.<span title="(f: kafka.common.TopicAndPartition =&gt; (kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.common.TopicAndPartition],(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]])Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]]" class="delimiter">{</span> <span title="kafka.common.TopicAndPartition">topicAndPartition</span> =&gt;
          val <span title="kafka.server.GroupTopicPartition">groupTopicPartition</span> = <a href="#kafka.server.GroupTopicPartition.readResolve" title="(group: String, topicPartition: kafka.common.TopicAndPartition)kafka.server.GroupTopicPartition">GroupTopicPartition</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getOffsets.group" title="String">group</a>, <span title="kafka.common.TopicAndPartition">topicAndPartition</span><span class="delimiter">)</span>
          <span title="(_1: kafka.common.TopicAndPartition, _2: kafka.common.OffsetMetadataAndError)(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)" class="delimiter">(</span><span title="kafka.server.GroupTopicPartition">groupTopicPartition</span>.<a href="#kafka.server;GroupTopicPartition.topicPartition" title="=&gt; kafka.common.TopicAndPartition">topicPartition</a>, <a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetMetadataAndError" title="kafka.common.OffsetMetadataAndError.type">OffsetMetadataAndError</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetMetadataAndError.NotOffsetManagerForGroup" title="=&gt; kafka.common.OffsetMetadataAndError">NotOffsetManagerForGroup</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>.<span title="(implicit ev: &lt;:&lt;[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)])scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]">toMap</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Asynchronously read the partition from the offsets topic and populate the cache
   */</span>
  def <a title="(offsetsPartition: Int)Unit" id="kafka.server;OffsetManager.loadOffsetsFromLog">loadOffsetsFromLog</a><span class="delimiter">(</span><a title="Int" id="kafka.server;OffsetManager.loadOffsetsFromLog.offsetsPartition">offsetsPartition</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    val <a title="kafka.common.TopicAndPartition" id="kafka.server;OffsetManager.loadOffsetsFromLog.topicPartition">topicPartition</a> = <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="#kafka.server.OffsetManager.OffsetsTopicName" title="=&gt; String">OffsetsTopicName</a>, <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.offsetsPartition" title="Int">offsetsPartition</a><span class="delimiter">)</span>

    <a href="#kafka.server;OffsetManager.loadingPartitions" title="=&gt; scala.collection.mutable.Set[Int]">loadingPartitions</a> <span title="(x$1: Unit)Unit">synchronized</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadingPartitions" title="=&gt; scala.collection.mutable.Set[Int]">loadingPartitions</a>.<span title="(elem: Int)Boolean">contains</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.offsetsPartition" title="Int">offsetsPartition</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Offset load from %s already in progress.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.topicPartition" title="kafka.common.TopicAndPartition">topicPartition</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <a href="#kafka.server;OffsetManager.loadingPartitions" title="=&gt; scala.collection.mutable.Set[Int]">loadingPartitions</a>.<span title="(elem: Int)Boolean">add</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.offsetsPartition" title="Int">offsetsPartition</a><span class="delimiter">)</span>
        <a href="#kafka.server;OffsetManager.scheduler" title="kafka.utils.Scheduler">scheduler</a>.<a href="../utils/KafkaScheduler.scala.html#kafka.utils;Scheduler.schedule" title="(name: String, fun: () =&gt; Unit, delay: Long, period: Long, unit: java.util.concurrent.TimeUnit)Unit">schedule</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.topicPartition" title="kafka.common.TopicAndPartition">topicPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.toString" title="()String">toString</a>, <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets" title="()Unit">loadOffsets</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    def <a title="()Unit" id="kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets">loadOffsets</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="String(&quot;Loading offsets from &quot;)" class="string">&quot;Loading offsets from &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.topicPartition" title="kafka.common.TopicAndPartition">topicPartition</a><span class="delimiter">)</span>

      val <a title="Long" id="kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.startMs">startMs</a> = <a href="../utils/Time.scala.html#kafka.utils.SystemTime" title="kafka.utils.SystemTime.type">SystemTime</a>.<a href="../utils/Time.scala.html#kafka.utils.SystemTime.milliseconds" title="=&gt; Long">milliseconds</a>
      try <span class="delimiter">{</span>
        <a href="#kafka.server;OffsetManager.replicaManager" title="kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.logManager" title="=&gt; kafka.log.LogManager">logManager</a>.<a href="../log/LogManager.scala.html#kafka.log;LogManager.getLog" title="(topicAndPartition: kafka.common.TopicAndPartition)Option[kafka.log.Log]">getLog</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.topicPartition" title="kafka.common.TopicAndPartition">topicPartition</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><a title="kafka.log.Log" id="kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.log">log</a><span class="delimiter">)</span> =&gt;
            var <a title="Long" id="kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.currOffset">currOffset</a> = <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.log" title="kafka.log.Log">log</a>.<a href="../log/Log.scala.html#kafka.log;Log.logSegments(b2658bab35)" title="=&gt; Iterable[kafka.log.LogSegment]">logSegments</a>.<span title="=&gt; kafka.log.LogSegment">head</span>.<a href="../log/LogSegment.scala.html#kafka.log;LogSegment.baseOffset" title="=&gt; Long">baseOffset</a>
            val <a title="java.nio.ByteBuffer" id="kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.buffer">buffer</a> = <span title="java.nio.ByteBuffer.type">ByteBuffer</span>.<span title="(x$1: Int)java.nio.ByteBuffer">allocate</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.config" title="=&gt; kafka.server.OffsetManagerConfig">config</a>.<a href="#kafka.server.OffsetManagerConfig.<init>$default$2" title="=&gt; Int">loadBufferSize</a><span class="delimiter">)</span>
            <span class="comment">// loop breaks if leader changes at any time during the load, since getHighWatermark is -1</span>
            while <span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.currOffset" title="Long">currOffset</a> <span title="(x: Long)Boolean">&lt;</span> <a href="#kafka.server;OffsetManager.getHighWatermark" title="(partitionId: Int)Long">getHighWatermark</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.offsetsPartition" title="Int">offsetsPartition</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#kafka.server;OffsetManager.shuttingDown" title="=&gt; java.util.concurrent.atomic.AtomicBoolean">shuttingDown</a>.<span title="()Boolean">get</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.while$1" title="()Unit" class="delimiter">{</a>
              <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.buffer" title="java.nio.ByteBuffer">buffer</a>.<span title="()java.nio.Buffer">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
              val <a title="kafka.log.FileMessageSet" id="kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.messages">messages</a> = <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.log" title="kafka.log.Log">log</a>.<a href="../log/Log.scala.html#kafka.log;Log.read" title="(startOffset: Long, maxLength: Int, maxOffset: Option[Long])kafka.server.FetchDataInfo">read</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.currOffset" title="Long">currOffset</a>, <a href="#kafka.server;OffsetManager.config" title="=&gt; kafka.server.OffsetManagerConfig">config</a>.<a href="#kafka.server.OffsetManagerConfig.<init>$default$2" title="=&gt; Int">loadBufferSize</a><span class="delimiter">)</span>.<a href="FetchDataInfo.scala.html#kafka.server;FetchDataInfo.messageSet" title="=&gt; kafka.message.MessageSet">messageSet</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.log.FileMessageSet" class="delimiter">[</span><a href="../log/FileMessageSet.scala.html#kafka.log;FileMessageSet" title="kafka.log.FileMessageSet">FileMessageSet</a><span class="delimiter">]</span>
              <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.messages" title="kafka.log.FileMessageSet">messages</a>.<a href="../log/FileMessageSet.scala.html#kafka.log;FileMessageSet.readInto" title="(buffer: java.nio.ByteBuffer, relativePosition: Int)java.nio.ByteBuffer">readInto</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.buffer" title="java.nio.ByteBuffer">buffer</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
              val <a title="kafka.message.ByteBufferMessageSet" id="kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.messageSet">messageSet</a> = new <a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet">ByteBufferMessageSet</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.buffer" title="java.nio.ByteBuffer">buffer</a><span class="delimiter">)</span>
              <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.messageSet" title="kafka.message.ByteBufferMessageSet">messageSet</a>.<span title="(f: kafka.message.MessageAndOffset =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="kafka.message.MessageAndOffset" id="kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.$anonfun.msgAndOffset">msgAndOffset</a> =&gt;
                <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.$anonfun.msgAndOffset" title="kafka.message.MessageAndOffset">msgAndOffset</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a>.<a href="../message/Message.scala.html#kafka.message;Message.key" title="=&gt; java.nio.ByteBuffer">key</a> <span title="(x$1: Any)Boolean">!=</span> null, <span title="String(&quot;Offset entry key should not be null&quot;)" class="string">&quot;Offset entry key should not be null&quot;</span><span class="delimiter">)</span>
                val <a title="kafka.server.GroupTopicPartition" id="kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.$anonfun.key">key</a> = <a href="#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="#kafka.server.OffsetManager.readMessageKey" title="(buffer: java.nio.ByteBuffer)kafka.server.GroupTopicPartition">readMessageKey</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.$anonfun.msgAndOffset" title="kafka.message.MessageAndOffset">msgAndOffset</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a>.<a href="../message/Message.scala.html#kafka.message;Message.key" title="=&gt; java.nio.ByteBuffer">key</a><span class="delimiter">)</span>
                if <span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.$anonfun.msgAndOffset" title="kafka.message.MessageAndOffset">msgAndOffset</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a>.<a href="../message/Message.scala.html#kafka.message;Message.payload" title="=&gt; java.nio.ByteBuffer">payload</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span> <span class="delimiter">{</span>
                  if <span class="delimiter">(</span><a href="#kafka.server;OffsetManager.offsetsCache" title="=&gt; kafka.utils.Pool[kafka.server.GroupTopicPartition,kafka.common.OffsetAndMetadata]">offsetsCache</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.remove" title="(key: kafka.server.GroupTopicPartition)kafka.common.OffsetAndMetadata">remove</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.$anonfun.key" title="kafka.server.GroupTopicPartition">key</a><span class="delimiter">)</span> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span>
                    <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Removed offset for %s due to tombstone entry.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.$anonfun.key" title="kafka.server.GroupTopicPartition">key</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  else
                    <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Ignoring redundant tombstone for %s.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.$anonfun.key" title="kafka.server.GroupTopicPartition">key</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="delimiter">}</span> else <span class="delimiter">{</span>
                  val <a title="kafka.common.OffsetAndMetadata" id="kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.$anonfun.value">value</a> = <a href="#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="#kafka.server.OffsetManager.readMessageValue" title="(buffer: java.nio.ByteBuffer)kafka.common.OffsetAndMetadata">readMessageValue</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.$anonfun.msgAndOffset" title="kafka.message.MessageAndOffset">msgAndOffset</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a>.<a href="../message/Message.scala.html#kafka.message;Message.payload" title="=&gt; java.nio.ByteBuffer">payload</a><span class="delimiter">)</span>
                  <a href="#kafka.server;OffsetManager.putOffset" title="(key: kafka.server.GroupTopicPartition, offsetAndMetadata: kafka.common.OffsetAndMetadata)Unit">putOffset</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.$anonfun.key" title="kafka.server.GroupTopicPartition">key</a>, <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.$anonfun.value" title="kafka.common.OffsetAndMetadata">value</a><span class="delimiter">)</span>
                  <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Loaded offset %s for %s.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.$anonfun.value" title="kafka.common.OffsetAndMetadata">value</a>, <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.$anonfun.key" title="kafka.server.GroupTopicPartition">key</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="delimiter">}</span>
                <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.currOffset" title="Long">currOffset</a> = <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.$anonfun.msgAndOffset" title="kafka.message.MessageAndOffset">msgAndOffset</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.nextOffset" title="=&gt; Long">nextOffset</a>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>

            if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.server;OffsetManager.shuttingDown" title="=&gt; java.util.concurrent.atomic.AtomicBoolean">shuttingDown</a>.<span title="()Boolean">get</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Finished loading offsets from %s in %d milliseconds.&quot;</span>
                   .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.topicPartition" title="kafka.common.TopicAndPartition">topicPartition</a>, <a href="../utils/Time.scala.html#kafka.utils.SystemTime" title="kafka.utils.SystemTime.type">SystemTime</a>.<a href="../utils/Time.scala.html#kafka.utils.SystemTime.milliseconds" title="=&gt; Long">milliseconds</a> <span title="(x: Long)Long">-</span> <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.startMs" title="Long">startMs</a><span class="delimiter">)</span><span class="delimiter">)</span>
          case <span title="None.type">None</span> =&gt;
            <a href="../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="String(&quot;No log found for &quot;)" class="string">&quot;No log found for &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.topicPartition" title="kafka.common.TopicAndPartition">topicPartition</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      catch <span class="delimiter">{</span>
        case <a title="Throwable" id="kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.t">t</a>: <span title="Throwable">Throwable</span> =&gt;
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.error(cfd112d89b)" title="(msg: =&gt; String, e: =&gt; Throwable)Unit">error</a><span class="delimiter">(</span><span title="String(&quot;Error in loading offsets from &quot;)" class="string">&quot;Error in loading offsets from &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.topicPartition" title="kafka.common.TopicAndPartition">topicPartition</a>, <a href="#kafka.server;OffsetManager.loadOffsetsFromLog.loadOffsets.t" title="Throwable">t</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      finally <span class="delimiter">{</span>
        <a href="#kafka.server;OffsetManager.loadingPartitions" title="=&gt; scala.collection.mutable.Set[Int]">loadingPartitions</a> <span title="(x$1: Boolean)Boolean">synchronized</span> <a href="#kafka.server;OffsetManager.loadingPartitions" title="=&gt; scala.collection.mutable.Set[Int]">loadingPartitions</a>.<span title="(elem: Int)Boolean">remove</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.loadOffsetsFromLog.offsetsPartition" title="Int">offsetsPartition</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span title="Unit" class="delimiter">}</span>

  private def <a title="(partitionId: Int)Long" id="kafka.server;OffsetManager.getHighWatermark">getHighWatermark</a><span class="delimiter">(</span><a title="Int" id="kafka.server;OffsetManager.getHighWatermark.partitionId">partitionId</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Long">Long</span> = <span class="delimiter">{</span>
    val <a title="Option[kafka.cluster.Partition]" id="kafka.server;OffsetManager.getHighWatermark.partitionOpt">partitionOpt</a> = <a href="#kafka.server;OffsetManager.replicaManager" title="kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.getPartition" title="(topic: String, partitionId: Int)Option[kafka.cluster.Partition]">getPartition</a><span class="delimiter">(</span><a href="#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="#kafka.server.OffsetManager.OffsetsTopicName" title="=&gt; String">OffsetsTopicName</a>, <a href="#kafka.server;OffsetManager.getHighWatermark.partitionId" title="Int">partitionId</a><span class="delimiter">)</span>

    val <a title="Long" id="kafka.server;OffsetManager.getHighWatermark.hw">hw</a> = <a href="#kafka.server;OffsetManager.getHighWatermark.partitionOpt" title="Option[kafka.cluster.Partition]">partitionOpt</a>.<span title="(f: kafka.cluster.Partition =&gt; Long)Option[Long]">map</span> <span class="delimiter">{</span> <a title="kafka.cluster.Partition" id="kafka.server;OffsetManager.getHighWatermark.hw.$anonfun.partition">partition</a> =&gt;
      <a href="#kafka.server;OffsetManager.getHighWatermark.hw.$anonfun.partition" title="kafka.cluster.Partition">partition</a>.<a href="../cluster/Partition.scala.html#kafka.cluster;Partition.leaderReplicaIfLocal" title="()Option[kafka.cluster.Replica]">leaderReplicaIfLocal</a><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="(f: kafka.cluster.Replica =&gt; Long)Option[Long]">map</span><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.getHighWatermark.hw.$anonfun.$anonfun.x$5" title="kafka.cluster.Replica">_</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.highWatermark" title="=&gt; kafka.server.LogOffsetMetadata">highWatermark</a>.<a href="LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="=&gt; Long">messageOffset</a><span class="delimiter">)</span>.<span title="(default: =&gt; Long)Long">getOrElse</span><span class="delimiter">(</span>-<span title="Long(-1L)" class="long">1L</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>.<span title="(default: =&gt; Long)Long">getOrElse</span><span class="delimiter">(</span>-<span title="Long(-1L)" class="long">1L</span><span class="delimiter">)</span>

    <a href="#kafka.server;OffsetManager.getHighWatermark.hw" title="Long">hw</a>
  <span class="delimiter">}</span>

  private def <a title="(partition: Int)Boolean" id="kafka.server;OffsetManager.leaderIsLocal">leaderIsLocal</a><span class="delimiter">(</span><a title="Int" id="kafka.server;OffsetManager.leaderIsLocal.partition">partition</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span class="delimiter">{</span> <a href="#kafka.server;OffsetManager.getHighWatermark" title="(partitionId: Int)Long">getHighWatermark</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.leaderIsLocal.partition" title="Int">partition</a><span class="delimiter">)</span> <span title="(x: Long)Boolean">!=</span> -<span title="Long(-1L)" class="long">1L</span> <span class="delimiter">}</span>

  <span class="comment">/**
   * When this broker becomes a follower for an offsets topic partition clear out the cache for groups that belong to
   * that partition.
   * @param offsetsPartition Groups belonging to this partition of the offsets topic will be deleted from the cache.
   */</span>
  def <a title="(offsetsPartition: Int)Unit" id="kafka.server;OffsetManager.clearOffsetsInPartition">clearOffsetsInPartition</a><span class="delimiter">(</span><a title="Int" id="kafka.server;OffsetManager.clearOffsetsInPartition.offsetsPartition">offsetsPartition</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Deleting offset entries belonging to [%s,%d].&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="#kafka.server.OffsetManager.OffsetsTopicName" title="=&gt; String">OffsetsTopicName</a>, <a href="#kafka.server;OffsetManager.clearOffsetsInPartition.offsetsPartition" title="Int">offsetsPartition</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <a href="#kafka.server;OffsetManager.followerTransitionLock" title="=&gt; Object">followerTransitionLock</a> <span title="(x$1: Unit)Unit">synchronized</span> <span class="delimiter">{</span>
      <a href="#kafka.server;OffsetManager.offsetsCache" title="=&gt; kafka.utils.Pool[kafka.server.GroupTopicPartition,kafka.common.OffsetAndMetadata]">offsetsCache</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.keys" title="=&gt; scala.collection.mutable.Set[kafka.server.GroupTopicPartition]">keys</a>.<span title="(f: kafka.server.GroupTopicPartition =&gt; Any)Unit">foreach</span> <span class="delimiter">{</span> <a title="kafka.server.GroupTopicPartition" id="kafka.server;OffsetManager.clearOffsetsInPartition.$anonfun.key">key</a> =&gt;
        if <span class="delimiter">(</span><a href="#kafka.server;OffsetManager.partitionFor" title="(group: String)Int">partitionFor</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.clearOffsetsInPartition.$anonfun.key" title="kafka.server.GroupTopicPartition">key</a>.<a href="#kafka.server;GroupTopicPartition.group" title="=&gt; String">group</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <a href="#kafka.server;OffsetManager.clearOffsetsInPartition.offsetsPartition" title="Int">offsetsPartition</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#kafka.server;OffsetManager.offsetsCache" title="=&gt; kafka.utils.Pool[kafka.server.GroupTopicPartition,kafka.common.OffsetAndMetadata]">offsetsCache</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.remove" title="(key: kafka.server.GroupTopicPartition)kafka.common.OffsetAndMetadata">remove</a><span class="delimiter">(</span><a href="#kafka.server;OffsetManager.clearOffsetsInPartition.$anonfun.key" title="kafka.server.GroupTopicPartition">key</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="()Unit" id="kafka.server;OffsetManager.shutdown">shutdown</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.server;OffsetManager.shuttingDown" title="=&gt; java.util.concurrent.atomic.AtomicBoolean">shuttingDown</a>.<span title="(x$1: Boolean)Unit">set</span><span class="delimiter">(</span>true<span class="delimiter">)</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

object <a title="kafka.server.OffsetManager.type" id="kafka.server.OffsetManager">OffsetManager</a> <a href="#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type" class="delimiter">{</a>

  val <a title="String" id="kafka.server.OffsetManager.OffsetsTopicName">OffsetsTopicName</a> = <span title="String(&quot;__consumer_offsets&quot;)" class="string">&quot;__consumer_offsets&quot;</span>

  private case class <a title="class KeyAndValueSchemas extends AnyRef with Product with Serializable" id="kafka.server.OffsetManager.KeyAndValueSchemas.readResolve">KeyAndValueSchemas</a><a href="#kafka.server.OffsetManager.KeyAndValueSchemas.readResolve" title="Product" class="delimiter">(</a><a title="org.apache.kafka.common.protocol.types.Schema" id="kafka.server.OffsetManager;KeyAndValueSchemas.keySchema">keySchema</a>: <span title="org.apache.kafka.common.protocol.types.Schema">Schema</span>, <a title="org.apache.kafka.common.protocol.types.Schema" id="kafka.server.OffsetManager;KeyAndValueSchemas.valueSchema">valueSchema</a>: <span title="org.apache.kafka.common.protocol.types.Schema">Schema</span><span class="delimiter">)</span>

  private val <a title="Short" id="kafka.server.OffsetManager.CURRENT_OFFSET_SCHEMA_VERSION">CURRENT_OFFSET_SCHEMA_VERSION</a> = <span title="Int(0)" class="int">0</span>.<span title="=&gt; Short">toShort</span>

  private val <a title="org.apache.kafka.common.protocol.types.Schema" id="kafka.server.OffsetManager.OFFSET_COMMIT_KEY_SCHEMA_V0">OFFSET_COMMIT_KEY_SCHEMA_V0</a> = new <span title="org.apache.kafka.common.protocol.types.Schema">Schema</span><span class="delimiter">(</span>new <span title="org.apache.kafka.common.protocol.types.Field">Field</span><span class="delimiter">(</span><span title="String(&quot;group&quot;)" class="string">&quot;group&quot;</span>, <span title="org.apache.kafka.common.protocol.types.Type">STRING</span><span class="delimiter">)</span>,
                                                       new <span title="org.apache.kafka.common.protocol.types.Field">Field</span><span class="delimiter">(</span><span title="String(&quot;topic&quot;)" class="string">&quot;topic&quot;</span>, <span title="org.apache.kafka.common.protocol.types.Type">STRING</span><span class="delimiter">)</span>,
                                                       new <span title="org.apache.kafka.common.protocol.types.Field">Field</span><span class="delimiter">(</span><span title="String(&quot;partition&quot;)" class="string">&quot;partition&quot;</span>, <span title="org.apache.kafka.common.protocol.types.Type">INT32</span><span class="delimiter">)</span><span class="delimiter">)</span>
  private val <a title="org.apache.kafka.common.protocol.types.Field" id="kafka.server.OffsetManager.KEY_GROUP_FIELD">KEY_GROUP_FIELD</a> = <a href="#kafka.server.OffsetManager.OFFSET_COMMIT_KEY_SCHEMA_V0" title="=&gt; org.apache.kafka.common.protocol.types.Schema">OFFSET_COMMIT_KEY_SCHEMA_V0</a>.<span title="(x$1: String)org.apache.kafka.common.protocol.types.Field">get</span><span class="delimiter">(</span><span title="String(&quot;group&quot;)" class="string">&quot;group&quot;</span><span class="delimiter">)</span>
  private val <a title="org.apache.kafka.common.protocol.types.Field" id="kafka.server.OffsetManager.KEY_TOPIC_FIELD">KEY_TOPIC_FIELD</a> = <a href="#kafka.server.OffsetManager.OFFSET_COMMIT_KEY_SCHEMA_V0" title="=&gt; org.apache.kafka.common.protocol.types.Schema">OFFSET_COMMIT_KEY_SCHEMA_V0</a>.<span title="(x$1: String)org.apache.kafka.common.protocol.types.Field">get</span><span class="delimiter">(</span><span title="String(&quot;topic&quot;)" class="string">&quot;topic&quot;</span><span class="delimiter">)</span>
  private val <a title="org.apache.kafka.common.protocol.types.Field" id="kafka.server.OffsetManager.KEY_PARTITION_FIELD">KEY_PARTITION_FIELD</a> = <a href="#kafka.server.OffsetManager.OFFSET_COMMIT_KEY_SCHEMA_V0" title="=&gt; org.apache.kafka.common.protocol.types.Schema">OFFSET_COMMIT_KEY_SCHEMA_V0</a>.<span title="(x$1: String)org.apache.kafka.common.protocol.types.Field">get</span><span class="delimiter">(</span><span title="String(&quot;partition&quot;)" class="string">&quot;partition&quot;</span><span class="delimiter">)</span>

  private val <a title="org.apache.kafka.common.protocol.types.Schema" id="kafka.server.OffsetManager.OFFSET_COMMIT_VALUE_SCHEMA_V0">OFFSET_COMMIT_VALUE_SCHEMA_V0</a> = new <span title="org.apache.kafka.common.protocol.types.Schema">Schema</span><span class="delimiter">(</span>new <span title="org.apache.kafka.common.protocol.types.Field">Field</span><span class="delimiter">(</span><span title="String(&quot;offset&quot;)" class="string">&quot;offset&quot;</span>, <span title="org.apache.kafka.common.protocol.types.Type">INT64</span><span class="delimiter">)</span>,
                                                         new <span title="org.apache.kafka.common.protocol.types.Field">Field</span><span class="delimiter">(</span><span title="String(&quot;metadata&quot;)" class="string">&quot;metadata&quot;</span>, <span title="org.apache.kafka.common.protocol.types.Type">STRING</span>, <span title="String(&quot;Associated metadata.&quot;)" class="string">&quot;Associated metadata.&quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>,
                                                         new <span title="org.apache.kafka.common.protocol.types.Field">Field</span><span class="delimiter">(</span><span title="String(&quot;timestamp&quot;)" class="string">&quot;timestamp&quot;</span>, <span title="org.apache.kafka.common.protocol.types.Type">INT64</span><span class="delimiter">)</span><span class="delimiter">)</span>
  private val <a title="org.apache.kafka.common.protocol.types.Field" id="kafka.server.OffsetManager.VALUE_OFFSET_FIELD">VALUE_OFFSET_FIELD</a> = <a href="#kafka.server.OffsetManager.OFFSET_COMMIT_VALUE_SCHEMA_V0" title="=&gt; org.apache.kafka.common.protocol.types.Schema">OFFSET_COMMIT_VALUE_SCHEMA_V0</a>.<span title="(x$1: String)org.apache.kafka.common.protocol.types.Field">get</span><span class="delimiter">(</span><span title="String(&quot;offset&quot;)" class="string">&quot;offset&quot;</span><span class="delimiter">)</span>
  private val <a title="org.apache.kafka.common.protocol.types.Field" id="kafka.server.OffsetManager.VALUE_METADATA_FIELD">VALUE_METADATA_FIELD</a> = <a href="#kafka.server.OffsetManager.OFFSET_COMMIT_VALUE_SCHEMA_V0" title="=&gt; org.apache.kafka.common.protocol.types.Schema">OFFSET_COMMIT_VALUE_SCHEMA_V0</a>.<span title="(x$1: String)org.apache.kafka.common.protocol.types.Field">get</span><span class="delimiter">(</span><span title="String(&quot;metadata&quot;)" class="string">&quot;metadata&quot;</span><span class="delimiter">)</span>
  private val <a title="org.apache.kafka.common.protocol.types.Field" id="kafka.server.OffsetManager.VALUE_TIMESTAMP_FIELD">VALUE_TIMESTAMP_FIELD</a> = <a href="#kafka.server.OffsetManager.OFFSET_COMMIT_VALUE_SCHEMA_V0" title="=&gt; org.apache.kafka.common.protocol.types.Schema">OFFSET_COMMIT_VALUE_SCHEMA_V0</a>.<span title="(x$1: String)org.apache.kafka.common.protocol.types.Field">get</span><span class="delimiter">(</span><span title="String(&quot;timestamp&quot;)" class="string">&quot;timestamp&quot;</span><span class="delimiter">)</span>

  <span class="comment">// map of versions to schemas</span>
  private val <a title="scala.collection.Map[Int,kafka.server.OffsetManager.KeyAndValueSchemas]" id="kafka.server.OffsetManager.OFFSET_SCHEMAS">OFFSET_SCHEMAS</a> = <span title="(elems: (Int, kafka.server.OffsetManager.KeyAndValueSchemas)*)scala.collection.Map[Int,kafka.server.OffsetManager.KeyAndValueSchemas]">Map</span><span class="delimiter">(</span><span title="(self: Int)ArrowAssoc[Int]" class="int">0</span> <span title="(y: kafka.server.OffsetManager.KeyAndValueSchemas)(Int, kafka.server.OffsetManager.KeyAndValueSchemas)">-&gt;</span> <a href="#kafka.server.OffsetManager.KeyAndValueSchemas.readResolve" title="(keySchema: org.apache.kafka.common.protocol.types.Schema, valueSchema: org.apache.kafka.common.protocol.types.Schema)kafka.server.OffsetManager.KeyAndValueSchemas">KeyAndValueSchemas</a><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.OFFSET_COMMIT_KEY_SCHEMA_V0" title="=&gt; org.apache.kafka.common.protocol.types.Schema">OFFSET_COMMIT_KEY_SCHEMA_V0</a>, <a href="#kafka.server.OffsetManager.OFFSET_COMMIT_VALUE_SCHEMA_V0" title="=&gt; org.apache.kafka.common.protocol.types.Schema">OFFSET_COMMIT_VALUE_SCHEMA_V0</a><span class="delimiter">)</span><span class="delimiter">)</span>

  private val <a title="kafka.server.OffsetManager.KeyAndValueSchemas" id="kafka.server.OffsetManager.CURRENT_SCHEMA">CURRENT_SCHEMA</a> = <a href="#kafka.server.OffsetManager.schemaFor" title="(version: Int)kafka.server.OffsetManager.KeyAndValueSchemas">schemaFor</a><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.CURRENT_OFFSET_SCHEMA_VERSION" title="=&gt; Int">CURRENT_OFFSET_SCHEMA_VERSION</a><span class="delimiter">)</span>

  private def <a title="(version: Int)kafka.server.OffsetManager.KeyAndValueSchemas" id="kafka.server.OffsetManager.schemaFor">schemaFor</a><span class="delimiter">(</span><a title="Int" id="kafka.server.OffsetManager.schemaFor.version">version</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val <a title="Option[kafka.server.OffsetManager.KeyAndValueSchemas]" id="kafka.server.OffsetManager.schemaFor.schemaOpt">schemaOpt</a> = <a href="#kafka.server.OffsetManager.OFFSET_SCHEMAS" title="=&gt; scala.collection.Map[Int,kafka.server.OffsetManager.KeyAndValueSchemas]">OFFSET_SCHEMAS</a>.<span title="(key: Int)Option[kafka.server.OffsetManager.KeyAndValueSchemas]">get</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.schemaFor.version" title="Int">version</a><span class="delimiter">)</span>
    <a href="#kafka.server.OffsetManager.schemaFor.schemaOpt" title="Option[kafka.server.OffsetManager.KeyAndValueSchemas]">schemaOpt</a> match <span class="delimiter">{</span>
      case Some<span class="delimiter">(</span><a title="kafka.server.OffsetManager.KeyAndValueSchemas" id="kafka.server.OffsetManager.schemaFor.schema">schema</a><span class="delimiter">)</span> =&gt; <a href="#kafka.server.OffsetManager.schemaFor.schema" title="kafka.server.OffsetManager.KeyAndValueSchemas">schema</a>
      case _ =&gt; throw new <a href="../common/KafkaException.scala.html#kafka.common;KafkaException" title="kafka.common.KafkaException">KafkaException</a><span class="delimiter">(</span><span title="String(&quot;Unknown offset schema version &quot;)" class="string">&quot;Unknown offset schema version &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.server.OffsetManager.schemaFor.version" title="Int">version</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Generates the key for offset commit message for given (group, topic, partition)
   *
   * @return key for offset commit message
   */</span>
  def <a title="(group: String, topic: String, partition: Int, versionId: Short)Array[Byte]" id="kafka.server.OffsetManager.offsetCommitKey">offsetCommitKey</a><span class="delimiter">(</span><a title="String" id="kafka.server.OffsetManager.offsetCommitKey.group">group</a>: <span title="String">String</span>, <a title="String" id="kafka.server.OffsetManager.offsetCommitKey.topic">topic</a>: <span title="String">String</span>, <a title="Int" id="kafka.server.OffsetManager.offsetCommitKey.partition">partition</a>: <span title="Int">Int</span>, <a title="Short" id="kafka.server.OffsetManager.offsetCommitKey$default$4">versionId</a>: <span title="Short">Short</span> = <span title="Short(0)" class="int">0</span><span class="delimiter">)</span>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="org.apache.kafka.common.protocol.types.Struct" id="kafka.server.OffsetManager.offsetCommitKey.key">key</a> = new <span title="org.apache.kafka.common.protocol.types.Struct">Struct</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.CURRENT_SCHEMA" title="=&gt; kafka.server.OffsetManager.KeyAndValueSchemas">CURRENT_SCHEMA</a>.<a href="#kafka.server.OffsetManager;KeyAndValueSchemas.keySchema" title="=&gt; org.apache.kafka.common.protocol.types.Schema">keySchema</a><span class="delimiter">)</span>
    <a href="#kafka.server.OffsetManager.offsetCommitKey.key" title="org.apache.kafka.common.protocol.types.Struct">key</a>.<span title="(x$1: org.apache.kafka.common.protocol.types.Field, x$2: Any)org.apache.kafka.common.protocol.types.Struct">set</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.KEY_GROUP_FIELD" title="=&gt; org.apache.kafka.common.protocol.types.Field">KEY_GROUP_FIELD</a>, <a href="#kafka.server.OffsetManager.offsetCommitKey.group" title="String">group</a><span class="delimiter">)</span>
    <a href="#kafka.server.OffsetManager.offsetCommitKey.key" title="org.apache.kafka.common.protocol.types.Struct">key</a>.<span title="(x$1: org.apache.kafka.common.protocol.types.Field, x$2: Any)org.apache.kafka.common.protocol.types.Struct">set</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.KEY_TOPIC_FIELD" title="=&gt; org.apache.kafka.common.protocol.types.Field">KEY_TOPIC_FIELD</a>, <a href="#kafka.server.OffsetManager.offsetCommitKey.topic" title="String">topic</a><span class="delimiter">)</span>
    <a href="#kafka.server.OffsetManager.offsetCommitKey.key" title="org.apache.kafka.common.protocol.types.Struct">key</a>.<span title="(x$1: org.apache.kafka.common.protocol.types.Field, x$2: Any)org.apache.kafka.common.protocol.types.Struct">set</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.KEY_PARTITION_FIELD" title="=&gt; org.apache.kafka.common.protocol.types.Field">KEY_PARTITION_FIELD</a>, <a href="#kafka.server.OffsetManager.offsetCommitKey.partition" title="Int">partition</a><span class="delimiter">)</span>

    val <a title="java.nio.ByteBuffer" id="kafka.server.OffsetManager.offsetCommitKey.byteBuffer">byteBuffer</a> = <span title="java.nio.ByteBuffer.type">ByteBuffer</span>.<span title="(x$1: Int)java.nio.ByteBuffer">allocate</span><span class="delimiter">(</span><span title="Int(2)" class="int">2</span> <span class="comment">/* version */</span> <span title="(x: Int)Int">+</span> <a href="#kafka.server.OffsetManager.offsetCommitKey.key" title="org.apache.kafka.common.protocol.types.Struct">key</a>.<span title="()Int">sizeOf</span><span class="delimiter">)</span>
    <a href="#kafka.server.OffsetManager.offsetCommitKey.byteBuffer" title="java.nio.ByteBuffer">byteBuffer</a>.<span title="(x$1: Short)java.nio.ByteBuffer">putShort</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.CURRENT_OFFSET_SCHEMA_VERSION" title="=&gt; Short">CURRENT_OFFSET_SCHEMA_VERSION</a><span class="delimiter">)</span>
    <a href="#kafka.server.OffsetManager.offsetCommitKey.key" title="org.apache.kafka.common.protocol.types.Struct">key</a>.<span title="(x$1: java.nio.ByteBuffer)Unit">writeTo</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.offsetCommitKey.byteBuffer" title="java.nio.ByteBuffer">byteBuffer</a><span class="delimiter">)</span>
    <a href="#kafka.server.OffsetManager.offsetCommitKey.byteBuffer" title="java.nio.ByteBuffer">byteBuffer</a>.<span title="()Array[Byte]">array</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Generates the payload for offset commit message from given offset and metadata
   *
   * @param offsetAndMetadata consumer's current offset and metadata
   * @return payload for offset commit message
   */</span>
  def <a title="(offsetAndMetadata: kafka.common.OffsetAndMetadata)Array[Byte]" id="kafka.server.OffsetManager.offsetCommitValue">offsetCommitValue</a><span class="delimiter">(</span><a title="kafka.common.OffsetAndMetadata" id="kafka.server.OffsetManager.offsetCommitValue.offsetAndMetadata">offsetAndMetadata</a>: <a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata" title="kafka.common.OffsetAndMetadata">OffsetAndMetadata</a><span class="delimiter">)</span>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="org.apache.kafka.common.protocol.types.Struct" id="kafka.server.OffsetManager.offsetCommitValue.value">value</a> = new <span title="org.apache.kafka.common.protocol.types.Struct">Struct</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.CURRENT_SCHEMA" title="=&gt; kafka.server.OffsetManager.KeyAndValueSchemas">CURRENT_SCHEMA</a>.<a href="#kafka.server.OffsetManager;KeyAndValueSchemas.valueSchema" title="=&gt; org.apache.kafka.common.protocol.types.Schema">valueSchema</a><span class="delimiter">)</span>
    <a href="#kafka.server.OffsetManager.offsetCommitValue.value" title="org.apache.kafka.common.protocol.types.Struct">value</a>.<span title="(x$1: org.apache.kafka.common.protocol.types.Field, x$2: Any)org.apache.kafka.common.protocol.types.Struct">set</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.VALUE_OFFSET_FIELD" title="=&gt; org.apache.kafka.common.protocol.types.Field">VALUE_OFFSET_FIELD</a>, <a href="#kafka.server.OffsetManager.offsetCommitValue.offsetAndMetadata" title="kafka.common.OffsetAndMetadata">offsetAndMetadata</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata.offset" title="=&gt; Long">offset</a><span class="delimiter">)</span>
    <a href="#kafka.server.OffsetManager.offsetCommitValue.value" title="org.apache.kafka.common.protocol.types.Struct">value</a>.<span title="(x$1: org.apache.kafka.common.protocol.types.Field, x$2: Any)org.apache.kafka.common.protocol.types.Struct">set</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.VALUE_METADATA_FIELD" title="=&gt; org.apache.kafka.common.protocol.types.Field">VALUE_METADATA_FIELD</a>, <a href="#kafka.server.OffsetManager.offsetCommitValue.offsetAndMetadata" title="kafka.common.OffsetAndMetadata">offsetAndMetadata</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata.metadata" title="=&gt; String">metadata</a><span class="delimiter">)</span>
    <a href="#kafka.server.OffsetManager.offsetCommitValue.value" title="org.apache.kafka.common.protocol.types.Struct">value</a>.<span title="(x$1: org.apache.kafka.common.protocol.types.Field, x$2: Any)org.apache.kafka.common.protocol.types.Struct">set</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.VALUE_TIMESTAMP_FIELD" title="=&gt; org.apache.kafka.common.protocol.types.Field">VALUE_TIMESTAMP_FIELD</a>, <a href="#kafka.server.OffsetManager.offsetCommitValue.offsetAndMetadata" title="kafka.common.OffsetAndMetadata">offsetAndMetadata</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata.timestamp" title="=&gt; Long">timestamp</a><span class="delimiter">)</span>

    val <a title="java.nio.ByteBuffer" id="kafka.server.OffsetManager.offsetCommitValue.byteBuffer">byteBuffer</a> = <span title="java.nio.ByteBuffer.type">ByteBuffer</span>.<span title="(x$1: Int)java.nio.ByteBuffer">allocate</span><span class="delimiter">(</span><span title="Int(2)" class="int">2</span> <span class="comment">/* version */</span> <span title="(x: Int)Int">+</span> <a href="#kafka.server.OffsetManager.offsetCommitValue.value" title="org.apache.kafka.common.protocol.types.Struct">value</a>.<span title="()Int">sizeOf</span><span class="delimiter">)</span>
    <a href="#kafka.server.OffsetManager.offsetCommitValue.byteBuffer" title="java.nio.ByteBuffer">byteBuffer</a>.<span title="(x$1: Short)java.nio.ByteBuffer">putShort</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.CURRENT_OFFSET_SCHEMA_VERSION" title="=&gt; Short">CURRENT_OFFSET_SCHEMA_VERSION</a><span class="delimiter">)</span>
    <a href="#kafka.server.OffsetManager.offsetCommitValue.value" title="org.apache.kafka.common.protocol.types.Struct">value</a>.<span title="(x$1: java.nio.ByteBuffer)Unit">writeTo</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.offsetCommitValue.byteBuffer" title="java.nio.ByteBuffer">byteBuffer</a><span class="delimiter">)</span>
    <a href="#kafka.server.OffsetManager.offsetCommitValue.byteBuffer" title="java.nio.ByteBuffer">byteBuffer</a>.<span title="()Array[Byte]">array</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Decodes the offset messages' key
   *
   * @param buffer input byte-buffer
   * @return an GroupTopicPartition object
   */</span>
  def <a title="(buffer: java.nio.ByteBuffer)kafka.server.GroupTopicPartition" id="kafka.server.OffsetManager.readMessageKey">readMessageKey</a><span class="delimiter">(</span><a title="java.nio.ByteBuffer" id="kafka.server.OffsetManager.readMessageKey.buffer">buffer</a>: <span title="java.nio.ByteBuffer">ByteBuffer</span><span class="delimiter">)</span>: <a href="#kafka.server.GroupTopicPartition.readResolve" title="kafka.server.GroupTopicPartition">GroupTopicPartition</a> = <span class="delimiter">{</span>
    val <a title="Short" id="kafka.server.OffsetManager.readMessageKey.version">version</a> = <a href="#kafka.server.OffsetManager.readMessageKey.buffer" title="java.nio.ByteBuffer">buffer</a>.<span title="()Short">getShort</span><span class="delimiter">(</span><span class="delimiter">)</span>
    val <a title="org.apache.kafka.common.protocol.types.Schema" id="kafka.server.OffsetManager.readMessageKey.keySchema">keySchema</a> = <a href="#kafka.server.OffsetManager.schemaFor" title="(version: Int)kafka.server.OffsetManager.KeyAndValueSchemas">schemaFor</a><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.readMessageKey.version" title="=&gt; Int">version</a><span class="delimiter">)</span>.<a href="#kafka.server.OffsetManager;KeyAndValueSchemas.keySchema" title="=&gt; org.apache.kafka.common.protocol.types.Schema">keySchema</a>
    val <a title="org.apache.kafka.common.protocol.types.Struct" id="kafka.server.OffsetManager.readMessageKey.key">key</a> = <a href="#kafka.server.OffsetManager.readMessageKey.keySchema" title="org.apache.kafka.common.protocol.types.Schema">keySchema</a>.<span title="(x$1: java.nio.ByteBuffer)Object">read</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.readMessageKey.buffer" title="java.nio.ByteBuffer">buffer</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="org.apache.kafka.common.protocol.types.Struct" class="delimiter">[</span><span title="org.apache.kafka.common.protocol.types.Struct">Struct</span><span class="delimiter">]</span>

    val <a title="String" id="kafka.server.OffsetManager.readMessageKey.group">group</a> = <a href="#kafka.server.OffsetManager.readMessageKey.key" title="org.apache.kafka.common.protocol.types.Struct">key</a>.<span title="(x$1: org.apache.kafka.common.protocol.types.Field)Object">get</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.KEY_GROUP_FIELD" title="=&gt; org.apache.kafka.common.protocol.types.Field">KEY_GROUP_FIELD</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="String" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span>
    val <a title="String" id="kafka.server.OffsetManager.readMessageKey.topic">topic</a> = <a href="#kafka.server.OffsetManager.readMessageKey.key" title="org.apache.kafka.common.protocol.types.Struct">key</a>.<span title="(x$1: org.apache.kafka.common.protocol.types.Field)Object">get</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.KEY_TOPIC_FIELD" title="=&gt; org.apache.kafka.common.protocol.types.Field">KEY_TOPIC_FIELD</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="String" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span>
    val <a title="Int" id="kafka.server.OffsetManager.readMessageKey.partition">partition</a> = <a href="#kafka.server.OffsetManager.readMessageKey.key" title="org.apache.kafka.common.protocol.types.Struct">key</a>.<span title="(x$1: org.apache.kafka.common.protocol.types.Field)Object">get</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.KEY_PARTITION_FIELD" title="=&gt; org.apache.kafka.common.protocol.types.Field">KEY_PARTITION_FIELD</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Int" class="delimiter">[</span><span title="Int">Int</span><span class="delimiter">]</span>

    <a href="#kafka.server.GroupTopicPartition.readResolve" title="(group: String, topicPartition: kafka.common.TopicAndPartition)kafka.server.GroupTopicPartition">GroupTopicPartition</a><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.readMessageKey.group" title="String">group</a>, <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.readMessageKey.topic" title="String">topic</a>, <a href="#kafka.server.OffsetManager.readMessageKey.partition" title="Int">partition</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Decodes the offset messages' payload and retrieves offset and metadata from it
   *
   * @param buffer input byte-buffer
   * @return an offset-metadata object from the message
   */</span>
  def <a title="(buffer: java.nio.ByteBuffer)kafka.common.OffsetAndMetadata" id="kafka.server.OffsetManager.readMessageValue">readMessageValue</a><span class="delimiter">(</span><a title="java.nio.ByteBuffer" id="kafka.server.OffsetManager.readMessageValue.buffer">buffer</a>: <span title="java.nio.ByteBuffer">ByteBuffer</span><span class="delimiter">)</span>: <a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata" title="kafka.common.OffsetAndMetadata">OffsetAndMetadata</a> = <span class="delimiter">{</span>
    if<span class="delimiter">(</span><a href="#kafka.server.OffsetManager.readMessageValue.buffer" title="java.nio.ByteBuffer">buffer</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// tombstone</span>
      null
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      val <a title="Short" id="kafka.server.OffsetManager.readMessageValue.version">version</a> = <a href="#kafka.server.OffsetManager.readMessageValue.buffer" title="java.nio.ByteBuffer">buffer</a>.<span title="()Short">getShort</span><span class="delimiter">(</span><span class="delimiter">)</span>
      val <a title="org.apache.kafka.common.protocol.types.Schema" id="kafka.server.OffsetManager.readMessageValue.valueSchema">valueSchema</a> = <a href="#kafka.server.OffsetManager.schemaFor" title="(version: Int)kafka.server.OffsetManager.KeyAndValueSchemas">schemaFor</a><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.readMessageValue.version" title="=&gt; Int">version</a><span class="delimiter">)</span>.<a href="#kafka.server.OffsetManager;KeyAndValueSchemas.valueSchema" title="=&gt; org.apache.kafka.common.protocol.types.Schema">valueSchema</a>
      val <a title="org.apache.kafka.common.protocol.types.Struct" id="kafka.server.OffsetManager.readMessageValue.value">value</a> = <a href="#kafka.server.OffsetManager.readMessageValue.valueSchema" title="org.apache.kafka.common.protocol.types.Schema">valueSchema</a>.<span title="(x$1: java.nio.ByteBuffer)Object">read</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.readMessageValue.buffer" title="java.nio.ByteBuffer">buffer</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="org.apache.kafka.common.protocol.types.Struct" class="delimiter">[</span><span title="org.apache.kafka.common.protocol.types.Struct">Struct</span><span class="delimiter">]</span>

      val <a title="Long" id="kafka.server.OffsetManager.readMessageValue.offset">offset</a> = <a href="#kafka.server.OffsetManager.readMessageValue.value" title="org.apache.kafka.common.protocol.types.Struct">value</a>.<span title="(x$1: org.apache.kafka.common.protocol.types.Field)Object">get</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.VALUE_OFFSET_FIELD" title="=&gt; org.apache.kafka.common.protocol.types.Field">VALUE_OFFSET_FIELD</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Long" class="delimiter">[</span><span title="Long">Long</span><span class="delimiter">]</span>
      val <a title="String" id="kafka.server.OffsetManager.readMessageValue.metadata">metadata</a> = <a href="#kafka.server.OffsetManager.readMessageValue.value" title="org.apache.kafka.common.protocol.types.Struct">value</a>.<span title="(x$1: org.apache.kafka.common.protocol.types.Field)Object">get</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.VALUE_METADATA_FIELD" title="=&gt; org.apache.kafka.common.protocol.types.Field">VALUE_METADATA_FIELD</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="String" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span>
      val <a title="Long" id="kafka.server.OffsetManager.readMessageValue.timestamp">timestamp</a> = <a href="#kafka.server.OffsetManager.readMessageValue.value" title="org.apache.kafka.common.protocol.types.Struct">value</a>.<span title="(x$1: org.apache.kafka.common.protocol.types.Field)Object">get</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.VALUE_TIMESTAMP_FIELD" title="=&gt; org.apache.kafka.common.protocol.types.Field">VALUE_TIMESTAMP_FIELD</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Long" class="delimiter">[</span><span title="Long">Long</span><span class="delimiter">]</span>

      <a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata" title="(offset: Long, metadata: String, timestamp: Long)kafka.common.OffsetAndMetadata">OffsetAndMetadata</a><span class="delimiter">(</span><a href="#kafka.server.OffsetManager.readMessageValue.offset" title="Long">offset</a>, <a href="#kafka.server.OffsetManager.readMessageValue.metadata" title="String">metadata</a>, <a href="#kafka.server.OffsetManager.readMessageValue.timestamp" title="Long">timestamp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">// Formatter for use with tools such as console consumer: Consumer should also set exclude.internal.topics to false.</span>
  <span class="comment">// (specify --formatter &quot;kafka.server.OffsetManager\$OffsetsMessageFormatter&quot; when consuming __consumer_offsets)</span>
  class <a title="class OffsetsMessageFormatter extends AnyRef with kafka.tools.MessageFormatter" id="kafka.server.OffsetManager;OffsetsMessageFormatter">OffsetsMessageFormatter</a> extends <a href="../tools/ConsoleConsumer.scala.html#kafka.tools;MessageFormatter" title="kafka.tools.MessageFormatter">MessageFormatter</a> <span class="delimiter">{</span>
    def <a title="(key: Array[Byte], value: Array[Byte], output: java.io.PrintStream)Unit" id="kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo">writeTo</a><span class="delimiter">(</span><a title="Array[Byte]" id="kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo.key">key</a>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span>, <a title="Array[Byte]" id="kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo.value">value</a>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span>, <a title="java.io.PrintStream" id="kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo.output">output</a>: <span title="java.io.PrintStream">PrintStream</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="String" id="kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo.formattedKey">formattedKey</a> = if <span class="delimiter">(</span><a href="#kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo.key" title="Array[Byte]">key</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span> <span title="String(&quot;NULL&quot;)" class="string">&quot;NULL&quot;</span> else <a href="#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="#kafka.server.OffsetManager.readMessageKey" title="(buffer: java.nio.ByteBuffer)kafka.server.GroupTopicPartition">readMessageKey</a><span class="delimiter">(</span><span title="java.nio.ByteBuffer.type">ByteBuffer</span>.<span title="(x$1: Array[Byte])java.nio.ByteBuffer">wrap</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo.key" title="Array[Byte]">key</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#kafka.server;GroupTopicPartition.toString" title="()String">toString</a>
      val <a title="String" id="kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo.formattedValue">formattedValue</a> = if <span class="delimiter">(</span><a href="#kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo.value" title="Array[Byte]">value</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span> <span title="String(&quot;NULL&quot;)" class="string">&quot;NULL&quot;</span> else <a href="#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="#kafka.server.OffsetManager.readMessageValue" title="(buffer: java.nio.ByteBuffer)kafka.common.OffsetAndMetadata">readMessageValue</a><span class="delimiter">(</span><span title="java.nio.ByteBuffer.type">ByteBuffer</span>.<span title="(x$1: Array[Byte])java.nio.ByteBuffer">wrap</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo.value" title="Array[Byte]">value</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata.toString" title="()String">toString</a>
      <a href="#kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo.output" title="java.io.PrintStream">output</a>.<span title="(x$1: Array[Byte])Unit">write</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo.formattedKey" title="String">formattedKey</a>.<span title="()Array[Byte]">getBytes</span><span class="delimiter">)</span>
      <a href="#kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo.output" title="java.io.PrintStream">output</a>.<span title="(x$1: Array[Byte])Unit">write</span><span class="delimiter">(</span><span title="String(&quot;::&quot;)" class="string">&quot;::&quot;</span>.<span title="()Array[Byte]">getBytes</span><span class="delimiter">)</span>
      <a href="#kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo.output" title="java.io.PrintStream">output</a>.<span title="(x$1: Array[Byte])Unit">write</span><span class="delimiter">(</span><a href="#kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo.formattedValue" title="String">formattedValue</a>.<span title="()Array[Byte]">getBytes</span><span class="delimiter">)</span>
      <a href="#kafka.server.OffsetManager;OffsetsMessageFormatter.writeTo.output" title="java.io.PrintStream">output</a>.<span title="(x$1: Array[Byte])Unit">write</span><span class="delimiter">(</span><span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span>.<span title="()Array[Byte]">getBytes</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

case class <a title="class GroupTopicPartition extends AnyRef with Product with Serializable" id="kafka.server.GroupTopicPartition.readResolve">GroupTopicPartition</a><a href="#kafka.server.GroupTopicPartition.readResolve" title="Product" class="delimiter">(</a><a title="String" id="kafka.server;GroupTopicPartition.group">group</a>: <span title="String">String</span>, <a title="kafka.common.TopicAndPartition" id="kafka.server;GroupTopicPartition.topicPartition">topicPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">)</span> <span class="delimiter">{</span>

  def this<span class="delimiter">(</span><a title="String" id="kafka.server;GroupTopicPartition.<init>(0d3d29130d).group">group</a>: <span title="String">String</span>, <a title="String" id="kafka.server;GroupTopicPartition.<init>(0d3d29130d).topic">topic</a>: <span title="String">String</span>, <a title="Int" id="kafka.server;GroupTopicPartition.<init>(0d3d29130d).partition">partition</a>: <span title="Int">Int</span><span class="delimiter">)</span> =
    this<span class="delimiter">(</span><a href="#kafka.server;GroupTopicPartition.<init>(0d3d29130d).group" title="String">group</a>, new <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.server;GroupTopicPartition.<init>(0d3d29130d).topic" title="String">topic</a>, <a href="#kafka.server;GroupTopicPartition.<init>(0d3d29130d).partition" title="Int">partition</a><span class="delimiter">)</span><span class="delimiter">)</span>

  override def <a title="()String" id="kafka.server;GroupTopicPartition.toString">toString</a> =
    <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;[%s,%s,%d]&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;GroupTopicPartition.group" title="=&gt; String">group</a>, <a href="#kafka.server;GroupTopicPartition.topicPartition" title="=&gt; kafka.common.TopicAndPartition">topicPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.server;GroupTopicPartition.topicPartition" title="=&gt; kafka.common.TopicAndPartition">topicPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a><span class="delimiter">)</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
