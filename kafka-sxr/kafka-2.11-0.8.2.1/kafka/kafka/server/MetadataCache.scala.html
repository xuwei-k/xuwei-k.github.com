<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/server/MetadataCache.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package kafka.server

import scala.collection.<span class="delimiter">{</span>Seq, Set, mutable<span class="delimiter">}</span>
import kafka.api._
import kafka.cluster.Broker
import java.util.concurrent.locks.ReentrantReadWriteLock
import kafka.utils.<a href="../utils/Utils.scala.html#kafka.utils.Utils" title="kafka.utils.Utils.type">Utils</a>._
import kafka.common.<span class="delimiter">{</span>ErrorMapping, ReplicaNotAvailableException, LeaderNotAvailableException<span class="delimiter">}</span>
import kafka.common.TopicAndPartition
import kafka.controller.<a href="../controller/KafkaController.scala.html#kafka.controller.KafkaController" title="kafka.controller.KafkaController.type">KafkaController</a>.StateChangeLogger

<span class="comment">/**
 *  A cache for the state (e.g., current leader) of each partition. This cache is updated through
 *  UpdateMetadataRequest from the controller. Every broker maintains the same cache, asynchronously.
 */</span>
private<span class="delimiter">[</span>server<span class="delimiter">]</span> class <a title="class MetadataCache extends AnyRef" id="kafka.server;MetadataCache">MetadataCache</a> <a href="#kafka.server;MetadataCache" title="kafka.server.MetadataCache" class="delimiter">{</a>
  private val <a title="scala.collection.mutable.Map[String,scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]]" id="kafka.server;MetadataCache.cache">cache</a>: mutable.<span title="scala.collection.mutable.Map[String,scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]]">Map</span><span class="delimiter">[</span>String, mutable.Map<span class="delimiter">[</span>Int, PartitionStateInfo<span class="delimiter">]</span><span class="delimiter">]</span> =
    new mutable.<span title="scala.collection.mutable.HashMap[String,scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]]">HashMap</span><span class="delimiter">[</span>String, mutable.Map<span class="delimiter">[</span>Int, PartitionStateInfo<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
  private var <a title="Map[Int,kafka.cluster.Broker]" id="kafka.server;MetadataCache.aliveBrokers_=">aliveBrokers</a>: <span title="Map[Int,kafka.cluster.Broker]">Map</span><span class="delimiter">[</span>Int, Broker<span class="delimiter">]</span> = <span title="(elems: (Int, Nothing)*)scala.collection.immutable.Map[Int,Nothing]">Map</span><span class="delimiter">(</span><span class="delimiter">)</span>
  private val <a title="java.util.concurrent.locks.ReentrantReadWriteLock" id="kafka.server;MetadataCache.partitionMetadataLock">partitionMetadataLock</a> = new <span title="java.util.concurrent.locks.ReentrantReadWriteLock">ReentrantReadWriteLock</span><span class="delimiter">(</span><span class="delimiter">)</span>

  def <a title="(topics: scala.collection.Set[String])scala.collection.mutable.ListBuffer[kafka.api.TopicMetadata]" id="kafka.server;MetadataCache.getTopicMetadata">getTopicMetadata</a><span class="delimiter">(</span><a title="scala.collection.Set[String]" id="kafka.server;MetadataCache.getTopicMetadata.topics">topics</a>: <span title="scala.collection.Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val <a title="Boolean" id="kafka.server;MetadataCache.getTopicMetadata.isAllTopics">isAllTopics</a> = <a href="#kafka.server;MetadataCache.getTopicMetadata.topics" title="scala.collection.Set[String]">topics</a>.<span title="=&gt; Boolean">isEmpty</span>
    val <a title="scala.collection.Set[String]" id="kafka.server;MetadataCache.getTopicMetadata.topicsRequested">topicsRequested</a> = if<span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.isAllTopics" title="Boolean">isAllTopics</a><span class="delimiter">)</span> <a href="#kafka.server;MetadataCache.cache" title="=&gt; scala.collection.mutable.Map[String,scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]]">cache</a>.<span title="=&gt; scala.collection.Set[String]">keySet</span> else <a href="#kafka.server;MetadataCache.getTopicMetadata.topics" title="scala.collection.Set[String]">topics</a>
    val <a title="scala.collection.mutable.ListBuffer[kafka.api.TopicMetadata]" id="kafka.server;MetadataCache.getTopicMetadata.topicResponses">topicResponses</a>: mutable.<span title="scala.collection.mutable.ListBuffer[kafka.api.TopicMetadata]">ListBuffer</span><span class="delimiter">[</span>TopicMetadata<span class="delimiter">]</span> = new mutable.<span title="scala.collection.mutable.ListBuffer[kafka.api.TopicMetadata]">ListBuffer</span><span class="delimiter">[</span>TopicMetadata<span class="delimiter">]</span>
    <a href="../utils/Utils.scala.html#kafka.utils.Utils.inReadLock" title="(lock: java.util.concurrent.locks.ReadWriteLock)(fun: =&gt; Unit)Unit">inReadLock</a><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.partitionMetadataLock" title="=&gt; java.util.concurrent.locks.ReentrantReadWriteLock">partitionMetadataLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      for <span class="delimiter">(</span><a title="String" id="kafka.server;MetadataCache.getTopicMetadata.$anonfun.topic">topic</a> &lt;- <a href="#kafka.server;MetadataCache.getTopicMetadata.topicsRequested" title="(f: String =&gt; Any)Unit">topicsRequested</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.isAllTopics" title="Boolean">isAllTopics</a> <span title="(x: Boolean)Boolean">||</span> <a href="#kafka.server;MetadataCache.cache" title="=&gt; scala.collection.mutable.Map[String,scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]]">cache</a>.<span title="(key: String)Boolean">contains</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          val <a title="scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]" id="kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionStateInfos">partitionStateInfos</a> = <a href="#kafka.server;MetadataCache.cache" title="(key: String)scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]">cache</a><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span>
          val <a title="scala.collection.mutable.Iterable[kafka.api.PartitionMetadata]" id="kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata">partitionMetadata</a> = <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionStateInfos" title="scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]">partitionStateInfos</a>.<span title="(f: ((Int, kafka.api.PartitionStateInfo)) =&gt; kafka.api.PartitionMetadata)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo],kafka.api.PartitionMetadata,scala.collection.mutable.Iterable[kafka.api.PartitionMetadata]])scala.collection.mutable.Iterable[kafka.api.PartitionMetadata]">map</span> <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.x0$1" title="kafka.api.PartitionMetadata" class="delimiter">{</a>
            case <span class="delimiter">(</span><a title="Int" id="kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.partitionId">partitionId</a>, <a title="kafka.api.PartitionStateInfo" id="kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.partitionState">partitionState</a><span class="delimiter">)</span> =&gt;
              val <a title="scala.collection.Set[Int]" id="kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.replicas">replicas</a> = <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.partitionState" title="kafka.api.PartitionStateInfo">partitionState</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;PartitionStateInfo.allReplicas" title="=&gt; scala.collection.Set[Int]">allReplicas</a>
              val <a title="Seq[kafka.cluster.Broker]" id="kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.replicaInfo">replicaInfo</a>: <span title="Seq[kafka.cluster.Broker]">Seq</span><span class="delimiter">[</span>Broker<span class="delimiter">]</span> = <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.replicas" title="scala.collection.Set[Int]">replicas</a>.<span title="(f: Int =&gt; kafka.cluster.Broker)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.Set[Int],kafka.cluster.Broker,scala.collection.Set[kafka.cluster.Broker]])scala.collection.Set[kafka.cluster.Broker]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Set.Coll,kafka.cluster.Broker,scala.collection.Set[kafka.cluster.Broker]]" class="delimiter">(</span><a href="#kafka.server;MetadataCache.aliveBrokers_=" title="=&gt; Map[Int,kafka.cluster.Broker]">aliveBrokers</a>.<span title="(key: Int, default: =&gt; kafka.cluster.Broker)kafka.cluster.Broker">getOrElse</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.replicaInfo.$anonfun.x$1" title="Int">_</a>, null<span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(p: kafka.cluster.Broker =&gt; Boolean)scala.collection.Set[kafka.cluster.Broker]">filter</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.replicaInfo.$anonfun.x$2" title="kafka.cluster.Broker">_</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span>.<span title="=&gt; Seq[kafka.cluster.Broker]">toSeq</span>
              var <a title="Option[kafka.cluster.Broker]" id="kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.leaderInfo">leaderInfo</a>: <span title="Option[kafka.cluster.Broker]">Option</span><span class="delimiter">[</span>Broker<span class="delimiter">]</span> = <span title="None.type">None</span>
              var <a title="Seq[kafka.cluster.Broker]" id="kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.isrInfo">isrInfo</a>: <span title="Seq[kafka.cluster.Broker]">Seq</span><span class="delimiter">[</span>Broker<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>
              val <a title="kafka.controller.LeaderIsrAndControllerEpoch" id="kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.leaderIsrAndEpoch">leaderIsrAndEpoch</a> = <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.partitionState" title="kafka.api.PartitionStateInfo">partitionState</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;PartitionStateInfo.leaderIsrAndControllerEpoch" title="=&gt; kafka.controller.LeaderIsrAndControllerEpoch">leaderIsrAndControllerEpoch</a>
              val <a title="Int" id="kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.leader">leader</a> = <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.leaderIsrAndEpoch" title="kafka.controller.LeaderIsrAndControllerEpoch">leaderIsrAndEpoch</a>.<a href="../controller/KafkaController.scala.html#kafka.controller;LeaderIsrAndControllerEpoch.leaderAndIsr" title="=&gt; kafka.api.LeaderAndIsr">leaderAndIsr</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;LeaderAndIsr.leader" title="=&gt; Int">leader</a>
              val <a title="List[Int]" id="kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.isr">isr</a> = <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.leaderIsrAndEpoch" title="kafka.controller.LeaderIsrAndControllerEpoch">leaderIsrAndEpoch</a>.<a href="../controller/KafkaController.scala.html#kafka.controller;LeaderIsrAndControllerEpoch.leaderAndIsr" title="=&gt; kafka.api.LeaderAndIsr">leaderAndIsr</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;LeaderAndIsr.isr" title="=&gt; List[Int]">isr</a>
              val <a title="kafka.common.TopicAndPartition" id="kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.topicPartition">topicPartition</a> = <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.topic" title="String">topic</a>, <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.partitionId" title="Int">partitionId</a><span class="delimiter">)</span>
              try <span class="delimiter">{</span>
                <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.leaderInfo" title="Option[kafka.cluster.Broker]">leaderInfo</a> = <a href="#kafka.server;MetadataCache.aliveBrokers_=" title="=&gt; Map[Int,kafka.cluster.Broker]">aliveBrokers</a>.<span title="(key: Int)Option[kafka.cluster.Broker]">get</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.leader" title="Int">leader</a><span class="delimiter">)</span>
                if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.leaderInfo" title="Option[kafka.cluster.Broker]">leaderInfo</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span>
                  throw new <a href="../common/LeaderNotAvailableException.scala.html#kafka.common;LeaderNotAvailableException" title="kafka.common.LeaderNotAvailableException">LeaderNotAvailableException</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Leader not available for %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.topicPartition" title="kafka.common.TopicAndPartition">topicPartition</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.isrInfo" title="Seq[kafka.cluster.Broker]">isrInfo</a> = <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.isr" title="List[Int]">isr</a>.<span title="(f: Int =&gt; kafka.cluster.Broker)(implicit bf: scala.collection.generic.CanBuildFrom[List[Int],kafka.cluster.Broker,List[kafka.cluster.Broker]])List[kafka.cluster.Broker]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,kafka.cluster.Broker,List[kafka.cluster.Broker]]" class="delimiter">(</span><a href="#kafka.server;MetadataCache.aliveBrokers_=" title="=&gt; Map[Int,kafka.cluster.Broker]">aliveBrokers</a>.<span title="(key: Int, default: =&gt; kafka.cluster.Broker)kafka.cluster.Broker">getOrElse</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.$anonfun.x$3" title="Int">_</a>, null<span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(p: kafka.cluster.Broker =&gt; Boolean)List[kafka.cluster.Broker]">filter</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.$anonfun.x$4" title="kafka.cluster.Broker">_</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span>
                if <span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.replicaInfo" title="Seq[kafka.cluster.Broker]">replicaInfo</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&lt;</span> <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.replicas" title="scala.collection.Set[Int]">replicas</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>
                  throw new <a href="../common/ReplicaNotAvailableException.scala.html#kafka.common;ReplicaNotAvailableException" title="kafka.common.ReplicaNotAvailableException">ReplicaNotAvailableException</a><span class="delimiter">(</span><span title="String(&quot;Replica information not available for following brokers: &quot;)" class="string">&quot;Replica information not available for following brokers: &quot;</span> <span title="(x$1: Any)String">+</span>
                    <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.replicas" title="scala.collection.Set[Int]">replicas</a>.<span title="(p: Int =&gt; Boolean)scala.collection.Set[Int]">filterNot</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.replicaInfo" title="Seq[kafka.cluster.Broker]">replicaInfo</a>.<span title="(f: kafka.cluster.Broker =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.cluster.Broker],Int,Seq[Int]])Seq[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,Int,Seq[Int]]" class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.$anonfun.$anonfun.x$5" title="kafka.cluster.Broker">_</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.id" title="=&gt; Int">id</a><span class="delimiter">)</span>.<span title="(elem: Int)Boolean">contains</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.$anonfun.x$6" title="Int">_</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
                if <span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.isrInfo" title="Seq[kafka.cluster.Broker]">isrInfo</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&lt;</span> <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.isr" title="List[Int]">isr</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>
                  throw new <a href="../common/ReplicaNotAvailableException.scala.html#kafka.common;ReplicaNotAvailableException" title="kafka.common.ReplicaNotAvailableException">ReplicaNotAvailableException</a><span class="delimiter">(</span><span title="String(&quot;In Sync Replica information not available for following brokers: &quot;)" class="string">&quot;In Sync Replica information not available for following brokers: &quot;</span> <span title="(x$1: Any)String">+</span>
                    <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.isr" title="List[Int]">isr</a>.<span title="(p: Int =&gt; Boolean)List[Int]">filterNot</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.isrInfo" title="Seq[kafka.cluster.Broker]">isrInfo</a>.<span title="(f: kafka.cluster.Broker =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.cluster.Broker],Int,Seq[Int]])Seq[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,Int,Seq[Int]]" class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.$anonfun.$anonfun.x$7" title="kafka.cluster.Broker">_</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.id" title="=&gt; Int">id</a><span class="delimiter">)</span>.<span title="(elem: Int)Boolean">contains</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.$anonfun.x$8" title="Int">_</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
                new <a href="../api/TopicMetadata.scala.html#kafka.api;PartitionMetadata" title="kafka.api.PartitionMetadata">PartitionMetadata</a><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.partitionId" title="Int">partitionId</a>, <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.leaderInfo" title="Option[kafka.cluster.Broker]">leaderInfo</a>, <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.replicaInfo" title="Seq[kafka.cluster.Broker]">replicaInfo</a>, <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.isrInfo" title="Seq[kafka.cluster.Broker]">isrInfo</a>, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span>
              <span class="delimiter">}</span> catch <span class="delimiter">{</span>
                case <a title="Throwable" id="kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.e">e</a>: <span title="Throwable">Throwable</span> =&gt;
                  <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Error while fetching metadata for %s. Possible cause: %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.topicPartition" title="kafka.common.TopicAndPartition">topicPartition</a>, <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.e" title="Throwable">e</a>.<span title="()String">getMessage</span><span class="delimiter">)</span><span class="delimiter">)</span>
                  new <a href="../api/TopicMetadata.scala.html#kafka.api;PartitionMetadata" title="kafka.api.PartitionMetadata">PartitionMetadata</a><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.partitionId" title="Int">partitionId</a>, <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.leaderInfo" title="Option[kafka.cluster.Broker]">leaderInfo</a>, <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.replicaInfo" title="Seq[kafka.cluster.Broker]">replicaInfo</a>, <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.isrInfo" title="Seq[kafka.cluster.Broker]">isrInfo</a>,
                    <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.codeFor" title="(exception: Class[Throwable])Short">codeFor</a><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata.$anonfun.e" title="Throwable">e</a>.<span title="()Class[_]">getClass</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Class[Throwable]" class="delimiter">[</span><span title="Class[Throwable]">Class</span><span class="delimiter">[</span>Throwable<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <a href="#kafka.server;MetadataCache.getTopicMetadata.topicResponses" title="scala.collection.mutable.ListBuffer[kafka.api.TopicMetadata]">topicResponses</a> <span title="(x: kafka.api.TopicMetadata)topicResponses.type">+=</span> new <a href="../api/TopicMetadata.scala.html#kafka.api;TopicMetadata" title="kafka.api.TopicMetadata">TopicMetadata</a><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.topic" title="String">topic</a>, <a href="#kafka.server;MetadataCache.getTopicMetadata.$anonfun.partitionMetadata" title="scala.collection.mutable.Iterable[kafka.api.PartitionMetadata]">partitionMetadata</a>.<span title="=&gt; Seq[kafka.api.PartitionMetadata]">toSeq</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#kafka.server;MetadataCache.getTopicMetadata.topicResponses" title="scala.collection.mutable.ListBuffer[kafka.api.TopicMetadata]">topicResponses</a>
  <span class="delimiter">}</span>

  def <a title="=&gt; Seq[kafka.cluster.Broker]" id="kafka.server;MetadataCache.getAliveBrokers">getAliveBrokers</a> = <span class="delimiter">{</span>
    <a href="../utils/Utils.scala.html#kafka.utils.Utils.inReadLock" title="(lock: java.util.concurrent.locks.ReadWriteLock)(fun: =&gt; Seq[kafka.cluster.Broker])Seq[kafka.cluster.Broker]">inReadLock</a><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.partitionMetadataLock" title="=&gt; java.util.concurrent.locks.ReentrantReadWriteLock">partitionMetadataLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.server;MetadataCache.aliveBrokers_=" title="=&gt; Map[Int,kafka.cluster.Broker]">aliveBrokers</a>.<span title="=&gt; Iterable[kafka.cluster.Broker]">values</span>.<span title="=&gt; Seq[kafka.cluster.Broker]">toSeq</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(topic: String, partitionId: Int, stateInfo: kafka.api.PartitionStateInfo)Unit" id="kafka.server;MetadataCache.addOrUpdatePartitionInfo">addOrUpdatePartitionInfo</a><span class="delimiter">(</span><a title="String" id="kafka.server;MetadataCache.addOrUpdatePartitionInfo.topic">topic</a>: <span title="String">String</span>,
                               <a title="Int" id="kafka.server;MetadataCache.addOrUpdatePartitionInfo.partitionId">partitionId</a>: <span title="Int">Int</span>,
                               <a title="kafka.api.PartitionStateInfo" id="kafka.server;MetadataCache.addOrUpdatePartitionInfo.stateInfo">stateInfo</a>: <a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;PartitionStateInfo" title="kafka.api.PartitionStateInfo">PartitionStateInfo</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Utils.scala.html#kafka.utils.Utils.inWriteLock" title="(lock: java.util.concurrent.locks.ReadWriteLock)(fun: =&gt; Option[kafka.api.PartitionStateInfo])Option[kafka.api.PartitionStateInfo]">inWriteLock</a><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.partitionMetadataLock" title="=&gt; java.util.concurrent.locks.ReentrantReadWriteLock">partitionMetadataLock</a><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span>
      <a href="#kafka.server;MetadataCache.cache" title="=&gt; scala.collection.mutable.Map[String,scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]]">cache</a>.<span title="(key: String)Option[scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]]">get</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.addOrUpdatePartitionInfo.topic" title="String">topic</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case Some<span class="delimiter">(</span><a title="scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]" id="kafka.server;MetadataCache.addOrUpdatePartitionInfo.infos">infos</a><span class="delimiter">)</span> =&gt; <a href="#kafka.server;MetadataCache.addOrUpdatePartitionInfo.infos" title="scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]">infos</a>.<span title="(key: Int, value: kafka.api.PartitionStateInfo)Option[kafka.api.PartitionStateInfo]">put</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.addOrUpdatePartitionInfo.partitionId" title="Int">partitionId</a>, <a href="#kafka.server;MetadataCache.addOrUpdatePartitionInfo.stateInfo" title="kafka.api.PartitionStateInfo">stateInfo</a><span class="delimiter">)</span>
        case <span title="None.type">None</span> =&gt; <span class="delimiter">{</span>
          val <a title="scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]" id="kafka.server;MetadataCache.addOrUpdatePartitionInfo.newInfos">newInfos</a>: mutable.<span title="scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]">Map</span><span class="delimiter">[</span>Int, PartitionStateInfo<span class="delimiter">]</span> = new mutable.<span title="scala.collection.mutable.HashMap[Int,kafka.api.PartitionStateInfo]">HashMap</span><span class="delimiter">[</span>Int, PartitionStateInfo<span class="delimiter">]</span>
          <a href="#kafka.server;MetadataCache.cache" title="=&gt; scala.collection.mutable.Map[String,scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]]">cache</a>.<span title="(key: String, value: scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo])Option[scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]]">put</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.addOrUpdatePartitionInfo.topic" title="String">topic</a>, <a href="#kafka.server;MetadataCache.addOrUpdatePartitionInfo.newInfos" title="scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]">newInfos</a><span class="delimiter">)</span>
          <a href="#kafka.server;MetadataCache.addOrUpdatePartitionInfo.newInfos" title="scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]">newInfos</a>.<span title="(key: Int, value: kafka.api.PartitionStateInfo)Option[kafka.api.PartitionStateInfo]">put</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.addOrUpdatePartitionInfo.partitionId" title="Int">partitionId</a>, <a href="#kafka.server;MetadataCache.addOrUpdatePartitionInfo.stateInfo" title="kafka.api.PartitionStateInfo">stateInfo</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(topic: String, partitionId: Int)Option[kafka.api.PartitionStateInfo]" id="kafka.server;MetadataCache.getPartitionInfo">getPartitionInfo</a><span class="delimiter">(</span><a title="String" id="kafka.server;MetadataCache.getPartitionInfo.topic">topic</a>: <span title="String">String</span>, <a title="Int" id="kafka.server;MetadataCache.getPartitionInfo.partitionId">partitionId</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Option[kafka.api.PartitionStateInfo]">Option</span><span class="delimiter">[</span>PartitionStateInfo<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="../utils/Utils.scala.html#kafka.utils.Utils.inReadLock" title="(lock: java.util.concurrent.locks.ReadWriteLock)(fun: =&gt; Option[kafka.api.PartitionStateInfo])Option[kafka.api.PartitionStateInfo]">inReadLock</a><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.partitionMetadataLock" title="=&gt; java.util.concurrent.locks.ReentrantReadWriteLock">partitionMetadataLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.server;MetadataCache.cache" title="=&gt; scala.collection.mutable.Map[String,scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]]">cache</a>.<span title="(key: String)Option[scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]]">get</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getPartitionInfo.topic" title="String">topic</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case Some<span class="delimiter">(</span><a title="scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]" id="kafka.server;MetadataCache.getPartitionInfo.partitionInfos">partitionInfos</a><span class="delimiter">)</span> =&gt; <a href="#kafka.server;MetadataCache.getPartitionInfo.partitionInfos" title="scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]">partitionInfos</a>.<span title="(key: Int)Option[kafka.api.PartitionStateInfo]">get</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.getPartitionInfo.partitionId" title="Int">partitionId</a><span class="delimiter">)</span>
        case <span title="None.type">None</span> =&gt; <span title="None.type">None</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(updateMetadataRequest: kafka.api.UpdateMetadataRequest, brokerId: Int, stateChangeLogger: kafka.controller.KafkaController.StateChangeLogger)Unit" id="kafka.server;MetadataCache.updateCache">updateCache</a><span class="delimiter">(</span><a title="kafka.api.UpdateMetadataRequest" id="kafka.server;MetadataCache.updateCache.updateMetadataRequest">updateMetadataRequest</a>: <a href="../api/UpdateMetadataRequest.scala.html#kafka.api;UpdateMetadataRequest" title="kafka.api.UpdateMetadataRequest">UpdateMetadataRequest</a>,
                  <a title="Int" id="kafka.server;MetadataCache.updateCache.brokerId">brokerId</a>: <span title="Int">Int</span>,
                  <a title="kafka.controller.KafkaController.StateChangeLogger" id="kafka.server;MetadataCache.updateCache.stateChangeLogger">stateChangeLogger</a>: <a href="../controller/KafkaController.scala.html#kafka.controller.KafkaController;StateChangeLogger" title="kafka.controller.KafkaController.StateChangeLogger">StateChangeLogger</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Utils.scala.html#kafka.utils.Utils.inWriteLock" title="(lock: java.util.concurrent.locks.ReadWriteLock)(fun: =&gt; Unit)Unit">inWriteLock</a><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.partitionMetadataLock" title="=&gt; java.util.concurrent.locks.ReentrantReadWriteLock">partitionMetadataLock</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.server;MetadataCache.aliveBrokers_=" title="(x$1: Map[Int,kafka.cluster.Broker])Unit">aliveBrokers</a> = <a href="#kafka.server;MetadataCache.updateCache.updateMetadataRequest" title="kafka.api.UpdateMetadataRequest">updateMetadataRequest</a>.<a href="../api/UpdateMetadataRequest.scala.html#kafka.api;UpdateMetadataRequest.aliveBrokers" title="=&gt; scala.collection.Set[kafka.cluster.Broker]">aliveBrokers</a>.<span title="(f: kafka.cluster.Broker =&gt; (Int, kafka.cluster.Broker))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.Set[kafka.cluster.Broker],(Int, kafka.cluster.Broker),scala.collection.Set[(Int, kafka.cluster.Broker)]])scala.collection.Set[(Int, kafka.cluster.Broker)]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Set.Coll,(Int, kafka.cluster.Broker),scala.collection.Set[(Int, kafka.cluster.Broker)]]" class="delimiter">(</span><a title="kafka.cluster.Broker" id="kafka.server;MetadataCache.updateCache.$anonfun.b">b</a> =&gt; <span title="(_1: Int, _2: kafka.cluster.Broker)(Int, kafka.cluster.Broker)" class="delimiter">(</span><a href="#kafka.server;MetadataCache.updateCache.$anonfun.b" title="kafka.cluster.Broker">b</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.id" title="=&gt; Int">id</a>, <a href="#kafka.server;MetadataCache.updateCache.$anonfun.b" title="kafka.cluster.Broker">b</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: &lt;:&lt;[(Int, kafka.cluster.Broker),(Int, kafka.cluster.Broker)])scala.collection.immutable.Map[Int,kafka.cluster.Broker]">toMap</span>
      <a href="#kafka.server;MetadataCache.updateCache.updateMetadataRequest" title="kafka.api.UpdateMetadataRequest">updateMetadataRequest</a>.<a href="../api/UpdateMetadataRequest.scala.html#kafka.api;UpdateMetadataRequest.partitionStateInfos" title="=&gt; Map[kafka.common.TopicAndPartition,kafka.api.PartitionStateInfo]">partitionStateInfos</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.api.PartitionStateInfo)) =&gt; Unit)Unit">foreach</span> <a href="#kafka.server;MetadataCache.updateCache.$anonfun.x0$2" title="Unit" class="delimiter">{</a> case<span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;MetadataCache.updateCache.$anonfun.tp">tp</a>, <a title="kafka.api.PartitionStateInfo" id="kafka.server;MetadataCache.updateCache.$anonfun.info">info</a><span class="delimiter">)</span> =&gt;
        if <span class="delimiter">(</span><a href="#kafka.server;MetadataCache.updateCache.$anonfun.info" title="kafka.api.PartitionStateInfo">info</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;PartitionStateInfo.leaderIsrAndControllerEpoch" title="=&gt; kafka.controller.LeaderIsrAndControllerEpoch">leaderIsrAndControllerEpoch</a>.<a href="../controller/KafkaController.scala.html#kafka.controller;LeaderIsrAndControllerEpoch.leaderAndIsr" title="=&gt; kafka.api.LeaderAndIsr">leaderAndIsr</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;LeaderAndIsr.leader" title="=&gt; Int">leader</a> <span title="(x: Int)Boolean">==</span> <a href="../api/LeaderAndIsrRequest.scala.html#kafka.api.LeaderAndIsr" title="kafka.api.LeaderAndIsr.type">LeaderAndIsr</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api.LeaderAndIsr.LeaderDuringDelete" title="=&gt; Int">LeaderDuringDelete</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#kafka.server;MetadataCache.removePartitionInfo" title="(topic: String, partitionId: Int)Boolean">removePartitionInfo</a><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.updateCache.$anonfun.tp" title="kafka.common.TopicAndPartition">tp</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.server;MetadataCache.updateCache.$anonfun.tp" title="kafka.common.TopicAndPartition">tp</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a><span class="delimiter">)</span>
          <a href="#kafka.server;MetadataCache.updateCache.stateChangeLogger" title="kafka.controller.KafkaController.StateChangeLogger">stateChangeLogger</a>.<a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="string">&quot;Broker %d deleted partition %s from metadata cache in response to UpdateMetadata request &quot;</span> <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">+</span>
            <span class="string">&quot;sent by controller %d epoch %d with correlation id %d&quot;</span><span class="delimiter">)</span>
            .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.updateCache.brokerId" title="Int">brokerId</a>, <a href="#kafka.server;MetadataCache.updateCache.$anonfun.tp" title="kafka.common.TopicAndPartition">tp</a>, <a href="#kafka.server;MetadataCache.updateCache.updateMetadataRequest" title="kafka.api.UpdateMetadataRequest">updateMetadataRequest</a>.<a href="../api/UpdateMetadataRequest.scala.html#kafka.api;UpdateMetadataRequest.controllerId" title="=&gt; Int">controllerId</a>,
            <a href="#kafka.server;MetadataCache.updateCache.updateMetadataRequest" title="kafka.api.UpdateMetadataRequest">updateMetadataRequest</a>.<a href="../api/UpdateMetadataRequest.scala.html#kafka.api;UpdateMetadataRequest.controllerEpoch" title="=&gt; Int">controllerEpoch</a>, <a href="#kafka.server;MetadataCache.updateCache.updateMetadataRequest" title="kafka.api.UpdateMetadataRequest">updateMetadataRequest</a>.<a href="../api/UpdateMetadataRequest.scala.html#kafka.api;UpdateMetadataRequest.correlationId" title="=&gt; Int">correlationId</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span> else <span class="delimiter">{</span>
          <a href="#kafka.server;MetadataCache.addOrUpdatePartitionInfo" title="(topic: String, partitionId: Int, stateInfo: kafka.api.PartitionStateInfo)Unit">addOrUpdatePartitionInfo</a><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.updateCache.$anonfun.tp" title="kafka.common.TopicAndPartition">tp</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.server;MetadataCache.updateCache.$anonfun.tp" title="kafka.common.TopicAndPartition">tp</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a>, <a href="#kafka.server;MetadataCache.updateCache.$anonfun.info" title="kafka.api.PartitionStateInfo">info</a><span class="delimiter">)</span>
          <a href="#kafka.server;MetadataCache.updateCache.stateChangeLogger" title="kafka.controller.KafkaController.StateChangeLogger">stateChangeLogger</a>.<a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="string">&quot;Broker %d cached leader info %s for partition %s in response to UpdateMetadata request &quot;</span> <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">+</span>
            <span class="string">&quot;sent by controller %d epoch %d with correlation id %d&quot;</span><span class="delimiter">)</span>
            .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.updateCache.brokerId" title="Int">brokerId</a>, <a href="#kafka.server;MetadataCache.updateCache.$anonfun.info" title="kafka.api.PartitionStateInfo">info</a>, <a href="#kafka.server;MetadataCache.updateCache.$anonfun.tp" title="kafka.common.TopicAndPartition">tp</a>, <a href="#kafka.server;MetadataCache.updateCache.updateMetadataRequest" title="kafka.api.UpdateMetadataRequest">updateMetadataRequest</a>.<a href="../api/UpdateMetadataRequest.scala.html#kafka.api;UpdateMetadataRequest.controllerId" title="=&gt; Int">controllerId</a>,
            <a href="#kafka.server;MetadataCache.updateCache.updateMetadataRequest" title="kafka.api.UpdateMetadataRequest">updateMetadataRequest</a>.<a href="../api/UpdateMetadataRequest.scala.html#kafka.api;UpdateMetadataRequest.controllerEpoch" title="=&gt; Int">controllerEpoch</a>, <a href="#kafka.server;MetadataCache.updateCache.updateMetadataRequest" title="kafka.api.UpdateMetadataRequest">updateMetadataRequest</a>.<a href="../api/UpdateMetadataRequest.scala.html#kafka.api;UpdateMetadataRequest.correlationId" title="=&gt; Int">correlationId</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  private def <a title="(topic: String, partitionId: Int)Boolean" id="kafka.server;MetadataCache.removePartitionInfo">removePartitionInfo</a><span class="delimiter">(</span><a title="String" id="kafka.server;MetadataCache.removePartitionInfo.topic">topic</a>: <span title="String">String</span>, <a title="Int" id="kafka.server;MetadataCache.removePartitionInfo.partitionId">partitionId</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#kafka.server;MetadataCache.cache" title="=&gt; scala.collection.mutable.Map[String,scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]]">cache</a>.<span title="(key: String)Option[scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]]">get</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.removePartitionInfo.topic" title="String">topic</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case Some<span class="delimiter">(</span><a title="scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]" id="kafka.server;MetadataCache.removePartitionInfo.infos">infos</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
        <a href="#kafka.server;MetadataCache.removePartitionInfo.infos" title="scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]">infos</a>.<span title="(key: Int)Option[kafka.api.PartitionStateInfo]">remove</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.removePartitionInfo.partitionId" title="Int">partitionId</a><span class="delimiter">)</span>
        if<span class="delimiter">(</span><a href="#kafka.server;MetadataCache.removePartitionInfo.infos" title="scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]">infos</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#kafka.server;MetadataCache.cache" title="=&gt; scala.collection.mutable.Map[String,scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]]">cache</a>.<span title="(key: String)Option[scala.collection.mutable.Map[Int,kafka.api.PartitionStateInfo]]">remove</span><span class="delimiter">(</span><a href="#kafka.server;MetadataCache.removePartitionInfo.topic" title="String">topic</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        true
      <span class="delimiter">}</span>
      case <span title="None.type">None</span> =&gt; false
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>
