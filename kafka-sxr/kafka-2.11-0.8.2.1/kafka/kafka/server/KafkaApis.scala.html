<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/server/KafkaApis.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package kafka.server

import kafka.api._
import kafka.common._
import kafka.log._
import kafka.message._
import kafka.network._
import kafka.admin.AdminUtils
import kafka.network.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel" title="kafka.network.RequestChannel.type">RequestChannel</a>.Response
import kafka.controller.KafkaController
import kafka.utils.<span class="delimiter">{</span>ZkUtils, ZKGroupTopicDirs, SystemTime, Logging<span class="delimiter">}</span>

import scala.collection._

import org.I0Itec.zkclient.ZkClient

<span class="comment">/**
 * Logic to handle the various Kafka requests
 */</span>
class <a title="class KafkaApis extends AnyRef with kafka.utils.Logging" id="kafka.server;KafkaApis">KafkaApis</a><a href="#kafka.server;KafkaApis" title="kafka.server.KafkaApis" class="delimiter">(</a>val <a title="kafka.network.RequestChannel" id="kafka.server;KafkaApis.requestChannel">requestChannel</a>: <a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel" title="kafka.network.RequestChannel">RequestChannel</a>,
                val <a title="kafka.server.ReplicaManager" id="kafka.server;KafkaApis.replicaManager">replicaManager</a>: <a href="ReplicaManager.scala.html#kafka.server;ReplicaManager" title="kafka.server.ReplicaManager">ReplicaManager</a>,
                val <a title="kafka.server.OffsetManager" id="kafka.server;KafkaApis.offsetManager">offsetManager</a>: <a href="OffsetManager.scala.html#kafka.server;OffsetManager" title="kafka.server.OffsetManager">OffsetManager</a>,
                val <a title="org.I0Itec.zkclient.ZkClient" id="kafka.server;KafkaApis.zkClient">zkClient</a>: <span title="org.I0Itec.zkclient.ZkClient">ZkClient</span>,
                val <a title="Int" id="kafka.server;KafkaApis.brokerId">brokerId</a>: <span title="Int">Int</span>,
                val <a title="kafka.server.KafkaConfig" id="kafka.server;KafkaApis.config">config</a>: <a href="KafkaConfig.scala.html#kafka.server;KafkaConfig" title="kafka.server.KafkaConfig">KafkaConfig</a>,
                val <a title="kafka.controller.KafkaController" id="kafka.server;KafkaApis.controller">controller</a>: <a href="../controller/KafkaController.scala.html#kafka.controller;KafkaController" title="kafka.controller.KafkaController">KafkaController</a><span class="delimiter">)</span> extends <a href="../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> <span class="delimiter">{</span>

  val <a title="kafka.server.ProducerRequestPurgatory" id="kafka.server;KafkaApis.producerRequestPurgatory">producerRequestPurgatory</a> = new <a href="ProducerRequestPurgatory.scala.html#kafka.server;ProducerRequestPurgatory" title="kafka.server.ProducerRequestPurgatory">ProducerRequestPurgatory</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.replicaManager" title="=&gt; kafka.server.ReplicaManager">replicaManager</a>, <a href="#kafka.server;KafkaApis.offsetManager" title="=&gt; kafka.server.OffsetManager">offsetManager</a>, <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a><span class="delimiter">)</span>
  val <a title="kafka.server.FetchRequestPurgatory" id="kafka.server;KafkaApis.fetchRequestPurgatory">fetchRequestPurgatory</a> = new <a href="FetchRequestPurgatory.scala.html#kafka.server;FetchRequestPurgatory" title="kafka.server.FetchRequestPurgatory">FetchRequestPurgatory</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.replicaManager" title="=&gt; kafka.server.ReplicaManager">replicaManager</a>, <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a><span class="delimiter">)</span>
  <span class="comment">// TODO: the following line will be removed in 0.9</span>
  <a href="#kafka.server;KafkaApis.replicaManager" title="=&gt; kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.initWithRequestPurgatory" title="(producerRequestPurgatory: kafka.server.ProducerRequestPurgatory, fetchRequestPurgatory: kafka.server.FetchRequestPurgatory)Unit">initWithRequestPurgatory</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.producerRequestPurgatory" title="=&gt; kafka.server.ProducerRequestPurgatory">producerRequestPurgatory</a>, <a href="#kafka.server;KafkaApis.fetchRequestPurgatory" title="=&gt; kafka.server.FetchRequestPurgatory">fetchRequestPurgatory</a><span class="delimiter">)</span>
  var <a title="kafka.server.MetadataCache" id="kafka.server;KafkaApis.metadataCache_=">metadataCache</a> = new <a href="MetadataCache.scala.html#kafka.server;MetadataCache" title="kafka.server.MetadataCache">MetadataCache</a>
  this.<a href="../utils/Logging.scala.html#kafka.utils;Logging.logIdent_=" title="(x$1: String)Unit">logIdent</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;[KafkaApi-%d] &quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Top-level method that handles all requests and multiplexes to the right api
   */</span>
  def <a title="(request: kafka.network.RequestChannel.Request)Unit" id="kafka.server;KafkaApis.handle">handle</a><span class="delimiter">(</span><a title="kafka.network.RequestChannel.Request" id="kafka.server;KafkaApis.handle.request">request</a>: RequestChannel.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request" title="kafka.network.RequestChannel.Request">Request</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    try<span class="delimiter">{</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="String(&quot;Handling request: &quot;)" class="string">&quot;Handling request: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestObj" title="=&gt; kafka.api.RequestOrResponse">requestObj</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; from client: &quot;)" class="string">&quot; from client: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.remoteAddress" title="=&gt; java.net.SocketAddress">remoteAddress</a><span class="delimiter">)</span>
      <a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestId" title="=&gt; Short">requestId</a> match <span class="delimiter">{</span>
        case <a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys" title="kafka.api.RequestKeys.type">RequestKeys</a>.<a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys.ProduceKey" title="=&gt; Short">ProduceKey</a> =&gt; <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest" title="(request: kafka.network.RequestChannel.Request)Unit">handleProducerOrOffsetCommitRequest</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a><span class="delimiter">)</span>
        case <a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys" title="kafka.api.RequestKeys.type">RequestKeys</a>.<a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys.FetchKey" title="=&gt; Short">FetchKey</a> =&gt; <a href="#kafka.server;KafkaApis.handleFetchRequest" title="(request: kafka.network.RequestChannel.Request)Unit">handleFetchRequest</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a><span class="delimiter">)</span>
        case <a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys" title="kafka.api.RequestKeys.type">RequestKeys</a>.<a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys.OffsetsKey" title="=&gt; Short">OffsetsKey</a> =&gt; <a href="#kafka.server;KafkaApis.handleOffsetRequest" title="(request: kafka.network.RequestChannel.Request)Unit">handleOffsetRequest</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a><span class="delimiter">)</span>
        case <a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys" title="kafka.api.RequestKeys.type">RequestKeys</a>.<a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys.MetadataKey" title="=&gt; Short">MetadataKey</a> =&gt; <a href="#kafka.server;KafkaApis.handleTopicMetadataRequest" title="(request: kafka.network.RequestChannel.Request)Unit">handleTopicMetadataRequest</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a><span class="delimiter">)</span>
        case <a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys" title="kafka.api.RequestKeys.type">RequestKeys</a>.<a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys.LeaderAndIsrKey" title="=&gt; Short">LeaderAndIsrKey</a> =&gt; <a href="#kafka.server;KafkaApis.handleLeaderAndIsrRequest" title="(request: kafka.network.RequestChannel.Request)Unit">handleLeaderAndIsrRequest</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a><span class="delimiter">)</span>
        case <a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys" title="kafka.api.RequestKeys.type">RequestKeys</a>.<a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys.StopReplicaKey" title="=&gt; Short">StopReplicaKey</a> =&gt; <a href="#kafka.server;KafkaApis.handleStopReplicaRequest" title="(request: kafka.network.RequestChannel.Request)Unit">handleStopReplicaRequest</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a><span class="delimiter">)</span>
        case <a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys" title="kafka.api.RequestKeys.type">RequestKeys</a>.<a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys.UpdateMetadataKey" title="=&gt; Short">UpdateMetadataKey</a> =&gt; <a href="#kafka.server;KafkaApis.handleUpdateMetadataRequest" title="(request: kafka.network.RequestChannel.Request)Unit">handleUpdateMetadataRequest</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a><span class="delimiter">)</span>
        case <a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys" title="kafka.api.RequestKeys.type">RequestKeys</a>.<a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys.ControlledShutdownKey" title="=&gt; Short">ControlledShutdownKey</a> =&gt; <a href="#kafka.server;KafkaApis.handleControlledShutdownRequest" title="(request: kafka.network.RequestChannel.Request)Unit">handleControlledShutdownRequest</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a><span class="delimiter">)</span>
        case <a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys" title="kafka.api.RequestKeys.type">RequestKeys</a>.<a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys.OffsetCommitKey" title="=&gt; Short">OffsetCommitKey</a> =&gt; <a href="#kafka.server;KafkaApis.handleOffsetCommitRequest" title="(request: kafka.network.RequestChannel.Request)Unit">handleOffsetCommitRequest</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a><span class="delimiter">)</span>
        case <a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys" title="kafka.api.RequestKeys.type">RequestKeys</a>.<a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys.OffsetFetchKey" title="=&gt; Short">OffsetFetchKey</a> =&gt; <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest" title="(request: kafka.network.RequestChannel.Request)Unit">handleOffsetFetchRequest</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a><span class="delimiter">)</span>
        case <a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys" title="kafka.api.RequestKeys.type">RequestKeys</a>.<a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys.ConsumerMetadataKey" title="=&gt; Short">ConsumerMetadataKey</a> =&gt; <a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest" title="(request: kafka.network.RequestChannel.Request)Unit">handleConsumerMetadataRequest</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a><span class="delimiter">)</span>
        case <a title="Short" id="kafka.server;KafkaApis.handle.requestId">requestId</a> =&gt; throw new <a href="../common/KafkaException.scala.html#kafka.common;KafkaException" title="kafka.common.KafkaException">KafkaException</a><span class="delimiter">(</span><span title="String(&quot;Unknown api code &quot;)" class="string">&quot;Unknown api code &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.server;KafkaApis.handle.requestId" title="Short">requestId</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> catch <span class="delimiter">{</span>
      case <a title="Throwable" id="kafka.server;KafkaApis.handle.e">e</a>: <span title="Throwable">Throwable</span> =&gt;
        <a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestObj" title="=&gt; kafka.api.RequestOrResponse">requestObj</a>.<a href="../api/RequestOrResponse.scala.html#kafka.api;RequestOrResponse.handleError" title="(e: Throwable, requestChannel: kafka.network.RequestChannel, request: kafka.network.RequestChannel.Request)Unit">handleError</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handle.e" title="Throwable">e</a>, <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>, <a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a><span class="delimiter">)</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.error(cfd112d89b)" title="(msg: =&gt; String, e: =&gt; Throwable)Unit">error</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;error when handling request %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestObj" title="=&gt; kafka.api.RequestOrResponse">requestObj</a><span class="delimiter">)</span>, <a href="#kafka.server;KafkaApis.handle.e" title="Throwable">e</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> finally
      <a href="#kafka.server;KafkaApis.handle.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.apiLocalCompleteTimeMs_=" title="(x$1: Long)Unit">apiLocalCompleteTimeMs</a> = <a href="../utils/Time.scala.html#kafka.utils.SystemTime" title="kafka.utils.SystemTime.type">SystemTime</a>.<a href="../utils/Time.scala.html#kafka.utils.SystemTime.milliseconds" title="=&gt; Long">milliseconds</a>
  <span class="delimiter">}</span>

  def <a title="(request: kafka.network.RequestChannel.Request)Unit" id="kafka.server;KafkaApis.handleOffsetCommitRequest">handleOffsetCommitRequest</a><span class="delimiter">(</span><a title="kafka.network.RequestChannel.Request" id="kafka.server;KafkaApis.handleOffsetCommitRequest.request">request</a>: RequestChannel.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request" title="kafka.network.RequestChannel.Request">Request</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="kafka.api.OffsetCommitRequest" id="kafka.server;KafkaApis.handleOffsetCommitRequest.offsetCommitRequest">offsetCommitRequest</a> = <a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestObj" title="=&gt; kafka.api.RequestOrResponse">requestObj</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.api.OffsetCommitRequest" class="delimiter">[</span><a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest" title="kafka.api.OffsetCommitRequest">OffsetCommitRequest</a><span class="delimiter">]</span>
    if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.offsetCommitRequest" title="kafka.api.OffsetCommitRequest">offsetCommitRequest</a>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.versionId" title="=&gt; Short">versionId</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// version 0 stores the offsets in ZK</span>
      val <a title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,Short]" id="kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo">responseInfo</a> = <a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.offsetCommitRequest" title="kafka.api.OffsetCommitRequest">offsetCommitRequest</a>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.requestInfo" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetAndMetadata]">requestInfo</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.common.OffsetAndMetadata)) =&gt; (kafka.common.TopicAndPartition, Short))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetAndMetadata],(kafka.common.TopicAndPartition, Short),scala.collection.immutable.Map[kafka.common.TopicAndPartition,Short]])scala.collection.immutable.Map[kafka.common.TopicAndPartition,Short]">map</span><a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.x0$1" title="(kafka.common.TopicAndPartition, Short)" class="delimiter">{</a>
        case <span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="kafka.common.OffsetAndMetadata" id="kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.metaAndError">metaAndError</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
          val <a title="kafka.utils.ZKGroupTopicDirs" id="kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.topicDirs">topicDirs</a> = new <a href="../utils/ZkUtils.scala.html#kafka.utils;ZKGroupTopicDirs" title="kafka.utils.ZKGroupTopicDirs">ZKGroupTopicDirs</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.offsetCommitRequest" title="kafka.api.OffsetCommitRequest">offsetCommitRequest</a>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.groupId" title="=&gt; String">groupId</a>, <a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>
          try <span class="delimiter">{</span>
            <a href="#kafka.server;KafkaApis.ensureTopicExists" title="(topic: String)Unit">ensureTopicExists</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>
            if<span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.metaAndError" title="kafka.common.OffsetAndMetadata">metaAndError</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata.metadata" title="=&gt; String">metadata</a> <span title="(x$1: Any)Boolean">!=</span> null <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.metaAndError" title="kafka.common.OffsetAndMetadata">metaAndError</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata.metadata" title="=&gt; String">metadata</a>.<span title="()Int">length</span> <span title="(x: Int)Boolean">&gt;</span> <a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.offsetMetadataMaxSize" title="=&gt; Int">offsetMetadataMaxSize</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span title="(_1: kafka.common.TopicAndPartition, _2: Short)(kafka.common.TopicAndPartition, Short)" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.OffsetMetadataTooLargeCode" title="=&gt; Short">OffsetMetadataTooLargeCode</a><span class="delimiter">)</span>
            <span class="delimiter">}</span> else <span class="delimiter">{</span>
              <a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.updatePersistentPath" title="(client: org.I0Itec.zkclient.ZkClient, path: String, data: String)Unit">updatePersistentPath</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.zkClient" title="=&gt; org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.topicDirs" title="kafka.utils.ZKGroupTopicDirs">topicDirs</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils;ZKGroupTopicDirs.consumerOffsetDir" title="=&gt; String">consumerOffsetDir</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;/&quot;)" class="string">&quot;/&quot;</span> <span title="(x$1: Any)String">+</span>
                <a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a>, <a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.metaAndError" title="kafka.common.OffsetAndMetadata">metaAndError</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetAndMetadata.offset" title="=&gt; Long">offset</a>.<span title="()String">toString</span><span class="delimiter">)</span>
              <span title="(_1: kafka.common.TopicAndPartition, _2: Short)(kafka.common.TopicAndPartition, Short)" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span> catch <span class="delimiter">{</span>
            case <a title="Throwable" id="kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.e">e</a>: <span title="Throwable">Throwable</span> =&gt; <span title="(_1: kafka.common.TopicAndPartition, _2: Short)(kafka.common.TopicAndPartition, Short)" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.codeFor" title="(exception: Class[Throwable])Short">codeFor</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo.$anonfun.e" title="Throwable">e</a>.<span title="()Class[_]">getClass</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Class[Throwable]" class="delimiter">[</span><span title="Class[Throwable]">Class</span><span class="delimiter">[</span>Throwable<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      val <a title="kafka.api.OffsetCommitResponse" id="kafka.server;KafkaApis.handleOffsetCommitRequest.response">response</a> = new <a href="../api/OffsetCommitResponse.scala.html#kafka.api;OffsetCommitResponse" title="kafka.api.OffsetCommitResponse">OffsetCommitResponse</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.responseInfo" title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,Short]">responseInfo</a>, <a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.offsetCommitRequest" title="kafka.api.OffsetCommitRequest">offsetCommitRequest</a>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.correlationId" title="=&gt; Int">correlationId</a><span class="delimiter">)</span>
      <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel.sendResponse" title="(response: kafka.network.RequestChannel.Response)Unit">sendResponse</a><span class="delimiter">(</span>new <a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel" title="kafka.network.RequestChannel.type">RequestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Response" title="kafka.network.RequestChannel.Response">Response</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.request" title="kafka.network.RequestChannel.Request">request</a>, new <a href="../network/BoundedByteBufferSend.scala.html#kafka.network;BoundedByteBufferSend" title="kafka.network.BoundedByteBufferSend">BoundedByteBufferSend</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.response" title="kafka.api.OffsetCommitResponse">response</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <span class="comment">// version 1 and above store the offsets in a special Kafka topic</span>
      <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest" title="(request: kafka.network.RequestChannel.Request)Unit">handleProducerOrOffsetCommitRequest</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetCommitRequest.request" title="kafka.network.RequestChannel.Request">request</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  private def <a title="(topic: String)Unit" id="kafka.server;KafkaApis.ensureTopicExists">ensureTopicExists</a><span class="delimiter">(</span><a title="String" id="kafka.server;KafkaApis.ensureTopicExists.topic">topic</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.metadataCache_=" title="=&gt; kafka.server.MetadataCache">metadataCache</a>.<a href="MetadataCache.scala.html#kafka.server;MetadataCache.getTopicMetadata" title="(topics: scala.collection.Set[String])scala.collection.mutable.ListBuffer[kafka.api.TopicMetadata]">getTopicMetadata</a><span class="delimiter">(</span><span title="(elems: String*)scala.collection.Set[String]">Set</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.ensureTopicExists.topic" title="String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      throw new <a href="../common/UnknownTopicOrPartitionException.scala.html#kafka.common;UnknownTopicOrPartitionException" title="kafka.common.UnknownTopicOrPartitionException">UnknownTopicOrPartitionException</a><span class="delimiter">(</span><span title="String(&quot;Topic &quot;)" class="string">&quot;Topic &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.server;KafkaApis.ensureTopicExists.topic" title="String">topic</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; either doesn\'t exist or is in the process of being deleted&quot;)" class="string">&quot; either doesn't exist or is in the process of being deleted&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(request: kafka.network.RequestChannel.Request)Unit" id="kafka.server;KafkaApis.handleLeaderAndIsrRequest">handleLeaderAndIsrRequest</a><span class="delimiter">(</span><a title="kafka.network.RequestChannel.Request" id="kafka.server;KafkaApis.handleLeaderAndIsrRequest.request">request</a>: RequestChannel.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request" title="kafka.network.RequestChannel.Request">Request</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">// ensureTopicExists is only for client facing requests</span>
    <span class="comment">// We can't have the ensureTopicExists check here since the controller sends it as an advisory to all brokers so they</span>
    <span class="comment">// stop serving data to clients for the topic being deleted</span>
    val <a title="kafka.api.LeaderAndIsrRequest" id="kafka.server;KafkaApis.handleLeaderAndIsrRequest.leaderAndIsrRequest">leaderAndIsrRequest</a> = <a href="#kafka.server;KafkaApis.handleLeaderAndIsrRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestObj" title="=&gt; kafka.api.RequestOrResponse">requestObj</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.api.LeaderAndIsrRequest" class="delimiter">[</span><a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;LeaderAndIsrRequest" title="kafka.api.LeaderAndIsrRequest">LeaderAndIsrRequest</a><span class="delimiter">]</span>
    try <span class="delimiter">{</span>
      val <a href="#kafka.server;KafkaApis.handleLeaderAndIsrRequest.response" title="(scala.collection.Map[(String, Int),Short], Short)" class="delimiter">(</a><a href="#kafka.server;KafkaApis.handleLeaderAndIsrRequest.x$1" title="scala.collection.Map[(String, Int),Short]" id="kafka.server;KafkaApis.handleLeaderAndIsrRequest.response">response</a>, <a href="#kafka.server;KafkaApis.handleLeaderAndIsrRequest.x$1" title="Short" id="kafka.server;KafkaApis.handleLeaderAndIsrRequest.error">error</a><span class="delimiter">)</span> = <a href="#kafka.server;KafkaApis.replicaManager" title="=&gt; kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.becomeLeaderOrFollower" title="(leaderAndISRRequest: kafka.api.LeaderAndIsrRequest, offsetManager: kafka.server.OffsetManager)(scala.collection.Map[(String, Int),Short], Short)">becomeLeaderOrFollower</a><span title="(scala.collection.Map[(String, Int),Short], Short) @unchecked" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleLeaderAndIsrRequest.leaderAndIsrRequest" title="kafka.api.LeaderAndIsrRequest">leaderAndIsrRequest</a>, <a href="#kafka.server;KafkaApis.offsetManager" title="=&gt; kafka.server.OffsetManager">offsetManager</a><span class="delimiter">)</span>
      val <a title="kafka.api.LeaderAndIsrResponse" id="kafka.server;KafkaApis.handleLeaderAndIsrRequest.leaderAndIsrResponse">leaderAndIsrResponse</a> = new <a href="../api/LeaderAndIsrResponse.scala.html#kafka.api;LeaderAndIsrResponse" title="kafka.api.LeaderAndIsrResponse">LeaderAndIsrResponse</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleLeaderAndIsrRequest.leaderAndIsrRequest" title="kafka.api.LeaderAndIsrRequest">leaderAndIsrRequest</a>.<a href="../api/LeaderAndIsrRequest.scala.html#kafka.api;LeaderAndIsrRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.handleLeaderAndIsrRequest.response" title="scala.collection.Map[(String, Int),Short]">response</a>, <a href="#kafka.server;KafkaApis.handleLeaderAndIsrRequest.error" title="Short">error</a><span class="delimiter">)</span>
      <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel.sendResponse" title="(response: kafka.network.RequestChannel.Response)Unit">sendResponse</a><span class="delimiter">(</span>new <a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Response" title="kafka.network.RequestChannel.Response">Response</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleLeaderAndIsrRequest.request" title="kafka.network.RequestChannel.Request">request</a>, new <a href="../network/BoundedByteBufferSend.scala.html#kafka.network;BoundedByteBufferSend" title="kafka.network.BoundedByteBufferSend">BoundedByteBufferSend</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleLeaderAndIsrRequest.leaderAndIsrResponse" title="kafka.api.LeaderAndIsrResponse">leaderAndIsrResponse</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> catch <span class="delimiter">{</span>
      case <a title="kafka.common.KafkaStorageException" id="kafka.server;KafkaApis.handleLeaderAndIsrRequest.e">e</a>: <a href="../common/KafkaStorageException.scala.html#kafka.common;KafkaStorageException" title="kafka.common.KafkaStorageException">KafkaStorageException</a> =&gt;
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.fatal(cfd112d89b)" title="(msg: =&gt; String, e: =&gt; Throwable)Unit">fatal</a><span class="delimiter">(</span><span title="String(&quot;Disk error during leadership change.&quot;)" class="string">&quot;Disk error during leadership change.&quot;</span>, <a href="#kafka.server;KafkaApis.handleLeaderAndIsrRequest.e" title="kafka.common.KafkaStorageException">e</a><span class="delimiter">)</span>
        <span title="Runtime.type">Runtime</span>.<span title="()Runtime">getRuntime</span>.<span title="(x$1: Int)Unit">halt</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(request: kafka.network.RequestChannel.Request)Unit" id="kafka.server;KafkaApis.handleStopReplicaRequest">handleStopReplicaRequest</a><span class="delimiter">(</span><a title="kafka.network.RequestChannel.Request" id="kafka.server;KafkaApis.handleStopReplicaRequest.request">request</a>: RequestChannel.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request" title="kafka.network.RequestChannel.Request">Request</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">// ensureTopicExists is only for client facing requests</span>
    <span class="comment">// We can't have the ensureTopicExists check here since the controller sends it as an advisory to all brokers so they</span>
    <span class="comment">// stop serving data to clients for the topic being deleted</span>
    val <a title="kafka.api.StopReplicaRequest" id="kafka.server;KafkaApis.handleStopReplicaRequest.stopReplicaRequest">stopReplicaRequest</a> = <a href="#kafka.server;KafkaApis.handleStopReplicaRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestObj" title="=&gt; kafka.api.RequestOrResponse">requestObj</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.api.StopReplicaRequest" class="delimiter">[</span><a href="../api/StopReplicaRequest.scala.html#kafka.api;StopReplicaRequest" title="kafka.api.StopReplicaRequest">StopReplicaRequest</a><span class="delimiter">]</span>
    val <a href="#kafka.server;KafkaApis.handleStopReplicaRequest.response" title="(scala.collection.mutable.Map[kafka.common.TopicAndPartition,Short], Short)" class="delimiter">(</a><a href="#kafka.server;KafkaApis.handleStopReplicaRequest.x$2" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,Short]" id="kafka.server;KafkaApis.handleStopReplicaRequest.response">response</a>, <a href="#kafka.server;KafkaApis.handleStopReplicaRequest.x$2" title="Short" id="kafka.server;KafkaApis.handleStopReplicaRequest.error">error</a><span class="delimiter">)</span> = <a href="#kafka.server;KafkaApis.replicaManager" title="=&gt; kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.stopReplicas" title="(stopReplicaRequest: kafka.api.StopReplicaRequest)(scala.collection.mutable.Map[kafka.common.TopicAndPartition,Short], Short)">stopReplicas</a><span title="(scala.collection.mutable.Map[kafka.common.TopicAndPartition,Short], Short) @unchecked" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleStopReplicaRequest.stopReplicaRequest" title="kafka.api.StopReplicaRequest">stopReplicaRequest</a><span class="delimiter">)</span>
    val <a title="kafka.api.StopReplicaResponse" id="kafka.server;KafkaApis.handleStopReplicaRequest.stopReplicaResponse">stopReplicaResponse</a> = new <a href="../api/StopReplicaResponse.scala.html#kafka.api;StopReplicaResponse" title="kafka.api.StopReplicaResponse">StopReplicaResponse</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleStopReplicaRequest.stopReplicaRequest" title="kafka.api.StopReplicaRequest">stopReplicaRequest</a>.<a href="../api/StopReplicaRequest.scala.html#kafka.api;StopReplicaRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.handleStopReplicaRequest.response" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,Short]">response</a>.<span title="(implicit ev: &lt;:&lt;[(kafka.common.TopicAndPartition, Short),(kafka.common.TopicAndPartition, Short)])scala.collection.immutable.Map[kafka.common.TopicAndPartition,Short]">toMap</span>, <a href="#kafka.server;KafkaApis.handleStopReplicaRequest.error" title="Short">error</a><span class="delimiter">)</span>
    <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel.sendResponse" title="(response: kafka.network.RequestChannel.Response)Unit">sendResponse</a><span class="delimiter">(</span>new <a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Response" title="kafka.network.RequestChannel.Response">Response</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleStopReplicaRequest.request" title="kafka.network.RequestChannel.Request">request</a>, new <a href="../network/BoundedByteBufferSend.scala.html#kafka.network;BoundedByteBufferSend" title="kafka.network.BoundedByteBufferSend">BoundedByteBufferSend</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleStopReplicaRequest.stopReplicaResponse" title="kafka.api.StopReplicaResponse">stopReplicaResponse</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.server;KafkaApis.replicaManager" title="=&gt; kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.replicaFetcherManager" title="=&gt; kafka.server.ReplicaFetcherManager">replicaFetcherManager</a>.<a href="AbstractFetcherManager.scala.html#kafka.server;AbstractFetcherManager.shutdownIdleFetcherThreads" title="()Unit">shutdownIdleFetcherThreads</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(request: kafka.network.RequestChannel.Request)Unit" id="kafka.server;KafkaApis.handleUpdateMetadataRequest">handleUpdateMetadataRequest</a><span class="delimiter">(</span><a title="kafka.network.RequestChannel.Request" id="kafka.server;KafkaApis.handleUpdateMetadataRequest.request">request</a>: RequestChannel.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request" title="kafka.network.RequestChannel.Request">Request</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="kafka.api.UpdateMetadataRequest" id="kafka.server;KafkaApis.handleUpdateMetadataRequest.updateMetadataRequest">updateMetadataRequest</a> = <a href="#kafka.server;KafkaApis.handleUpdateMetadataRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestObj" title="=&gt; kafka.api.RequestOrResponse">requestObj</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.api.UpdateMetadataRequest" class="delimiter">[</span><a href="../api/UpdateMetadataRequest.scala.html#kafka.api;UpdateMetadataRequest" title="kafka.api.UpdateMetadataRequest">UpdateMetadataRequest</a><span class="delimiter">]</span>
    <a href="#kafka.server;KafkaApis.replicaManager" title="=&gt; kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.maybeUpdateMetadataCache" title="(updateMetadataRequest: kafka.api.UpdateMetadataRequest, metadataCache: kafka.server.MetadataCache)Unit">maybeUpdateMetadataCache</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleUpdateMetadataRequest.updateMetadataRequest" title="kafka.api.UpdateMetadataRequest">updateMetadataRequest</a>, <a href="#kafka.server;KafkaApis.metadataCache_=" title="=&gt; kafka.server.MetadataCache">metadataCache</a><span class="delimiter">)</span>

    val <a title="kafka.api.UpdateMetadataResponse" id="kafka.server;KafkaApis.handleUpdateMetadataRequest.updateMetadataResponse">updateMetadataResponse</a> = new <a href="../api/UpdateMetadataResponse.scala.html#kafka.api;UpdateMetadataResponse" title="kafka.api.UpdateMetadataResponse">UpdateMetadataResponse</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleUpdateMetadataRequest.updateMetadataRequest" title="kafka.api.UpdateMetadataRequest">updateMetadataRequest</a>.<a href="../api/UpdateMetadataRequest.scala.html#kafka.api;UpdateMetadataRequest.correlationId" title="=&gt; Int">correlationId</a><span class="delimiter">)</span>
    <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel.sendResponse" title="(response: kafka.network.RequestChannel.Response)Unit">sendResponse</a><span class="delimiter">(</span>new <a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Response" title="kafka.network.RequestChannel.Response">Response</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleUpdateMetadataRequest.request" title="kafka.network.RequestChannel.Request">request</a>, new <a href="../network/BoundedByteBufferSend.scala.html#kafka.network;BoundedByteBufferSend" title="kafka.network.BoundedByteBufferSend">BoundedByteBufferSend</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleUpdateMetadataRequest.updateMetadataResponse" title="kafka.api.UpdateMetadataResponse">updateMetadataResponse</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(request: kafka.network.RequestChannel.Request)Unit" id="kafka.server;KafkaApis.handleControlledShutdownRequest">handleControlledShutdownRequest</a><span class="delimiter">(</span><a title="kafka.network.RequestChannel.Request" id="kafka.server;KafkaApis.handleControlledShutdownRequest.request">request</a>: RequestChannel.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request" title="kafka.network.RequestChannel.Request">Request</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">// ensureTopicExists is only for client facing requests</span>
    <span class="comment">// We can't have the ensureTopicExists check here since the controller sends it as an advisory to all brokers so they</span>
    <span class="comment">// stop serving data to clients for the topic being deleted</span>
    val <a title="kafka.api.ControlledShutdownRequest" id="kafka.server;KafkaApis.handleControlledShutdownRequest.controlledShutdownRequest">controlledShutdownRequest</a> = <a href="#kafka.server;KafkaApis.handleControlledShutdownRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestObj" title="=&gt; kafka.api.RequestOrResponse">requestObj</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.api.ControlledShutdownRequest" class="delimiter">[</span><a href="../api/ControlledShutdownRequest.scala.html#kafka.api;ControlledShutdownRequest" title="kafka.api.ControlledShutdownRequest">ControlledShutdownRequest</a><span class="delimiter">]</span>
    val <a title="scala.collection.Set[kafka.common.TopicAndPartition]" id="kafka.server;KafkaApis.handleControlledShutdownRequest.partitionsRemaining">partitionsRemaining</a> = <a href="#kafka.server;KafkaApis.controller" title="=&gt; kafka.controller.KafkaController">controller</a>.<a href="../controller/KafkaController.scala.html#kafka.controller;KafkaController.shutdownBroker" title="(id: Int)scala.collection.Set[kafka.common.TopicAndPartition]">shutdownBroker</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleControlledShutdownRequest.controlledShutdownRequest" title="kafka.api.ControlledShutdownRequest">controlledShutdownRequest</a>.<a href="../api/ControlledShutdownRequest.scala.html#kafka.api;ControlledShutdownRequest.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span>
    val <a title="kafka.api.ControlledShutdownResponse" id="kafka.server;KafkaApis.handleControlledShutdownRequest.controlledShutdownResponse">controlledShutdownResponse</a> = new <a href="../api/ControlledShutdownResponse.scala.html#kafka.api;ControlledShutdownResponse" title="kafka.api.ControlledShutdownResponse">ControlledShutdownResponse</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleControlledShutdownRequest.controlledShutdownRequest" title="kafka.api.ControlledShutdownRequest">controlledShutdownRequest</a>.<a href="../api/ControlledShutdownRequest.scala.html#kafka.api;ControlledShutdownRequest.correlationId" title="=&gt; Int">correlationId</a>,
      <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a>, <a href="#kafka.server;KafkaApis.handleControlledShutdownRequest.partitionsRemaining" title="scala.collection.Set[kafka.common.TopicAndPartition]">partitionsRemaining</a><span class="delimiter">)</span>
    <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel.sendResponse" title="(response: kafka.network.RequestChannel.Response)Unit">sendResponse</a><span class="delimiter">(</span>new <a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Response" title="kafka.network.RequestChannel.Response">Response</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleControlledShutdownRequest.request" title="kafka.network.RequestChannel.Request">request</a>, new <a href="../network/BoundedByteBufferSend.scala.html#kafka.network;BoundedByteBufferSend" title="kafka.network.BoundedByteBufferSend">BoundedByteBufferSend</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleControlledShutdownRequest.controlledShutdownResponse" title="kafka.api.ControlledShutdownResponse">controlledShutdownResponse</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private def <a title="(offsetCommitRequest: kafka.api.OffsetCommitRequest)kafka.api.ProducerRequest" id="kafka.server;KafkaApis.producerRequestFromOffsetCommit">producerRequestFromOffsetCommit</a><span class="delimiter">(</span><a title="kafka.api.OffsetCommitRequest" id="kafka.server;KafkaApis.producerRequestFromOffsetCommit.offsetCommitRequest">offsetCommitRequest</a>: <a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest" title="kafka.api.OffsetCommitRequest">OffsetCommitRequest</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val <a title="Seq[kafka.message.Message]" id="kafka.server;KafkaApis.producerRequestFromOffsetCommit.msgs">msgs</a> = <a href="#kafka.server;KafkaApis.producerRequestFromOffsetCommit.offsetCommitRequest" title="kafka.api.OffsetCommitRequest">offsetCommitRequest</a>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.filterLargeMetadata" title="(maxMetadataSize: Int)scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetAndMetadata]">filterLargeMetadata</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.offsetMetadataMaxSize" title="=&gt; Int">offsetMetadataMaxSize</a><span class="delimiter">)</span>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.common.OffsetAndMetadata)) =&gt; kafka.message.Message)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetAndMetadata],kafka.message.Message,scala.collection.immutable.Iterable[kafka.message.Message]])scala.collection.immutable.Iterable[kafka.message.Message]">map</span> <a href="#kafka.server;KafkaApis.producerRequestFromOffsetCommit.msgs.$anonfun.x0$2" title="kafka.message.Message" class="delimiter">{</a>
      case <span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;KafkaApis.producerRequestFromOffsetCommit.msgs.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="kafka.common.OffsetAndMetadata" id="kafka.server;KafkaApis.producerRequestFromOffsetCommit.msgs.$anonfun.offset">offset</a><span class="delimiter">)</span> =&gt;
        new <a href="../message/Message.scala.html#kafka.message;Message" title="kafka.message.Message">Message</a><span class="delimiter">(</span>
          bytes = <a href="OffsetManager.scala.html#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="OffsetManager.scala.html#kafka.server.OffsetManager.offsetCommitValue" title="(offsetAndMetadata: kafka.common.OffsetAndMetadata)Array[Byte]">offsetCommitValue</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.producerRequestFromOffsetCommit.msgs.$anonfun.offset" title="kafka.common.OffsetAndMetadata">offset</a><span class="delimiter">)</span>,
          key = <a href="OffsetManager.scala.html#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="OffsetManager.scala.html#kafka.server.OffsetManager.offsetCommitKey" title="(group: String, topic: String, partition: Int, versionId: Short)Array[Byte]">offsetCommitKey</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.producerRequestFromOffsetCommit.offsetCommitRequest" title="kafka.api.OffsetCommitRequest">offsetCommitRequest</a>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.groupId" title="=&gt; String">groupId</a>, <a href="#kafka.server;KafkaApis.producerRequestFromOffsetCommit.msgs.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.server;KafkaApis.producerRequestFromOffsetCommit.msgs.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a><span class="delimiter">)</span>
        <span class="delimiter">)</span>
    <span class="delimiter">}</span>.<span title="=&gt; Seq[kafka.message.Message]">toSeq</span>

    val <a title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]" id="kafka.server;KafkaApis.producerRequestFromOffsetCommit.producerData">producerData</a> = mutable.<span title="(elems: (kafka.common.TopicAndPartition, kafka.message.ByteBufferMessageSet)*)scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">Map</span><span class="delimiter">(</span>
      <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span title="(self: kafka.common.TopicAndPartition)ArrowAssoc[kafka.common.TopicAndPartition]" class="delimiter">(</span><a href="OffsetManager.scala.html#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="OffsetManager.scala.html#kafka.server.OffsetManager.OffsetsTopicName" title="=&gt; String">OffsetsTopicName</a>, <a href="#kafka.server;KafkaApis.offsetManager" title="=&gt; kafka.server.OffsetManager">offsetManager</a>.<a href="OffsetManager.scala.html#kafka.server;OffsetManager.partitionFor" title="(group: String)Int">partitionFor</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.producerRequestFromOffsetCommit.offsetCommitRequest" title="kafka.api.OffsetCommitRequest">offsetCommitRequest</a>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.groupId" title="=&gt; String">groupId</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(y: kafka.message.ByteBufferMessageSet)(kafka.common.TopicAndPartition, kafka.message.ByteBufferMessageSet)">-&gt;</span>
        new <a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet">ByteBufferMessageSet</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.offsetsTopicCompressionCodec" title="=&gt; kafka.message.CompressionCodec">offsetsTopicCompressionCodec</a>, <a href="#kafka.server;KafkaApis.producerRequestFromOffsetCommit.msgs" title="Seq[kafka.message.Message]">msgs</a>:_*<span class="delimiter">)</span>
    <span class="delimiter">)</span>

    val <a title="kafka.api.ProducerRequest" id="kafka.server;KafkaApis.producerRequestFromOffsetCommit.request">request</a> = <a href="../api/ProducerRequest.scala.html#kafka.api.ProducerRequest.apply$default$1" title="Short" id="kafka.server;KafkaApis.producerRequestFromOffsetCommit.request.x$26">ProducerRequest</a><span class="delimiter">(</span>
      correlationId = <a href="#kafka.server;KafkaApis.producerRequestFromOffsetCommit.offsetCommitRequest" title="kafka.api.OffsetCommitRequest">offsetCommitRequest</a>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.correlationId" title="Int" id="kafka.server;KafkaApis.producerRequestFromOffsetCommit.request.x$21">correlationId</a>,
      clientId = <a href="#kafka.server;KafkaApis.producerRequestFromOffsetCommit.offsetCommitRequest" title="kafka.api.OffsetCommitRequest">offsetCommitRequest</a>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.clientId" title="String" id="kafka.server;KafkaApis.producerRequestFromOffsetCommit.request.x$22">clientId</a>,
      requiredAcks = <a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.offsetCommitRequiredAcks" title="Short" id="kafka.server;KafkaApis.producerRequestFromOffsetCommit.request.x$23">offsetCommitRequiredAcks</a>,
      ackTimeoutMs = <a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.offsetCommitTimeoutMs" title="Int" id="kafka.server;KafkaApis.producerRequestFromOffsetCommit.request.x$24">offsetCommitTimeoutMs</a>,
      data = <a href="#kafka.server;KafkaApis.producerRequestFromOffsetCommit.producerData" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]" id="kafka.server;KafkaApis.producerRequestFromOffsetCommit.request.x$25">producerData</a><span class="delimiter">)</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Created producer request %s for offset commit request %s.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.producerRequestFromOffsetCommit.request" title="kafka.api.ProducerRequest">request</a>, <a href="#kafka.server;KafkaApis.producerRequestFromOffsetCommit.offsetCommitRequest" title="kafka.api.OffsetCommitRequest">offsetCommitRequest</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.server;KafkaApis.producerRequestFromOffsetCommit.request" title="kafka.api.ProducerRequest">request</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Handle a produce request or offset commit request (which is really a specialized producer request)
   */</span>
  def <a title="(request: kafka.network.RequestChannel.Request)Unit" id="kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest">handleProducerOrOffsetCommitRequest</a><span class="delimiter">(</span><a title="kafka.network.RequestChannel.Request" id="kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.request">request</a>: RequestChannel.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request" title="kafka.network.RequestChannel.Request">Request</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="(kafka.api.ProducerRequest, Option[kafka.api.OffsetCommitRequest])" class="delimiter">(</a><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.x$3" title="kafka.api.ProducerRequest" id="kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest">produceRequest</a>, <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.x$3" title="Option[kafka.api.OffsetCommitRequest]" id="kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.offsetCommitRequestOpt">offsetCommitRequestOpt</a><span class="delimiter">)</span> =
      if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestId" title="=&gt; Short">requestId</a> <span title="(x: Short)Boolean">==</span> <a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys" title="kafka.api.RequestKeys.type">RequestKeys</a>.<a href="../api/RequestKeys.scala.html#kafka.api.RequestKeys.OffsetCommitKey" title="=&gt; Short">OffsetCommitKey</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="kafka.api.OffsetCommitRequest" id="kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.x$3.offsetCommitRequest">offsetCommitRequest</a> = <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestObj" title="=&gt; kafka.api.RequestOrResponse">requestObj</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.api.OffsetCommitRequest" class="delimiter">[</span><a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest" title="kafka.api.OffsetCommitRequest">OffsetCommitRequest</a><span class="delimiter">]</span>
        <a href="../api/OffsetCommitRequest.scala.html#kafka.api.OffsetCommitRequest" title="kafka.api.OffsetCommitRequest.type">OffsetCommitRequest</a>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api.OffsetCommitRequest.changeInvalidTimeToCurrentTime" title="(offsetCommitRequest: kafka.api.OffsetCommitRequest)Unit">changeInvalidTimeToCurrentTime</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.x$3.offsetCommitRequest" title="kafka.api.OffsetCommitRequest">offsetCommitRequest</a><span class="delimiter">)</span>
        <span title="(_1: kafka.api.ProducerRequest, _2: Some[kafka.api.OffsetCommitRequest])(kafka.api.ProducerRequest, Some[kafka.api.OffsetCommitRequest])" class="delimiter">(</span><a href="#kafka.server;KafkaApis.producerRequestFromOffsetCommit" title="(offsetCommitRequest: kafka.api.OffsetCommitRequest)kafka.api.ProducerRequest">producerRequestFromOffsetCommit</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.x$3.offsetCommitRequest" title="kafka.api.OffsetCommitRequest">offsetCommitRequest</a><span class="delimiter">)</span>, <span title="(x: kafka.api.OffsetCommitRequest)Some[kafka.api.OffsetCommitRequest]">Some</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.x$3.offsetCommitRequest" title="kafka.api.OffsetCommitRequest">offsetCommitRequest</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <span title="(_1: kafka.api.ProducerRequest, _2: None.type)(kafka.api.ProducerRequest, None.type)" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestObj" title="=&gt; kafka.api.RequestOrResponse">requestObj</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.api.ProducerRequest" class="delimiter">[</span><a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest" title="kafka.api.ProducerRequest">ProducerRequest</a><span class="delimiter">]</span>, <span title="None.type">None</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.requiredAcks" title="=&gt; Short">requiredAcks</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(1)" class="int">1</span> <span title="(x: Boolean)Boolean">||</span> <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.requiredAcks" title="=&gt; Short">requiredAcks</a> <span title="(x: Int)Boolean">&lt;</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="string">&quot;Client %s from %s sent a produce request with request.required.acks of %d, which is now deprecated and will &quot;</span> +
            <span class="string">&quot;be removed in next release. Valid values are -1, 0 or 1. Please consult Kafka documentation for supported &quot;</span> <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">+</span>
            <span class="string">&quot;and recommended configuration.&quot;</span><span class="delimiter">)</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.clientId" title="=&gt; String">clientId</a>, <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.remoteAddress" title="=&gt; java.net.SocketAddress">remoteAddress</a>, <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.requiredAcks" title="=&gt; Short">requiredAcks</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    val <a title="Long" id="kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.sTime">sTime</a> = <a href="../utils/Time.scala.html#kafka.utils.SystemTime" title="kafka.utils.SystemTime.type">SystemTime</a>.<a href="../utils/Time.scala.html#kafka.utils.SystemTime.milliseconds" title="=&gt; Long">milliseconds</a>
    val <a title="Iterable[KafkaApis.this.ProduceResult]" id="kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.localProduceResults">localProduceResults</a> = <a href="#kafka.server;KafkaApis.appendToLocalLog" title="(producerRequest: kafka.api.ProducerRequest, isOffsetCommit: Boolean)Iterable[KafkaApis.this.ProduceResult]">appendToLocalLog</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>, <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.offsetCommitRequestOpt" title="Option[kafka.api.OffsetCommitRequest]">offsetCommitRequestOpt</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Produce to local log in %d ms&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="../utils/Time.scala.html#kafka.utils.SystemTime" title="kafka.utils.SystemTime.type">SystemTime</a>.<a href="../utils/Time.scala.html#kafka.utils.SystemTime.milliseconds" title="=&gt; Long">milliseconds</a> <span title="(x: Long)Long">-</span> <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.sTime" title="Long">sTime</a><span class="delimiter">)</span><span class="delimiter">)</span>

    val <a title="Short" id="kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.firstErrorCode">firstErrorCode</a> = <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.localProduceResults" title="Iterable[KafkaApis.this.ProduceResult]">localProduceResults</a>.<span title="(p: KafkaApis.this.ProduceResult =&gt; Boolean)Option[KafkaApis.this.ProduceResult]">find</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.firstErrorCode.$anonfun.x$4" title="KafkaApis.this.ProduceResult">_</a>.<a href="#kafka.server;KafkaApis;ProduceResult.errorCode" title="=&gt; Short">errorCode</a> <span title="(x: Short)Boolean">!=</span> <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span>.<span title="(f: KafkaApis.this.ProduceResult =&gt; Short)Option[Short]">map</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.firstErrorCode.$anonfun.x$5" title="KafkaApis.this.ProduceResult">_</a>.<a href="#kafka.server;KafkaApis;ProduceResult.errorCode" title="=&gt; Short">errorCode</a><span class="delimiter">)</span>.<span title="(default: =&gt; Short)Short">getOrElse</span><span class="delimiter">(</span><a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span>

    val <a title="Int" id="kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.numPartitionsInError">numPartitionsInError</a> = <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.localProduceResults" title="Iterable[KafkaApis.this.ProduceResult]">localProduceResults</a>.<span title="(p: KafkaApis.this.ProduceResult =&gt; Boolean)Int">count</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.numPartitionsInError.$anonfun.x$6" title="KafkaApis.this.ProduceResult">_</a>.<a href="#kafka.server;KafkaApis.ProduceResult.apply$default$4" title="=&gt; Option[Throwable]">error</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span>
    if<span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.requiredAcks" title="=&gt; Short">requiredAcks</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// no operation needed if producer request.required.acks = 0; however, if there is any exception in handling the request, since</span>
      <span class="comment">// no response is expected by the producer the handler will send a close connection response to the socket server</span>
      <span class="comment">// to close the socket so that the producer client will know that some exception has happened and will refresh its metadata</span>
      if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.numPartitionsInError" title="Int">numPartitionsInError</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="string">&quot;Send the close connection response due to error handling produce request &quot;</span> <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">+</span>
          <span class="string">&quot;[clientId = %s, correlationId = %s, topicAndPartition = %s] with Ack=0&quot;</span><span class="delimiter">)</span>
          .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.clientId" title="=&gt; String">clientId</a>, <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.topicPartitionMessageSizeMap" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,Int]">topicPartitionMessageSizeMap</a>.<span title="=&gt; scala.collection.immutable.Set[kafka.common.TopicAndPartition]">keySet</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel.closeConnection" title="(processor: Int, request: kafka.network.RequestChannel.Request)Unit">closeConnection</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.processor" title="=&gt; Int">processor</a>, <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.request" title="kafka.network.RequestChannel.Request">request</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>

        if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.firstErrorCode" title="Short">firstErrorCode</a> <span title="(x: Short)Boolean">==</span> <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span>
          <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.offsetCommitRequestOpt" title="Option[kafka.api.OffsetCommitRequest]">offsetCommitRequestOpt</a>.<span title="(f: kafka.api.OffsetCommitRequest =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><span title="kafka.api.OffsetCommitRequest">ocr</span> =&gt; <a href="#kafka.server;KafkaApis.offsetManager" title="=&gt; kafka.server.OffsetManager">offsetManager</a>.<a href="OffsetManager.scala.html#kafka.server;OffsetManager.putOffsets" title="(group: String, offsets: scala.collection.Map[kafka.common.TopicAndPartition,kafka.common.OffsetAndMetadata])Unit">putOffsets</a><span class="delimiter">(</span><span title="kafka.api.OffsetCommitRequest">ocr</span>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.groupId" title="=&gt; String">groupId</a>, <span title="kafka.api.OffsetCommitRequest">ocr</span>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.requestInfo" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetAndMetadata]">requestInfo</a><span class="delimiter">)</span><span class="delimiter">)</span>

        if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.offsetCommitRequestOpt" title="Option[kafka.api.OffsetCommitRequest]">offsetCommitRequestOpt</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          val <span title="kafka.api.OffsetCommitResponse">response</span> = <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.offsetCommitRequestOpt" title="Option[kafka.api.OffsetCommitRequest]">offsetCommitRequestOpt</a>.<span title="=&gt; kafka.api.OffsetCommitRequest">get</span>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.responseFor" title="(errorCode: Short, offsetMetadataMaxSize: Int)kafka.api.OffsetCommitResponse">responseFor</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.firstErrorCode" title="Short">firstErrorCode</a>, <a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.offsetMetadataMaxSize" title="=&gt; Int">offsetMetadataMaxSize</a><span class="delimiter">)</span>
          <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel.sendResponse" title="(response: kafka.network.RequestChannel.Response)Unit">sendResponse</a><span class="delimiter">(</span>new <a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel" title="kafka.network.RequestChannel.type">RequestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Response" title="kafka.network.RequestChannel.Response">Response</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.request" title="kafka.network.RequestChannel.Request">request</a>, new <a href="../network/BoundedByteBufferSend.scala.html#kafka.network;BoundedByteBufferSend" title="kafka.network.BoundedByteBufferSend">BoundedByteBufferSend</a><span class="delimiter">(</span><span title="kafka.api.OffsetCommitResponse">response</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span> else
          <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel.noOperation" title="(processor: Int, request: kafka.network.RequestChannel.Request)Unit">noOperation</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.processor" title="=&gt; Int">processor</a>, <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.request" title="kafka.network.RequestChannel.Request">request</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.requiredAcks" title="=&gt; Short">requiredAcks</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span> <span title="(x: Boolean)Boolean">||</span>
        <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.numPartitions" title="=&gt; Int">numPartitions</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span>
        <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.numPartitionsInError" title="Int">numPartitionsInError</a> <span title="(x: Int)Boolean">==</span> <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.numPartitions" title="=&gt; Int">numPartitions</a><span class="delimiter">)</span> <span class="delimiter">{</span>

      if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.firstErrorCode" title="Short">firstErrorCode</a> <span title="(x: Short)Boolean">==</span> <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.offsetCommitRequestOpt" title="Option[kafka.api.OffsetCommitRequest]">offsetCommitRequestOpt</a>.<span title="(f: kafka.api.OffsetCommitRequest =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><span title="kafka.api.OffsetCommitRequest">ocr</span> =&gt; <a href="#kafka.server;KafkaApis.offsetManager" title="=&gt; kafka.server.OffsetManager">offsetManager</a>.<a href="OffsetManager.scala.html#kafka.server;OffsetManager.putOffsets" title="(group: String, offsets: scala.collection.Map[kafka.common.TopicAndPartition,kafka.common.OffsetAndMetadata])Unit">putOffsets</a><span class="delimiter">(</span><span title="kafka.api.OffsetCommitRequest">ocr</span>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.groupId" title="=&gt; String">groupId</a>, <span title="kafka.api.OffsetCommitRequest">ocr</span>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.requestInfo" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetAndMetadata]">requestInfo</a><span class="delimiter">)</span> <span class="delimiter">)</span>
      <span class="delimiter">}</span>

      val <span title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus]">statuses</span> = <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.localProduceResults" title="Iterable[KafkaApis.this.ProduceResult]">localProduceResults</a>.<span title="(f: KafkaApis.this.ProduceResult =&gt; (kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus))(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[KafkaApis.this.ProduceResult],(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus),Iterable[(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)]])Iterable[(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus),Iterable[(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)]]" class="delimiter">(</span><span title="KafkaApis.this.ProduceResult">r</span> =&gt; <span title="KafkaApis.this.ProduceResult">r</span>.<a href="#kafka.server;KafkaApis;ProduceResult.key" title="(self: kafka.common.TopicAndPartition)ArrowAssoc[kafka.common.TopicAndPartition]">key</a> <span title="(y: kafka.api.ProducerResponseStatus)(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)">-&gt;</span> <a href="../api/ProducerResponse.scala.html#kafka.api;ProducerResponseStatus" title="(error: Short, offset: Long)kafka.api.ProducerResponseStatus">ProducerResponseStatus</a><span class="delimiter">(</span><span title="KafkaApis.this.ProduceResult">r</span>.<a href="#kafka.server;KafkaApis;ProduceResult.errorCode" title="=&gt; Short">errorCode</a>, <span title="KafkaApis.this.ProduceResult">r</span>.<a href="#kafka.server;KafkaApis;ProduceResult.start" title="=&gt; Long">start</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: &lt;:&lt;[(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus),(kafka.common.TopicAndPartition, kafka.api.ProducerResponseStatus)])scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus]">toMap</span>
      val <span title="&lt;refinement of kafka.api.RequestOrResponse with Product&gt; extends kafka.api.RequestOrResponse with Product with Serializable">response</span> = <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.offsetCommitRequestOpt" title="Option[kafka.api.OffsetCommitRequest]">offsetCommitRequestOpt</a>.<span title="(f: kafka.api.OffsetCommitRequest =&gt; kafka.api.OffsetCommitResponse)Option[kafka.api.OffsetCommitResponse]">map</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.response.$anonfun.x$7" title="kafka.api.OffsetCommitRequest">_</a>.<a href="../api/OffsetCommitRequest.scala.html#kafka.api;OffsetCommitRequest.responseFor" title="(errorCode: Short, offsetMetadataMaxSize: Int)kafka.api.OffsetCommitResponse">responseFor</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.firstErrorCode" title="Short">firstErrorCode</a>, <a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.offsetMetadataMaxSize" title="=&gt; Int">offsetMetadataMaxSize</a><span class="delimiter">)</span><span class="delimiter">)</span>
                                           .<span title="(default: =&gt; kafka.api.RequestOrResponse with Product with Serializable)kafka.api.RequestOrResponse with Product with Serializable">getOrElse</span><span class="delimiter">(</span><a href="../api/ProducerResponse.scala.html#kafka.api;ProducerResponse" title="(correlationId: Int, status: scala.collection.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus])kafka.api.ProducerResponse">ProducerResponse</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.correlationId" title="=&gt; Int">correlationId</a>, <span title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.ProducerResponseStatus]">statuses</span><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel.sendResponse" title="(response: kafka.network.RequestChannel.Response)Unit">sendResponse</a><span class="delimiter">(</span>new <a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel" title="kafka.network.RequestChannel.type">RequestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Response" title="kafka.network.RequestChannel.Response">Response</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.request" title="kafka.network.RequestChannel.Request">request</a>, new <a href="../network/BoundedByteBufferSend.scala.html#kafka.network;BoundedByteBufferSend" title="kafka.network.BoundedByteBufferSend">BoundedByteBufferSend</a><span class="delimiter">(</span><span title="&lt;refinement of kafka.api.RequestOrResponse with Product&gt; extends kafka.api.RequestOrResponse with Product with Serializable">response</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <span class="comment">// create a list of (topic, partition) pairs to use as keys for this delayed request</span>
      val <a title="Seq[kafka.common.TopicAndPartition]" id="kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.producerRequestKeys">producerRequestKeys</a> = <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.data" title="=&gt; scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">data</a>.<span title="=&gt; Iterable[kafka.common.TopicAndPartition]">keys</span>.<span title="=&gt; Seq[kafka.common.TopicAndPartition]">toSeq</span>
      val <span title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.DelayedProduceResponseStatus]">statuses</span> = <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.localProduceResults" title="Iterable[KafkaApis.this.ProduceResult]">localProduceResults</a>.<span title="(f: KafkaApis.this.ProduceResult =&gt; (kafka.common.TopicAndPartition, kafka.server.DelayedProduceResponseStatus))(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[KafkaApis.this.ProduceResult],(kafka.common.TopicAndPartition, kafka.server.DelayedProduceResponseStatus),Iterable[(kafka.common.TopicAndPartition, kafka.server.DelayedProduceResponseStatus)]])Iterable[(kafka.common.TopicAndPartition, kafka.server.DelayedProduceResponseStatus)]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,(kafka.common.TopicAndPartition, kafka.server.DelayedProduceResponseStatus),Iterable[(kafka.common.TopicAndPartition, kafka.server.DelayedProduceResponseStatus)]]" class="delimiter">(</span><span title="KafkaApis.this.ProduceResult">r</span> =&gt;
        <span title="KafkaApis.this.ProduceResult">r</span>.<a href="#kafka.server;KafkaApis;ProduceResult.key" title="(self: kafka.common.TopicAndPartition)ArrowAssoc[kafka.common.TopicAndPartition]">key</a> <span title="(y: kafka.server.DelayedProduceResponseStatus)(kafka.common.TopicAndPartition, kafka.server.DelayedProduceResponseStatus)">-&gt;</span> <a href="DelayedProduce.scala.html#kafka.server;DelayedProduceResponseStatus" title="(requiredOffset: Long, responseStatus: kafka.api.ProducerResponseStatus)kafka.server.DelayedProduceResponseStatus">DelayedProduceResponseStatus</a><span class="delimiter">(</span><span title="KafkaApis.this.ProduceResult">r</span>.<a href="#kafka.server;KafkaApis;ProduceResult.end" title="=&gt; Long">end</a> <span title="(x: Int)Long">+</span> <span title="Int(1)" class="int">1</span>, <a href="../api/ProducerResponse.scala.html#kafka.api;ProducerResponseStatus" title="(error: Short, offset: Long)kafka.api.ProducerResponseStatus">ProducerResponseStatus</a><span class="delimiter">(</span><span title="KafkaApis.this.ProduceResult">r</span>.<a href="#kafka.server;KafkaApis;ProduceResult.errorCode" title="=&gt; Short">errorCode</a>, <span title="KafkaApis.this.ProduceResult">r</span>.<a href="#kafka.server;KafkaApis;ProduceResult.start" title="=&gt; Long">start</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: &lt;:&lt;[(kafka.common.TopicAndPartition, kafka.server.DelayedProduceResponseStatus),(kafka.common.TopicAndPartition, kafka.server.DelayedProduceResponseStatus)])scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.DelayedProduceResponseStatus]">toMap</span>
      val <a title="kafka.server.DelayedProduce" id="kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.delayedRequest">delayedRequest</a> =  new <a href="DelayedProduce.scala.html#kafka.server;DelayedProduce" title="kafka.server.DelayedProduce">DelayedProduce</a><span class="delimiter">(</span>
        <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.producerRequestKeys" title="Seq[kafka.common.TopicAndPartition]">producerRequestKeys</a>,
        <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.request" title="kafka.network.RequestChannel.Request">request</a>,
        <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.ackTimeoutMs" title="=&gt; Int">ackTimeoutMs</a>.<span title="=&gt; Long">toLong</span>,
        <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>,
        <span title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.DelayedProduceResponseStatus]">statuses</span>,
        <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.offsetCommitRequestOpt" title="Option[kafka.api.OffsetCommitRequest]">offsetCommitRequestOpt</a><span class="delimiter">)</span>

      <span class="comment">// add the produce request for watch if it's not satisfied, otherwise send the response back</span>
      val <a title="Boolean" id="kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.satisfiedByMe">satisfiedByMe</a> = <a href="#kafka.server;KafkaApis.producerRequestPurgatory" title="=&gt; kafka.server.ProducerRequestPurgatory">producerRequestPurgatory</a>.<a href="RequestPurgatory.scala.html#kafka.server;RequestPurgatory.checkAndMaybeWatch" title="(delayedRequest: kafka.server.DelayedProduce)Boolean">checkAndMaybeWatch</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.delayedRequest" title="kafka.server.DelayedProduce">delayedRequest</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.satisfiedByMe" title="Boolean">satisfiedByMe</a><span class="delimiter">)</span>
        <a href="#kafka.server;KafkaApis.producerRequestPurgatory" title="=&gt; kafka.server.ProducerRequestPurgatory">producerRequestPurgatory</a>.<a href="ProducerRequestPurgatory.scala.html#kafka.server;ProducerRequestPurgatory.respond" title="(delayedProduce: kafka.server.DelayedProduce)Unit">respond</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.delayedRequest" title="kafka.server.DelayedProduce">delayedRequest</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// we do not need the data anymore</span>
    <a href="#kafka.server;KafkaApis.handleProducerOrOffsetCommitRequest.produceRequest" title="kafka.api.ProducerRequest">produceRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.emptyData" title="()Unit">emptyData</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  case class <a title="class ProduceResult extends AnyRef with Product with Serializable" id="kafka.server;KafkaApis.ProduceResult.readResolve">ProduceResult</a><a href="#kafka.server;KafkaApis.ProduceResult.readResolve" title="Product" class="delimiter">(</a><a title="kafka.common.TopicAndPartition" id="kafka.server;KafkaApis;ProduceResult.key">key</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a>, <a title="Long" id="kafka.server;KafkaApis;ProduceResult.start">start</a>: <span title="Long">Long</span>, <a title="Long" id="kafka.server;KafkaApis;ProduceResult.end">end</a>: <span title="Long">Long</span>, <a title="Option[Throwable]" id="kafka.server;KafkaApis.ProduceResult.apply$default$4">error</a>: <span title="Option[Throwable]">Option</span><span class="delimiter">[</span>Throwable<span class="delimiter">]</span> = <span title="None.type">None</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    def this<span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;KafkaApis;ProduceResult.<init>(a6312ed04a).key">key</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a>, <a title="Throwable" id="kafka.server;KafkaApis;ProduceResult.<init>(a6312ed04a).throwable">throwable</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span> = 
      this<span class="delimiter">(</span><a href="#kafka.server;KafkaApis;ProduceResult.<init>(a6312ed04a).key" title="kafka.common.TopicAndPartition">key</a>, -<span title="Long(-1L)" class="long">1L</span>, -<span title="Long(-1L)" class="long">1L</span>, <span title="(x: Throwable)Some[Throwable]">Some</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis;ProduceResult.<init>(a6312ed04a).throwable" title="Throwable">throwable</a><span class="delimiter">)</span><span class="delimiter">)</span>
    
    def <a title="=&gt; Short" id="kafka.server;KafkaApis;ProduceResult.errorCode">errorCode</a> = <a href="#kafka.server;KafkaApis.ProduceResult.apply$default$4" title="=&gt; Option[Throwable]">error</a> match <span class="delimiter">{</span>
      case <span title="None.type">None</span> =&gt; <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a>
      case Some<span class="delimiter">(</span><a title="Throwable" id="kafka.server;KafkaApis;ProduceResult.errorCode.error">error</a><span class="delimiter">)</span> =&gt; <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.codeFor" title="(exception: Class[Throwable])Short">codeFor</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis;ProduceResult.errorCode.error" title="Throwable">error</a>.<span title="()Class[_]">getClass</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Class[Throwable]" class="delimiter">[</span><span title="Class[Throwable]">Class</span><span class="delimiter">[</span>Throwable<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Helper method for handling a parsed producer request
   */</span>
  private def <a title="(producerRequest: kafka.api.ProducerRequest, isOffsetCommit: Boolean)Iterable[KafkaApis.this.ProduceResult]" id="kafka.server;KafkaApis.appendToLocalLog">appendToLocalLog</a><span class="delimiter">(</span><a title="kafka.api.ProducerRequest" id="kafka.server;KafkaApis.appendToLocalLog.producerRequest">producerRequest</a>: <a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest" title="kafka.api.ProducerRequest">ProducerRequest</a>, <a title="Boolean" id="kafka.server;KafkaApis.appendToLocalLog.isOffsetCommit">isOffsetCommit</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Iterable[KafkaApis.this.ProduceResult]">Iterable</span><span class="delimiter">[</span>ProduceResult<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.message.MessageSet]" id="kafka.server;KafkaApis.appendToLocalLog.partitionAndData">partitionAndData</a>: <span title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.message.MessageSet]">Map</span><span class="delimiter">[</span>TopicAndPartition, MessageSet<span class="delimiter">]</span> = <a href="#kafka.server;KafkaApis.appendToLocalLog.producerRequest" title="kafka.api.ProducerRequest">producerRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.data" title="=&gt; scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.message.ByteBufferMessageSet]">data</a>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Append [%s] to local log &quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.partitionAndData" title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.message.MessageSet]">partitionAndData</a>.<span title="()String">toString</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.server;KafkaApis.appendToLocalLog.partitionAndData" title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.message.MessageSet]">partitionAndData</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.message.MessageSet)) =&gt; KafkaApis.this.ProduceResult)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.Map[kafka.common.TopicAndPartition,kafka.message.MessageSet],KafkaApis.this.ProduceResult,Iterable[KafkaApis.this.ProduceResult]])Iterable[KafkaApis.this.ProduceResult]">map</span> <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.x0$3" title="KafkaApis.this.ProduceResult" class="delimiter">{</a>case <span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="kafka.message.MessageSet" id="kafka.server;KafkaApis.appendToLocalLog.$anonfun.messages">messages</a><span class="delimiter">)</span> =&gt;
      try <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="../common/Topic.scala.html#kafka.common.Topic" title="kafka.common.Topic.type">Topic</a>.<a href="../common/Topic.scala.html#kafka.common.Topic.InternalTopics" title="=&gt; scala.collection.immutable.Set[String]">InternalTopics</a>.<span title="(elem: String)Boolean">contains</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.isOffsetCommit" title="Boolean">isOffsetCommit</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a> <span title="(x$1: Any)Boolean">==</span> <a href="OffsetManager.scala.html#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="OffsetManager.scala.html#kafka.server.OffsetManager.OffsetsTopicName" title="=&gt; String">OffsetsTopicName</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          throw new <a href="../common/InvalidTopicException.scala.html#kafka.common;InvalidTopicException" title="kafka.common.InvalidTopicException">InvalidTopicException</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Cannot append to internal topic %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        val <a title="Option[kafka.cluster.Partition]" id="kafka.server;KafkaApis.appendToLocalLog.$anonfun.partitionOpt">partitionOpt</a> = <a href="#kafka.server;KafkaApis.replicaManager" title="=&gt; kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.getPartition" title="(topic: String, partitionId: Int)Option[kafka.cluster.Partition]">getPartition</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a><span class="delimiter">)</span>
        val <a title="kafka.log.Log#LogAppendInfo" id="kafka.server;KafkaApis.appendToLocalLog.$anonfun.info">info</a> = <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.partitionOpt" title="Option[kafka.cluster.Partition]">partitionOpt</a> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><a title="kafka.cluster.Partition" id="kafka.server;KafkaApis.appendToLocalLog.$anonfun.info.partition">partition</a><span class="delimiter">)</span> =&gt;
            <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.info.partition" title="kafka.cluster.Partition">partition</a>.<a href="../cluster/Partition.scala.html#kafka.cluster;Partition.appendMessagesToLeader" title="(messages: kafka.message.ByteBufferMessageSet, requiredAcks: Int)kafka.log.Log#LogAppendInfo">appendMessagesToLeader</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.messages" title="kafka.message.MessageSet">messages</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.message.ByteBufferMessageSet" class="delimiter">[</span><a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet">ByteBufferMessageSet</a><span class="delimiter">]</span>,<a href="#kafka.server;KafkaApis.appendToLocalLog.producerRequest" title="kafka.api.ProducerRequest">producerRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.requiredAcks" title="=&gt; Int">requiredAcks</a><span class="delimiter">)</span>
          case <span title="None.type">None</span> =&gt; throw new <a href="../common/UnknownTopicOrPartitionException.scala.html#kafka.common;UnknownTopicOrPartitionException" title="kafka.common.UnknownTopicOrPartitionException">UnknownTopicOrPartitionException</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Partition %s doesn't exist on %d&quot;</span>
            .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;KafkaApis.brokerId" title="=&gt; Int">brokerId</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        val <a title="Long" id="kafka.server;KafkaApis.appendToLocalLog.$anonfun.numAppendedMessages">numAppendedMessages</a> = if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.info" title="kafka.log.Log#LogAppendInfo">info</a>.<a href="../log/Log.scala.html#kafka.log;Log;LogAppendInfo.firstOffset" title="=&gt; Long">firstOffset</a> <span title="(x: Long)Boolean">==</span> -<span title="Long(-1L)" class="long">1L</span> <span title="(x: Boolean)Boolean">||</span> <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.info" title="kafka.log.Log#LogAppendInfo">info</a>.<a href="../log/Log.scala.html#kafka.log;Log;LogAppendInfo.lastOffset" title="=&gt; Long">lastOffset</a> <span title="(x: Long)Boolean">==</span> -<span title="Long(-1L)" class="long">1L</span><span class="delimiter">)</span> <span title="Long(0L)" class="int">0</span> else <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.info" title="kafka.log.Log#LogAppendInfo">info</a>.<a href="../log/Log.scala.html#kafka.log;Log;LogAppendInfo.lastOffset" title="=&gt; Long">lastOffset</a> <span title="(x: Long)Long">-</span> <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.info" title="kafka.log.Log#LogAppendInfo">info</a>.<a href="../log/Log.scala.html#kafka.log;Log;LogAppendInfo.firstOffset" title="=&gt; Long">firstOffset</a> <span title="(x: Int)Long">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

        <span class="comment">// update stats for successfully appended bytes and messages as bytesInRate and messageInRate</span>
        <a href="KafkaRequestHandler.scala.html#kafka.server.BrokerTopicStats" title="kafka.server.BrokerTopicStats.type">BrokerTopicStats</a>.<a href="KafkaRequestHandler.scala.html#kafka.server.BrokerTopicStats.getBrokerTopicStats" title="(topic: String)kafka.server.BrokerTopicMetrics">getBrokerTopicStats</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>.<a href="KafkaRequestHandler.scala.html#kafka.server;BrokerTopicMetrics.bytesInRate" title="=&gt; com.yammer.metrics.core.Meter">bytesInRate</a>.<span title="(x$1: Long)Unit">mark</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.messages" title="kafka.message.MessageSet">messages</a>.<a href="../message/MessageSet.scala.html#kafka.message;MessageSet.sizeInBytes" title="=&gt; Long">sizeInBytes</a><span class="delimiter">)</span>
        <a href="KafkaRequestHandler.scala.html#kafka.server.BrokerTopicStats" title="kafka.server.BrokerTopicStats.type">BrokerTopicStats</a>.<a href="KafkaRequestHandler.scala.html#kafka.server.BrokerTopicStats.getBrokerAllTopicsStats" title="()kafka.server.BrokerTopicMetrics">getBrokerAllTopicsStats</a>.<a href="KafkaRequestHandler.scala.html#kafka.server;BrokerTopicMetrics.bytesInRate" title="=&gt; com.yammer.metrics.core.Meter">bytesInRate</a>.<span title="(x$1: Long)Unit">mark</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.messages" title="kafka.message.MessageSet">messages</a>.<a href="../message/MessageSet.scala.html#kafka.message;MessageSet.sizeInBytes" title="=&gt; Long">sizeInBytes</a><span class="delimiter">)</span>
        <a href="KafkaRequestHandler.scala.html#kafka.server.BrokerTopicStats" title="kafka.server.BrokerTopicStats.type">BrokerTopicStats</a>.<a href="KafkaRequestHandler.scala.html#kafka.server.BrokerTopicStats.getBrokerTopicStats" title="(topic: String)kafka.server.BrokerTopicMetrics">getBrokerTopicStats</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>.<a href="KafkaRequestHandler.scala.html#kafka.server;BrokerTopicMetrics.messagesInRate" title="=&gt; com.yammer.metrics.core.Meter">messagesInRate</a>.<span title="(x$1: Long)Unit">mark</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.numAppendedMessages" title="Long">numAppendedMessages</a><span class="delimiter">)</span>
        <a href="KafkaRequestHandler.scala.html#kafka.server.BrokerTopicStats" title="kafka.server.BrokerTopicStats.type">BrokerTopicStats</a>.<a href="KafkaRequestHandler.scala.html#kafka.server.BrokerTopicStats.getBrokerAllTopicsStats" title="()kafka.server.BrokerTopicMetrics">getBrokerAllTopicsStats</a>.<a href="KafkaRequestHandler.scala.html#kafka.server;BrokerTopicMetrics.messagesInRate" title="=&gt; com.yammer.metrics.core.Meter">messagesInRate</a>.<span title="(x$1: Long)Unit">mark</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.numAppendedMessages" title="Long">numAppendedMessages</a><span class="delimiter">)</span>

        <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%d bytes written to log %s-%d beginning at offset %d and ending at offset %d&quot;</span>
              .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.messages" title="kafka.message.MessageSet">messages</a>.<span title="=&gt; Int">size</span>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.info" title="kafka.log.Log#LogAppendInfo">info</a>.<a href="../log/Log.scala.html#kafka.log;Log;LogAppendInfo.firstOffset" title="=&gt; Long">firstOffset</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.info" title="kafka.log.Log#LogAppendInfo">info</a>.<a href="../log/Log.scala.html#kafka.log;Log;LogAppendInfo.lastOffset" title="=&gt; Long">lastOffset</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#kafka.server;KafkaApis.ProduceResult.readResolve" title="(key: kafka.common.TopicAndPartition, start: Long, end: Long, error: Option[Throwable])KafkaApis.this.ProduceResult">ProduceResult</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.info" title="kafka.log.Log#LogAppendInfo">info</a>.<a href="../log/Log.scala.html#kafka.log;Log;LogAppendInfo.firstOffset" title="=&gt; Long">firstOffset</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.info" title="kafka.log.Log#LogAppendInfo">info</a>.<a href="../log/Log.scala.html#kafka.log;Log;LogAppendInfo.lastOffset" title="=&gt; Long">lastOffset</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> catch <span class="delimiter">{</span>
        <span class="comment">// NOTE: Failed produce requests is not incremented for UnknownTopicOrPartitionException and NotLeaderForPartitionException</span>
        <span class="comment">// since failed produce requests metric is supposed to indicate failure of a broker in handling a produce request</span>
        <span class="comment">// for a partition it is the leader for</span>
        case <span title="kafka.common.KafkaStorageException">e</span>: <a href="../common/KafkaStorageException.scala.html#kafka.common;KafkaStorageException" title="kafka.common.KafkaStorageException">KafkaStorageException</a> =&gt;
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.fatal(cfd112d89b)" title="(msg: =&gt; String, e: =&gt; Throwable)Unit">fatal</a><span class="delimiter">(</span><span title="String(&quot;Halting due to unrecoverable I/O error while handling produce request: &quot;)" class="string">&quot;Halting due to unrecoverable I/O error while handling produce request: &quot;</span>, <span title="kafka.common.KafkaStorageException">e</span><span class="delimiter">)</span>
          <span title="Runtime.type">Runtime</span>.<span title="()Runtime">getRuntime</span>.<span title="(x$1: Int)Unit">halt</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
          null
        case <a title="kafka.common.InvalidTopicException" id="kafka.server;KafkaApis.appendToLocalLog.$anonfun.ite">ite</a>: <a href="../common/InvalidTopicException.scala.html#kafka.common;InvalidTopicException" title="kafka.common.InvalidTopicException">InvalidTopicException</a> =&gt;
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Produce request with correlation id %d from client %s on partition %s failed due to %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span>
            <a href="#kafka.server;KafkaApis.appendToLocalLog.producerRequest" title="kafka.api.ProducerRequest">producerRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.producerRequest" title="kafka.api.ProducerRequest">producerRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.clientId" title="=&gt; String">clientId</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.ite" title="kafka.common.InvalidTopicException">ite</a>.<span title="()String">getMessage</span><span class="delimiter">)</span><span class="delimiter">)</span>
          new <a href="#kafka.server;KafkaApis.ProduceResult.readResolve" title="KafkaApis.this.ProduceResult">ProduceResult</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.ite" title="kafka.common.InvalidTopicException">ite</a><span class="delimiter">)</span>
        case <a title="kafka.common.UnknownTopicOrPartitionException" id="kafka.server;KafkaApis.appendToLocalLog.$anonfun.utpe">utpe</a>: <a href="../common/UnknownTopicOrPartitionException.scala.html#kafka.common;UnknownTopicOrPartitionException" title="kafka.common.UnknownTopicOrPartitionException">UnknownTopicOrPartitionException</a> =&gt;
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Produce request with correlation id %d from client %s on partition %s failed due to %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span>
               <a href="#kafka.server;KafkaApis.appendToLocalLog.producerRequest" title="kafka.api.ProducerRequest">producerRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.producerRequest" title="kafka.api.ProducerRequest">producerRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.clientId" title="=&gt; String">clientId</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.utpe" title="kafka.common.UnknownTopicOrPartitionException">utpe</a>.<span title="()String">getMessage</span><span class="delimiter">)</span><span class="delimiter">)</span>
          new <a href="#kafka.server;KafkaApis.ProduceResult.readResolve" title="KafkaApis.this.ProduceResult">ProduceResult</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.utpe" title="kafka.common.UnknownTopicOrPartitionException">utpe</a><span class="delimiter">)</span>
        case <a title="kafka.common.NotLeaderForPartitionException" id="kafka.server;KafkaApis.appendToLocalLog.$anonfun.nle">nle</a>: <a href="../common/NotLeaderForPartitionException.scala.html#kafka.common;NotLeaderForPartitionException" title="kafka.common.NotLeaderForPartitionException">NotLeaderForPartitionException</a> =&gt;
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Produce request with correlation id %d from client %s on partition %s failed due to %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span>
               <a href="#kafka.server;KafkaApis.appendToLocalLog.producerRequest" title="kafka.api.ProducerRequest">producerRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.producerRequest" title="kafka.api.ProducerRequest">producerRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.clientId" title="=&gt; String">clientId</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.nle" title="kafka.common.NotLeaderForPartitionException">nle</a>.<span title="()String">getMessage</span><span class="delimiter">)</span><span class="delimiter">)</span>
          new <a href="#kafka.server;KafkaApis.ProduceResult.readResolve" title="KafkaApis.this.ProduceResult">ProduceResult</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.nle" title="kafka.common.NotLeaderForPartitionException">nle</a><span class="delimiter">)</span>
        case <a title="kafka.common.NotEnoughReplicasException" id="kafka.server;KafkaApis.appendToLocalLog.$anonfun.nere">nere</a>: <a href="../common/NotEnoughReplicasException.scala.html#kafka.common;NotEnoughReplicasException" title="kafka.common.NotEnoughReplicasException">NotEnoughReplicasException</a> =&gt;
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Produce request with correlation id %d from client %s on partition %s failed due to %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span>
            <a href="#kafka.server;KafkaApis.appendToLocalLog.producerRequest" title="kafka.api.ProducerRequest">producerRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.producerRequest" title="kafka.api.ProducerRequest">producerRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.clientId" title="=&gt; String">clientId</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.nere" title="kafka.common.NotEnoughReplicasException">nere</a>.<span title="()String">getMessage</span><span class="delimiter">)</span><span class="delimiter">)</span>
          new <a href="#kafka.server;KafkaApis.ProduceResult.readResolve" title="KafkaApis.this.ProduceResult">ProduceResult</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.nere" title="kafka.common.NotEnoughReplicasException">nere</a><span class="delimiter">)</span>
        case <span title="Throwable">e</span>: <span title="Throwable">Throwable</span> =&gt;
          <a href="KafkaRequestHandler.scala.html#kafka.server.BrokerTopicStats" title="kafka.server.BrokerTopicStats.type">BrokerTopicStats</a>.<a href="KafkaRequestHandler.scala.html#kafka.server.BrokerTopicStats.getBrokerTopicStats" title="(topic: String)kafka.server.BrokerTopicMetrics">getBrokerTopicStats</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>.<a href="KafkaRequestHandler.scala.html#kafka.server;BrokerTopicMetrics.failedProduceRequestRate" title="=&gt; com.yammer.metrics.core.Meter">failedProduceRequestRate</a>.<span title="()Unit">mark</span><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="KafkaRequestHandler.scala.html#kafka.server.BrokerTopicStats" title="kafka.server.BrokerTopicStats.type">BrokerTopicStats</a>.<a href="KafkaRequestHandler.scala.html#kafka.server.BrokerTopicStats.getBrokerAllTopicsStats" title="()kafka.server.BrokerTopicMetrics">getBrokerAllTopicsStats</a>.<a href="KafkaRequestHandler.scala.html#kafka.server;BrokerTopicMetrics.failedProduceRequestRate" title="=&gt; com.yammer.metrics.core.Meter">failedProduceRequestRate</a>.<span title="()Unit">mark</span><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.error(cfd112d89b)" title="(msg: =&gt; String, e: =&gt; Throwable)Unit">error</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Error processing ProducerRequest with correlation id %d from client %s on partition %s&quot;</span>
            .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.producerRequest" title="kafka.api.ProducerRequest">producerRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.producerRequest" title="kafka.api.ProducerRequest">producerRequest</a>.<a href="../api/ProducerRequest.scala.html#kafka.api;ProducerRequest.clientId" title="=&gt; String">clientId</a>, <a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>, <span title="Throwable">e</span><span class="delimiter">)</span>
          new <a href="#kafka.server;KafkaApis.ProduceResult.readResolve" title="KafkaApis.this.ProduceResult">ProduceResult</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.appendToLocalLog.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <span title="Throwable">e</span><span class="delimiter">)</span>
       <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Handle a fetch request
   */</span>
  def <a title="(request: kafka.network.RequestChannel.Request)Unit" id="kafka.server;KafkaApis.handleFetchRequest">handleFetchRequest</a><span class="delimiter">(</span><a title="kafka.network.RequestChannel.Request" id="kafka.server;KafkaApis.handleFetchRequest.request">request</a>: RequestChannel.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request" title="kafka.network.RequestChannel.Request">Request</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="kafka.api.FetchRequest" id="kafka.server;KafkaApis.handleFetchRequest.fetchRequest">fetchRequest</a> = <a href="#kafka.server;KafkaApis.handleFetchRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestObj" title="=&gt; kafka.api.RequestOrResponse">requestObj</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.api.FetchRequest" class="delimiter">[</span><a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest" title="kafka.api.FetchRequest">FetchRequest</a><span class="delimiter">]</span>
    val <a title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.PartitionDataAndOffset]" id="kafka.server;KafkaApis.handleFetchRequest.dataRead">dataRead</a> = <a href="#kafka.server;KafkaApis.replicaManager" title="=&gt; kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.readMessageSets" title="(fetchRequest: kafka.api.FetchRequest)scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.PartitionDataAndOffset]">readMessageSets</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a><span class="delimiter">)</span>

    <span class="comment">// if the fetch request comes from the follower,</span>
    <span class="comment">// update its corresponding log end offset</span>
    if<span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest.isFromFollower" title="=&gt; Boolean">isFromFollower</a><span class="delimiter">)</span>
      <a href="#kafka.server;KafkaApis.recordFollowerLogEndOffsets" title="(replicaId: Int, offsets: scala.collection.Map[kafka.common.TopicAndPartition,kafka.server.LogOffsetMetadata])Unit">recordFollowerLogEndOffsets</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest.replicaId" title="=&gt; Int">replicaId</a>, <a href="#kafka.server;KafkaApis.handleFetchRequest.dataRead" title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.PartitionDataAndOffset]">dataRead</a>.<span title="(f: kafka.server.PartitionDataAndOffset =&gt; kafka.server.LogOffsetMetadata)scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.LogOffsetMetadata]">mapValues</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.$anonfun.x$8" title="kafka.server.PartitionDataAndOffset">_</a>.<a href="ReplicaManager.scala.html#kafka.server;PartitionDataAndOffset.offset" title="=&gt; kafka.server.LogOffsetMetadata">offset</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">// check if this fetch request can be satisfied right away</span>
    val <a title="Int" id="kafka.server;KafkaApis.handleFetchRequest.bytesReadable">bytesReadable</a> = <a href="#kafka.server;KafkaApis.handleFetchRequest.dataRead" title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.PartitionDataAndOffset]">dataRead</a>.<span title="=&gt; Iterable[kafka.server.PartitionDataAndOffset]">values</span>.<span title="(f: kafka.server.PartitionDataAndOffset =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[kafka.server.PartitionDataAndOffset],Int,Iterable[Int]])Iterable[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,Int,Iterable[Int]]" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.bytesReadable.$anonfun.x$9" title="kafka.server.PartitionDataAndOffset">_</a>.<a href="ReplicaManager.scala.html#kafka.server;PartitionDataAndOffset.data" title="=&gt; kafka.api.FetchResponsePartitionData">data</a>.<a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData.messages" title="=&gt; kafka.message.MessageSet">messages</a>.<a href="../message/MessageSet.scala.html#kafka.message;MessageSet.sizeInBytes" title="=&gt; Int">sizeInBytes</a><span class="delimiter">)</span>.<span title="(implicit num: Numeric[Int])Int">sum</span>
    val <a title="Boolean" id="kafka.server;KafkaApis.handleFetchRequest.errorReadingData">errorReadingData</a> = <a href="#kafka.server;KafkaApis.handleFetchRequest.dataRead" title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.PartitionDataAndOffset]">dataRead</a>.<span title="=&gt; Iterable[kafka.server.PartitionDataAndOffset]">values</span>.<span title="(z: Boolean)(op: (Boolean, kafka.server.PartitionDataAndOffset) =&gt; Boolean)Boolean">foldLeft</span><span class="delimiter">(</span>false<span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Boolean" id="kafka.server;KafkaApis.handleFetchRequest.errorReadingData.$anonfun.errorIncurred">errorIncurred</a>, <a title="kafka.server.PartitionDataAndOffset" id="kafka.server;KafkaApis.handleFetchRequest.errorReadingData.$anonfun.dataAndOffset">dataAndOffset</a><span class="delimiter">)</span> =&gt;
      <a href="#kafka.server;KafkaApis.handleFetchRequest.errorReadingData.$anonfun.errorIncurred" title="Boolean">errorIncurred</a> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.errorReadingData.$anonfun.dataAndOffset" title="kafka.server.PartitionDataAndOffset">dataAndOffset</a>.<a href="ReplicaManager.scala.html#kafka.server;PartitionDataAndOffset.data" title="=&gt; kafka.api.FetchResponsePartitionData">data</a>.<a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData.error" title="=&gt; Short">error</a> <span title="(x: Short)Boolean">!=</span> <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="comment">// send the data immediately if 1) fetch request does not want to wait</span>
    <span class="comment">//                              2) fetch request does not require any data</span>
    <span class="comment">//                              3) has enough data to respond</span>
    <span class="comment">//                              4) some error happens while reading data</span>
    if<span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest.maxWait" title="=&gt; Int">maxWait</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span>
       <a href="#kafka.server;KafkaApis.handleFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest.numPartitions" title="=&gt; Int">numPartitions</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span>
       <a href="#kafka.server;KafkaApis.handleFetchRequest.bytesReadable" title="Int">bytesReadable</a> <span title="(x: Int)Boolean">&gt;=</span> <a href="#kafka.server;KafkaApis.handleFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest.minBytes" title="=&gt; Int">minBytes</a> <span title="(x: Boolean)Boolean">||</span>
       <a href="#kafka.server;KafkaApis.handleFetchRequest.errorReadingData" title="Boolean">errorReadingData</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Returning fetch response %s for fetch request with correlation id %d to client %s&quot;</span>
        .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.dataRead" title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.PartitionDataAndOffset]">dataRead</a>.<span title="=&gt; Iterable[kafka.server.PartitionDataAndOffset]">values</span>.<span title="(f: kafka.server.PartitionDataAndOffset =&gt; Short)(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[kafka.server.PartitionDataAndOffset],Short,Iterable[Short]])Iterable[Short]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,Short,Iterable[Short]]" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.$anonfun.x$10" title="kafka.server.PartitionDataAndOffset">_</a>.<a href="ReplicaManager.scala.html#kafka.server;PartitionDataAndOffset.data" title="=&gt; kafka.api.FetchResponsePartitionData">data</a>.<a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData.error" title="=&gt; Short">error</a><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>, <a href="#kafka.server;KafkaApis.handleFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.handleFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest.clientId" title="=&gt; String">clientId</a><span class="delimiter">)</span><span class="delimiter">)</span>
      val <a title="kafka.api.FetchResponse" id="kafka.server;KafkaApis.handleFetchRequest.response">response</a> = new <a href="../api/FetchResponse.scala.html#kafka.api;FetchResponse" title="kafka.api.FetchResponse">FetchResponse</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.handleFetchRequest.dataRead" title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.PartitionDataAndOffset]">dataRead</a>.<span title="(f: kafka.server.PartitionDataAndOffset =&gt; kafka.api.FetchResponsePartitionData)scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.FetchResponsePartitionData]">mapValues</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.response.$anonfun.x$11" title="kafka.server.PartitionDataAndOffset">_</a>.<a href="ReplicaManager.scala.html#kafka.server;PartitionDataAndOffset.data" title="=&gt; kafka.api.FetchResponsePartitionData">data</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel.sendResponse" title="(response: kafka.network.RequestChannel.Response)Unit">sendResponse</a><span class="delimiter">(</span>new <a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel" title="kafka.network.RequestChannel.type">RequestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Response" title="kafka.network.RequestChannel.Response">Response</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.request" title="kafka.network.RequestChannel.Request">request</a>, new <a href="../api/FetchResponse.scala.html#kafka.api;FetchResponseSend" title="kafka.api.FetchResponseSend">FetchResponseSend</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.response" title="kafka.api.FetchResponse">response</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Putting fetch request with correlation id %d from client %s into purgatory&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest.correlationId" title="=&gt; Int">correlationId</a>,
        <a href="#kafka.server;KafkaApis.handleFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest.clientId" title="=&gt; String">clientId</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="comment">// create a list of (topic, partition) pairs to use as keys for this delayed request</span>
      val <a title="Seq[kafka.common.TopicAndPartition]" id="kafka.server;KafkaApis.handleFetchRequest.delayedFetchKeys">delayedFetchKeys</a> = <a href="#kafka.server;KafkaApis.handleFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest.requestInfo" title="=&gt; scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.PartitionFetchInfo]">requestInfo</a>.<span title="=&gt; Iterable[kafka.common.TopicAndPartition]">keys</span>.<span title="=&gt; Seq[kafka.common.TopicAndPartition]">toSeq</span>
      val <a title="kafka.server.DelayedFetch" id="kafka.server;KafkaApis.handleFetchRequest.delayedFetch">delayedFetch</a> = new <a href="DelayedFetch.scala.html#kafka.server;DelayedFetch" title="kafka.server.DelayedFetch">DelayedFetch</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.delayedFetchKeys" title="Seq[kafka.common.TopicAndPartition]">delayedFetchKeys</a>, <a href="#kafka.server;KafkaApis.handleFetchRequest.request" title="kafka.network.RequestChannel.Request">request</a>, <a href="#kafka.server;KafkaApis.handleFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequest.maxWait" title="=&gt; Long">maxWait</a>, <a href="#kafka.server;KafkaApis.handleFetchRequest.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a>,
        <a href="#kafka.server;KafkaApis.handleFetchRequest.dataRead" title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.PartitionDataAndOffset]">dataRead</a>.<span title="(f: kafka.server.PartitionDataAndOffset =&gt; kafka.server.LogOffsetMetadata)scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.server.LogOffsetMetadata]">mapValues</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.delayedFetch.$anonfun.x$12" title="kafka.server.PartitionDataAndOffset">_</a>.<a href="ReplicaManager.scala.html#kafka.server;PartitionDataAndOffset.offset" title="=&gt; kafka.server.LogOffsetMetadata">offset</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="comment">// add the fetch request for watch if it's not satisfied, otherwise send the response back</span>
      val <a title="Boolean" id="kafka.server;KafkaApis.handleFetchRequest.satisfiedByMe">satisfiedByMe</a> = <a href="#kafka.server;KafkaApis.fetchRequestPurgatory" title="=&gt; kafka.server.FetchRequestPurgatory">fetchRequestPurgatory</a>.<a href="RequestPurgatory.scala.html#kafka.server;RequestPurgatory.checkAndMaybeWatch" title="(delayedRequest: kafka.server.DelayedFetch)Boolean">checkAndMaybeWatch</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.delayedFetch" title="kafka.server.DelayedFetch">delayedFetch</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.satisfiedByMe" title="Boolean">satisfiedByMe</a><span class="delimiter">)</span>
        <a href="#kafka.server;KafkaApis.fetchRequestPurgatory" title="=&gt; kafka.server.FetchRequestPurgatory">fetchRequestPurgatory</a>.<a href="FetchRequestPurgatory.scala.html#kafka.server;FetchRequestPurgatory.respond" title="(delayedFetch: kafka.server.DelayedFetch)Unit">respond</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleFetchRequest.delayedFetch" title="kafka.server.DelayedFetch">delayedFetch</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  private def <a title="(replicaId: Int, offsets: scala.collection.Map[kafka.common.TopicAndPartition,kafka.server.LogOffsetMetadata])Unit" id="kafka.server;KafkaApis.recordFollowerLogEndOffsets">recordFollowerLogEndOffsets</a><span class="delimiter">(</span><a title="Int" id="kafka.server;KafkaApis.recordFollowerLogEndOffsets.replicaId">replicaId</a>: <span title="Int">Int</span>, <a title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.server.LogOffsetMetadata]" id="kafka.server;KafkaApis.recordFollowerLogEndOffsets.offsets">offsets</a>: <span title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.server.LogOffsetMetadata]">Map</span><span class="delimiter">[</span>TopicAndPartition, LogOffsetMetadata<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Record follower log end offsets: %s &quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.recordFollowerLogEndOffsets.offsets" title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.server.LogOffsetMetadata]">offsets</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.server;KafkaApis.recordFollowerLogEndOffsets.offsets" title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.server.LogOffsetMetadata]">offsets</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.server.LogOffsetMetadata)) =&gt; Unit)Unit">foreach</span> <a href="#kafka.server;KafkaApis.recordFollowerLogEndOffsets.$anonfun.x0$4" title="Unit" class="delimiter">{</a>
      case <span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;KafkaApis.recordFollowerLogEndOffsets.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="kafka.server.LogOffsetMetadata" id="kafka.server;KafkaApis.recordFollowerLogEndOffsets.$anonfun.offset">offset</a><span class="delimiter">)</span> =&gt;
        <a href="#kafka.server;KafkaApis.replicaManager" title="=&gt; kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.updateReplicaLEOAndPartitionHW" title="(topic: String, partitionId: Int, replicaId: Int, offset: kafka.server.LogOffsetMetadata)Unit">updateReplicaLEOAndPartitionHW</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.recordFollowerLogEndOffsets.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>,
          <a href="#kafka.server;KafkaApis.recordFollowerLogEndOffsets.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a>, <a href="#kafka.server;KafkaApis.recordFollowerLogEndOffsets.replicaId" title="Int">replicaId</a>, <a href="#kafka.server;KafkaApis.recordFollowerLogEndOffsets.$anonfun.offset" title="kafka.server.LogOffsetMetadata">offset</a><span class="delimiter">)</span>

        <span class="comment">// for producer requests with ack &gt; 1, we need to check</span>
        <span class="comment">// if they can be unblocked after some follower's log end offsets have moved</span>
        <a href="#kafka.server;KafkaApis.replicaManager" title="=&gt; kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.unblockDelayedProduceRequests" title="(key: kafka.common.TopicAndPartition)Unit">unblockDelayedProduceRequests</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.recordFollowerLogEndOffsets.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Service the offset request API 
   */</span>
  def <a title="(request: kafka.network.RequestChannel.Request)Unit" id="kafka.server;KafkaApis.handleOffsetRequest">handleOffsetRequest</a><span class="delimiter">(</span><a title="kafka.network.RequestChannel.Request" id="kafka.server;KafkaApis.handleOffsetRequest.request">request</a>: RequestChannel.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request" title="kafka.network.RequestChannel.Request">Request</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="kafka.api.OffsetRequest" id="kafka.server;KafkaApis.handleOffsetRequest.offsetRequest">offsetRequest</a> = <a href="#kafka.server;KafkaApis.handleOffsetRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestObj" title="=&gt; kafka.api.RequestOrResponse">requestObj</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.api.OffsetRequest" class="delimiter">[</span><a href="../api/OffsetRequest.scala.html#kafka.api;OffsetRequest" title="kafka.api.OffsetRequest">OffsetRequest</a><span class="delimiter">]</span>
    val <a title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetsResponse]" id="kafka.server;KafkaApis.handleOffsetRequest.responseMap">responseMap</a> = <a href="#kafka.server;KafkaApis.handleOffsetRequest.offsetRequest" title="kafka.api.OffsetRequest">offsetRequest</a>.<a href="../api/OffsetRequest.scala.html#kafka.api;OffsetRequest.requestInfo" title="=&gt; Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetRequestInfo]">requestInfo</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.api.PartitionOffsetRequestInfo)) =&gt; (kafka.common.TopicAndPartition, kafka.api.PartitionOffsetsResponse))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetRequestInfo],(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetsResponse),scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetsResponse]])scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetsResponse]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map.Coll,(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetsResponse),scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetsResponse]]" class="delimiter">(</span><a title="(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetRequestInfo)" id="kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.elem">elem</a> =&gt; <span class="delimiter">{</span>
      val <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.topicAndPartition" title="(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetRequestInfo)" class="delimiter">(</a><a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.x$13" title="kafka.common.TopicAndPartition" id="kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.topicAndPartition">topicAndPartition</a>, <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.x$13" title="kafka.api.PartitionOffsetRequestInfo" id="kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.partitionOffsetRequestInfo">partitionOffsetRequestInfo</a><span class="delimiter">)</span> = <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.elem" title="(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetRequestInfo)">elem</a>
      try <span class="delimiter">{</span>
        <span class="comment">// ensure leader exists</span>
        val <a title="kafka.cluster.Replica" id="kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.localReplica">localReplica</a> = if<span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.offsetRequest" title="kafka.api.OffsetRequest">offsetRequest</a>.<a href="../api/OffsetRequest.scala.html#kafka.api;OffsetRequest.isFromDebuggingClient" title="=&gt; Boolean">isFromDebuggingClient</a><span class="delimiter">)</span>
          <a href="#kafka.server;KafkaApis.replicaManager" title="=&gt; kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.getLeaderReplicaIfLocal" title="(topic: String, partitionId: Int)kafka.cluster.Replica">getLeaderReplicaIfLocal</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a><span class="delimiter">)</span>
        else
          <a href="#kafka.server;KafkaApis.replicaManager" title="=&gt; kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.getReplicaOrException" title="(topic: String, partition: Int)kafka.cluster.Replica">getReplicaOrException</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a><span class="delimiter">)</span>
        val <a title="Seq[Long]" id="kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.offsets">offsets</a> = <span class="delimiter">{</span>
          val <a title="Seq[Long]" id="kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.offsets.allOffsets">allOffsets</a> = <a href="#kafka.server;KafkaApis.fetchOffsets" title="(logManager: kafka.log.LogManager, topicAndPartition: kafka.common.TopicAndPartition, timestamp: Long, maxNumOffsets: Int)Seq[Long]">fetchOffsets</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.replicaManager" title="=&gt; kafka.server.ReplicaManager">replicaManager</a>.<a href="ReplicaManager.scala.html#kafka.server;ReplicaManager.logManager" title="=&gt; kafka.log.LogManager">logManager</a>,
                                        <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>,
                                        <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.partitionOffsetRequestInfo" title="kafka.api.PartitionOffsetRequestInfo">partitionOffsetRequestInfo</a>.<a href="../api/OffsetRequest.scala.html#kafka.api;PartitionOffsetRequestInfo.time" title="=&gt; Long">time</a>,
                                        <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.partitionOffsetRequestInfo" title="kafka.api.PartitionOffsetRequestInfo">partitionOffsetRequestInfo</a>.<a href="../api/OffsetRequest.scala.html#kafka.api;PartitionOffsetRequestInfo.maxNumOffsets" title="=&gt; Int">maxNumOffsets</a><span class="delimiter">)</span>
          if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.offsetRequest" title="kafka.api.OffsetRequest">offsetRequest</a>.<a href="../api/OffsetRequest.scala.html#kafka.api;OffsetRequest.isFromOrdinaryClient" title="=&gt; Boolean">isFromOrdinaryClient</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.offsets.allOffsets" title="Seq[Long]">allOffsets</a>
          <span class="delimiter">}</span> else <span class="delimiter">{</span>
            val <a title="Long" id="kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.offsets.hw">hw</a> = <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.localReplica" title="kafka.cluster.Replica">localReplica</a>.<a href="../cluster/Replica.scala.html#kafka.cluster;Replica.highWatermark" title="=&gt; kafka.server.LogOffsetMetadata">highWatermark</a>.<a href="LogOffsetMetadata.scala.html#kafka.server;LogOffsetMetadata.messageOffset" title="=&gt; Long">messageOffset</a>
            if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.offsets.allOffsets" title="Seq[Long]">allOffsets</a>.<span title="(p: Long =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.offsets.$anonfun.x$14" title="Long">_</a> <span title="(x: Long)Boolean">&gt;</span> <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.offsets.hw" title="Long">hw</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.offsets.hw" title="Long">hw</a> <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.offsets.x$16" title="(elem: Long)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Long],Long,Seq[Long]])Seq[Long]">+:</a> <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.offsets.allOffsets" title="Seq[Long]">allOffsets</a>.<span title="(p: Long =&gt; Boolean)Seq[Long]">dropWhile</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.offsets.$anonfun.x$15" title="Long">_</a> <span title="(x: Long)Boolean">&gt;</span> <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.offsets.hw" title="Long">hw</a><span class="delimiter">)</span>
            else 
              <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.offsets.allOffsets" title="Seq[Long]">allOffsets</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span title="(_1: kafka.common.TopicAndPartition, _2: kafka.api.PartitionOffsetsResponse)(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetsResponse)" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="../api/OffsetResponse.scala.html#kafka.api;PartitionOffsetsResponse" title="(error: Short, offsets: Seq[Long])kafka.api.PartitionOffsetsResponse">PartitionOffsetsResponse</a><span class="delimiter">(</span><a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a>, <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.offsets" title="Seq[Long]">offsets</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> catch <span class="delimiter">{</span>
        <span class="comment">// NOTE: UnknownTopicOrPartitionException and NotLeaderForPartitionException are special cased since these error messages</span>
        <span class="comment">// are typically transient and there is no value in logging the entire stack trace for the same</span>
        case <a title="kafka.common.UnknownTopicOrPartitionException" id="kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.utpe">utpe</a>: <a href="../common/UnknownTopicOrPartitionException.scala.html#kafka.common;UnknownTopicOrPartitionException" title="kafka.common.UnknownTopicOrPartitionException">UnknownTopicOrPartitionException</a> =&gt;
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Offset request with correlation id %d from client %s on partition %s failed due to %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span>
               <a href="#kafka.server;KafkaApis.handleOffsetRequest.offsetRequest" title="kafka.api.OffsetRequest">offsetRequest</a>.<a href="../api/OffsetRequest.scala.html#kafka.api;OffsetRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.handleOffsetRequest.offsetRequest" title="kafka.api.OffsetRequest">offsetRequest</a>.<a href="../api/OffsetRequest.scala.html#kafka.api;OffsetRequest.clientId" title="=&gt; String">clientId</a>, <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.utpe" title="kafka.common.UnknownTopicOrPartitionException">utpe</a>.<span title="()String">getMessage</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="(_1: kafka.common.TopicAndPartition, _2: kafka.api.PartitionOffsetsResponse)(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetsResponse)" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="../api/OffsetResponse.scala.html#kafka.api;PartitionOffsetsResponse" title="(error: Short, offsets: Seq[Long])kafka.api.PartitionOffsetsResponse">PartitionOffsetsResponse</a><span class="delimiter">(</span><a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.codeFor" title="(exception: Class[Throwable])Short">codeFor</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.utpe" title="kafka.common.UnknownTopicOrPartitionException">utpe</a>.<span title="()Class[_]">getClass</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Class[Throwable]" class="delimiter">[</span><span title="Class[Throwable]">Class</span><span class="delimiter">[</span>Throwable<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> <span class="delimiter">)</span>
        case <a title="kafka.common.NotLeaderForPartitionException" id="kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.nle">nle</a>: <a href="../common/NotLeaderForPartitionException.scala.html#kafka.common;NotLeaderForPartitionException" title="kafka.common.NotLeaderForPartitionException">NotLeaderForPartitionException</a> =&gt;
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Offset request with correlation id %d from client %s on partition %s failed due to %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span>
               <a href="#kafka.server;KafkaApis.handleOffsetRequest.offsetRequest" title="kafka.api.OffsetRequest">offsetRequest</a>.<a href="../api/OffsetRequest.scala.html#kafka.api;OffsetRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.handleOffsetRequest.offsetRequest" title="kafka.api.OffsetRequest">offsetRequest</a>.<a href="../api/OffsetRequest.scala.html#kafka.api;OffsetRequest.clientId" title="=&gt; String">clientId</a>, <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>,<a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.nle" title="kafka.common.NotLeaderForPartitionException">nle</a>.<span title="()String">getMessage</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="(_1: kafka.common.TopicAndPartition, _2: kafka.api.PartitionOffsetsResponse)(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetsResponse)" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="../api/OffsetResponse.scala.html#kafka.api;PartitionOffsetsResponse" title="(error: Short, offsets: Seq[Long])kafka.api.PartitionOffsetsResponse">PartitionOffsetsResponse</a><span class="delimiter">(</span><a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.codeFor" title="(exception: Class[Throwable])Short">codeFor</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.nle" title="kafka.common.NotLeaderForPartitionException">nle</a>.<span title="()Class[_]">getClass</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Class[Throwable]" class="delimiter">[</span><span title="Class[Throwable]">Class</span><span class="delimiter">[</span>Throwable<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> <span class="delimiter">)</span>
        case <a title="Throwable" id="kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.e">e</a>: <span title="Throwable">Throwable</span> =&gt;
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.warn(cfd112d89b)" title="(msg: =&gt; String, e: =&gt; Throwable)Unit">warn</a><span class="delimiter">(</span><span title="String(&quot;Error while responding to offset request&quot;)" class="string">&quot;Error while responding to offset request&quot;</span>, <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.e" title="Throwable">e</a><span class="delimiter">)</span>
          <span title="(_1: kafka.common.TopicAndPartition, _2: kafka.api.PartitionOffsetsResponse)(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetsResponse)" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="../api/OffsetResponse.scala.html#kafka.api;PartitionOffsetsResponse" title="(error: Short, offsets: Seq[Long])kafka.api.PartitionOffsetsResponse">PartitionOffsetsResponse</a><span class="delimiter">(</span><a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.codeFor" title="(exception: Class[Throwable])Short">codeFor</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap.$anonfun.e" title="Throwable">e</a>.<span title="()Class[_]">getClass</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Class[Throwable]" class="delimiter">[</span><span title="Class[Throwable]">Class</span><span class="delimiter">[</span>Throwable<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> <span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>
    val <a title="kafka.api.OffsetResponse" id="kafka.server;KafkaApis.handleOffsetRequest.response">response</a> = <a href="../api/OffsetResponse.scala.html#kafka.api;OffsetResponse" title="(correlationId: Int, partitionErrorAndOffsets: Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetsResponse])kafka.api.OffsetResponse">OffsetResponse</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.offsetRequest" title="kafka.api.OffsetRequest">offsetRequest</a>.<a href="../api/OffsetRequest.scala.html#kafka.api;OffsetRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.handleOffsetRequest.responseMap" title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetsResponse]">responseMap</a><span class="delimiter">)</span>
    <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel.sendResponse" title="(response: kafka.network.RequestChannel.Response)Unit">sendResponse</a><span class="delimiter">(</span>new <a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel" title="kafka.network.RequestChannel.type">RequestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Response" title="kafka.network.RequestChannel.Response">Response</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.request" title="kafka.network.RequestChannel.Request">request</a>, new <a href="../network/BoundedByteBufferSend.scala.html#kafka.network;BoundedByteBufferSend" title="kafka.network.BoundedByteBufferSend">BoundedByteBufferSend</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetRequest.response" title="kafka.api.OffsetResponse">response</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  def <a title="(logManager: kafka.log.LogManager, topicAndPartition: kafka.common.TopicAndPartition, timestamp: Long, maxNumOffsets: Int)Seq[Long]" id="kafka.server;KafkaApis.fetchOffsets">fetchOffsets</a><span class="delimiter">(</span><a title="kafka.log.LogManager" id="kafka.server;KafkaApis.fetchOffsets.logManager">logManager</a>: <a href="../log/LogManager.scala.html#kafka.log;LogManager" title="kafka.log.LogManager">LogManager</a>, <a title="kafka.common.TopicAndPartition" id="kafka.server;KafkaApis.fetchOffsets.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a>, <a title="Long" id="kafka.server;KafkaApis.fetchOffsets.timestamp">timestamp</a>: <span title="Long">Long</span>, <a title="Int" id="kafka.server;KafkaApis.fetchOffsets.maxNumOffsets">maxNumOffsets</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Seq[Long]">Seq</span><span class="delimiter">[</span>Long<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#kafka.server;KafkaApis.fetchOffsets.logManager" title="kafka.log.LogManager">logManager</a>.<a href="../log/LogManager.scala.html#kafka.log;LogManager.getLog" title="(topicAndPartition: kafka.common.TopicAndPartition)Option[kafka.log.Log]">getLog</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsets.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case Some<span class="delimiter">(</span><a title="kafka.log.Log" id="kafka.server;KafkaApis.fetchOffsets.log">log</a><span class="delimiter">)</span> =&gt; 
        <a href="#kafka.server;KafkaApis.fetchOffsetsBefore" title="(log: kafka.log.Log, timestamp: Long, maxNumOffsets: Int)Seq[Long]">fetchOffsetsBefore</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsets.log" title="kafka.log.Log">log</a>, <a href="#kafka.server;KafkaApis.fetchOffsets.timestamp" title="Long">timestamp</a>, <a href="#kafka.server;KafkaApis.fetchOffsets.maxNumOffsets" title="Int">maxNumOffsets</a><span class="delimiter">)</span>
      case <span title="None.type">None</span> =&gt; 
        if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsets.timestamp" title="Long">timestamp</a> <span title="(x: Long)Boolean">==</span> <a href="../api/OffsetRequest.scala.html#kafka.api.OffsetRequest" title="kafka.api.OffsetRequest.type">OffsetRequest</a>.<a href="../api/OffsetRequest.scala.html#kafka.api.OffsetRequest.LatestTime" title="=&gt; Long">LatestTime</a> <span title="(x: Boolean)Boolean">||</span> <a href="#kafka.server;KafkaApis.fetchOffsets.timestamp" title="Long">timestamp</a> <span title="(x: Long)Boolean">==</span> <a href="../api/OffsetRequest.scala.html#kafka.api.OffsetRequest" title="kafka.api.OffsetRequest.type">OffsetRequest</a>.<a href="../api/OffsetRequest.scala.html#kafka.api.OffsetRequest.EarliestTime" title="=&gt; Long">EarliestTime</a><span class="delimiter">)</span>
          <span title="(elems: Long*)Seq[Long]">Seq</span><span class="delimiter">(</span><span title="Long(0L)" class="long">0L</span><span class="delimiter">)</span>
        else
          <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  def <a title="(log: kafka.log.Log, timestamp: Long, maxNumOffsets: Int)Seq[Long]" id="kafka.server;KafkaApis.fetchOffsetsBefore">fetchOffsetsBefore</a><span class="delimiter">(</span><a title="kafka.log.Log" id="kafka.server;KafkaApis.fetchOffsetsBefore.log">log</a>: <a href="../log/Log.scala.html#kafka.log;Log" title="kafka.log.Log">Log</a>, <a title="Long" id="kafka.server;KafkaApis.fetchOffsetsBefore.timestamp">timestamp</a>: <span title="Long">Long</span>, <a title="Int" id="kafka.server;KafkaApis.fetchOffsetsBefore.maxNumOffsets">maxNumOffsets</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Seq[Long]">Seq</span><span class="delimiter">[</span>Long<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[kafka.log.LogSegment]" id="kafka.server;KafkaApis.fetchOffsetsBefore.segsArray">segsArray</a> = <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.log" title="kafka.log.Log">log</a>.<a href="../log/Log.scala.html#kafka.log;Log.logSegments(b2658bab35)" title="=&gt; Iterable[kafka.log.LogSegment]">logSegments</a>.<span title="(implicit evidence$1: scala.reflect.ClassTag[kafka.log.LogSegment])Array[kafka.log.LogSegment]">toArray</span>
    var <a title="Array[(Long, Long)]" id="kafka.server;KafkaApis.fetchOffsetsBefore.offsetTimeArray">offsetTimeArray</a>: <span title="Array[(Long, Long)]">Array</span><span class="delimiter">[</span><span class="delimiter">(</span>Long, Long<span class="delimiter">)</span><span class="delimiter">]</span> = null
    if<span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.segsArray" title="(xs: Array[kafka.log.LogSegment])scala.collection.mutable.ArrayOps[kafka.log.LogSegment]">segsArray</a>.<span title="=&gt; kafka.log.LogSegment">last</span>.<a href="../log/LogSegment.scala.html#kafka.log;LogSegment.size" title="=&gt; Long">size</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.offsetTimeArray" title="Array[(Long, Long)]">offsetTimeArray</a> = new <span title="Array[(Long, Long)]">Array</span><span class="delimiter">[</span><span class="delimiter">(</span>Long, Long<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.segsArray" title="Array[kafka.log.LogSegment]">segsArray</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    else
      <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.offsetTimeArray" title="Array[(Long, Long)]">offsetTimeArray</a> = new <span title="Array[(Long, Long)]">Array</span><span class="delimiter">[</span><span class="delimiter">(</span>Long, Long<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.segsArray" title="Array[kafka.log.LogSegment]">segsArray</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span>

    for<span class="delimiter">(</span><a title="Int" id="kafka.server;KafkaApis.fetchOffsetsBefore.$anonfun.i">i</a> &lt;- <span title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">0</span> <span title="(f: Int =&gt; Unit)Unit">until</span> <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.segsArray" title="Array[kafka.log.LogSegment]">segsArray</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span>
      <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.offsetTimeArray" title="(i: Int, x: (Long, Long))Unit">offsetTimeArray</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.$anonfun.i" title="Int">i</a><span class="delimiter">)</span> = <span title="(_1: Long, _2: Long)(Long, Long)" class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.segsArray" title="(i: Int)kafka.log.LogSegment">segsArray</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.$anonfun.i" title="Int">i</a><span class="delimiter">)</span>.<a href="../log/LogSegment.scala.html#kafka.log;LogSegment.baseOffset" title="=&gt; Long">baseOffset</a>, <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.segsArray" title="(i: Int)kafka.log.LogSegment">segsArray</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.$anonfun.i" title="Int">i</a><span class="delimiter">)</span>.<a href="../log/LogSegment.scala.html#kafka.log;LogSegment.lastModified" title="=&gt; Long">lastModified</a><span class="delimiter">)</span>
    if<span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.segsArray" title="(xs: Array[kafka.log.LogSegment])scala.collection.mutable.ArrayOps[kafka.log.LogSegment]">segsArray</a>.<span title="=&gt; kafka.log.LogSegment">last</span>.<a href="../log/LogSegment.scala.html#kafka.log;LogSegment.size" title="=&gt; Long">size</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.offsetTimeArray" title="(i: Int, x: (Long, Long))Unit">offsetTimeArray</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.segsArray" title="Array[kafka.log.LogSegment]">segsArray</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> = <span title="(_1: Long, _2: Long)(Long, Long)" class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.log" title="kafka.log.Log">log</a>.<a href="../log/Log.scala.html#kafka.log;Log.logEndOffset" title="=&gt; Long">logEndOffset</a>, <a href="../utils/Time.scala.html#kafka.utils.SystemTime" title="kafka.utils.SystemTime.type">SystemTime</a>.<a href="../utils/Time.scala.html#kafka.utils.SystemTime.milliseconds" title="=&gt; Long">milliseconds</a><span class="delimiter">)</span>

    var <a title="Int" id="kafka.server;KafkaApis.fetchOffsetsBefore.startIndex">startIndex</a> = -<span title="Int(-1)" class="int">1</span>
    <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.timestamp" title="Long">timestamp</a> match <span class="delimiter">{</span>
      case <a href="../api/OffsetRequest.scala.html#kafka.api.OffsetRequest" title="kafka.api.OffsetRequest.type">OffsetRequest</a>.<a href="../api/OffsetRequest.scala.html#kafka.api.OffsetRequest.LatestTime" title="=&gt; Long">LatestTime</a> =&gt;
        <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.startIndex" title="Int">startIndex</a> = <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.offsetTimeArray" title="Array[(Long, Long)]">offsetTimeArray</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>
      case <a href="../api/OffsetRequest.scala.html#kafka.api.OffsetRequest" title="kafka.api.OffsetRequest.type">OffsetRequest</a>.<a href="../api/OffsetRequest.scala.html#kafka.api.OffsetRequest.EarliestTime" title="=&gt; Long">EarliestTime</a> =&gt;
        <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.startIndex" title="Int">startIndex</a> = <span title="Int(0)" class="int">0</span>
      case _ =&gt;
        var <a title="Boolean" id="kafka.server;KafkaApis.fetchOffsetsBefore.isFound">isFound</a> = false
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Offset time array = &quot;)" class="string">&quot;Offset time array = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.offsetTimeArray" title="(xs: Array[(Long, Long)])scala.collection.mutable.ArrayOps[(Long, Long)]">offsetTimeArray</a>.<span title="(f: ((Long, Long)) =&gt; String)Unit">foreach</span><span class="delimiter">(</span><a title="(Long, Long)" id="kafka.server;KafkaApis.fetchOffsetsBefore.$anonfun.o">o</a> =&gt; <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%d, %d&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.$anonfun.o" title="(Long, Long)">o</a>.<span title="=&gt; Long">_1</span>, <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.$anonfun.o" title="(Long, Long)">o</a>.<span title="=&gt; Long">_2</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.startIndex" title="Int">startIndex</a> = <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.offsetTimeArray" title="Array[(Long, Long)]">offsetTimeArray</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>
        while <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.startIndex" title="Int">startIndex</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.isFound" title="Boolean">isFound</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.offsetTimeArray" title="(i: Int)(Long, Long)">offsetTimeArray</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.startIndex" title="Int">startIndex</a><span class="delimiter">)</span>.<span title="=&gt; Long">_2</span> <span title="(x: Long)Boolean">&lt;=</span> <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.timestamp" title="Long">timestamp</a><span class="delimiter">)</span>
            <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.isFound" title="Boolean">isFound</a> = true
          else
            <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.startIndex" title="Int">startIndex</a> <span title="(x: Int)Int">-=</span><span title="Int(1)" class="int">1</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    val <a title="Int" id="kafka.server;KafkaApis.fetchOffsetsBefore.retSize">retSize</a> = <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.maxNumOffsets" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">maxNumOffsets</a>.<span title="(that: Int)Int">min</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.startIndex" title="Int">startIndex</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    val <a title="Array[Long]" id="kafka.server;KafkaApis.fetchOffsetsBefore.ret">ret</a> = new <span title="Array[Long]">Array</span><span class="delimiter">[</span>Long<span class="delimiter">]</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.retSize" title="Int">retSize</a><span class="delimiter">)</span>
    for<span class="delimiter">(</span><a title="Int" id="kafka.server;KafkaApis.fetchOffsetsBefore.$anonfun.j">j</a> &lt;- <span title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">0</span> <span title="(f: Int =&gt; Unit)Unit">until</span> <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.retSize" title="Int">retSize</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.ret" title="(i: Int, x: Long)Unit">ret</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.$anonfun.j" title="Int">j</a><span class="delimiter">)</span> = <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.offsetTimeArray" title="(i: Int)(Long, Long)">offsetTimeArray</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.fetchOffsetsBefore.startIndex" title="Int">startIndex</a><span class="delimiter">)</span>.<span title="=&gt; Long">_1</span>
      <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.startIndex" title="Int">startIndex</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
    <span class="delimiter">}</span>
    <span class="comment">// ensure that the returned seq is in descending order of offsets</span>
    <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.ret" title="implicit scala.Predef.longArrayOps : (xs: Array[Long])scala.collection.mutable.ArrayOps[Long]">ret</a>.<span title="=&gt; Seq[Long]">toSeq</span>.<span title="(f: Long =&gt; Long)(implicit ord: scala.math.Ordering[Long])Seq[Long]">sortBy</span><span title="scala.math.Ordering.Long.type" class="delimiter">(</span><span title="=&gt; Long">-</span> <a href="#kafka.server;KafkaApis.fetchOffsetsBefore.$anonfun.x$17" title="Long">_</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private def <a title="(topics: scala.collection.Set[String])Seq[kafka.api.TopicMetadata]" id="kafka.server;KafkaApis.getTopicMetadata">getTopicMetadata</a><span class="delimiter">(</span><a title="scala.collection.Set[String]" id="kafka.server;KafkaApis.getTopicMetadata.topics">topics</a>: <span title="scala.collection.Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[kafka.api.TopicMetadata]">Seq</span><span class="delimiter">[</span>TopicMetadata<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scala.collection.mutable.ListBuffer[kafka.api.TopicMetadata]" id="kafka.server;KafkaApis.getTopicMetadata.topicResponses">topicResponses</a> = <a href="#kafka.server;KafkaApis.metadataCache_=" title="=&gt; kafka.server.MetadataCache">metadataCache</a>.<a href="MetadataCache.scala.html#kafka.server;MetadataCache.getTopicMetadata" title="(topics: scala.collection.Set[String])scala.collection.mutable.ListBuffer[kafka.api.TopicMetadata]">getTopicMetadata</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.getTopicMetadata.topics" title="scala.collection.Set[String]">topics</a><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.getTopicMetadata.topics" title="scala.collection.Set[String]">topics</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.server;KafkaApis.getTopicMetadata.topicResponses" title="scala.collection.mutable.ListBuffer[kafka.api.TopicMetadata]">topicResponses</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">!=</span> <a href="#kafka.server;KafkaApis.getTopicMetadata.topics" title="scala.collection.Set[String]">topics</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      val nonExistentTopics = <a href="#kafka.server;KafkaApis.getTopicMetadata.topics" title="scala.collection.Set[String]">topics</a> <a title="scala.collection.Set[String]" id="kafka.server;KafkaApis.getTopicMetadata.nonExistentTopics">--</a> <a href="#kafka.server;KafkaApis.getTopicMetadata.topicResponses" title="scala.collection.mutable.ListBuffer[kafka.api.TopicMetadata]">topicResponses</a>.<span title="(f: kafka.api.TopicMetadata =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.ListBuffer[kafka.api.TopicMetadata],String,scala.collection.mutable.ListBuffer[String]])scala.collection.mutable.ListBuffer[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.mutable.ListBuffer.Coll,String,scala.collection.mutable.ListBuffer[String]]" class="delimiter">(</span><a href="#kafka.server;KafkaApis.getTopicMetadata.nonExistentTopics.$anonfun.x$18" title="kafka.api.TopicMetadata">_</a>.<a href="../api/TopicMetadata.scala.html#kafka.api;TopicMetadata.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[String]">toSet</span>
      val <a title="scala.collection.Set[kafka.api.TopicMetadata]" id="kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics">responsesForNonExistentTopics</a> = <a href="#kafka.server;KafkaApis.getTopicMetadata.nonExistentTopics" title="scala.collection.Set[String]">nonExistentTopics</a>.<span title="(f: String =&gt; kafka.api.TopicMetadata)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.Set[String],kafka.api.TopicMetadata,scala.collection.Set[kafka.api.TopicMetadata]])scala.collection.Set[kafka.api.TopicMetadata]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Set.Coll,kafka.api.TopicMetadata,scala.collection.Set[kafka.api.TopicMetadata]]" class="delimiter">{</span> <a title="String" id="kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.topic">topic</a> =&gt;
        if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.topic" title="String">topic</a> <span title="(x$1: Any)Boolean">==</span> <a href="OffsetManager.scala.html#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="OffsetManager.scala.html#kafka.server.OffsetManager.OffsetsTopicName" title="=&gt; String">OffsetsTopicName</a> <span title="(x: Boolean)Boolean">||</span> <a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.autoCreateTopicsEnable" title="=&gt; Boolean">autoCreateTopicsEnable</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          try <span class="delimiter">{</span>
            if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.topic" title="String">topic</a> <span title="(x$1: Any)Boolean">==</span> <a href="OffsetManager.scala.html#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="OffsetManager.scala.html#kafka.server.OffsetManager.OffsetsTopicName" title="=&gt; String">OffsetsTopicName</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              val <a title="Seq[kafka.cluster.Broker]" id="kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.aliveBrokers">aliveBrokers</a> = <a href="#kafka.server;KafkaApis.metadataCache_=" title="=&gt; kafka.server.MetadataCache">metadataCache</a>.<a href="MetadataCache.scala.html#kafka.server;MetadataCache.getAliveBrokers" title="=&gt; Seq[kafka.cluster.Broker]">getAliveBrokers</a>
              val <a title="Int" id="kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.offsetsTopicReplicationFactor">offsetsTopicReplicationFactor</a> =
                if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.aliveBrokers" title="Seq[kafka.cluster.Broker]">aliveBrokers</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
                  <span title="Math.type">Math</span>.<span title="(x$1: Int, x$2: Int)Int">min</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.offsetsTopicReplicationFactor" title="=&gt; Int">offsetsTopicReplicationFactor</a>, <a href="#kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.aliveBrokers" title="Seq[kafka.cluster.Broker]">aliveBrokers</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span>
                else
                  <a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.offsetsTopicReplicationFactor" title="=&gt; Int">offsetsTopicReplicationFactor</a>
              <a href="../admin/AdminUtils.scala.html#kafka.admin.AdminUtils" title="kafka.admin.AdminUtils.type">AdminUtils</a>.<a href="../admin/AdminUtils.scala.html#kafka.admin.AdminUtils.createTopic" title="(zkClient: org.I0Itec.zkclient.ZkClient, topic: String, partitions: Int, replicationFactor: Int, topicConfig: java.util.Properties)Unit">createTopic</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.zkClient" title="=&gt; org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.topic" title="String">topic</a>, <a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.offsetsTopicPartitions" title="=&gt; Int">offsetsTopicPartitions</a>,
                                     <a href="#kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.offsetsTopicReplicationFactor" title="Int">offsetsTopicReplicationFactor</a>,
                                     <a href="#kafka.server;KafkaApis.offsetManager" title="=&gt; kafka.server.OffsetManager">offsetManager</a>.<a href="OffsetManager.scala.html#kafka.server;OffsetManager.offsetsTopicConfig" title="=&gt; java.util.Properties">offsetsTopicConfig</a><span class="delimiter">)</span>
              <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Auto creation of topic %s with %d partitions and replication factor %d is successful!&quot;</span>
                .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.topic" title="String">topic</a>, <a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.offsetsTopicPartitions" title="=&gt; Int">offsetsTopicPartitions</a>, <a href="#kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.offsetsTopicReplicationFactor" title="Int">offsetsTopicReplicationFactor</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            else <span class="delimiter">{</span>
              <a href="../admin/AdminUtils.scala.html#kafka.admin.AdminUtils" title="kafka.admin.AdminUtils.type">AdminUtils</a>.<a href="../admin/AdminUtils.scala.html#kafka.admin.AdminUtils.createTopic" title="(zkClient: org.I0Itec.zkclient.ZkClient, topic: String, partitions: Int, replicationFactor: Int, topicConfig: java.util.Properties)Unit">createTopic</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.zkClient" title="=&gt; org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.topic" title="String">topic</a>, <a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.numPartitions" title="=&gt; Int">numPartitions</a>, <a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.defaultReplicationFactor" title="=&gt; Int">defaultReplicationFactor</a><span class="delimiter">)</span>
              <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Auto creation of topic %s with %d partitions and replication factor %d is successful!&quot;</span>
                   .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.topic" title="String">topic</a>, <a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.numPartitions" title="=&gt; Int">numPartitions</a>, <a href="#kafka.server;KafkaApis.config" title="=&gt; kafka.server.KafkaConfig">config</a>.<a href="KafkaConfig.scala.html#kafka.server;KafkaConfig.defaultReplicationFactor" title="=&gt; Int">defaultReplicationFactor</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span> catch <span class="delimiter">{</span>
            case <a title="kafka.common.TopicExistsException" id="kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.e">e</a>: <a href="../common/TopicExistsException.scala.html#kafka.common;TopicExistsException" title="kafka.common.TopicExistsException">TopicExistsException</a> =&gt; <span class="comment">// let it go, possibly another broker created this topic</span>
          <span class="delimiter">}</span>
          new <a href="../api/TopicMetadata.scala.html#kafka.api;TopicMetadata" title="kafka.api.TopicMetadata">TopicMetadata</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.topic" title="String">topic</a>, <span title="scala.collection.Seq.type">Seq</span>.<span title="[A]=&gt; Seq[A]">empty</span><span title="Seq[kafka.api.PartitionMetadata]" class="delimiter">[</span><a href="../api/TopicMetadata.scala.html#kafka.api;PartitionMetadata" title="kafka.api.PartitionMetadata">PartitionMetadata</a><span class="delimiter">]</span>, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.LeaderNotAvailableCode" title="=&gt; Short">LeaderNotAvailableCode</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> else <span class="delimiter">{</span>
          new <a href="../api/TopicMetadata.scala.html#kafka.api;TopicMetadata" title="kafka.api.TopicMetadata">TopicMetadata</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics.$anonfun.topic" title="String">topic</a>, <span title="scala.collection.Seq.type">Seq</span>.<span title="[A]=&gt; Seq[A]">empty</span><span title="Seq[kafka.api.PartitionMetadata]" class="delimiter">[</span><a href="../api/TopicMetadata.scala.html#kafka.api;PartitionMetadata" title="kafka.api.PartitionMetadata">PartitionMetadata</a><span class="delimiter">]</span>, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.UnknownTopicOrPartitionCode" title="=&gt; Short">UnknownTopicOrPartitionCode</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#kafka.server;KafkaApis.getTopicMetadata.topicResponses" title="scala.collection.mutable.ListBuffer[kafka.api.TopicMetadata]">topicResponses</a>.<span title="(xs: scala.collection.TraversableOnce[kafka.api.TopicMetadata])Unit">appendAll</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.getTopicMetadata.responsesForNonExistentTopics" title="scala.collection.Set[kafka.api.TopicMetadata]">responsesForNonExistentTopics</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#kafka.server;KafkaApis.getTopicMetadata.topicResponses" title="scala.collection.mutable.ListBuffer[kafka.api.TopicMetadata]">topicResponses</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Service the topic metadata request API
   */</span>
  def <a title="(request: kafka.network.RequestChannel.Request)Unit" id="kafka.server;KafkaApis.handleTopicMetadataRequest">handleTopicMetadataRequest</a><span class="delimiter">(</span><a title="kafka.network.RequestChannel.Request" id="kafka.server;KafkaApis.handleTopicMetadataRequest.request">request</a>: RequestChannel.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request" title="kafka.network.RequestChannel.Request">Request</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="kafka.api.TopicMetadataRequest" id="kafka.server;KafkaApis.handleTopicMetadataRequest.metadataRequest">metadataRequest</a> = <a href="#kafka.server;KafkaApis.handleTopicMetadataRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestObj" title="=&gt; kafka.api.RequestOrResponse">requestObj</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.api.TopicMetadataRequest" class="delimiter">[</span><a href="../api/TopicMetadataRequest.scala.html#kafka.api;TopicMetadataRequest" title="kafka.api.TopicMetadataRequest">TopicMetadataRequest</a><span class="delimiter">]</span>
    val <a title="Seq[kafka.api.TopicMetadata]" id="kafka.server;KafkaApis.handleTopicMetadataRequest.topicMetadata">topicMetadata</a> = <a href="#kafka.server;KafkaApis.getTopicMetadata" title="(topics: scala.collection.Set[String])Seq[kafka.api.TopicMetadata]">getTopicMetadata</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleTopicMetadataRequest.metadataRequest" title="kafka.api.TopicMetadataRequest">metadataRequest</a>.<a href="../api/TopicMetadataRequest.scala.html#kafka.api;TopicMetadataRequest.topics" title="=&gt; Seq[String]">topics</a>.<span title="scala.collection.immutable.Set[String]">toSet</span><span class="delimiter">)</span>
    val <a title="Seq[kafka.cluster.Broker]" id="kafka.server;KafkaApis.handleTopicMetadataRequest.brokers">brokers</a> = <a href="#kafka.server;KafkaApis.metadataCache_=" title="=&gt; kafka.server.MetadataCache">metadataCache</a>.<a href="MetadataCache.scala.html#kafka.server;MetadataCache.getAliveBrokers" title="=&gt; Seq[kafka.cluster.Broker]">getAliveBrokers</a>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Sending topic metadata %s and brokers %s for correlation id %d to client %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleTopicMetadataRequest.topicMetadata" title="Seq[kafka.api.TopicMetadata]">topicMetadata</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>, <a href="#kafka.server;KafkaApis.handleTopicMetadataRequest.brokers" title="Seq[kafka.cluster.Broker]">brokers</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>, <a href="#kafka.server;KafkaApis.handleTopicMetadataRequest.metadataRequest" title="kafka.api.TopicMetadataRequest">metadataRequest</a>.<a href="../api/TopicMetadataRequest.scala.html#kafka.api;TopicMetadataRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.handleTopicMetadataRequest.metadataRequest" title="kafka.api.TopicMetadataRequest">metadataRequest</a>.<a href="../api/TopicMetadataRequest.scala.html#kafka.api;TopicMetadataRequest.clientId" title="=&gt; String">clientId</a><span class="delimiter">)</span><span class="delimiter">)</span>
    val <a title="kafka.api.TopicMetadataResponse" id="kafka.server;KafkaApis.handleTopicMetadataRequest.response">response</a> = new <a href="../api/TopicMetadataResponse.scala.html#kafka.api;TopicMetadataResponse" title="kafka.api.TopicMetadataResponse">TopicMetadataResponse</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleTopicMetadataRequest.brokers" title="Seq[kafka.cluster.Broker]">brokers</a>, <a href="#kafka.server;KafkaApis.handleTopicMetadataRequest.topicMetadata" title="Seq[kafka.api.TopicMetadata]">topicMetadata</a>, <a href="#kafka.server;KafkaApis.handleTopicMetadataRequest.metadataRequest" title="kafka.api.TopicMetadataRequest">metadataRequest</a>.<a href="../api/TopicMetadataRequest.scala.html#kafka.api;TopicMetadataRequest.correlationId" title="=&gt; Int">correlationId</a><span class="delimiter">)</span>
    <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel.sendResponse" title="(response: kafka.network.RequestChannel.Response)Unit">sendResponse</a><span class="delimiter">(</span>new <a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel" title="kafka.network.RequestChannel.type">RequestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Response" title="kafka.network.RequestChannel.Response">Response</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleTopicMetadataRequest.request" title="kafka.network.RequestChannel.Request">request</a>, new <a href="../network/BoundedByteBufferSend.scala.html#kafka.network;BoundedByteBufferSend" title="kafka.network.BoundedByteBufferSend">BoundedByteBufferSend</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleTopicMetadataRequest.response" title="kafka.api.TopicMetadataResponse">response</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/*
   * Service the Offset fetch API
   */</span>
  def <a title="(request: kafka.network.RequestChannel.Request)Unit" id="kafka.server;KafkaApis.handleOffsetFetchRequest">handleOffsetFetchRequest</a><span class="delimiter">(</span><a title="kafka.network.RequestChannel.Request" id="kafka.server;KafkaApis.handleOffsetFetchRequest.request">request</a>: RequestChannel.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request" title="kafka.network.RequestChannel.Request">Request</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="kafka.api.OffsetFetchRequest" id="kafka.server;KafkaApis.handleOffsetFetchRequest.offsetFetchRequest">offsetFetchRequest</a> = <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestObj" title="=&gt; kafka.api.RequestOrResponse">requestObj</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.api.OffsetFetchRequest" class="delimiter">[</span><a href="../api/OffsetFetchRequest.scala.html#kafka.api;OffsetFetchRequest" title="kafka.api.OffsetFetchRequest">OffsetFetchRequest</a><span class="delimiter">]</span>

    if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.offsetFetchRequest" title="kafka.api.OffsetFetchRequest">offsetFetchRequest</a>.<a href="../api/OffsetFetchRequest.scala.html#kafka.api;OffsetFetchRequest.versionId" title="=&gt; Short">versionId</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// version 0 reads offsets from ZK</span>
      val <a title="Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]" id="kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo">responseInfo</a> = <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.offsetFetchRequest" title="kafka.api.OffsetFetchRequest">offsetFetchRequest</a>.<a href="../api/OffsetFetchRequest.scala.html#kafka.api;OffsetFetchRequest.requestInfo" title="=&gt; Seq[kafka.common.TopicAndPartition]">requestInfo</a>.<span title="(f: kafka.common.TopicAndPartition =&gt; (kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.common.TopicAndPartition],(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]])Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]]" class="delimiter">(</span> <a title="kafka.common.TopicAndPartition" id="kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.t">t</a> =&gt; <span class="delimiter">{</span>
        val <a title="kafka.utils.ZKGroupTopicDirs" id="kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.topicDirs">topicDirs</a> = new <a href="../utils/ZkUtils.scala.html#kafka.utils;ZKGroupTopicDirs" title="kafka.utils.ZKGroupTopicDirs">ZKGroupTopicDirs</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.offsetFetchRequest" title="kafka.api.OffsetFetchRequest">offsetFetchRequest</a>.<a href="../api/OffsetFetchRequest.scala.html#kafka.api;OffsetFetchRequest.groupId" title="=&gt; String">groupId</a>, <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.t" title="kafka.common.TopicAndPartition">t</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>
        try <span class="delimiter">{</span>
          <a href="#kafka.server;KafkaApis.ensureTopicExists" title="(topic: String)Unit">ensureTopicExists</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.t" title="kafka.common.TopicAndPartition">t</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>
          val <a title="Option[String]" id="kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.payloadOpt">payloadOpt</a> = <a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.readDataMaybeNull" title="(client: org.I0Itec.zkclient.ZkClient, path: String)(Option[String], org.apache.zookeeper.data.Stat)">readDataMaybeNull</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.zkClient" title="=&gt; org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.topicDirs" title="kafka.utils.ZKGroupTopicDirs">topicDirs</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils;ZKGroupTopicDirs.consumerOffsetDir" title="=&gt; String">consumerOffsetDir</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;/&quot;)" class="string">&quot;/&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.t" title="kafka.common.TopicAndPartition">t</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a><span class="delimiter">)</span>.<span title="=&gt; Option[String]">_1</span>
          <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.payloadOpt" title="Option[String]">payloadOpt</a> match <span class="delimiter">{</span>
            case Some<span class="delimiter">(</span><a title="String" id="kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.payload">payload</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
              <span title="(_1: kafka.common.TopicAndPartition, _2: kafka.common.OffsetMetadataAndError)(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.t" title="kafka.common.TopicAndPartition">t</a>, <a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetMetadataAndError.apply$default$2" title="String" id="kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.x$29">OffsetMetadataAndError</a><span class="delimiter">(</span>offset=<a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.payload" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">payload</a>.<a title="Long" id="kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.x$27">toLong</a>, error=<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="Short" id="kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.x$28">NoError</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            case <span title="None.type">None</span> =&gt; <span title="(_1: kafka.common.TopicAndPartition, _2: kafka.common.OffsetMetadataAndError)(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.t" title="kafka.common.TopicAndPartition">t</a>, <a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetMetadataAndError" title="(offset: Long, metadata: String, error: Short)kafka.common.OffsetMetadataAndError">OffsetMetadataAndError</a><span class="delimiter">(</span><a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetAndMetadata" title="kafka.common.OffsetAndMetadata.type">OffsetAndMetadata</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetAndMetadata.InvalidOffset" title="=&gt; Long">InvalidOffset</a>, <a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetAndMetadata" title="kafka.common.OffsetAndMetadata.type">OffsetAndMetadata</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetAndMetadata.NoMetadata" title="=&gt; String">NoMetadata</a>,
              <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.UnknownTopicOrPartitionCode" title="=&gt; Short">UnknownTopicOrPartitionCode</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span> catch <span class="delimiter">{</span>
          case <a title="Throwable" id="kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.e">e</a>: <span title="Throwable">Throwable</span> =&gt;
            <span title="(_1: kafka.common.TopicAndPartition, _2: kafka.common.OffsetMetadataAndError)(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.t" title="kafka.common.TopicAndPartition">t</a>, <a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetMetadataAndError" title="(offset: Long, metadata: String, error: Short)kafka.common.OffsetMetadataAndError">OffsetMetadataAndError</a><span class="delimiter">(</span><a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetAndMetadata" title="kafka.common.OffsetAndMetadata.type">OffsetAndMetadata</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetAndMetadata.InvalidOffset" title="=&gt; Long">InvalidOffset</a>, <a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetAndMetadata" title="kafka.common.OffsetAndMetadata.type">OffsetAndMetadata</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetAndMetadata.NoMetadata" title="=&gt; String">NoMetadata</a>,
              <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.codeFor" title="(exception: Class[Throwable])Short">codeFor</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo.$anonfun.e" title="Throwable">e</a>.<span title="()Class[_]">getClass</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Class[Throwable]" class="delimiter">[</span><span title="Class[Throwable]">Class</span><span class="delimiter">[</span>Throwable<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>
      val <span title="kafka.api.OffsetFetchResponse">response</span> = new <a href="../api/OffsetFetchResponse.scala.html#kafka.api;OffsetFetchResponse" title="kafka.api.OffsetFetchResponse">OffsetFetchResponse</a><span class="delimiter">(</span>collection.immutable.<span title="(elems: (kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)*)scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]">Map</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.responseInfo" title="Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]">responseInfo</a>: _*<span class="delimiter">)</span>, <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.offsetFetchRequest" title="kafka.api.OffsetFetchRequest">offsetFetchRequest</a>.<a href="../api/OffsetFetchRequest.scala.html#kafka.api;OffsetFetchRequest.correlationId" title="=&gt; Int">correlationId</a><span class="delimiter">)</span>
      <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel.sendResponse" title="(response: kafka.network.RequestChannel.Response)Unit">sendResponse</a><span class="delimiter">(</span>new <a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel" title="kafka.network.RequestChannel.type">RequestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Response" title="kafka.network.RequestChannel.Response">Response</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.request" title="kafka.network.RequestChannel.Request">request</a>, new <a href="../network/BoundedByteBufferSend.scala.html#kafka.network;BoundedByteBufferSend" title="kafka.network.BoundedByteBufferSend">BoundedByteBufferSend</a><span class="delimiter">(</span><span title="kafka.api.OffsetFetchResponse">response</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      <span class="comment">// version 1 reads offsets from Kafka</span>
      val <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.unknownTopicPartitions" title="(Seq[kafka.common.TopicAndPartition], Seq[kafka.common.TopicAndPartition])" class="delimiter">(</a><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.x$19" title="Seq[kafka.common.TopicAndPartition]" id="kafka.server;KafkaApis.handleOffsetFetchRequest.unknownTopicPartitions">unknownTopicPartitions</a>, <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.x$19" title="Seq[kafka.common.TopicAndPartition]" id="kafka.server;KafkaApis.handleOffsetFetchRequest.knownTopicPartitions">knownTopicPartitions</a><span class="delimiter">)</span> = <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.offsetFetchRequest" title="kafka.api.OffsetFetchRequest">offsetFetchRequest</a>.<a href="../api/OffsetFetchRequest.scala.html#kafka.api;OffsetFetchRequest.requestInfo" title="=&gt; Seq[kafka.common.TopicAndPartition]">requestInfo</a>.<span title="(p: kafka.common.TopicAndPartition =&gt; Boolean)(Seq[kafka.common.TopicAndPartition], Seq[kafka.common.TopicAndPartition])">partition</span><span title="(Seq[kafka.common.TopicAndPartition], Seq[kafka.common.TopicAndPartition]) @unchecked" class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;KafkaApis.handleOffsetFetchRequest.x$19.$anonfun.topicAndPartition">topicAndPartition</a> =&gt;
        <a href="#kafka.server;KafkaApis.metadataCache_=" title="=&gt; kafka.server.MetadataCache">metadataCache</a>.<a href="MetadataCache.scala.html#kafka.server;MetadataCache.getPartitionInfo" title="(topic: String, partitionId: Int)Option[kafka.api.PartitionStateInfo]">getPartitionInfo</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.x$19.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.x$19.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a><span class="delimiter">)</span>.<span title="=&gt; Boolean">isEmpty</span>
      <span class="delimiter">)</span>
      val <a title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]" id="kafka.server;KafkaApis.handleOffsetFetchRequest.unknownStatus">unknownStatus</a> = <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.unknownTopicPartitions" title="Seq[kafka.common.TopicAndPartition]">unknownTopicPartitions</a>.<span title="(f: kafka.common.TopicAndPartition =&gt; (kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.common.TopicAndPartition],(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]])Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),Seq[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)]]" class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.server;KafkaApis.handleOffsetFetchRequest.unknownStatus.$anonfun.topicAndPartition">topicAndPartition</a> =&gt; <span title="(_1: kafka.common.TopicAndPartition, _2: kafka.common.OffsetMetadataAndError)(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)" class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.unknownStatus.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetMetadataAndError" title="kafka.common.OffsetMetadataAndError.type">OffsetMetadataAndError</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetMetadataAndError.UnknownTopicOrPartition" title="=&gt; kafka.common.OffsetMetadataAndError">UnknownTopicOrPartition</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: &lt;:&lt;[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)])scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]">toMap</span>
      val <a title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]" id="kafka.server;KafkaApis.handleOffsetFetchRequest.knownStatus">knownStatus</a> =
        if <span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.knownTopicPartitions" title="Seq[kafka.common.TopicAndPartition]">knownTopicPartitions</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
          <a href="#kafka.server;KafkaApis.offsetManager" title="=&gt; kafka.server.OffsetManager">offsetManager</a>.<a href="OffsetManager.scala.html#kafka.server;OffsetManager.getOffsets" title="(group: String, topicPartitions: Seq[kafka.common.TopicAndPartition])scala.collection.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]">getOffsets</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.offsetFetchRequest" title="kafka.api.OffsetFetchRequest">offsetFetchRequest</a>.<a href="../api/OffsetFetchRequest.scala.html#kafka.api;OffsetFetchRequest.groupId" title="=&gt; String">groupId</a>, <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.knownTopicPartitions" title="Seq[kafka.common.TopicAndPartition]">knownTopicPartitions</a><span class="delimiter">)</span>.<span title="(implicit ev: &lt;:&lt;[(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError),(kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)])scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]">toMap</span>
        else
          <span title="scala.collection.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]" class="delimiter">[</span><a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a>, <a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetMetadataAndError" title="kafka.common.OffsetMetadataAndError">OffsetMetadataAndError</a><span class="delimiter">]</span>
      val status = <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.unknownStatus" title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]">unknownStatus</a> <a title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]" id="kafka.server;KafkaApis.handleOffsetFetchRequest.status">++</a> <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.knownStatus" title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]">knownStatus</a>

      val <span title="kafka.api.OffsetFetchResponse">response</span> = <a href="../api/OffsetFetchResponse.scala.html#kafka.api;OffsetFetchResponse" title="(requestInfo: Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError], correlationId: Int)kafka.api.OffsetFetchResponse">OffsetFetchResponse</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.status" title="scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]">status</a>, <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.offsetFetchRequest" title="kafka.api.OffsetFetchRequest">offsetFetchRequest</a>.<a href="../api/OffsetFetchRequest.scala.html#kafka.api;OffsetFetchRequest.correlationId" title="=&gt; Int">correlationId</a><span class="delimiter">)</span>

      <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Sending offset fetch response %s for correlation id %d to client %s.&quot;</span>
            .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><span title="kafka.api.OffsetFetchResponse">response</span>, <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.offsetFetchRequest" title="kafka.api.OffsetFetchRequest">offsetFetchRequest</a>.<a href="../api/OffsetFetchRequest.scala.html#kafka.api;OffsetFetchRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.offsetFetchRequest" title="kafka.api.OffsetFetchRequest">offsetFetchRequest</a>.<a href="../api/OffsetFetchRequest.scala.html#kafka.api;OffsetFetchRequest.clientId" title="=&gt; String">clientId</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel.sendResponse" title="(response: kafka.network.RequestChannel.Response)Unit">sendResponse</a><span class="delimiter">(</span>new <a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel" title="kafka.network.RequestChannel.type">RequestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Response" title="kafka.network.RequestChannel.Response">Response</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleOffsetFetchRequest.request" title="kafka.network.RequestChannel.Request">request</a>, new <a href="../network/BoundedByteBufferSend.scala.html#kafka.network;BoundedByteBufferSend" title="kafka.network.BoundedByteBufferSend">BoundedByteBufferSend</a><span class="delimiter">(</span><span title="kafka.api.OffsetFetchResponse">response</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/*
   * Service the consumer metadata API
   */</span>
  def <a title="(request: kafka.network.RequestChannel.Request)Unit" id="kafka.server;KafkaApis.handleConsumerMetadataRequest">handleConsumerMetadataRequest</a><span class="delimiter">(</span><a title="kafka.network.RequestChannel.Request" id="kafka.server;KafkaApis.handleConsumerMetadataRequest.request">request</a>: RequestChannel.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request" title="kafka.network.RequestChannel.Request">Request</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="kafka.api.ConsumerMetadataRequest" id="kafka.server;KafkaApis.handleConsumerMetadataRequest.consumerMetadataRequest">consumerMetadataRequest</a> = <a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.request" title="kafka.network.RequestChannel.Request">request</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Request.requestObj" title="=&gt; kafka.api.RequestOrResponse">requestObj</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.api.ConsumerMetadataRequest" class="delimiter">[</span><a href="../api/ConsumerMetadataRequest.scala.html#kafka.api;ConsumerMetadataRequest" title="kafka.api.ConsumerMetadataRequest">ConsumerMetadataRequest</a><span class="delimiter">]</span>

    val <a title="Int" id="kafka.server;KafkaApis.handleConsumerMetadataRequest.partition">partition</a> = <a href="#kafka.server;KafkaApis.offsetManager" title="=&gt; kafka.server.OffsetManager">offsetManager</a>.<a href="OffsetManager.scala.html#kafka.server;OffsetManager.partitionFor" title="(group: String)Int">partitionFor</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.consumerMetadataRequest" title="kafka.api.ConsumerMetadataRequest">consumerMetadataRequest</a>.<a href="../api/ConsumerMetadataRequest.scala.html#kafka.api;ConsumerMetadataRequest.group" title="=&gt; String">group</a><span class="delimiter">)</span>

    <span class="comment">// get metadata (and create the topic if necessary)</span>
    val <a title="kafka.api.TopicMetadata" id="kafka.server;KafkaApis.handleConsumerMetadataRequest.offsetsTopicMetadata">offsetsTopicMetadata</a> = <a href="#kafka.server;KafkaApis.getTopicMetadata" title="(topics: scala.collection.Set[String])Seq[kafka.api.TopicMetadata]">getTopicMetadata</a><span class="delimiter">(</span><span title="(elems: String*)scala.collection.Set[String]">Set</span><span class="delimiter">(</span><a href="OffsetManager.scala.html#kafka.server.OffsetManager" title="kafka.server.OffsetManager.type">OffsetManager</a>.<a href="OffsetManager.scala.html#kafka.server.OffsetManager.OffsetsTopicName" title="=&gt; String">OffsetsTopicName</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; kafka.api.TopicMetadata">head</span>

    val <a title="kafka.api.ConsumerMetadataResponse" id="kafka.server;KafkaApis.handleConsumerMetadataRequest.errorResponse">errorResponse</a> = <a href="../api/ConsumerMetadataResponse.scala.html#kafka.api;ConsumerMetadataResponse" title="(coordinatorOpt: Option[kafka.cluster.Broker], errorCode: Short, correlationId: Int)kafka.api.ConsumerMetadataResponse">ConsumerMetadataResponse</a><span class="delimiter">(</span><span title="None.type">None</span>, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.ConsumerCoordinatorNotAvailableCode" title="=&gt; Short">ConsumerCoordinatorNotAvailableCode</a>, <a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.consumerMetadataRequest" title="kafka.api.ConsumerMetadataRequest">consumerMetadataRequest</a>.<a href="../api/ConsumerMetadataRequest.scala.html#kafka.api;ConsumerMetadataRequest.correlationId" title="=&gt; Int">correlationId</a><span class="delimiter">)</span>

    val <a title="kafka.api.ConsumerMetadataResponse" id="kafka.server;KafkaApis.handleConsumerMetadataRequest.response">response</a> =
      <a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.offsetsTopicMetadata" title="kafka.api.TopicMetadata">offsetsTopicMetadata</a>.<a href="../api/TopicMetadata.scala.html#kafka.api;TopicMetadata.partitionsMetadata" title="=&gt; Seq[kafka.api.PartitionMetadata]">partitionsMetadata</a>.<span title="(p: kafka.api.PartitionMetadata =&gt; Boolean)Option[kafka.api.PartitionMetadata]">find</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.response.$anonfun.x$20" title="kafka.api.PartitionMetadata">_</a>.<a href="../api/TopicMetadata.scala.html#kafka.api;PartitionMetadata.partitionId" title="=&gt; Int">partitionId</a> <span title="(x: Int)Boolean">==</span> <a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.partition" title="Int">partition</a><span class="delimiter">)</span>.<span title="(f: kafka.api.PartitionMetadata =&gt; kafka.api.ConsumerMetadataResponse)Option[kafka.api.ConsumerMetadataResponse]">map</span> <span class="delimiter">{</span> <a title="kafka.api.PartitionMetadata" id="kafka.server;KafkaApis.handleConsumerMetadataRequest.response.$anonfun.partitionMetadata">partitionMetadata</a> =&gt;
        <a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.response.$anonfun.partitionMetadata" title="kafka.api.PartitionMetadata">partitionMetadata</a>.<a href="../api/TopicMetadata.scala.html#kafka.api;PartitionMetadata.leader" title="=&gt; Option[kafka.cluster.Broker]">leader</a>.<span title="(f: kafka.cluster.Broker =&gt; kafka.api.ConsumerMetadataResponse)Option[kafka.api.ConsumerMetadataResponse]">map</span> <span class="delimiter">{</span> <a title="kafka.cluster.Broker" id="kafka.server;KafkaApis.handleConsumerMetadataRequest.response.$anonfun.$anonfun.leader">leader</a> =&gt;
          <a href="../api/ConsumerMetadataResponse.scala.html#kafka.api;ConsumerMetadataResponse" title="(coordinatorOpt: Option[kafka.cluster.Broker], errorCode: Short, correlationId: Int)kafka.api.ConsumerMetadataResponse">ConsumerMetadataResponse</a><span class="delimiter">(</span><span title="(x: kafka.cluster.Broker)Some[kafka.cluster.Broker]">Some</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.response.$anonfun.$anonfun.leader" title="kafka.cluster.Broker">leader</a><span class="delimiter">)</span>, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a>, <a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.consumerMetadataRequest" title="kafka.api.ConsumerMetadataRequest">consumerMetadataRequest</a>.<a href="../api/ConsumerMetadataRequest.scala.html#kafka.api;ConsumerMetadataRequest.correlationId" title="=&gt; Int">correlationId</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>.<span title="(default: =&gt; kafka.api.ConsumerMetadataResponse)kafka.api.ConsumerMetadataResponse">getOrElse</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.errorResponse" title="kafka.api.ConsumerMetadataResponse">errorResponse</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>.<span title="(default: =&gt; kafka.api.ConsumerMetadataResponse)kafka.api.ConsumerMetadataResponse">getOrElse</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.errorResponse" title="kafka.api.ConsumerMetadataResponse">errorResponse</a><span class="delimiter">)</span>

    <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Sending consumer metadata %s for correlation id %d to client %s.&quot;</span>
          .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.response" title="kafka.api.ConsumerMetadataResponse">response</a>, <a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.consumerMetadataRequest" title="kafka.api.ConsumerMetadataRequest">consumerMetadataRequest</a>.<a href="../api/ConsumerMetadataRequest.scala.html#kafka.api;ConsumerMetadataRequest.correlationId" title="=&gt; Int">correlationId</a>, <a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.consumerMetadataRequest" title="kafka.api.ConsumerMetadataRequest">consumerMetadataRequest</a>.<a href="../api/ConsumerMetadataRequest.scala.html#kafka.api;ConsumerMetadataRequest.clientId" title="=&gt; String">clientId</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.server;KafkaApis.requestChannel" title="=&gt; kafka.network.RequestChannel">requestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network;RequestChannel.sendResponse" title="(response: kafka.network.RequestChannel.Response)Unit">sendResponse</a><span class="delimiter">(</span>new <a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel" title="kafka.network.RequestChannel.type">RequestChannel</a>.<a href="../network/RequestChannel.scala.html#kafka.network.RequestChannel;Response" title="kafka.network.RequestChannel.Response">Response</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.request" title="kafka.network.RequestChannel.Request">request</a>, new <a href="../network/BoundedByteBufferSend.scala.html#kafka.network;BoundedByteBufferSend" title="kafka.network.BoundedByteBufferSend">BoundedByteBufferSend</a><span class="delimiter">(</span><a href="#kafka.server;KafkaApis.handleConsumerMetadataRequest.response" title="kafka.api.ConsumerMetadataResponse">response</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="()Unit" id="kafka.server;KafkaApis.close">close</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Shutting down.&quot;)" class="string">&quot;Shutting down.&quot;</span><span class="delimiter">)</span>
    <a href="#kafka.server;KafkaApis.fetchRequestPurgatory" title="=&gt; kafka.server.FetchRequestPurgatory">fetchRequestPurgatory</a>.<a href="RequestPurgatory.scala.html#kafka.server;RequestPurgatory.shutdown" title="()Unit">shutdown</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#kafka.server;KafkaApis.producerRequestPurgatory" title="=&gt; kafka.server.ProducerRequestPurgatory">producerRequestPurgatory</a>.<a href="RequestPurgatory.scala.html#kafka.server;RequestPurgatory.shutdown" title="()Unit">shutdown</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Shut down complete.&quot;)" class="string">&quot;Shut down complete.&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>
