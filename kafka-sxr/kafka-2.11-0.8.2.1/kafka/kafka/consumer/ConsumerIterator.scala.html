<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/consumer/ConsumerIterator.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package kafka.consumer

import kafka.utils.<span class="delimiter">{</span>IteratorTemplate, Logging, Utils<span class="delimiter">}</span>
import java.util.concurrent.<span class="delimiter">{</span>TimeUnit, BlockingQueue<span class="delimiter">}</span>
import kafka.serializer.Decoder
import java.util.concurrent.atomic.AtomicReference
import kafka.message.<span class="delimiter">{</span>MessageAndOffset, MessageAndMetadata<span class="delimiter">}</span>
import kafka.common.<span class="delimiter">{</span>KafkaException, MessageSizeTooLargeException<span class="delimiter">}</span>


<span class="comment">/**
 * An iterator that blocks until a value can be read from the supplied queue.
 * The iterator takes a shutdownCommand object which can be added to the queue to trigger a shutdown
 *
 */</span>
class <a title="class ConsumerIterator[K, V] extends kafka.utils.IteratorTemplate[kafka.message.MessageAndMetadata[K,V]] with kafka.utils.Logging" id="kafka.consumer;ConsumerIterator">ConsumerIterator</a><span class="delimiter">[</span><a title="" id="kafka.consumer;ConsumerIterator;K">K</a>, <a title="" id="kafka.consumer;ConsumerIterator;V">V</a><span class="delimiter">]</span><a href="#kafka.consumer;ConsumerIterator" title="kafka.consumer.ConsumerIterator[K,V]" class="delimiter">(</a>private val <a title="java.util.concurrent.BlockingQueue[kafka.consumer.FetchedDataChunk]" id="kafka.consumer;ConsumerIterator.channel">channel</a>: <span title="java.util.concurrent.BlockingQueue[kafka.consumer.FetchedDataChunk]">BlockingQueue</span><span class="delimiter">[</span>FetchedDataChunk<span class="delimiter">]</span>,
                             <a title="Int" id="kafka.consumer;ConsumerIterator.consumerTimeoutMs">consumerTimeoutMs</a>: <span title="Int">Int</span>,
                             private val <a title="kafka.serializer.Decoder[K]" id="kafka.consumer;ConsumerIterator.keyDecoder">keyDecoder</a>: <a href="../serializer/Decoder.scala.html#kafka.serializer;Decoder" title="kafka.serializer.Decoder[K]">Decoder</a><span class="delimiter">[</span>K<span class="delimiter">]</span>,
                             private val <a title="kafka.serializer.Decoder[V]" id="kafka.consumer;ConsumerIterator.valueDecoder">valueDecoder</a>: <a href="../serializer/Decoder.scala.html#kafka.serializer;Decoder" title="kafka.serializer.Decoder[V]">Decoder</a><span class="delimiter">[</span>V<span class="delimiter">]</span>,
                             val <a title="String" id="kafka.consumer;ConsumerIterator.clientId">clientId</a>: <span title="String">String</span><span class="delimiter">)</span>
  extends <a href="../utils/IteratorTemplate.scala.html#kafka.utils;IteratorTemplate" title="kafka.utils.IteratorTemplate[kafka.message.MessageAndMetadata[K,V]]">IteratorTemplate</a><span class="delimiter">[</span>MessageAndMetadata<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> with <a href="../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> <span class="delimiter">{</span>

  private var <a title="java.util.concurrent.atomic.AtomicReference[Iterator[kafka.message.MessageAndOffset]]" id="kafka.consumer;ConsumerIterator.current_=">current</a>: <span title="java.util.concurrent.atomic.AtomicReference[Iterator[kafka.message.MessageAndOffset]]">AtomicReference</span><span class="delimiter">[</span>Iterator<span class="delimiter">[</span>MessageAndOffset<span class="delimiter">]</span><span class="delimiter">]</span> = new <span title="java.util.concurrent.atomic.AtomicReference[Iterator[kafka.message.MessageAndOffset]]">AtomicReference</span><span class="delimiter">(</span>null<span class="delimiter">)</span>
  private var <a title="kafka.consumer.PartitionTopicInfo" id="kafka.consumer;ConsumerIterator.currentTopicInfo_=">currentTopicInfo</a>: <a href="PartitionTopicInfo.scala.html#kafka.consumer;PartitionTopicInfo" title="kafka.consumer.PartitionTopicInfo">PartitionTopicInfo</a> = null
  private var <a title="Long" id="kafka.consumer;ConsumerIterator.consumedOffset_=">consumedOffset</a>: <span title="Long">Long</span> = -<span title="Long(-1L)" class="long">1L</span>
  private val <a title="kafka.consumer.ConsumerTopicStats" id="kafka.consumer;ConsumerIterator.consumerTopicStats">consumerTopicStats</a> = <a href="ConsumerTopicStats.scala.html#kafka.consumer.ConsumerTopicStatsRegistry" title="kafka.consumer.ConsumerTopicStatsRegistry.type">ConsumerTopicStatsRegistry</a>.<a href="ConsumerTopicStats.scala.html#kafka.consumer.ConsumerTopicStatsRegistry.getConsumerTopicStat" title="(clientId: String)kafka.consumer.ConsumerTopicStats">getConsumerTopicStat</a><span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.clientId" title="=&gt; String">clientId</a><span class="delimiter">)</span>

  override def <a title="()kafka.message.MessageAndMetadata[K,V]" id="kafka.consumer;ConsumerIterator.next">next</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../message/MessageAndMetadata.scala.html#kafka.message;MessageAndMetadata" title="kafka.message.MessageAndMetadata[K,V]">MessageAndMetadata</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="kafka.message.MessageAndMetadata[K,V]" id="kafka.consumer;ConsumerIterator.next.item">item</a> = super.<a href="../utils/IteratorTemplate.scala.html#kafka.utils;IteratorTemplate.next" title="()kafka.message.MessageAndMetadata[K,V]">next</a><span class="delimiter">(</span><span class="delimiter">)</span>
    if<span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.consumedOffset_=" title="=&gt; Long">consumedOffset</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      throw new <a href="../common/KafkaException.scala.html#kafka.common;KafkaException" title="kafka.common.KafkaException">KafkaException</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Offset returned by the message set is invalid %d&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.consumedOffset_=" title="=&gt; Long">consumedOffset</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.consumer;ConsumerIterator.currentTopicInfo_=" title="=&gt; kafka.consumer.PartitionTopicInfo">currentTopicInfo</a>.<a href="PartitionTopicInfo.scala.html#kafka.consumer;PartitionTopicInfo.resetConsumeOffset" title="(newConsumeOffset: Long)Unit">resetConsumeOffset</a><span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.consumedOffset_=" title="=&gt; Long">consumedOffset</a><span class="delimiter">)</span>
    val <a title="String" id="kafka.consumer;ConsumerIterator.next.topic">topic</a> = <a href="#kafka.consumer;ConsumerIterator.currentTopicInfo_=" title="=&gt; kafka.consumer.PartitionTopicInfo">currentTopicInfo</a>.<a href="PartitionTopicInfo.scala.html#kafka.consumer;PartitionTopicInfo.topic" title="=&gt; String">topic</a>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.trace(1729dbc42f)" title="(msg: =&gt; String)Unit">trace</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Setting %s consumed offset to %d&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.next.topic" title="String">topic</a>, <a href="#kafka.consumer;ConsumerIterator.consumedOffset_=" title="=&gt; Long">consumedOffset</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#kafka.consumer;ConsumerIterator.consumerTopicStats" title="=&gt; kafka.consumer.ConsumerTopicStats">consumerTopicStats</a>.<a href="ConsumerTopicStats.scala.html#kafka.consumer;ConsumerTopicStats.getConsumerTopicStats" title="(topic: String)kafka.consumer.ConsumerTopicMetrics">getConsumerTopicStats</a><span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.next.topic" title="String">topic</a><span class="delimiter">)</span>.<a href="ConsumerTopicStats.scala.html#kafka.consumer;ConsumerTopicMetrics.messageRate" title="=&gt; com.yammer.metrics.core.Meter">messageRate</a>.<span title="()Unit">mark</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#kafka.consumer;ConsumerIterator.consumerTopicStats" title="=&gt; kafka.consumer.ConsumerTopicStats">consumerTopicStats</a>.<a href="ConsumerTopicStats.scala.html#kafka.consumer;ConsumerTopicStats.getConsumerAllTopicStats" title="()kafka.consumer.ConsumerTopicMetrics">getConsumerAllTopicStats</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="ConsumerTopicStats.scala.html#kafka.consumer;ConsumerTopicMetrics.messageRate" title="=&gt; com.yammer.metrics.core.Meter">messageRate</a>.<span title="()Unit">mark</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#kafka.consumer;ConsumerIterator.next.item" title="kafka.message.MessageAndMetadata[K,V]">item</a>
  <span class="delimiter">}</span>

  protected def <a title="()kafka.message.MessageAndMetadata[K,V]" id="kafka.consumer;ConsumerIterator.makeNext">makeNext</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../message/MessageAndMetadata.scala.html#kafka.message;MessageAndMetadata" title="kafka.message.MessageAndMetadata[K,V]">MessageAndMetadata</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span class="delimiter">{</span>
    var <a title="kafka.consumer.FetchedDataChunk" id="kafka.consumer;ConsumerIterator.makeNext.currentDataChunk">currentDataChunk</a>: <a href="FetchedDataChunk.scala.html#kafka.consumer;FetchedDataChunk" title="kafka.consumer.FetchedDataChunk">FetchedDataChunk</a> = null
    <span class="comment">// if we don't have an iterator, get one</span>
    var <a title="Iterator[kafka.message.MessageAndOffset]" id="kafka.consumer;ConsumerIterator.makeNext.localCurrent">localCurrent</a> = <a href="#kafka.consumer;ConsumerIterator.current_=" title="=&gt; java.util.concurrent.atomic.AtomicReference[Iterator[kafka.message.MessageAndOffset]]">current</a>.<span title="()Iterator[kafka.message.MessageAndOffset]">get</span><span class="delimiter">(</span><span class="delimiter">)</span>
    if<span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.makeNext.localCurrent" title="Iterator[kafka.message.MessageAndOffset]">localCurrent</a> <span title="(x$1: Any)Boolean">==</span> null <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#kafka.consumer;ConsumerIterator.makeNext.localCurrent" title="Iterator[kafka.message.MessageAndOffset]">localCurrent</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.consumerTimeoutMs" title="Int">consumerTimeoutMs</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
        <a href="#kafka.consumer;ConsumerIterator.makeNext.currentDataChunk" title="kafka.consumer.FetchedDataChunk">currentDataChunk</a> = <a href="#kafka.consumer;ConsumerIterator.channel" title="=&gt; java.util.concurrent.BlockingQueue[kafka.consumer.FetchedDataChunk]">channel</a>.<span title="()kafka.consumer.FetchedDataChunk">take</span>
      else <span class="delimiter">{</span>
        <a href="#kafka.consumer;ConsumerIterator.makeNext.currentDataChunk" title="kafka.consumer.FetchedDataChunk">currentDataChunk</a> = <a href="#kafka.consumer;ConsumerIterator.channel" title="=&gt; java.util.concurrent.BlockingQueue[kafka.consumer.FetchedDataChunk]">channel</a>.<span title="(x$1: Long, x$2: java.util.concurrent.TimeUnit)kafka.consumer.FetchedDataChunk">poll</span><span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.consumerTimeoutMs" title="=&gt; Long">consumerTimeoutMs</a>, TimeUnit.<span title="java.util.concurrent.TimeUnit(MILLISECONDS)">MILLISECONDS</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.makeNext.currentDataChunk" title="kafka.consumer.FetchedDataChunk">currentDataChunk</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="comment">// reset state to make the iterator re-iterable</span>
          <a href="../utils/IteratorTemplate.scala.html#kafka.utils;IteratorTemplate.resetState" title="()Unit">resetState</a><span class="delimiter">(</span><span class="delimiter">)</span>
          throw new <a href="#kafka.consumer;ConsumerTimeoutException" title="kafka.consumer.ConsumerTimeoutException">ConsumerTimeoutException</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      if<span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.makeNext.currentDataChunk" title="kafka.consumer.FetchedDataChunk">currentDataChunk</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="ZookeeperConsumerConnector.scala.html#kafka.consumer.ZookeeperConsumerConnector" title="kafka.consumer.ZookeeperConsumerConnector.type">ZookeeperConsumerConnector</a>.<a href="ZookeeperConsumerConnector.scala.html#kafka.consumer.ZookeeperConsumerConnector.shutdownCommand" title="=&gt; kafka.consumer.FetchedDataChunk">shutdownCommand</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Received the shutdown command&quot;)" class="string">&quot;Received the shutdown command&quot;</span><span class="delimiter">)</span>
        return <a href="../utils/IteratorTemplate.scala.html#kafka.utils;IteratorTemplate.allDone" title="()kafka.message.MessageAndMetadata[K,V]">allDone</a>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        <a href="#kafka.consumer;ConsumerIterator.currentTopicInfo_=" title="(x$1: kafka.consumer.PartitionTopicInfo)Unit">currentTopicInfo</a> = <a href="#kafka.consumer;ConsumerIterator.makeNext.currentDataChunk" title="kafka.consumer.FetchedDataChunk">currentDataChunk</a>.<a href="FetchedDataChunk.scala.html#kafka.consumer;FetchedDataChunk.topicInfo" title="=&gt; kafka.consumer.PartitionTopicInfo">topicInfo</a>
        val <a title="Long" id="kafka.consumer;ConsumerIterator.makeNext.cdcFetchOffset">cdcFetchOffset</a> = <a href="#kafka.consumer;ConsumerIterator.makeNext.currentDataChunk" title="kafka.consumer.FetchedDataChunk">currentDataChunk</a>.<a href="FetchedDataChunk.scala.html#kafka.consumer;FetchedDataChunk.fetchOffset" title="=&gt; Long">fetchOffset</a>
        val <a title="Long" id="kafka.consumer;ConsumerIterator.makeNext.ctiConsumeOffset">ctiConsumeOffset</a> = <a href="#kafka.consumer;ConsumerIterator.currentTopicInfo_=" title="=&gt; kafka.consumer.PartitionTopicInfo">currentTopicInfo</a>.<a href="PartitionTopicInfo.scala.html#kafka.consumer;PartitionTopicInfo.getConsumeOffset" title="()Long">getConsumeOffset</a>
        if <span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.makeNext.ctiConsumeOffset" title="Long">ctiConsumeOffset</a> <span title="(x: Long)Boolean">&lt;</span> <a href="#kafka.consumer;ConsumerIterator.makeNext.cdcFetchOffset" title="Long">cdcFetchOffset</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.error(1729dbc42f)" title="(msg: =&gt; String)Unit">error</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;consumed offset: %d doesn't match fetch offset: %d for %s;\n Consumer may lose data&quot;</span>
            .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.makeNext.ctiConsumeOffset" title="Long">ctiConsumeOffset</a>, <a href="#kafka.consumer;ConsumerIterator.makeNext.cdcFetchOffset" title="Long">cdcFetchOffset</a>, <a href="#kafka.consumer;ConsumerIterator.currentTopicInfo_=" title="=&gt; kafka.consumer.PartitionTopicInfo">currentTopicInfo</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#kafka.consumer;ConsumerIterator.currentTopicInfo_=" title="=&gt; kafka.consumer.PartitionTopicInfo">currentTopicInfo</a>.<a href="PartitionTopicInfo.scala.html#kafka.consumer;PartitionTopicInfo.resetConsumeOffset" title="(newConsumeOffset: Long)Unit">resetConsumeOffset</a><span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.makeNext.cdcFetchOffset" title="Long">cdcFetchOffset</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#kafka.consumer;ConsumerIterator.makeNext.localCurrent" title="Iterator[kafka.message.MessageAndOffset]">localCurrent</a> = <a href="#kafka.consumer;ConsumerIterator.makeNext.currentDataChunk" title="kafka.consumer.FetchedDataChunk">currentDataChunk</a>.<a href="FetchedDataChunk.scala.html#kafka.consumer;FetchedDataChunk.messages" title="=&gt; kafka.message.ByteBufferMessageSet">messages</a>.<a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet.iterator" title="=&gt; Iterator[kafka.message.MessageAndOffset]">iterator</a>

        <a href="#kafka.consumer;ConsumerIterator.current_=" title="=&gt; java.util.concurrent.atomic.AtomicReference[Iterator[kafka.message.MessageAndOffset]]">current</a>.<span title="(x$1: Iterator[kafka.message.MessageAndOffset])Unit">set</span><span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.makeNext.localCurrent" title="Iterator[kafka.message.MessageAndOffset]">localCurrent</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="comment">// if we just updated the current chunk and it is empty that means the fetch size is too small!</span>
      if<span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.makeNext.currentDataChunk" title="kafka.consumer.FetchedDataChunk">currentDataChunk</a>.<a href="FetchedDataChunk.scala.html#kafka.consumer;FetchedDataChunk.messages" title="=&gt; kafka.message.ByteBufferMessageSet">messages</a>.<a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet.validBytes" title="=&gt; Int">validBytes</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
        throw new <a href="../common/MessageSizeTooLargeException.scala.html#kafka.common;MessageSizeTooLargeException" title="kafka.common.MessageSizeTooLargeException">MessageSizeTooLargeException</a><span class="delimiter">(</span><span title="String(&quot;Found a message larger than the maximum fetch size of this consumer on topic &quot;)" class="string">&quot;Found a message larger than the maximum fetch size of this consumer on topic &quot;</span> <span title="(x$1: Any)String">+</span>
                                               <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%s partition %d at fetch offset %d. Increase the fetch size, or decrease the maximum message size the broker will allow.&quot;</span>
                                               .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.makeNext.currentDataChunk" title="kafka.consumer.FetchedDataChunk">currentDataChunk</a>.<a href="FetchedDataChunk.scala.html#kafka.consumer;FetchedDataChunk.topicInfo" title="=&gt; kafka.consumer.PartitionTopicInfo">topicInfo</a>.<a href="PartitionTopicInfo.scala.html#kafka.consumer;PartitionTopicInfo.topic" title="=&gt; String">topic</a>, <a href="#kafka.consumer;ConsumerIterator.makeNext.currentDataChunk" title="kafka.consumer.FetchedDataChunk">currentDataChunk</a>.<a href="FetchedDataChunk.scala.html#kafka.consumer;FetchedDataChunk.topicInfo" title="=&gt; kafka.consumer.PartitionTopicInfo">topicInfo</a>.<a href="PartitionTopicInfo.scala.html#kafka.consumer;PartitionTopicInfo.partitionId" title="=&gt; Int">partitionId</a>, <a href="#kafka.consumer;ConsumerIterator.makeNext.currentDataChunk" title="kafka.consumer.FetchedDataChunk">currentDataChunk</a>.<a href="FetchedDataChunk.scala.html#kafka.consumer;FetchedDataChunk.fetchOffset" title="=&gt; Long">fetchOffset</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    var <a title="kafka.message.MessageAndOffset" id="kafka.consumer;ConsumerIterator.makeNext.item">item</a> = <a href="#kafka.consumer;ConsumerIterator.makeNext.localCurrent" title="Iterator[kafka.message.MessageAndOffset]">localCurrent</a>.<span title="()kafka.message.MessageAndOffset">next</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="comment">// reject the messages that have already been consumed</span>
    while <span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.makeNext.item" title="kafka.message.MessageAndOffset">item</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.offset" title="=&gt; Long">offset</a> <span title="(x: Long)Boolean">&lt;</span> <a href="#kafka.consumer;ConsumerIterator.currentTopicInfo_=" title="=&gt; kafka.consumer.PartitionTopicInfo">currentTopicInfo</a>.<a href="PartitionTopicInfo.scala.html#kafka.consumer;PartitionTopicInfo.getConsumeOffset" title="()Long">getConsumeOffset</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.consumer;ConsumerIterator.makeNext.localCurrent" title="Iterator[kafka.message.MessageAndOffset]">localCurrent</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.consumer;ConsumerIterator.makeNext.item" title="kafka.message.MessageAndOffset">item</a> = <a href="#kafka.consumer;ConsumerIterator.makeNext.localCurrent" title="Iterator[kafka.message.MessageAndOffset]">localCurrent</a>.<span title="()kafka.message.MessageAndOffset">next</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#kafka.consumer;ConsumerIterator.consumedOffset_=" title="(x$1: Long)Unit">consumedOffset</a> = <a href="#kafka.consumer;ConsumerIterator.makeNext.item" title="kafka.message.MessageAndOffset">item</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.nextOffset" title="=&gt; Long">nextOffset</a>

    <a href="#kafka.consumer;ConsumerIterator.makeNext.item" title="kafka.message.MessageAndOffset">item</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a>.<a href="../message/Message.scala.html#kafka.message;Message.ensureValid" title="()Unit">ensureValid</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="comment">// validate checksum of message to ensure it is valid</span>

    new <a href="../message/MessageAndMetadata.scala.html#kafka.message;MessageAndMetadata" title="kafka.message.MessageAndMetadata[K,V]">MessageAndMetadata</a><span class="delimiter">(</span><a href="#kafka.consumer;ConsumerIterator.currentTopicInfo_=" title="=&gt; kafka.consumer.PartitionTopicInfo">currentTopicInfo</a>.<a href="PartitionTopicInfo.scala.html#kafka.consumer;PartitionTopicInfo.topic" title="=&gt; String">topic</a>, <a href="#kafka.consumer;ConsumerIterator.currentTopicInfo_=" title="=&gt; kafka.consumer.PartitionTopicInfo">currentTopicInfo</a>.<a href="PartitionTopicInfo.scala.html#kafka.consumer;PartitionTopicInfo.partitionId" title="=&gt; Int">partitionId</a>, <a href="#kafka.consumer;ConsumerIterator.makeNext.item" title="kafka.message.MessageAndOffset">item</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a>, <a href="#kafka.consumer;ConsumerIterator.makeNext.item" title="kafka.message.MessageAndOffset">item</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.offset" title="=&gt; Long">offset</a>, <a href="#kafka.consumer;ConsumerIterator.keyDecoder" title="=&gt; kafka.serializer.Decoder[K]">keyDecoder</a>, <a href="#kafka.consumer;ConsumerIterator.valueDecoder" title="=&gt; kafka.serializer.Decoder[V]">valueDecoder</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="()Unit" id="kafka.consumer;ConsumerIterator.clearCurrentChunk">clearCurrentChunk</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    try <span class="delimiter">{</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Clearing the current data chunk for this consumer iterator&quot;)" class="string">&quot;Clearing the current data chunk for this consumer iterator&quot;</span><span class="delimiter">)</span>
      <a href="#kafka.consumer;ConsumerIterator.current_=" title="=&gt; java.util.concurrent.atomic.AtomicReference[Iterator[kafka.message.MessageAndOffset]]">current</a>.<span title="(x$1: Iterator[kafka.message.MessageAndOffset])Unit">set</span><span class="delimiter">(</span>null<span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

class <a title="class ConsumerTimeoutException extends RuntimeException" id="kafka.consumer;ConsumerTimeoutException">ConsumerTimeoutException</a><a href="#kafka.consumer;ConsumerTimeoutException" title="kafka.consumer.ConsumerTimeoutException" class="delimiter">(</a><span class="delimiter">)</span> extends <a href="#kafka.consumer;ConsumerTimeoutException" title="RuntimeException">RuntimeException</a><span class="delimiter">(</span><span class="delimiter">)</span>


        </pre>
    </body>
</html>
