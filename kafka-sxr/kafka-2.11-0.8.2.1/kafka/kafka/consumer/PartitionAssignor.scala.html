<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/consumer/PartitionAssignor.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package kafka.consumer

import org.I0Itec.zkclient.ZkClient
import kafka.common.TopicAndPartition
import kafka.utils.<span class="delimiter">{</span>Utils, ZkUtils, Logging<span class="delimiter">}</span>

trait <a title="trait PartitionAssignor extends AnyRef" id="kafka.consumer;PartitionAssignor">PartitionAssignor</a> <span class="delimiter">{</span>

  <span class="comment">/**
   * Assigns partitions to consumer instances in a group.
   * @return An assignment map of partition to consumer thread. This only includes assignments for threads that belong
   *         to the given assignment-context's consumer.
   */</span>
  def <a title="(ctx: kafka.consumer.AssignmentContext)scala.collection.Map[kafka.common.TopicAndPartition,kafka.consumer.ConsumerThreadId]" id="kafka.consumer;PartitionAssignor.assign">assign</a><span class="delimiter">(</span><a title="kafka.consumer.AssignmentContext" id="kafka.consumer;PartitionAssignor.assign.ctx">ctx</a>: <a href="#kafka.consumer;AssignmentContext" title="kafka.consumer.AssignmentContext">AssignmentContext</a><span class="delimiter">)</span>: scala.collection.<span title="scala.collection.Map[kafka.common.TopicAndPartition,kafka.consumer.ConsumerThreadId]">Map</span><span class="delimiter">[</span>TopicAndPartition, ConsumerThreadId<span class="delimiter">]</span>

<span class="delimiter">}</span>

object <a title="kafka.consumer.PartitionAssignor.type" id="kafka.consumer.PartitionAssignor">PartitionAssignor</a> <a href="#kafka.consumer.PartitionAssignor" title="kafka.consumer.PartitionAssignor.type" class="delimiter">{</a>
  def <a title="(assignmentStrategy: String)kafka.consumer.PartitionAssignor with kafka.utils.Logging{def assign(ctx: kafka.consumer.AssignmentContext): scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.consumer.ConsumerThreadId]}" id="kafka.consumer.PartitionAssignor.createInstance">createInstance</a><span class="delimiter">(</span><a title="String" id="kafka.consumer.PartitionAssignor.createInstance.assignmentStrategy">assignmentStrategy</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#kafka.consumer.PartitionAssignor.createInstance.assignmentStrategy" title="String">assignmentStrategy</a> match <span class="delimiter">{</span>
    case <span title="String(&quot;roundrobin&quot;)" class="string">&quot;roundrobin&quot;</span> =&gt; new <a href="#kafka.consumer;RoundRobinAssignor" title="kafka.consumer.RoundRobinAssignor">RoundRobinAssignor</a><span class="delimiter">(</span><span class="delimiter">)</span>
    case _ =&gt; new <a href="#kafka.consumer;RangeAssignor" title="kafka.consumer.RangeAssignor">RangeAssignor</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

class <a title="class AssignmentContext extends AnyRef" id="kafka.consumer;AssignmentContext">AssignmentContext</a><a href="#kafka.consumer;AssignmentContext" title="kafka.consumer.AssignmentContext" class="delimiter">(</a><a title="String" id="kafka.consumer;AssignmentContext.group">group</a>: <span title="String">String</span>, val <a title="String" id="kafka.consumer;AssignmentContext.consumerId">consumerId</a>: <span title="String">String</span>, <a title="Boolean" id="kafka.consumer;AssignmentContext.excludeInternalTopics">excludeInternalTopics</a>: <span title="Boolean">Boolean</span>, <a title="org.I0Itec.zkclient.ZkClient" id="kafka.consumer;AssignmentContext.zkClient">zkClient</a>: <span title="org.I0Itec.zkclient.ZkClient">ZkClient</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  val <a title="scala.collection.Map[String,scala.collection.Set[kafka.consumer.ConsumerThreadId]]" id="kafka.consumer;AssignmentContext.myTopicThreadIds">myTopicThreadIds</a>: collection.<span title="scala.collection.Map[String,scala.collection.Set[kafka.consumer.ConsumerThreadId]]">Map</span><span class="delimiter">[</span>String, collection.Set<span class="delimiter">[</span>ConsumerThreadId<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="kafka.consumer.TopicCount" id="kafka.consumer;AssignmentContext.myTopicThreadIds.myTopicCount">myTopicCount</a> = <a href="TopicCount.scala.html#kafka.consumer.TopicCount" title="kafka.consumer.TopicCount.type">TopicCount</a>.<a href="TopicCount.scala.html#kafka.consumer.TopicCount.constructTopicCount(14f9b37225)" title="(group: String, consumerId: String, zkClient: org.I0Itec.zkclient.ZkClient, excludeInternalTopics: Boolean)kafka.consumer.TopicCount">constructTopicCount</a><span class="delimiter">(</span><a href="#kafka.consumer;AssignmentContext.group" title="String">group</a>, <a href="#kafka.consumer;AssignmentContext.consumerId" title="=&gt; String">consumerId</a>, <a href="#kafka.consumer;AssignmentContext.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.consumer;AssignmentContext.excludeInternalTopics" title="Boolean">excludeInternalTopics</a><span class="delimiter">)</span>
    <a href="#kafka.consumer;AssignmentContext.myTopicThreadIds.myTopicCount" title="kafka.consumer.TopicCount">myTopicCount</a>.<a href="TopicCount.scala.html#kafka.consumer;TopicCount.getConsumerThreadIdsPerTopic" title="=&gt; scala.collection.Map[String,scala.collection.Set[kafka.consumer.ConsumerThreadId]]">getConsumerThreadIdsPerTopic</a>
  <span class="delimiter">}</span>

  val <a title="scala.collection.Map[String,Seq[Int]]" id="kafka.consumer;AssignmentContext.partitionsForTopic">partitionsForTopic</a>: collection.<span title="scala.collection.Map[String,Seq[Int]]">Map</span><span class="delimiter">[</span>String, Seq<span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.getPartitionsForTopics" title="(zkClient: org.I0Itec.zkclient.ZkClient, topics: Seq[String])scala.collection.mutable.Map[String,Seq[Int]]">getPartitionsForTopics</a><span class="delimiter">(</span><a href="#kafka.consumer;AssignmentContext.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.consumer;AssignmentContext.myTopicThreadIds" title="=&gt; scala.collection.Map[String,scala.collection.Set[kafka.consumer.ConsumerThreadId]]">myTopicThreadIds</a>.<span title="=&gt; scala.collection.Set[String]">keySet</span>.<span title="=&gt; Seq[String]">toSeq</span><span class="delimiter">)</span>

  val <a title="scala.collection.Map[String,List[kafka.consumer.ConsumerThreadId]]" id="kafka.consumer;AssignmentContext.consumersForTopic">consumersForTopic</a>: collection.<span title="scala.collection.Map[String,List[kafka.consumer.ConsumerThreadId]]">Map</span><span class="delimiter">[</span>String, List<span class="delimiter">[</span>ConsumerThreadId<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.getConsumersPerTopic" title="(zkClient: org.I0Itec.zkclient.ZkClient, group: String, excludeInternalTopics: Boolean)scala.collection.mutable.Map[String,List[kafka.consumer.ConsumerThreadId]]">getConsumersPerTopic</a><span class="delimiter">(</span><a href="#kafka.consumer;AssignmentContext.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.consumer;AssignmentContext.group" title="String">group</a>, <a href="#kafka.consumer;AssignmentContext.excludeInternalTopics" title="Boolean">excludeInternalTopics</a><span class="delimiter">)</span>

  val <a title="Seq[String]" id="kafka.consumer;AssignmentContext.consumers">consumers</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.getConsumersInGroup" title="(zkClient: org.I0Itec.zkclient.ZkClient, group: String)Seq[String]">getConsumersInGroup</a><span class="delimiter">(</span><a href="#kafka.consumer;AssignmentContext.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.consumer;AssignmentContext.group" title="String">group</a><span class="delimiter">)</span>.<span title="(implicit ord: scala.math.Ordering[String])Seq[String]">sorted</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * The round-robin partition assignor lays out all the available partitions and all the available consumer threads. It
 * then proceeds to do a round-robin assignment from partition to consumer thread. If the subscriptions of all consumer
 * instances are identical, then the partitions will be uniformly distributed. (i.e., the partition ownership counts
 * will be within a delta of exactly one across all consumer threads.)
 *
 * (For simplicity of implementation) the assignor is allowed to assign a given topic-partition to any consumer instance
 * and thread-id within that instance. Therefore, round-robin assignment is allowed only if:
 * a) Every topic has the same number of streams within a consumer instance
 * b) The set of subscribed topics is identical for every consumer instance within the group.
 */</span>

class <a title="class RoundRobinAssignor extends AnyRef with kafka.consumer.PartitionAssignor with kafka.utils.Logging" id="kafka.consumer;RoundRobinAssignor">RoundRobinAssignor</a><a href="#kafka.consumer;RoundRobinAssignor" title="kafka.consumer.RoundRobinAssignor" class="delimiter">(</a><span class="delimiter">)</span> extends <a href="#kafka.consumer;PartitionAssignor" title="kafka.consumer.PartitionAssignor">PartitionAssignor</a> with <a href="../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> <span class="delimiter">{</span>

  def <a title="(ctx: kafka.consumer.AssignmentContext)scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.consumer.ConsumerThreadId]" id="kafka.consumer;RoundRobinAssignor.assign">assign</a><span class="delimiter">(</span><a title="kafka.consumer.AssignmentContext" id="kafka.consumer;RoundRobinAssignor.assign.ctx">ctx</a>: <a href="#kafka.consumer;AssignmentContext" title="kafka.consumer.AssignmentContext">AssignmentContext</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val <a title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.consumer.ConsumerThreadId]" id="kafka.consumer;RoundRobinAssignor.assign.partitionOwnershipDecision">partitionOwnershipDecision</a> = collection.mutable.<span title="[A, B](elems: (A, B)*)scala.collection.mutable.Map[A,B]">Map</span><span title="(elems: (kafka.common.TopicAndPartition, kafka.consumer.ConsumerThreadId)*)scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.consumer.ConsumerThreadId]" class="delimiter">[</span><a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a>, <a href="TopicCount.scala.html#kafka.consumer;ConsumerThreadId" title="kafka.consumer.ConsumerThreadId">ConsumerThreadId</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">// check conditions (a) and (b)</span>
    val <a href="#kafka.consumer;RoundRobinAssignor.assign.headTopic" title="(String, scala.collection.immutable.Set[kafka.consumer.ConsumerThreadId])" class="delimiter">(</a><a href="#kafka.consumer;RoundRobinAssignor.assign.x$1" title="String" id="kafka.consumer;RoundRobinAssignor.assign.headTopic">headTopic</a>, <a href="#kafka.consumer;RoundRobinAssignor.assign.x$1" title="scala.collection.immutable.Set[kafka.consumer.ConsumerThreadId]" id="kafka.consumer;RoundRobinAssignor.assign.headThreadIdSet">headThreadIdSet</a><span class="delimiter">)</span> = <span title="(_1: String, _2: scala.collection.immutable.Set[kafka.consumer.ConsumerThreadId])(String, scala.collection.immutable.Set[kafka.consumer.ConsumerThreadId])" class="delimiter">(</span><a href="#kafka.consumer;RoundRobinAssignor.assign.ctx" title="kafka.consumer.AssignmentContext">ctx</a>.<a href="#kafka.consumer;AssignmentContext.consumersForTopic" title="=&gt; scala.collection.Map[String,List[kafka.consumer.ConsumerThreadId]]">consumersForTopic</a>.<span title="=&gt; (String, List[kafka.consumer.ConsumerThreadId])">head</span>.<span title="=&gt; String">_1</span>, <a href="#kafka.consumer;RoundRobinAssignor.assign.ctx" title="kafka.consumer.AssignmentContext">ctx</a>.<a href="#kafka.consumer;AssignmentContext.consumersForTopic" title="=&gt; scala.collection.Map[String,List[kafka.consumer.ConsumerThreadId]]">consumersForTopic</a>.<span title="=&gt; (String, List[kafka.consumer.ConsumerThreadId])">head</span>.<span title="=&gt; List[kafka.consumer.ConsumerThreadId]">_2</span>.<span title="scala.collection.immutable.Set[kafka.consumer.ConsumerThreadId]">toSet</span><span class="delimiter">)</span>
    <a href="#kafka.consumer;RoundRobinAssignor.assign.ctx" title="kafka.consumer.AssignmentContext">ctx</a>.<a href="#kafka.consumer;AssignmentContext.consumersForTopic" title="=&gt; scala.collection.Map[String,List[kafka.consumer.ConsumerThreadId]]">consumersForTopic</a>.<span title="(f: ((String, List[kafka.consumer.ConsumerThreadId])) =&gt; Unit)Unit">foreach</span> <a href="#kafka.consumer;RoundRobinAssignor.assign.$anonfun.x0$1" title="Unit" class="delimiter">{</a> case <span class="delimiter">(</span><a title="String" id="kafka.consumer;RoundRobinAssignor.assign.$anonfun.topic">topic</a>, <a title="List[kafka.consumer.ConsumerThreadId]" id="kafka.consumer;RoundRobinAssignor.assign.$anonfun.threadIds">threadIds</a><span class="delimiter">)</span> =&gt;
      val <a title="scala.collection.immutable.Set[kafka.consumer.ConsumerThreadId]" id="kafka.consumer;RoundRobinAssignor.assign.$anonfun.threadIdSet">threadIdSet</a> = <a href="#kafka.consumer;RoundRobinAssignor.assign.$anonfun.threadIds" title="List[kafka.consumer.ConsumerThreadId]">threadIds</a>.<span title="scala.collection.immutable.Set[kafka.consumer.ConsumerThreadId]">toSet</span>
      <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#kafka.consumer;RoundRobinAssignor.assign.$anonfun.threadIdSet" title="scala.collection.immutable.Set[kafka.consumer.ConsumerThreadId]">threadIdSet</a> <span title="(x$1: Any)Boolean">==</span> <a href="#kafka.consumer;RoundRobinAssignor.assign.headThreadIdSet" title="scala.collection.immutable.Set[kafka.consumer.ConsumerThreadId]">headThreadIdSet</a>,
              <span class="string">&quot;Round-robin assignment is allowed only if all consumers in the group subscribe to the same topics, &quot;</span> <span title="String(&quot;Round-robin assignment is allowed only if all consumers in the group subscribe to the same topics, AND if the stream counts across topics are identical for a given consumer instance.\n&quot;)">+</span>
              <span class="string">&quot;AND if the stream counts across topics are identical for a given consumer instance.\n&quot;</span> <span title="(x$1: Any)String">+</span>
              <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Topic %s has the following available consumer streams: %s\n&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.consumer;RoundRobinAssignor.assign.$anonfun.topic" title="String">topic</a>, <a href="#kafka.consumer;RoundRobinAssignor.assign.$anonfun.threadIdSet" title="scala.collection.immutable.Set[kafka.consumer.ConsumerThreadId]">threadIdSet</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span>
              <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Topic %s has the following available consumer streams: %s\n&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.consumer;RoundRobinAssignor.assign.headTopic" title="String">headTopic</a>, <a href="#kafka.consumer;RoundRobinAssignor.assign.headThreadIdSet" title="scala.collection.immutable.Set[kafka.consumer.ConsumerThreadId]">headThreadIdSet</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    val <a title="Iterator[kafka.consumer.ConsumerThreadId]" id="kafka.consumer;RoundRobinAssignor.assign.threadAssignor">threadAssignor</a> = <a href="../utils/Utils.scala.html#kafka.utils.Utils" title="kafka.utils.Utils.type">Utils</a>.<a href="../utils/Utils.scala.html#kafka.utils.Utils.circularIterator" title="(coll: Iterable[kafka.consumer.ConsumerThreadId])Iterator[kafka.consumer.ConsumerThreadId]">circularIterator</a><span class="delimiter">(</span><a href="#kafka.consumer;RoundRobinAssignor.assign.headThreadIdSet" title="scala.collection.immutable.Set[kafka.consumer.ConsumerThreadId]">headThreadIdSet</a>.<span title="=&gt; Seq[kafka.consumer.ConsumerThreadId]">toSeq</span>.<span title="(implicit ord: scala.math.Ordering[kafka.consumer.ConsumerThreadId])Seq[kafka.consumer.ConsumerThreadId]">sorted</span><span class="delimiter">)</span>

    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="String(&quot;Starting round-robin assignment with consumers &quot;)" class="string">&quot;Starting round-robin assignment with consumers &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.consumer;RoundRobinAssignor.assign.ctx" title="kafka.consumer.AssignmentContext">ctx</a>.<a href="#kafka.consumer;AssignmentContext.consumers" title="=&gt; Seq[String]">consumers</a><span class="delimiter">)</span>
    val <a title="Seq[kafka.common.TopicAndPartition]" id="kafka.consumer;RoundRobinAssignor.assign.allTopicPartitions">allTopicPartitions</a> = <a href="#kafka.consumer;RoundRobinAssignor.assign.ctx" title="kafka.consumer.AssignmentContext">ctx</a>.<a href="#kafka.consumer;AssignmentContext.partitionsForTopic" title="=&gt; scala.collection.Map[String,Seq[Int]]">partitionsForTopic</a>.<span title="(f: ((String, Seq[Int])) =&gt; scala.collection.GenTraversableOnce[kafka.common.TopicAndPartition])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.Map[String,Seq[Int]],kafka.common.TopicAndPartition,Iterable[kafka.common.TopicAndPartition]])Iterable[kafka.common.TopicAndPartition]">flatMap</span> <a href="#kafka.consumer;RoundRobinAssignor.assign.allTopicPartitions.$anonfun.x0$2" title="Seq[kafka.common.TopicAndPartition]" class="delimiter">{</a> case<span class="delimiter">(</span><a title="String" id="kafka.consumer;RoundRobinAssignor.assign.allTopicPartitions.$anonfun.topic">topic</a>, <a title="Seq[Int]" id="kafka.consumer;RoundRobinAssignor.assign.allTopicPartitions.$anonfun.partitions">partitions</a><span class="delimiter">)</span> =&gt;
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Consumer %s rebalancing the following partitions for topic %s: %s&quot;</span>
           .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.consumer;RoundRobinAssignor.assign.ctx" title="kafka.consumer.AssignmentContext">ctx</a>.<a href="#kafka.consumer;AssignmentContext.consumerId" title="=&gt; String">consumerId</a>, <a href="#kafka.consumer;RoundRobinAssignor.assign.allTopicPartitions.$anonfun.topic" title="String">topic</a>, <a href="#kafka.consumer;RoundRobinAssignor.assign.allTopicPartitions.$anonfun.partitions" title="Seq[Int]">partitions</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.consumer;RoundRobinAssignor.assign.allTopicPartitions.$anonfun.partitions" title="Seq[Int]">partitions</a>.<span title="(f: Int =&gt; kafka.common.TopicAndPartition)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Int],kafka.common.TopicAndPartition,Seq[kafka.common.TopicAndPartition]])Seq[kafka.common.TopicAndPartition]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,kafka.common.TopicAndPartition,Seq[kafka.common.TopicAndPartition]]" class="delimiter">(</span><a title="Int" id="kafka.consumer;RoundRobinAssignor.assign.allTopicPartitions.$anonfun.$anonfun.partition">partition</a> =&gt; <span class="delimiter">{</span>
        <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.consumer;RoundRobinAssignor.assign.allTopicPartitions.$anonfun.topic" title="String">topic</a>, <a href="#kafka.consumer;RoundRobinAssignor.assign.allTopicPartitions.$anonfun.$anonfun.partition" title="Int">partition</a><span class="delimiter">)</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>.<span title="=&gt; Seq[kafka.common.TopicAndPartition]">toSeq</span>.<span title="(lt: (kafka.common.TopicAndPartition, kafka.common.TopicAndPartition) =&gt; Boolean)Seq[kafka.common.TopicAndPartition]">sortWith</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.consumer;RoundRobinAssignor.assign.allTopicPartitions.$anonfun.topicPartition1">topicPartition1</a>, <a title="kafka.common.TopicAndPartition" id="kafka.consumer;RoundRobinAssignor.assign.allTopicPartitions.$anonfun.topicPartition2">topicPartition2</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
      <span class="comment">/*
       * Randomize the order by taking the hashcode to reduce the likelihood of all partitions of a given topic ending
       * up on one consumer (if it has a high enough stream count).
       */</span>
      <a href="#kafka.consumer;RoundRobinAssignor.assign.allTopicPartitions.$anonfun.topicPartition1" title="kafka.common.TopicAndPartition">topicPartition1</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.toString" title="()String">toString</a>.<span title="()Int">hashCode</span> <span title="(x: Int)Boolean">&lt;</span> <a href="#kafka.consumer;RoundRobinAssignor.assign.allTopicPartitions.$anonfun.topicPartition2" title="kafka.common.TopicAndPartition">topicPartition2</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.toString" title="()String">toString</a>.<span title="()Int">hashCode</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>

    <a href="#kafka.consumer;RoundRobinAssignor.assign.allTopicPartitions" title="Seq[kafka.common.TopicAndPartition]">allTopicPartitions</a>.<span title="(f: kafka.common.TopicAndPartition =&gt; Any)Unit">foreach</span><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.consumer;RoundRobinAssignor.assign.$anonfun.topicPartition">topicPartition</a> =&gt; <span class="delimiter">{</span>
      val <a title="kafka.consumer.ConsumerThreadId" id="kafka.consumer;RoundRobinAssignor.assign.$anonfun.threadId">threadId</a> = <a href="#kafka.consumer;RoundRobinAssignor.assign.threadAssignor" title="Iterator[kafka.consumer.ConsumerThreadId]">threadAssignor</a>.<span title="()kafka.consumer.ConsumerThreadId">next</span><span class="delimiter">(</span><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#kafka.consumer;RoundRobinAssignor.assign.$anonfun.threadId" title="kafka.consumer.ConsumerThreadId">threadId</a>.<a href="TopicCount.scala.html#kafka.consumer;ConsumerThreadId.consumer" title="=&gt; String">consumer</a> <span title="(x$1: Any)Boolean">==</span> <a href="#kafka.consumer;RoundRobinAssignor.assign.ctx" title="kafka.consumer.AssignmentContext">ctx</a>.<a href="#kafka.consumer;AssignmentContext.consumerId" title="=&gt; String">consumerId</a><span class="delimiter">)</span>
        <a href="#kafka.consumer;RoundRobinAssignor.assign.partitionOwnershipDecision" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.consumer.ConsumerThreadId]">partitionOwnershipDecision</a> <span title="(kv: (kafka.common.TopicAndPartition, kafka.consumer.ConsumerThreadId))partitionOwnershipDecision.type">+=</span> <span class="delimiter">(</span><a href="#kafka.consumer;RoundRobinAssignor.assign.$anonfun.topicPartition" title="(self: kafka.common.TopicAndPartition)ArrowAssoc[kafka.common.TopicAndPartition]">topicPartition</a> <span title="(y: kafka.consumer.ConsumerThreadId)(kafka.common.TopicAndPartition, kafka.consumer.ConsumerThreadId)">-&gt;</span> <a href="#kafka.consumer;RoundRobinAssignor.assign.$anonfun.threadId" title="kafka.consumer.ConsumerThreadId">threadId</a><span class="delimiter">)</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>

    <a href="#kafka.consumer;RoundRobinAssignor.assign.partitionOwnershipDecision" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.consumer.ConsumerThreadId]">partitionOwnershipDecision</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Range partitioning works on a per-topic basis. For each topic, we lay out the available partitions in numeric order
 * and the consumer threads in lexicographic order. We then divide the number of partitions by the total number of
 * consumer streams (threads) to determine the number of partitions to assign to each consumer. If it does not evenly
 * divide, then the first few consumers will have one extra partition. For example, suppose there are two consumers C1
 * and C2 with two streams each, and there are five available partitions (p0, p1, p2, p3, p4). So each consumer thread
 * will get at least one partition and the first consumer thread will get one extra partition. So the assignment will be:
 * p0 -&gt; C1-0, p1 -&gt; C1-0, p2 -&gt; C1-1, p3 -&gt; C2-0, p4 -&gt; C2-1
 */</span>
class <a title="class RangeAssignor extends AnyRef with kafka.consumer.PartitionAssignor with kafka.utils.Logging" id="kafka.consumer;RangeAssignor">RangeAssignor</a><a href="#kafka.consumer;RangeAssignor" title="kafka.consumer.RangeAssignor" class="delimiter">(</a><span class="delimiter">)</span> extends <a href="#kafka.consumer;PartitionAssignor" title="kafka.consumer.PartitionAssignor">PartitionAssignor</a> with <a href="../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> <span class="delimiter">{</span>

  def <a title="(ctx: kafka.consumer.AssignmentContext)scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.consumer.ConsumerThreadId]" id="kafka.consumer;RangeAssignor.assign">assign</a><span class="delimiter">(</span><a title="kafka.consumer.AssignmentContext" id="kafka.consumer;RangeAssignor.assign.ctx">ctx</a>: <a href="#kafka.consumer;AssignmentContext" title="kafka.consumer.AssignmentContext">AssignmentContext</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val <a title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.consumer.ConsumerThreadId]" id="kafka.consumer;RangeAssignor.assign.partitionOwnershipDecision">partitionOwnershipDecision</a> = collection.mutable.<span title="[A, B](elems: (A, B)*)scala.collection.mutable.Map[A,B]">Map</span><span title="(elems: (kafka.common.TopicAndPartition, kafka.consumer.ConsumerThreadId)*)scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.consumer.ConsumerThreadId]" class="delimiter">[</span><a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a>, <a href="TopicCount.scala.html#kafka.consumer;ConsumerThreadId" title="kafka.consumer.ConsumerThreadId">ConsumerThreadId</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>

    for <span class="delimiter">(</span><span class="delimiter">(</span><a title="String" id="kafka.consumer;RangeAssignor.assign.$anonfun.topic">topic</a>, <a title="scala.collection.Set[kafka.consumer.ConsumerThreadId]" id="kafka.consumer;RangeAssignor.assign.$anonfun.consumerThreadIdSet">consumerThreadIdSet</a><span class="delimiter">)</span> &lt;- <a href="#kafka.consumer;RangeAssignor.assign.ctx" title="kafka.consumer.AssignmentContext">ctx</a>.<a href="#kafka.consumer;AssignmentContext.myTopicThreadIds" title="(f: ((String, scala.collection.Set[kafka.consumer.ConsumerThreadId])) =&gt; Unit)Unit">myTopicThreadIds</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="List[kafka.consumer.ConsumerThreadId]" id="kafka.consumer;RangeAssignor.assign.$anonfun.curConsumers">curConsumers</a> = <a href="#kafka.consumer;RangeAssignor.assign.ctx" title="kafka.consumer.AssignmentContext">ctx</a>.<a href="#kafka.consumer;AssignmentContext.consumersForTopic" title="(key: String)List[kafka.consumer.ConsumerThreadId]">consumersForTopic</a><span class="delimiter">(</span><a href="#kafka.consumer;RangeAssignor.assign.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span>
      val <a title="Seq[Int]" id="kafka.consumer;RangeAssignor.assign.$anonfun.curPartitions">curPartitions</a>: <span title="Seq[Int]">Seq</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> = <a href="#kafka.consumer;RangeAssignor.assign.ctx" title="kafka.consumer.AssignmentContext">ctx</a>.<a href="#kafka.consumer;AssignmentContext.partitionsForTopic" title="(key: String)Seq[Int]">partitionsForTopic</a><span class="delimiter">(</span><a href="#kafka.consumer;RangeAssignor.assign.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span>

      val nPartsPerConsumer = <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.curPartitions" title="Seq[Int]">curPartitions</a>.<span title="=&gt; Int">size</span> <a title="Int" id="kafka.consumer;RangeAssignor.assign.$anonfun.nPartsPerConsumer">/</a> <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.curConsumers" title="List[kafka.consumer.ConsumerThreadId]">curConsumers</a>.<span title="=&gt; Int">size</span>
      val nConsumersWithExtraPart = <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.curPartitions" title="Seq[Int]">curPartitions</a>.<span title="=&gt; Int">size</span> <a title="Int" id="kafka.consumer;RangeAssignor.assign.$anonfun.nConsumersWithExtraPart">%</a> <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.curConsumers" title="List[kafka.consumer.ConsumerThreadId]">curConsumers</a>.<span title="=&gt; Int">size</span>

      <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="String(&quot;Consumer &quot;)" class="string">&quot;Consumer &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.consumer;RangeAssignor.assign.ctx" title="kafka.consumer.AssignmentContext">ctx</a>.<a href="#kafka.consumer;AssignmentContext.consumerId" title="=&gt; String">consumerId</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; rebalancing the following partitions: &quot;)" class="string">&quot; rebalancing the following partitions: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.curPartitions" title="Seq[Int]">curPartitions</a> <span title="(x$1: Any)String">+</span>
        <span title="String(&quot; for topic &quot;)" class="string">&quot; for topic &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.topic" title="String">topic</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; with consumers: &quot;)" class="string">&quot; with consumers: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.curConsumers" title="List[kafka.consumer.ConsumerThreadId]">curConsumers</a><span class="delimiter">)</span>

      for <span class="delimiter">(</span><a title="kafka.consumer.ConsumerThreadId" id="kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.consumerThreadId">consumerThreadId</a> &lt;- <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.consumerThreadIdSet" title="(f: kafka.consumer.ConsumerThreadId =&gt; Unit)Unit">consumerThreadIdSet</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="Int" id="kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.myConsumerPosition">myConsumerPosition</a> = <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.curConsumers" title="List[kafka.consumer.ConsumerThreadId]">curConsumers</a>.<span title="(elem: kafka.consumer.ConsumerThreadId)Int">indexOf</span><span class="delimiter">(</span><a href="#kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.consumerThreadId" title="kafka.consumer.ConsumerThreadId">consumerThreadId</a><span class="delimiter">)</span>
        <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.myConsumerPosition" title="Int">myConsumerPosition</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
        val startPart = <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.nPartsPerConsumer" title="Int">nPartsPerConsumer</a> <span title="(x: Int)Int">*</span> <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.myConsumerPosition" title="Int">myConsumerPosition</a> <a title="Int" id="kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.startPart">+</a> <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.myConsumerPosition" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">myConsumerPosition</a>.<span title="(that: Int)Int">min</span><span class="delimiter">(</span><a href="#kafka.consumer;RangeAssignor.assign.$anonfun.nConsumersWithExtraPart" title="Int">nConsumersWithExtraPart</a><span class="delimiter">)</span>
        val nParts = <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.nPartsPerConsumer" title="Int">nPartsPerConsumer</a> <a title="Int" id="kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.nParts">+</a> <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.myConsumerPosition" title="Int">myConsumerPosition</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span> <span title="(x: Int)Boolean">&gt;</span> <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.nConsumersWithExtraPart" title="Int">nConsumersWithExtraPart</a><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> else <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

        <span class="comment">/**
         *   Range-partition the sorted partitions to consumers for better locality.
         *  The first few consumers pick up an extra partition, if any.
         */</span>
        if <span class="delimiter">(</span><a href="#kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.nParts" title="Int">nParts</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.warn(1729dbc42f)" title="(msg: =&gt; String)Unit">warn</a><span class="delimiter">(</span><span title="String(&quot;No broker partitions consumed by consumer thread &quot;)" class="string">&quot;No broker partitions consumed by consumer thread &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.consumerThreadId" title="kafka.consumer.ConsumerThreadId">consumerThreadId</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; for topic &quot;)" class="string">&quot; for topic &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span>
        else <span class="delimiter">{</span>
          for <span class="delimiter">(</span><a title="Int" id="kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.$anonfun.i">i</a> &lt;- <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.startPart" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">startPart</a> <span title="(f: Int =&gt; scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.consumer.ConsumerThreadId])Unit">until</span> <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.startPart" title="Int">startPart</a> <span title="(x: Int)Int">+</span> <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.nParts" title="Int">nParts</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            val <a title="Int" id="kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.$anonfun.partition">partition</a> = <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.curPartitions" title="(idx: Int)Int">curPartitions</a><span class="delimiter">(</span><a href="#kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.$anonfun.i" title="Int">i</a><span class="delimiter">)</span>
            <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><a href="#kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.consumerThreadId" title="(self: kafka.consumer.ConsumerThreadId)any2stringadd[kafka.consumer.ConsumerThreadId]">consumerThreadId</a> <span title="(other: String)String">+</span> <span title="String(&quot; attempting to claim partition &quot;)" class="string">&quot; attempting to claim partition &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.$anonfun.partition" title="Int">partition</a><span class="delimiter">)</span>
            <span class="comment">// record the partition ownership decision</span>
            <a href="#kafka.consumer;RangeAssignor.assign.partitionOwnershipDecision" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.consumer.ConsumerThreadId]">partitionOwnershipDecision</a> <span title="(kv: (kafka.common.TopicAndPartition, kafka.consumer.ConsumerThreadId))partitionOwnershipDecision.type">+=</span> <span class="delimiter">(</span><a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span title="(self: kafka.common.TopicAndPartition)ArrowAssoc[kafka.common.TopicAndPartition]" class="delimiter">(</span><a href="#kafka.consumer;RangeAssignor.assign.$anonfun.topic" title="String">topic</a>, <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.$anonfun.partition" title="Int">partition</a><span class="delimiter">)</span> <span title="(y: kafka.consumer.ConsumerThreadId)(kafka.common.TopicAndPartition, kafka.consumer.ConsumerThreadId)">-&gt;</span> <a href="#kafka.consumer;RangeAssignor.assign.$anonfun.$anonfun.consumerThreadId" title="kafka.consumer.ConsumerThreadId">consumerThreadId</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="#kafka.consumer;RangeAssignor.assign.partitionOwnershipDecision" title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,kafka.consumer.ConsumerThreadId]">partitionOwnershipDecision</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
