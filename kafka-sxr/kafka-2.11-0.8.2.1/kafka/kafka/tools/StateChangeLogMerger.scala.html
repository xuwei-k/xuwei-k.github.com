<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/tools/StateChangeLogMerger.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package kafka.tools

import joptsimple._
import scala.util.matching.Regex
import collection.mutable
import java.util.Date
import java.text.SimpleDateFormat
import kafka.utils.<span class="delimiter">{</span>Utils, Logging, CommandLineUtils<span class="delimiter">}</span>
import kafka.common.Topic
import java.io.<span class="delimiter">{</span>BufferedOutputStream, OutputStream<span class="delimiter">}</span>

<span class="comment">/**
 * A utility that merges the state change logs (possibly obtained from different brokers and over multiple days).
 *
 * This utility expects at least one of the following two arguments -
 * 1. A list of state change log files
 * 2. A regex to specify state change log file names.
 *
 * This utility optionally also accepts the following arguments -
 * 1. The topic whose state change logs should be merged
 * 2. A list of partitions whose state change logs should be merged (can be specified only when the topic argument
 * is explicitly specified)
 * 3. Start time from when the logs should be merged
 * 4. End time until when the logs should be merged
 */</span>

object <a title="kafka.tools.StateChangeLogMerger.type" id="kafka.tools.StateChangeLogMerger">StateChangeLogMerger</a> extends <a href="../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> <span class="delimiter">{</span>

  val <a title="String" id="kafka.tools.StateChangeLogMerger.dateFormatString">dateFormatString</a> = <span title="String(&quot;yyyy-MM-dd HH:mm:ss,SSS&quot;)" class="string">&quot;yyyy-MM-dd HH:mm:ss,SSS&quot;</span>
  val <a title="scala.util.matching.Regex" id="kafka.tools.StateChangeLogMerger.topicPartitionRegex">topicPartitionRegex</a> = new <span title="scala.util.matching.Regex">Regex</span><span class="delimiter">(</span><span title="String(&quot;\\[(&quot;)" class="string">&quot;\\[(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="../common/Topic.scala.html#kafka.common.Topic" title="kafka.common.Topic.type">Topic</a>.<a href="../common/Topic.scala.html#kafka.common.Topic.legalChars" title="=&gt; String">legalChars</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;+),( )*([0-9]+)\\]&quot;)" class="string">&quot;+),( )*([0-9]+)\\]&quot;</span><span class="delimiter">)</span>
  val <a title="scala.util.matching.Regex" id="kafka.tools.StateChangeLogMerger.dateRegex">dateRegex</a> = new <span title="scala.util.matching.Regex">Regex</span><span class="delimiter">(</span><span title="String(&quot;[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2},[0-9]{3}&quot;)" class="string">&quot;[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2},[0-9]{3}&quot;</span><span class="delimiter">)</span>
  val <a title="java.text.SimpleDateFormat" id="kafka.tools.StateChangeLogMerger.dateFormat">dateFormat</a> = new <span title="java.text.SimpleDateFormat">SimpleDateFormat</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.dateFormatString" title="=&gt; String">dateFormatString</a><span class="delimiter">)</span>
  var <a title="List[String]" id="kafka.tools.StateChangeLogMerger.files_=">files</a>: <span title="List[String]">List</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>
  var <a title="String" id="kafka.tools.StateChangeLogMerger.topic_=">topic</a>: <span title="String">String</span> = null
  var <a title="List[Int]" id="kafka.tools.StateChangeLogMerger.partitions_=">partitions</a>: <span title="List[Int]">List</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> = List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>
  var <a title="java.util.Date" id="kafka.tools.StateChangeLogMerger.startDate_=">startDate</a>: <span title="java.util.Date">Date</span> = null
  var <a title="java.util.Date" id="kafka.tools.StateChangeLogMerger.endDate_=">endDate</a>: <span title="java.util.Date">Date</span> = null

  def <a title="(args: Array[String])Unit" id="kafka.tools.StateChangeLogMerger.main">main</a><span class="delimiter">(</span><a title="Array[String]" id="kafka.tools.StateChangeLogMerger.main.args">args</a>: <span title="Array[String]">Array</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">// Parse input arguments.</span>
    val <a title="joptsimple.OptionParser" id="kafka.tools.StateChangeLogMerger.main.parser">parser</a> = new <span title="joptsimple.OptionParser">OptionParser</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[String]" id="kafka.tools.StateChangeLogMerger.main.filesOpt">filesOpt</a> = <a href="#kafka.tools.StateChangeLogMerger.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;logs&quot;)" class="string">&quot;logs&quot;</span>, <span title="String(&quot;Comma separated list of state change logs or a regex for the log file names&quot;)" class="string">&quot;Comma separated list of state change logs or a regex for the log file names&quot;</span><span class="delimiter">)</span>
                              .<span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span>
                              .<span title="(x$1: String)joptsimple.ArgumentAcceptingOptionSpec[String]">describedAs</span><span class="delimiter">(</span><span title="String(&quot;file1,file2,...&quot;)" class="string">&quot;file1,file2,...&quot;</span><span class="delimiter">)</span>
                              .<span title="(x$1: Class[String])joptsimple.ArgumentAcceptingOptionSpec[String]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[String]" id="kafka.tools.StateChangeLogMerger.main.regexOpt">regexOpt</a> = <a href="#kafka.tools.StateChangeLogMerger.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;logs-regex&quot;)" class="string">&quot;logs-regex&quot;</span>, <span title="String(&quot;Regex to match the state change log files to be merged&quot;)" class="string">&quot;Regex to match the state change log files to be merged&quot;</span><span class="delimiter">)</span>
                              .<span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span>
                              .<span title="(x$1: String)joptsimple.ArgumentAcceptingOptionSpec[String]">describedAs</span><span class="delimiter">(</span><span title="String(&quot;for example: /tmp/state-change.log*&quot;)" class="string">&quot;for example: /tmp/state-change.log*&quot;</span><span class="delimiter">)</span>
                              .<span title="(x$1: Class[String])joptsimple.ArgumentAcceptingOptionSpec[String]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[String]" id="kafka.tools.StateChangeLogMerger.main.topicOpt">topicOpt</a> = <a href="#kafka.tools.StateChangeLogMerger.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;topic&quot;)" class="string">&quot;topic&quot;</span>, <span title="String(&quot;The topic whose state change logs should be merged&quot;)" class="string">&quot;The topic whose state change logs should be merged&quot;</span><span class="delimiter">)</span>
                              .<span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span>
                              .<span title="(x$1: String)joptsimple.ArgumentAcceptingOptionSpec[String]">describedAs</span><span class="delimiter">(</span><span title="String(&quot;topic&quot;)" class="string">&quot;topic&quot;</span><span class="delimiter">)</span>
                              .<span title="(x$1: Class[String])joptsimple.ArgumentAcceptingOptionSpec[String]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[String]" id="kafka.tools.StateChangeLogMerger.main.partitionsOpt">partitionsOpt</a> = <a href="#kafka.tools.StateChangeLogMerger.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;partitions&quot;)" class="string">&quot;partitions&quot;</span>, <span title="String(&quot;Comma separated list of partition ids whose state change logs should be merged&quot;)" class="string">&quot;Comma separated list of partition ids whose state change logs should be merged&quot;</span><span class="delimiter">)</span>
                              .<span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span>
                              .<span title="(x$1: String)joptsimple.ArgumentAcceptingOptionSpec[String]">describedAs</span><span class="delimiter">(</span><span title="String(&quot;0,1,2,...&quot;)" class="string">&quot;0,1,2,...&quot;</span><span class="delimiter">)</span>
                              .<span title="(x$1: Class[String])joptsimple.ArgumentAcceptingOptionSpec[String]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[String]" id="kafka.tools.StateChangeLogMerger.main.startTimeOpt">startTimeOpt</a> = <a href="#kafka.tools.StateChangeLogMerger.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;start-time&quot;)" class="string">&quot;start-time&quot;</span>, <span title="String(&quot;The earliest timestamp of state change log entries to be merged&quot;)" class="string">&quot;The earliest timestamp of state change log entries to be merged&quot;</span><span class="delimiter">)</span>
                              .<span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span>
                              .<span title="(x$1: String)joptsimple.ArgumentAcceptingOptionSpec[String]">describedAs</span><span class="delimiter">(</span><span title="String(&quot;start timestamp in the format &quot;)" class="string">&quot;start timestamp in the format &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools.StateChangeLogMerger.dateFormat" title="=&gt; java.text.SimpleDateFormat">dateFormat</a><span class="delimiter">)</span>
                              .<span title="(x$1: Class[String])joptsimple.ArgumentAcceptingOptionSpec[String]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>
                              .<span title="(x$1: String, x$2: String*)joptsimple.ArgumentAcceptingOptionSpec[String]">defaultsTo</span><span class="delimiter">(</span><span title="String(&quot;0000-00-00 00:00:00,000&quot;)" class="string">&quot;0000-00-00 00:00:00,000&quot;</span><span class="delimiter">)</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[String]" id="kafka.tools.StateChangeLogMerger.main.endTimeOpt">endTimeOpt</a> = <a href="#kafka.tools.StateChangeLogMerger.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;end-time&quot;)" class="string">&quot;end-time&quot;</span>, <span title="String(&quot;The latest timestamp of state change log entries to be merged&quot;)" class="string">&quot;The latest timestamp of state change log entries to be merged&quot;</span><span class="delimiter">)</span>
                              .<span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span>
                              .<span title="(x$1: String)joptsimple.ArgumentAcceptingOptionSpec[String]">describedAs</span><span class="delimiter">(</span><span title="String(&quot;end timestamp in the format &quot;)" class="string">&quot;end timestamp in the format &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools.StateChangeLogMerger.dateFormat" title="=&gt; java.text.SimpleDateFormat">dateFormat</a><span class="delimiter">)</span>
                              .<span title="(x$1: Class[String])joptsimple.ArgumentAcceptingOptionSpec[String]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>
                              .<span title="(x$1: String, x$2: String*)joptsimple.ArgumentAcceptingOptionSpec[String]">defaultsTo</span><span class="delimiter">(</span><span title="String(&quot;9999-12-31 23:59:59,999&quot;)" class="string">&quot;9999-12-31 23:59:59,999&quot;</span><span class="delimiter">)</span>
                              
    if<span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.args" title="Array[String]">args</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      <a href="../utils/CommandLineUtils.scala.html#kafka.utils.CommandLineUtils" title="kafka.utils.CommandLineUtils.type">CommandLineUtils</a>.<a href="../utils/CommandLineUtils.scala.html#kafka.utils.CommandLineUtils.printUsageAndDie" title="(parser: joptsimple.OptionParser, message: String)Unit">printUsageAndDie</a><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.parser" title="joptsimple.OptionParser">parser</a>, <span title="String(&quot;A tool for merging the log files from several brokers to reconnstruct a unified history of what happened.&quot;)" class="string">&quot;A tool for merging the log files from several brokers to reconnstruct a unified history of what happened.&quot;</span><span class="delimiter">)</span>


    val <a title="joptsimple.OptionSet" id="kafka.tools.StateChangeLogMerger.main.options">options</a> = <a href="#kafka.tools.StateChangeLogMerger.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String*)joptsimple.OptionSet">parse</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.args" title="Array[String]">args</a> : _*<span class="delimiter">)</span>
    if <span class="delimiter">(</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[_])Boolean">has</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.filesOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">filesOpt</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[_])Boolean">has</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.regexOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">regexOpt</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[_])Boolean">has</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.filesOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">filesOpt</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[_])Boolean">has</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.regexOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">regexOpt</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="System.type">System</span>.<span title="java.io.PrintStream">err</span>.<span title="(x$1: String)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;Provide arguments to exactly one of the two options \&quot;&quot;)" class="string">&quot;Provide arguments to exactly one of the two options \&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools.StateChangeLogMerger.main.filesOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">filesOpt</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\&quot; or \&quot;&quot;)" class="string">&quot;\&quot; or \&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools.StateChangeLogMerger.main.regexOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">regexOpt</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\&quot;&quot;)" class="string">&quot;\&quot;&quot;</span><span class="delimiter">)</span>
      <a href="#kafka.tools.StateChangeLogMerger.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: java.io.OutputStream)Unit">printHelpOn</span><span class="delimiter">(</span><span title="System.type">System</span>.<span title="java.io.PrintStream">err</span><span class="delimiter">)</span>
      <span title="System.type">System</span>.<span title="(x$1: Int)Unit">exit</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    if <span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[_])Boolean">has</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.partitionsOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">partitionsOpt</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[_])Boolean">has</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.topicOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">topicOpt</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="System.type">System</span>.<span title="java.io.PrintStream">err</span>.<span title="(x$1: String)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;The option \&quot;&quot;)" class="string">&quot;The option \&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools.StateChangeLogMerger.main.topicOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">topicOpt</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\&quot; needs to be provided an argument when specifying partition ids&quot;)" class="string">&quot;\&quot; needs to be provided an argument when specifying partition ids&quot;</span><span class="delimiter">)</span>
      <a href="#kafka.tools.StateChangeLogMerger.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: java.io.OutputStream)Unit">printHelpOn</span><span class="delimiter">(</span><span title="System.type">System</span>.<span title="java.io.PrintStream">err</span><span class="delimiter">)</span>
      <span title="System.type">System</span>.<span title="(x$1: Int)Unit">exit</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// Populate data structures.</span>
    if <span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[_])Boolean">has</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.filesOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">filesOpt</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.tools.StateChangeLogMerger.files_=" title="(x$1: List[String])Unit">files</a> <span title="(prefix: List[String])List[String]">:::=</span> <a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[String])String">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.filesOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">filesOpt</a><span class="delimiter">)</span>.<span title="(x$1: String)Array[String]">split</span><span title="(xs: Array[String])scala.collection.mutable.ArrayOps[String]" class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>.<span title="=&gt; List[String]">toList</span>
    <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[_])Boolean">has</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.regexOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">regexOpt</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="String" id="kafka.tools.StateChangeLogMerger.main.regex">regex</a> = <a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[String])String">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.regexOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">regexOpt</a><span class="delimiter">)</span>
      val fileNameIndex = <a href="#kafka.tools.StateChangeLogMerger.main.regex" title="String">regex</a>.<span title="(x$1: Int)Int">lastIndexOf</span><span class="delimiter">(</span><span title="Int(47)" class="char">'/'</span><span class="delimiter">)</span> <a title="Int" id="kafka.tools.StateChangeLogMerger.main.fileNameIndex">+</a> <span title="Int(1)" class="int">1</span>
      val <a title="String" id="kafka.tools.StateChangeLogMerger.main.dirName">dirName</a> = if <span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.fileNameIndex" title="Int">fileNameIndex</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span> else <a href="#kafka.tools.StateChangeLogMerger.main.regex" title="String">regex</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#kafka.tools.StateChangeLogMerger.main.fileNameIndex" title="Int">fileNameIndex</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      val <a title="scala.util.matching.Regex" id="kafka.tools.StateChangeLogMerger.main.fileNameRegex">fileNameRegex</a> = new <span title="scala.util.matching.Regex">Regex</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.regex" title="String">regex</a>.<span title="(x$1: Int)String">substring</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.fileNameIndex" title="Int">fileNameIndex</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.tools.StateChangeLogMerger.files_=" title="(x$1: List[String])Unit">files</a> <span title="(prefix: List[String])List[String]">:::=</span> new java.io.<span title="java.io.File">File</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.dirName" title="String">dirName</a><span class="delimiter">)</span>.<span title="(xs: Array[java.io.File])scala.collection.mutable.ArrayOps[java.io.File]">listFiles</span>.<span title="(p: java.io.File =&gt; Boolean)Array[java.io.File]">filter</span><span title="(xs: Array[java.io.File])scala.collection.mutable.ArrayOps[java.io.File]" class="delimiter">(</span><a title="java.io.File" id="kafka.tools.StateChangeLogMerger.main.$anonfun.f">f</a> =&gt; <a href="#kafka.tools.StateChangeLogMerger.main.fileNameRegex" title="scala.util.matching.Regex">fileNameRegex</a>.<span title="(source: CharSequence)Option[String]">findFirstIn</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.$anonfun.f" title="java.io.File">f</a>.<span title="()String">getName</span><span class="delimiter">)</span> <span title="(x$1: Any)Boolean">!=</span> <span title="None.type">None</span><span class="delimiter">)</span>.<span title="(f: java.io.File =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Array[java.io.File],String,Array[String]])Array[String]">map</span><span title="(xs: Array[String])scala.collection.mutable.ArrayOps[String]" class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.dirName" title="String">dirName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;/&quot;)" class="string">&quot;/&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools.StateChangeLogMerger.main.$anonfun.x$1" title="java.io.File">_</a>.<span title="()String">getName</span><span class="delimiter">)</span>.<span title="=&gt; List[String]">toList</span>
    <span class="delimiter">}</span>
    if <span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[_])Boolean">has</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.topicOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">topicOpt</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.tools.StateChangeLogMerger.topic_=" title="(x$1: String)Unit">topic</a> = <a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[String])String">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.topicOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">topicOpt</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    if <span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[_])Boolean">has</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.partitionsOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">partitionsOpt</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.tools.StateChangeLogMerger.partitions_=" title="(x$1: List[Int])Unit">partitions</a> = <a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[String])String">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.partitionsOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">partitionsOpt</a><span class="delimiter">)</span>.<span title="(x$1: String)Array[String]">split</span><span title="(xs: Array[String])scala.collection.mutable.ArrayOps[String]" class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>.<span title="=&gt; List[String]">toList</span>.<span title="(f: String =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[String],Int,List[Int]])List[Int]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Int,List[Int]]" class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.$anonfun.x$2" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">_</a>.<span title="=&gt; Int">toInt</span><span class="delimiter">)</span>
      val <a title="Iterable[Int]" id="kafka.tools.StateChangeLogMerger.main.duplicatePartitions">duplicatePartitions</a> = <a href="../utils/Utils.scala.html#kafka.utils.Utils" title="kafka.utils.Utils.type">Utils</a>.<a href="../utils/Utils.scala.html#kafka.utils.Utils.duplicates" title="(s: Traversable[Int])Iterable[Int]">duplicates</a><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.partitions_=" title="=&gt; List[Int]">partitions</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.duplicatePartitions" title="Iterable[Int]">duplicatePartitions</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="System.type">System</span>.<span title="java.io.PrintStream">err</span>.<span title="(x$1: String)Unit">println</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;The list of partitions contains repeated entries: %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.duplicatePartitions" title="Iterable[Int]">duplicatePartitions</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="System.type">System</span>.<span title="(x$1: Int)Unit">exit</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#kafka.tools.StateChangeLogMerger.startDate_=" title="(x$1: java.util.Date)Unit">startDate</a> = <a href="#kafka.tools.StateChangeLogMerger.dateFormat" title="=&gt; java.text.SimpleDateFormat">dateFormat</a>.<span title="(x$1: String)java.util.Date">parse</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[String])String">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.startTimeOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">startTimeOpt</a><span class="delimiter">)</span>.<span title="(x$1: Char, x$2: Char)String">replace</span><span class="delimiter">(</span><span title="Char('\&quot;')" class="char">'\&quot;'</span>, <span title="Char(' ')" class="char">' '</span><span class="delimiter">)</span>.<span title="()String">trim</span><span class="delimiter">)</span>
    <a href="#kafka.tools.StateChangeLogMerger.endDate_=" title="(x$1: java.util.Date)Unit">endDate</a> = <a href="#kafka.tools.StateChangeLogMerger.dateFormat" title="=&gt; java.text.SimpleDateFormat">dateFormat</a>.<span title="(x$1: String)java.util.Date">parse</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[String])String">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.endTimeOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">endTimeOpt</a><span class="delimiter">)</span>.<span title="(x$1: Char, x$2: Char)String">replace</span><span class="delimiter">(</span><span title="Char('\&quot;')" class="char">'\&quot;'</span>, <span title="Char(' ')" class="char">' '</span><span class="delimiter">)</span>.<span title="()String">trim</span><span class="delimiter">)</span>

    <span class="comment">/**
     * n-way merge from m input files:
     * 1. Read a line that matches the specified topic/partitions and date range from every input file in a priority queue.
     * 2. Take the line from the file with the earliest date and add it to a buffered output stream.
     * 3. Add another line from the file selected in step 2 in the priority queue.
     * 4. Flush the output buffer at the end. (The buffer will also be automatically flushed every K bytes.)
     */</span>
    val <a title="scala.collection.mutable.PriorityQueue[kafka.tools.StateChangeLogMerger.LineIterator]" id="kafka.tools.StateChangeLogMerger.main.pqueue">pqueue</a> = new mutable.<span title="scala.collection.mutable.PriorityQueue[kafka.tools.StateChangeLogMerger.LineIterator]">PriorityQueue</span><span class="delimiter">[</span>LineIterator<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.dateBasedOrdering.readResolve" title="kafka.tools.StateChangeLogMerger.dateBasedOrdering.type">dateBasedOrdering</a><span class="delimiter">)</span>
    val <a title="java.io.OutputStream" id="kafka.tools.StateChangeLogMerger.main.output">output</a>: <span title="java.io.OutputStream">OutputStream</span> = new <span title="java.io.BufferedOutputStream">BufferedOutputStream</span><span class="delimiter">(</span><span title="System.type">System</span>.<span title="java.io.PrintStream">out</span>, <span class="int">1024</span><span title="Int(1048576)">*</span><span class="int">1024</span><span class="delimiter">)</span>
    val <a title="List[Iterator[String]]" id="kafka.tools.StateChangeLogMerger.main.lineIterators">lineIterators</a> = <a href="#kafka.tools.StateChangeLogMerger.files_=" title="=&gt; List[String]">files</a>.<span title="(f: String =&gt; Iterator[String])(implicit bf: scala.collection.generic.CanBuildFrom[List[String],Iterator[String],List[Iterator[String]]])List[Iterator[String]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Iterator[String],List[Iterator[String]]]" class="delimiter">(</span>io.<span title="scala.io.Source.type">Source</span>.<span title="(name: String)(implicit codec: scala.io.Codec)scala.io.BufferedSource">fromFile</span><span title="=&gt; scala.io.Codec" class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.lineIterators.$anonfun.x$3" title="String">_</a><span class="delimiter">)</span>.<span title="()Iterator[String]">getLines</span><span class="delimiter">)</span>
    var <a title="List[kafka.tools.StateChangeLogMerger.LineIterator]" id="kafka.tools.StateChangeLogMerger.main.lines">lines</a>: <span title="List[kafka.tools.StateChangeLogMerger.LineIterator]">List</span><span class="delimiter">[</span>LineIterator<span class="delimiter">]</span> = List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>

    for <span class="delimiter">(</span><a title="Iterator[String]" id="kafka.tools.StateChangeLogMerger.main.$anonfun.itr">itr</a> &lt;- <a href="#kafka.tools.StateChangeLogMerger.main.lineIterators" title="(f: Iterator[String] =&gt; Unit)Unit">lineIterators</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="kafka.tools.StateChangeLogMerger.LineIterator" id="kafka.tools.StateChangeLogMerger.main.$anonfun.lineItr">lineItr</a> = <a href="#kafka.tools.StateChangeLogMerger.getNextLine" title="(itr: Iterator[String])kafka.tools.StateChangeLogMerger.LineIterator">getNextLine</a><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.$anonfun.itr" title="Iterator[String]">itr</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.tools.StateChangeLogMerger.main.$anonfun.lineItr" title="kafka.tools.StateChangeLogMerger.LineIterator">lineItr</a>.<a href="#kafka.tools.StateChangeLogMerger;LineIterator.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span>
        <a href="#kafka.tools.StateChangeLogMerger.main.lines" title="List[kafka.tools.StateChangeLogMerger.LineIterator]">lines</a> <span title="(x: kafka.tools.StateChangeLogMerger.LineIterator)List[kafka.tools.StateChangeLogMerger.LineIterator]">::=</span> <a href="#kafka.tools.StateChangeLogMerger.main.$anonfun.lineItr" title="kafka.tools.StateChangeLogMerger.LineIterator">lineItr</a>
    <span class="delimiter">}</span>
    if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.tools.StateChangeLogMerger.main.lines" title="List[kafka.tools.StateChangeLogMerger.LineIterator]">lines</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#kafka.tools.StateChangeLogMerger.main.pqueue" title="scala.collection.mutable.PriorityQueue[kafka.tools.StateChangeLogMerger.LineIterator]">pqueue</a>.<span title="(elems: kafka.tools.StateChangeLogMerger.LineIterator*)Unit">enqueue</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.lines" title="List[kafka.tools.StateChangeLogMerger.LineIterator]">lines</a>:_*<span class="delimiter">)</span>

    while <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.tools.StateChangeLogMerger.main.pqueue" title="scala.collection.mutable.PriorityQueue[kafka.tools.StateChangeLogMerger.LineIterator]">pqueue</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#kafka.tools.StateChangeLogMerger.main.while$1" title="()Unit" class="delimiter">{</a>
      val <a title="kafka.tools.StateChangeLogMerger.LineIterator" id="kafka.tools.StateChangeLogMerger.main.lineItr">lineItr</a> = <a href="#kafka.tools.StateChangeLogMerger.main.pqueue" title="scala.collection.mutable.PriorityQueue[kafka.tools.StateChangeLogMerger.LineIterator]">pqueue</a>.<span title="()kafka.tools.StateChangeLogMerger.LineIterator">dequeue</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#kafka.tools.StateChangeLogMerger.main.output" title="java.io.OutputStream">output</a>.<span title="(x$1: Array[Byte])Unit">write</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.lineItr" title="kafka.tools.StateChangeLogMerger.LineIterator">lineItr</a>.<a href="#kafka.tools.StateChangeLogMerger;LineIterator.line" title="=&gt; String">line</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span>.<span title="()Array[Byte]">getBytes</span><span class="delimiter">)</span>
      val <a title="kafka.tools.StateChangeLogMerger.LineIterator" id="kafka.tools.StateChangeLogMerger.main.nextLineItr">nextLineItr</a> = <a href="#kafka.tools.StateChangeLogMerger.getNextLine" title="(itr: Iterator[String])kafka.tools.StateChangeLogMerger.LineIterator">getNextLine</a><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.lineItr" title="kafka.tools.StateChangeLogMerger.LineIterator">lineItr</a>.<a href="#kafka.tools.StateChangeLogMerger;LineIterator.itr" title="=&gt; Iterator[String]">itr</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.tools.StateChangeLogMerger.main.nextLineItr" title="kafka.tools.StateChangeLogMerger.LineIterator">nextLineItr</a>.<a href="#kafka.tools.StateChangeLogMerger;LineIterator.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span>
        <a href="#kafka.tools.StateChangeLogMerger.main.pqueue" title="scala.collection.mutable.PriorityQueue[kafka.tools.StateChangeLogMerger.LineIterator]">pqueue</a>.<span title="(elems: kafka.tools.StateChangeLogMerger.LineIterator*)Unit">enqueue</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.main.nextLineItr" title="kafka.tools.StateChangeLogMerger.LineIterator">nextLineItr</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#kafka.tools.StateChangeLogMerger.main.output" title="java.io.OutputStream">output</a>.<span title="()Unit">flush</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns the next line that matches the specified topic/partitions from the file that has the earliest date
   * from the specified date range.
   * @param itr Line iterator of a file
   * @return (line from a file, line iterator for the same file)
   */</span>
  def <a title="(itr: Iterator[String])kafka.tools.StateChangeLogMerger.LineIterator" id="kafka.tools.StateChangeLogMerger.getNextLine">getNextLine</a><span class="delimiter">(</span><a title="Iterator[String]" id="kafka.tools.StateChangeLogMerger.getNextLine.itr">itr</a>: <span title="Iterator[String]">Iterator</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#kafka.tools.StateChangeLogMerger;LineIterator" title="kafka.tools.StateChangeLogMerger.LineIterator">LineIterator</a> = <span class="delimiter">{</span>
    while <span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.getNextLine.itr" title="Iterator[String]">itr</a> <span title="(x$1: Any)Boolean">!=</span> null <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.tools.StateChangeLogMerger.getNextLine.itr" title="Iterator[String]">itr</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <a href="#kafka.tools.StateChangeLogMerger.getNextLine.while$2" title="()Unit" class="delimiter">{</a>
      val <a title="String" id="kafka.tools.StateChangeLogMerger.getNextLine.nextLine">nextLine</a> = <a href="#kafka.tools.StateChangeLogMerger.getNextLine.itr" title="Iterator[String]">itr</a>.<span title="()String">next</span>
      <a href="#kafka.tools.StateChangeLogMerger.dateRegex" title="=&gt; scala.util.matching.Regex">dateRegex</a>.<span title="(source: CharSequence)Option[String]">findFirstIn</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.getNextLine.nextLine" title="String">nextLine</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case Some<span class="delimiter">(</span><a title="String" id="kafka.tools.StateChangeLogMerger.getNextLine.d">d</a><span class="delimiter">)</span> =&gt;
          val <a title="java.util.Date" id="kafka.tools.StateChangeLogMerger.getNextLine.date">date</a> = <a href="#kafka.tools.StateChangeLogMerger.dateFormat" title="=&gt; java.text.SimpleDateFormat">dateFormat</a>.<span title="(x$1: String)java.util.Date">parse</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.getNextLine.d" title="String">d</a><span class="delimiter">)</span>
          if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.getNextLine.date" title="java.util.Date">date</a>.<span title="(x$1: Any)Boolean">equals</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.startDate_=" title="=&gt; java.util.Date">startDate</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#kafka.tools.StateChangeLogMerger.getNextLine.date" title="java.util.Date">date</a>.<span title="(x$1: java.util.Date)Boolean">after</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.startDate_=" title="=&gt; java.util.Date">startDate</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.getNextLine.date" title="java.util.Date">date</a>.<span title="(x$1: Any)Boolean">equals</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.endDate_=" title="=&gt; java.util.Date">endDate</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#kafka.tools.StateChangeLogMerger.getNextLine.date" title="java.util.Date">date</a>.<span title="(x$1: java.util.Date)Boolean">before</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.endDate_=" title="=&gt; java.util.Date">endDate</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="#kafka.tools.StateChangeLogMerger.topicPartitionRegex" title="=&gt; scala.util.matching.Regex">topicPartitionRegex</a>.<span title="(source: CharSequence)Option[scala.util.matching.Regex.Match]">findFirstMatchIn</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.getNextLine.nextLine" title="String">nextLine</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
              case Some<span class="delimiter">(</span><a title="scala.util.matching.Regex.Match" id="kafka.tools.StateChangeLogMerger.getNextLine.matcher">matcher</a><span class="delimiter">)</span> =&gt;
                if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.topic_=" title="=&gt; String">topic</a> <span title="(x$1: Any)Boolean">==</span> null <span title="(x: Boolean)Boolean">||</span> <a href="#kafka.tools.StateChangeLogMerger.topic_=" title="=&gt; String">topic</a> <span title="(x$1: Any)Boolean">==</span> <a href="#kafka.tools.StateChangeLogMerger.getNextLine.matcher" title="scala.util.matching.Regex.Match">matcher</a>.<span title="(i: Int)String">group</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.partitions_=" title="=&gt; List[Int]">partitions</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#kafka.tools.StateChangeLogMerger.partitions_=" title="=&gt; List[Int]">partitions</a>.<span title="(elem: Int)Boolean">contains</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.getNextLine.matcher" title="scala.util.matching.Regex.Match">matcher</a>.<span title="(i: Int)String">group</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="delimiter">(</span><span title="Int(3)" class="int">3</span><span class="delimiter">)</span>.<span title="=&gt; Int">toInt</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                  return new <a href="#kafka.tools.StateChangeLogMerger;LineIterator" title="kafka.tools.StateChangeLogMerger.LineIterator">LineIterator</a><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.getNextLine.nextLine" title="String">nextLine</a>, <a href="#kafka.tools.StateChangeLogMerger.getNextLine.itr" title="Iterator[String]">itr</a><span class="delimiter">)</span>
              case <span title="None.type">None</span> =&gt;
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        case <span title="None.type">None</span> =&gt;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    new <a href="#kafka.tools.StateChangeLogMerger;LineIterator" title="kafka.tools.StateChangeLogMerger.LineIterator">LineIterator</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  class <a title="class LineIterator extends AnyRef" id="kafka.tools.StateChangeLogMerger;LineIterator">LineIterator</a><a href="#kafka.tools.StateChangeLogMerger;LineIterator" title="kafka.tools.StateChangeLogMerger.LineIterator" class="delimiter">(</a>val <a title="String" id="kafka.tools.StateChangeLogMerger;LineIterator.line">line</a>: <span title="String">String</span>, val <a title="Iterator[String]" id="kafka.tools.StateChangeLogMerger;LineIterator.itr">itr</a>: <span title="Iterator[String]">Iterator</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    def this<span class="delimiter">(</span><span class="delimiter">)</span> = this<span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, null<span class="delimiter">)</span>
    def <a title="=&gt; Boolean" id="kafka.tools.StateChangeLogMerger;LineIterator.isEmpty">isEmpty</a> = <span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger;LineIterator.line" title="=&gt; String">line</a> <span title="(x$1: Any)Boolean">==</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#kafka.tools.StateChangeLogMerger;LineIterator.itr" title="=&gt; Iterator[String]">itr</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span>
  <span class="delimiter">}</span>

  implicit object <a title="kafka.tools.StateChangeLogMerger.dateBasedOrdering.type" id="kafka.tools.StateChangeLogMerger.dateBasedOrdering.readResolve">dateBasedOrdering</a> extends <span title="Ordering[kafka.tools.StateChangeLogMerger.LineIterator]">Ordering</span><span class="delimiter">[</span>LineIterator<span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="(first: kafka.tools.StateChangeLogMerger.LineIterator, second: kafka.tools.StateChangeLogMerger.LineIterator)Int" id="kafka.tools.StateChangeLogMerger.dateBasedOrdering.compare">compare</a><span class="delimiter">(</span><a title="kafka.tools.StateChangeLogMerger.LineIterator" id="kafka.tools.StateChangeLogMerger.dateBasedOrdering.compare.first">first</a>: <a href="#kafka.tools.StateChangeLogMerger;LineIterator" title="kafka.tools.StateChangeLogMerger.LineIterator">LineIterator</a>, <a title="kafka.tools.StateChangeLogMerger.LineIterator" id="kafka.tools.StateChangeLogMerger.dateBasedOrdering.compare.second">second</a>: <a href="#kafka.tools.StateChangeLogMerger;LineIterator" title="kafka.tools.StateChangeLogMerger.LineIterator">LineIterator</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      val <a title="String" id="kafka.tools.StateChangeLogMerger.dateBasedOrdering.compare.firstDate">firstDate</a> = <a href="#kafka.tools.StateChangeLogMerger.dateRegex" title="=&gt; scala.util.matching.Regex">dateRegex</a>.<span title="(source: CharSequence)Option[String]">findFirstIn</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.dateBasedOrdering.compare.first" title="kafka.tools.StateChangeLogMerger.LineIterator">first</a>.<a href="#kafka.tools.StateChangeLogMerger;LineIterator.line" title="=&gt; String">line</a><span class="delimiter">)</span>.<span title="=&gt; String">get</span>
      val <a title="String" id="kafka.tools.StateChangeLogMerger.dateBasedOrdering.compare.secondDate">secondDate</a> = <a href="#kafka.tools.StateChangeLogMerger.dateRegex" title="=&gt; scala.util.matching.Regex">dateRegex</a>.<span title="(source: CharSequence)Option[String]">findFirstIn</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.dateBasedOrdering.compare.second" title="kafka.tools.StateChangeLogMerger.LineIterator">second</a>.<a href="#kafka.tools.StateChangeLogMerger;LineIterator.line" title="=&gt; String">line</a><span class="delimiter">)</span>.<span title="=&gt; String">get</span>
      <a href="#kafka.tools.StateChangeLogMerger.dateBasedOrdering.compare.secondDate" title="String">secondDate</a>.<span title="(x$1: String)Int">compareTo</span><span class="delimiter">(</span><a href="#kafka.tools.StateChangeLogMerger.dateBasedOrdering.compare.firstDate" title="String">firstDate</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>
        </pre>
    </body>
</html>
