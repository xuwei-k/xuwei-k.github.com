<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/tools/ConsumerOffsetChecker.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package kafka.tools


import joptsimple._
import org.I0Itec.zkclient.ZkClient
import kafka.utils._
import kafka.consumer.SimpleConsumer
import kafka.api.<span class="delimiter">{</span>OffsetFetchResponse, OffsetFetchRequest, OffsetRequest<span class="delimiter">}</span>
import kafka.common.<span class="delimiter">{</span>OffsetMetadataAndError, ErrorMapping, BrokerNotAvailableException, TopicAndPartition<span class="delimiter">}</span>
import scala.collection._
import kafka.client.ClientUtils
import kafka.network.BlockingChannel
import kafka.api.PartitionOffsetRequestInfo
import scala.Some
import org.I0Itec.zkclient.exception.ZkNoNodeException

object <a title="kafka.tools.ConsumerOffsetChecker.type" id="kafka.tools.ConsumerOffsetChecker">ConsumerOffsetChecker</a> extends <a href="../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> <span class="delimiter">{</span>

  private val <a title="scala.collection.mutable.Map[Int,Option[kafka.consumer.SimpleConsumer]]" id="kafka.tools.ConsumerOffsetChecker.consumerMap">consumerMap</a>: mutable.<span title="scala.collection.mutable.Map[Int,Option[kafka.consumer.SimpleConsumer]]">Map</span><span class="delimiter">[</span>Int, Option<span class="delimiter">[</span>SimpleConsumer<span class="delimiter">]</span><span class="delimiter">]</span> = mutable.<span title="(elems: (Int, Option[kafka.consumer.SimpleConsumer])*)scala.collection.mutable.Map[Int,Option[kafka.consumer.SimpleConsumer]]">Map</span><span class="delimiter">(</span><span class="delimiter">)</span>
  private val <a title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,Long]" id="kafka.tools.ConsumerOffsetChecker.offsetMap">offsetMap</a>: mutable.<span title="scala.collection.mutable.Map[kafka.common.TopicAndPartition,Long]">Map</span><span class="delimiter">[</span>TopicAndPartition, Long<span class="delimiter">]</span> = mutable.<span title="(elems: (kafka.common.TopicAndPartition, Long)*)scala.collection.mutable.Map[kafka.common.TopicAndPartition,Long]">Map</span><span class="delimiter">(</span><span class="delimiter">)</span>
  private var <a title="scala.collection.immutable.Map[String,Seq[Int]]" id="kafka.tools.ConsumerOffsetChecker.topicPidMap_=">topicPidMap</a>: immutable.<span title="scala.collection.immutable.Map[String,Seq[Int]]">Map</span><span class="delimiter">[</span>String, Seq<span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">]</span> = immutable.<span title="(elems: (String, Nothing)*)scala.collection.immutable.Map[String,Nothing]">Map</span><span class="delimiter">(</span><span class="delimiter">)</span>

  private def <a title="(zkClient: org.I0Itec.zkclient.ZkClient, bid: Int)Option[kafka.consumer.SimpleConsumer]" id="kafka.tools.ConsumerOffsetChecker.getConsumer">getConsumer</a><span class="delimiter">(</span><a title="org.I0Itec.zkclient.ZkClient" id="kafka.tools.ConsumerOffsetChecker.getConsumer.zkClient">zkClient</a>: <span title="org.I0Itec.zkclient.ZkClient">ZkClient</span>, <a title="Int" id="kafka.tools.ConsumerOffsetChecker.getConsumer.bid">bid</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Option[kafka.consumer.SimpleConsumer]">Option</span><span class="delimiter">[</span>SimpleConsumer<span class="delimiter">]</span> = <span class="delimiter">{</span>
    try <span class="delimiter">{</span>
      <a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.readDataMaybeNull" title="(client: org.I0Itec.zkclient.ZkClient, path: String)(Option[String], org.apache.zookeeper.data.Stat)">readDataMaybeNull</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.getConsumer.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.BrokerIdsPath" title="=&gt; String">BrokerIdsPath</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;/&quot;)" class="string">&quot;/&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools.ConsumerOffsetChecker.getConsumer.bid" title="Int">bid</a><span class="delimiter">)</span>.<span title="=&gt; Option[String]">_1</span> match <span class="delimiter">{</span>
        case Some<span class="delimiter">(</span><a title="String" id="kafka.tools.ConsumerOffsetChecker.getConsumer.brokerInfoString">brokerInfoString</a><span class="delimiter">)</span> =&gt;
          <a href="../utils/Json.scala.html#kafka.utils.Json" title="kafka.utils.Json.type">Json</a>.<a href="../utils/Json.scala.html#kafka.utils.Json.parseFull" title="(input: String)Option[Any]">parseFull</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.getConsumer.brokerInfoString" title="String">brokerInfoString</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
            case Some<span class="delimiter">(</span><a title="Any" id="kafka.tools.ConsumerOffsetChecker.getConsumer.m">m</a><span class="delimiter">)</span> =&gt;
              val <a title="scala.collection.Map[String,Any]" id="kafka.tools.ConsumerOffsetChecker.getConsumer.brokerInfo">brokerInfo</a> = <a href="#kafka.tools.ConsumerOffsetChecker.getConsumer.m" title="Any">m</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.collection.Map[String,Any]" class="delimiter">[</span><span title="scala.collection.Map[String,Any]">Map</span><span class="delimiter">[</span>String, Any<span class="delimiter">]</span><span class="delimiter">]</span>
              val <a title="String" id="kafka.tools.ConsumerOffsetChecker.getConsumer.host">host</a> = <a href="#kafka.tools.ConsumerOffsetChecker.getConsumer.brokerInfo" title="scala.collection.Map[String,Any]">brokerInfo</a>.<span title="(key: String)Option[Any]">get</span><span class="delimiter">(</span><span title="String(&quot;host&quot;)" class="string">&quot;host&quot;</span><span class="delimiter">)</span>.<span title="=&gt; Any">get</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="String" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span>
              val <a title="Int" id="kafka.tools.ConsumerOffsetChecker.getConsumer.port">port</a> = <a href="#kafka.tools.ConsumerOffsetChecker.getConsumer.brokerInfo" title="scala.collection.Map[String,Any]">brokerInfo</a>.<span title="(key: String)Option[Any]">get</span><span class="delimiter">(</span><span title="String(&quot;port&quot;)" class="string">&quot;port&quot;</span><span class="delimiter">)</span>.<span title="=&gt; Any">get</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Int" class="delimiter">[</span><span title="Int">Int</span><span class="delimiter">]</span>
              <span title="(x: kafka.consumer.SimpleConsumer)Some[kafka.consumer.SimpleConsumer]">Some</span><span class="delimiter">(</span>new <a href="../consumer/SimpleConsumer.scala.html#kafka.consumer;SimpleConsumer" title="kafka.consumer.SimpleConsumer">SimpleConsumer</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.getConsumer.host" title="String">host</a>, <a href="#kafka.tools.ConsumerOffsetChecker.getConsumer.port" title="Int">port</a>, <span title="Int(10000)" class="int">10000</span>, <span title="Int(100000)" class="int">100000</span>, <span title="String(&quot;ConsumerOffsetChecker&quot;)" class="string">&quot;ConsumerOffsetChecker&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
            case <span title="None.type">None</span> =&gt;
              throw new <a href="../common/BrokerNotAvailableException.scala.html#kafka.common;BrokerNotAvailableException" title="kafka.common.BrokerNotAvailableException">BrokerNotAvailableException</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Broker id %d does not exist&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.getConsumer.bid" title="Int">bid</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        case <span title="None.type">None</span> =&gt;
          throw new <a href="../common/BrokerNotAvailableException.scala.html#kafka.common;BrokerNotAvailableException" title="kafka.common.BrokerNotAvailableException">BrokerNotAvailableException</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Broker id %d does not exist&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.getConsumer.bid" title="Int">bid</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> catch <span class="delimiter">{</span>
      case <a title="Throwable" id="kafka.tools.ConsumerOffsetChecker.getConsumer.t">t</a>: <span title="Throwable">Throwable</span> =&gt;
        <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;Could not parse broker info due to &quot;)" class="string">&quot;Could not parse broker info due to &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools.ConsumerOffsetChecker.getConsumer.t" title="Throwable">t</a>.<span title="()Throwable">getCause</span><span class="delimiter">)</span>
        <span title="None.type">None</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  private def <a title="(zkClient: org.I0Itec.zkclient.ZkClient, group: String, topic: String, pid: Int)Unit" id="kafka.tools.ConsumerOffsetChecker.processPartition">processPartition</a><span class="delimiter">(</span><a title="org.I0Itec.zkclient.ZkClient" id="kafka.tools.ConsumerOffsetChecker.processPartition.zkClient">zkClient</a>: <span title="org.I0Itec.zkclient.ZkClient">ZkClient</span>,
                               <a title="String" id="kafka.tools.ConsumerOffsetChecker.processPartition.group">group</a>: <span title="String">String</span>, <a title="String" id="kafka.tools.ConsumerOffsetChecker.processPartition.topic">topic</a>: <span title="String">String</span>, <a title="Int" id="kafka.tools.ConsumerOffsetChecker.processPartition.pid">pid</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="kafka.common.TopicAndPartition" id="kafka.tools.ConsumerOffsetChecker.processPartition.topicPartition">topicPartition</a> = <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.topic" title="String">topic</a>, <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.pid" title="Int">pid</a><span class="delimiter">)</span>
    val <a title="Option[Long]" id="kafka.tools.ConsumerOffsetChecker.processPartition.offsetOpt">offsetOpt</a> = <a href="#kafka.tools.ConsumerOffsetChecker.offsetMap" title="=&gt; scala.collection.mutable.Map[kafka.common.TopicAndPartition,Long]">offsetMap</a>.<span title="(key: kafka.common.TopicAndPartition)Option[Long]">get</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.topicPartition" title="kafka.common.TopicAndPartition">topicPartition</a><span class="delimiter">)</span>
    val <a title="kafka.utils.ZKGroupTopicDirs" id="kafka.tools.ConsumerOffsetChecker.processPartition.groupDirs">groupDirs</a> = new <a href="../utils/ZkUtils.scala.html#kafka.utils;ZKGroupTopicDirs" title="kafka.utils.ZKGroupTopicDirs">ZKGroupTopicDirs</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.group" title="String">group</a>, <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.topic" title="String">topic</a><span class="delimiter">)</span>
    val <a title="Option[String]" id="kafka.tools.ConsumerOffsetChecker.processPartition.owner">owner</a> = <a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.readDataMaybeNull" title="(client: org.I0Itec.zkclient.ZkClient, path: String)(Option[String], org.apache.zookeeper.data.Stat)">readDataMaybeNull</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.groupDirs" title="kafka.utils.ZKGroupTopicDirs">groupDirs</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils;ZKGroupTopicDirs.consumerOwnerDir" title="=&gt; String">consumerOwnerDir</a> <span title="(x$1: Any)String">+</span> <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;/%s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.pid" title="Int">pid</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; Option[String]">_1</span>
    <a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.getLeaderForPartition" title="(zkClient: org.I0Itec.zkclient.ZkClient, topic: String, partition: Int)Option[Int]">getLeaderForPartition</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.topic" title="String">topic</a>, <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.pid" title="Int">pid</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case Some<span class="delimiter">(</span><a title="Int" id="kafka.tools.ConsumerOffsetChecker.processPartition.bid">bid</a><span class="delimiter">)</span> =&gt;
        val <a title="Option[kafka.consumer.SimpleConsumer]" id="kafka.tools.ConsumerOffsetChecker.processPartition.consumerOpt">consumerOpt</a> = <a href="#kafka.tools.ConsumerOffsetChecker.consumerMap" title="=&gt; scala.collection.mutable.Map[Int,Option[kafka.consumer.SimpleConsumer]]">consumerMap</a>.<span title="(key: Int, op: =&gt; Option[kafka.consumer.SimpleConsumer])Option[kafka.consumer.SimpleConsumer]">getOrElseUpdate</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.bid" title="Int">bid</a>, <a href="#kafka.tools.ConsumerOffsetChecker.getConsumer" title="(zkClient: org.I0Itec.zkclient.ZkClient, bid: Int)Option[kafka.consumer.SimpleConsumer]">getConsumer</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.bid" title="Int">bid</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.consumerOpt" title="Option[kafka.consumer.SimpleConsumer]">consumerOpt</a> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><a title="kafka.consumer.SimpleConsumer" id="kafka.tools.ConsumerOffsetChecker.processPartition.consumer">consumer</a><span class="delimiter">)</span> =&gt;
            val <a title="kafka.common.TopicAndPartition" id="kafka.tools.ConsumerOffsetChecker.processPartition.topicAndPartition">topicAndPartition</a> = <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.topic" title="String">topic</a>, <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.pid" title="Int">pid</a><span class="delimiter">)</span>
            val <a title="kafka.api.OffsetRequest" id="kafka.tools.ConsumerOffsetChecker.processPartition.request">request</a> =
              <a href="../api/OffsetRequest.scala.html#kafka.api;OffsetRequest" title="(requestInfo: Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetRequestInfo], versionId: Short, correlationId: Int, clientId: String, replicaId: Int)kafka.api.OffsetRequest">OffsetRequest</a><span class="delimiter">(</span>immutable.<span title="(elems: (kafka.common.TopicAndPartition, kafka.api.PartitionOffsetRequestInfo)*)scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetRequestInfo]">Map</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.topicAndPartition" title="(self: kafka.common.TopicAndPartition)ArrowAssoc[kafka.common.TopicAndPartition]">topicAndPartition</a> <span title="(y: kafka.api.PartitionOffsetRequestInfo)(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetRequestInfo)">-&gt;</span> <a href="../api/OffsetRequest.scala.html#kafka.api;PartitionOffsetRequestInfo" title="(time: Long, maxNumOffsets: Int)kafka.api.PartitionOffsetRequestInfo">PartitionOffsetRequestInfo</a><span class="delimiter">(</span><a href="../api/OffsetRequest.scala.html#kafka.api.OffsetRequest" title="kafka.api.OffsetRequest.type">OffsetRequest</a>.<a href="../api/OffsetRequest.scala.html#kafka.api.OffsetRequest.LatestTime" title="=&gt; Long">LatestTime</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            val <a title="Long" id="kafka.tools.ConsumerOffsetChecker.processPartition.logSize">logSize</a> = <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.consumer" title="kafka.consumer.SimpleConsumer">consumer</a>.<a href="../consumer/SimpleConsumer.scala.html#kafka.consumer;SimpleConsumer.getOffsetsBefore" title="(request: kafka.api.OffsetRequest)kafka.api.OffsetResponse">getOffsetsBefore</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.request" title="kafka.api.OffsetRequest">request</a><span class="delimiter">)</span>.<a href="../api/OffsetResponse.scala.html#kafka.api;OffsetResponse.partitionErrorAndOffsets" title="(key: kafka.common.TopicAndPartition)kafka.api.PartitionOffsetsResponse">partitionErrorAndOffsets</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>.<a href="../api/OffsetResponse.scala.html#kafka.api;PartitionOffsetsResponse.offsets" title="=&gt; Seq[Long]">offsets</a>.<span title="=&gt; Long">head</span>

            val <a title="Option[String]" id="kafka.tools.ConsumerOffsetChecker.processPartition.lagString">lagString</a> = <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.offsetOpt" title="Option[Long]">offsetOpt</a>.<span title="(f: Long =&gt; String)Option[String]">map</span><span class="delimiter">(</span><a title="Long" id="kafka.tools.ConsumerOffsetChecker.processPartition.lagString.$anonfun.o">o</a> =&gt; if <span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.lagString.$anonfun.o" title="Long">o</a> <span title="(x: Int)Boolean">==</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span> <span title="String(&quot;unknown&quot;)" class="string">&quot;unknown&quot;</span> else <span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.logSize" title="Long">logSize</a> <span title="(x: Long)Long">-</span> <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.lagString.$anonfun.o" title="Long">o</a><span class="delimiter">)</span>.<span title="()String">toString</span><span class="delimiter">)</span>
            <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%-15s %-30s %-3s %-15s %-15s %-15s %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.group" title="String">group</a>, <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.topic" title="String">topic</a>, <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.pid" title="Int">pid</a>, <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.offsetOpt" title="Option[Long]">offsetOpt</a>.<span title="(default: =&gt; Any)Any">getOrElse</span><span class="delimiter">(</span><span title="String(&quot;unknown&quot;)" class="string">&quot;unknown&quot;</span><span class="delimiter">)</span>, <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.logSize" title="Long">logSize</a>, <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.lagString" title="Option[String]">lagString</a>.<span title="(default: =&gt; String)String">getOrElse</span><span class="delimiter">(</span><span title="String(&quot;unknown&quot;)" class="string">&quot;unknown&quot;</span><span class="delimiter">)</span>,
                                                                   <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.owner" title="Option[String]">owner</a> match <span class="delimiter">{</span>case Some<span class="delimiter">(</span><a title="String" id="kafka.tools.ConsumerOffsetChecker.processPartition.ownerStr">ownerStr</a><span class="delimiter">)</span> =&gt; <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.ownerStr" title="String">ownerStr</a> case <span title="None.type">None</span> =&gt; <span title="String(&quot;none&quot;)" class="string">&quot;none&quot;</span><span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>
          case <span title="None.type">None</span> =&gt; <span class="comment">// ignore</span>
        <span class="delimiter">}</span>
      case <span title="None.type">None</span> =&gt;
        <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;No broker for partition %s - %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processPartition.topic" title="String">topic</a>, <a href="#kafka.tools.ConsumerOffsetChecker.processPartition.pid" title="Int">pid</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  private def <a title="(zkClient: org.I0Itec.zkclient.ZkClient, group: String, topic: String)Unit" id="kafka.tools.ConsumerOffsetChecker.processTopic">processTopic</a><span class="delimiter">(</span><a title="org.I0Itec.zkclient.ZkClient" id="kafka.tools.ConsumerOffsetChecker.processTopic.zkClient">zkClient</a>: <span title="org.I0Itec.zkclient.ZkClient">ZkClient</span>, <a title="String" id="kafka.tools.ConsumerOffsetChecker.processTopic.group">group</a>: <span title="String">String</span>, <a title="String" id="kafka.tools.ConsumerOffsetChecker.processTopic.topic">topic</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.tools.ConsumerOffsetChecker.topicPidMap_=" title="=&gt; scala.collection.immutable.Map[String,Seq[Int]]">topicPidMap</a>.<span title="(key: String)Option[Seq[Int]]">get</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processTopic.topic" title="String">topic</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case Some<span class="delimiter">(</span><a title="Seq[Int]" id="kafka.tools.ConsumerOffsetChecker.processTopic.pids">pids</a><span class="delimiter">)</span> =&gt;
        <a href="#kafka.tools.ConsumerOffsetChecker.processTopic.pids" title="Seq[Int]">pids</a>.<span title="(implicit ord: scala.math.Ordering[Int])Seq[Int]">sorted</span>.<span title="(f: Int =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span>
          <a title="Int" id="kafka.tools.ConsumerOffsetChecker.processTopic.$anonfun.pid">pid</a> =&gt; <a href="#kafka.tools.ConsumerOffsetChecker.processPartition" title="(zkClient: org.I0Itec.zkclient.ZkClient, group: String, topic: String, pid: Int)Unit">processPartition</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.processTopic.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.tools.ConsumerOffsetChecker.processTopic.group" title="String">group</a>, <a href="#kafka.tools.ConsumerOffsetChecker.processTopic.topic" title="String">topic</a>, <a href="#kafka.tools.ConsumerOffsetChecker.processTopic.$anonfun.pid" title="Int">pid</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      case <span title="None.type">None</span> =&gt; <span class="comment">// ignore</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  private def <a title="()Unit" id="kafka.tools.ConsumerOffsetChecker.printBrokerInfo">printBrokerInfo</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;BROKER INFO&quot;)" class="string">&quot;BROKER INFO&quot;</span><span class="delimiter">)</span>
    for <span class="delimiter">(</span><span class="delimiter">(</span><a title="Int" id="kafka.tools.ConsumerOffsetChecker.printBrokerInfo.$anonfun.bid">bid</a>, <a title="Option[kafka.consumer.SimpleConsumer]" id="kafka.tools.ConsumerOffsetChecker.printBrokerInfo.$anonfun.consumerOpt">consumerOpt</a><span class="delimiter">)</span> &lt;- <a href="#kafka.tools.ConsumerOffsetChecker.consumerMap" title="(f: ((Int, Option[kafka.consumer.SimpleConsumer])) =&gt; Unit)Unit">consumerMap</a><span class="delimiter">)</span>
      <a href="#kafka.tools.ConsumerOffsetChecker.printBrokerInfo.$anonfun.consumerOpt" title="Option[kafka.consumer.SimpleConsumer]">consumerOpt</a> match <span class="delimiter">{</span>
        case Some<span class="delimiter">(</span><a title="kafka.consumer.SimpleConsumer" id="kafka.tools.ConsumerOffsetChecker.printBrokerInfo.$anonfun.consumer">consumer</a><span class="delimiter">)</span> =&gt;
          <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%s -&gt; %s:%d&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.printBrokerInfo.$anonfun.bid" title="Int">bid</a>, <a href="#kafka.tools.ConsumerOffsetChecker.printBrokerInfo.$anonfun.consumer" title="kafka.consumer.SimpleConsumer">consumer</a>.<a href="../consumer/SimpleConsumer.scala.html#kafka.consumer;SimpleConsumer.host" title="=&gt; String">host</a>, <a href="#kafka.tools.ConsumerOffsetChecker.printBrokerInfo.$anonfun.consumer" title="kafka.consumer.SimpleConsumer">consumer</a>.<a href="../consumer/SimpleConsumer.scala.html#kafka.consumer;SimpleConsumer.port" title="=&gt; Int">port</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case <span title="None.type">None</span> =&gt; <span class="comment">// ignore</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(args: Array[String])Unit" id="kafka.tools.ConsumerOffsetChecker.main">main</a><span class="delimiter">(</span><a title="Array[String]" id="kafka.tools.ConsumerOffsetChecker.main.args">args</a>: <span title="Array[String]">Array</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="joptsimple.OptionParser" id="kafka.tools.ConsumerOffsetChecker.main.parser">parser</a> = new <span title="joptsimple.OptionParser">OptionParser</span><span class="delimiter">(</span><span class="delimiter">)</span>

    val <a title="joptsimple.ArgumentAcceptingOptionSpec[String]" id="kafka.tools.ConsumerOffsetChecker.main.zkConnectOpt">zkConnectOpt</a> = <a href="#kafka.tools.ConsumerOffsetChecker.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;zookeeper&quot;)" class="string">&quot;zookeeper&quot;</span>, <span title="String(&quot;ZooKeeper connect string.&quot;)" class="string">&quot;ZooKeeper connect string.&quot;</span><span class="delimiter">)</span>.
            <span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="(x$1: String, x$2: String*)joptsimple.ArgumentAcceptingOptionSpec[String]">defaultsTo</span><span class="delimiter">(</span><span title="String(&quot;localhost:2181&quot;)" class="string">&quot;localhost:2181&quot;</span><span class="delimiter">)</span>.<span title="(x$1: Class[String])joptsimple.ArgumentAcceptingOptionSpec[String]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[String]" id="kafka.tools.ConsumerOffsetChecker.main.topicsOpt">topicsOpt</a> = <a href="#kafka.tools.ConsumerOffsetChecker.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;topic&quot;)" class="string">&quot;topic&quot;</span>,
            <span title="String(&quot;Comma-separated list of consumer topics (all topics if absent).&quot;)" class="string">&quot;Comma-separated list of consumer topics (all topics if absent).&quot;</span><span class="delimiter">)</span>.
            <span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="(x$1: Class[String])joptsimple.ArgumentAcceptingOptionSpec[String]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[String]" id="kafka.tools.ConsumerOffsetChecker.main.groupOpt">groupOpt</a> = <a href="#kafka.tools.ConsumerOffsetChecker.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;group&quot;)" class="string">&quot;group&quot;</span>, <span title="String(&quot;Consumer group.&quot;)" class="string">&quot;Consumer group.&quot;</span><span class="delimiter">)</span>.
            <span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="(x$1: Class[String])joptsimple.ArgumentAcceptingOptionSpec[String]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[Integer]" id="kafka.tools.ConsumerOffsetChecker.main.channelSocketTimeoutMsOpt">channelSocketTimeoutMsOpt</a> = <a href="#kafka.tools.ConsumerOffsetChecker.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;socket.timeout.ms&quot;)" class="string">&quot;socket.timeout.ms&quot;</span>, <span title="String(&quot;Socket timeout to use when querying for offsets.&quot;)" class="string">&quot;Socket timeout to use when querying for offsets.&quot;</span><span class="delimiter">)</span>.
            <span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="(x$1: Class[Integer])joptsimple.ArgumentAcceptingOptionSpec[Integer]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[Integer](classOf[java.lang.Integer])" class="delimiter">[</span>java.lang.Integer<span class="delimiter">]</span><span class="delimiter">)</span>.<span title="(x$1: Integer, x$2: Integer*)joptsimple.ArgumentAcceptingOptionSpec[Integer]">defaultsTo</span><span class="delimiter">(</span><span title="implicit scala.Predef.int2Integer : (x: Int)Integer" class="int">6000</span><span class="delimiter">)</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[Integer]" id="kafka.tools.ConsumerOffsetChecker.main.channelRetryBackoffMsOpt">channelRetryBackoffMsOpt</a> = <a href="#kafka.tools.ConsumerOffsetChecker.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;retry.backoff.ms&quot;)" class="string">&quot;retry.backoff.ms&quot;</span>, <span title="String(&quot;Retry back-off to use for failed offset queries.&quot;)" class="string">&quot;Retry back-off to use for failed offset queries.&quot;</span><span class="delimiter">)</span>.
            <span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="(x$1: Class[Integer])joptsimple.ArgumentAcceptingOptionSpec[Integer]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[Integer](classOf[java.lang.Integer])" class="delimiter">[</span>java.lang.Integer<span class="delimiter">]</span><span class="delimiter">)</span>.<span title="(x$1: Integer, x$2: Integer*)joptsimple.ArgumentAcceptingOptionSpec[Integer]">defaultsTo</span><span class="delimiter">(</span><span title="implicit scala.Predef.int2Integer : (x: Int)Integer" class="int">3000</span><span class="delimiter">)</span>

    <a href="#kafka.tools.ConsumerOffsetChecker.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;broker-info&quot;)" class="string">&quot;broker-info&quot;</span>, <span title="String(&quot;Print broker info&quot;)" class="string">&quot;Print broker info&quot;</span><span class="delimiter">)</span>
    <a href="#kafka.tools.ConsumerOffsetChecker.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;help&quot;)" class="string">&quot;help&quot;</span>, <span title="String(&quot;Print this message.&quot;)" class="string">&quot;Print this message.&quot;</span><span class="delimiter">)</span>
    
    if<span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.args" title="Array[String]">args</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      <a href="../utils/CommandLineUtils.scala.html#kafka.utils.CommandLineUtils" title="kafka.utils.CommandLineUtils.type">CommandLineUtils</a>.<a href="../utils/CommandLineUtils.scala.html#kafka.utils.CommandLineUtils.printUsageAndDie" title="(parser: joptsimple.OptionParser, message: String)Unit">printUsageAndDie</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.parser" title="joptsimple.OptionParser">parser</a>, <span title="String(&quot;Check the offset of your consumers.&quot;)" class="string">&quot;Check the offset of your consumers.&quot;</span><span class="delimiter">)</span>

    val <a title="joptsimple.OptionSet" id="kafka.tools.ConsumerOffsetChecker.main.options">options</a> = <a href="#kafka.tools.ConsumerOffsetChecker.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String*)joptsimple.OptionSet">parse</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.args" title="Array[String]">args</a> : _*<span class="delimiter">)</span>

    if <span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: String)Boolean">has</span><span class="delimiter">(</span><span title="String(&quot;help&quot;)" class="string">&quot;help&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
       <a href="#kafka.tools.ConsumerOffsetChecker.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: java.io.OutputStream)Unit">printHelpOn</span><span class="delimiter">(</span><span title="System.type">System</span>.<span title="java.io.PrintStream">out</span><span class="delimiter">)</span>
       <span title="System.type">System</span>.<span title="(x$1: Int)Unit">exit</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="../utils/CommandLineUtils.scala.html#kafka.utils.CommandLineUtils" title="kafka.utils.CommandLineUtils.type">CommandLineUtils</a>.<a href="../utils/CommandLineUtils.scala.html#kafka.utils.CommandLineUtils.checkRequiredArgs" title="(parser: joptsimple.OptionParser, options: joptsimple.OptionSet, required: joptsimple.OptionSpec[_]*)Unit">checkRequiredArgs</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.parser" title="joptsimple.OptionParser">parser</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.options" title="joptsimple.OptionSet">options</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.groupOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">groupOpt</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.zkConnectOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">zkConnectOpt</a><span class="delimiter">)</span>

    val <a title="String" id="kafka.tools.ConsumerOffsetChecker.main.zkConnect">zkConnect</a> = <a href="#kafka.tools.ConsumerOffsetChecker.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[String])String">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.zkConnectOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">zkConnectOpt</a><span class="delimiter">)</span>

    val <a title="String" id="kafka.tools.ConsumerOffsetChecker.main.group">group</a> = <a href="#kafka.tools.ConsumerOffsetChecker.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[String])String">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.groupOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">groupOpt</a><span class="delimiter">)</span>
    val <a title="kafka.utils.ZKGroupDirs" id="kafka.tools.ConsumerOffsetChecker.main.groupDirs">groupDirs</a> = new <a href="../utils/ZkUtils.scala.html#kafka.utils;ZKGroupDirs" title="kafka.utils.ZKGroupDirs">ZKGroupDirs</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.group" title="String">group</a><span class="delimiter">)</span>

    val <a title="Int" id="kafka.tools.ConsumerOffsetChecker.main.channelSocketTimeoutMs">channelSocketTimeoutMs</a> = <a href="#kafka.tools.ConsumerOffsetChecker.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[Integer])Integer">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.channelSocketTimeoutMsOpt" title="joptsimple.ArgumentAcceptingOptionSpec[Integer]">channelSocketTimeoutMsOpt</a><span class="delimiter">)</span>.<span title="()Int">intValue</span><span class="delimiter">(</span><span class="delimiter">)</span>
    val <a title="Int" id="kafka.tools.ConsumerOffsetChecker.main.channelRetryBackoffMs">channelRetryBackoffMs</a> = <a href="#kafka.tools.ConsumerOffsetChecker.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[Integer])Integer">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.channelRetryBackoffMsOpt" title="joptsimple.ArgumentAcceptingOptionSpec[Integer]">channelRetryBackoffMsOpt</a><span class="delimiter">)</span>.<span title="()Int">intValue</span><span class="delimiter">(</span><span class="delimiter">)</span>

    val <a title="Option[String]" id="kafka.tools.ConsumerOffsetChecker.main.topics">topics</a> = if <span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[_])Boolean">has</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.topicsOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">topicsOpt</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: String)Some[String]">Some</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[String])String">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.topicsOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">topicsOpt</a><span class="delimiter">)</span><span class="delimiter">)</span> else <span title="None.type">None</span>

    var <a title="org.I0Itec.zkclient.ZkClient" id="kafka.tools.ConsumerOffsetChecker.main.zkClient">zkClient</a>: <span title="org.I0Itec.zkclient.ZkClient">ZkClient</span> = null
    var <span title="kafka.network.BlockingChannel">channel</span>: <a href="../network/BlockingChannel.scala.html#kafka.network;BlockingChannel" title="kafka.network.BlockingChannel">BlockingChannel</a> = null
    try <span class="delimiter">{</span>
      <a href="#kafka.tools.ConsumerOffsetChecker.main.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a> = new <span title="org.I0Itec.zkclient.ZkClient">ZkClient</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.zkConnect" title="String">zkConnect</a>, <span title="Int(30000)" class="int">30000</span>, <span title="Int(30000)" class="int">30000</span>, <a href="../utils/ZkUtils.scala.html#kafka.utils.ZKStringSerializer" title="kafka.utils.ZKStringSerializer.type">ZKStringSerializer</a><span class="delimiter">)</span>

      val <a title="List[String]" id="kafka.tools.ConsumerOffsetChecker.main.topicList">topicList</a> = <a href="#kafka.tools.ConsumerOffsetChecker.main.topics" title="Option[String]">topics</a> match <span class="delimiter">{</span>
        case Some<span class="delimiter">(</span><a title="String" id="kafka.tools.ConsumerOffsetChecker.main.topicList.x">x</a><span class="delimiter">)</span> =&gt; <a href="#kafka.tools.ConsumerOffsetChecker.main.topicList.x" title="String">x</a>.<span title="(x$1: String)Array[String]">split</span><span title="(xs: Array[String])scala.collection.mutable.ArrayOps[String]" class="delimiter">(</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>.<span title="=&gt; scala.collection.mutable.IndexedSeqView[String,Array[String]]">view</span>.<span title="=&gt; List[String]">toList</span>
        case <span title="None.type">None</span> =&gt; <a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.getChildren" title="(client: org.I0Itec.zkclient.ZkClient, path: String)Seq[String]">getChildren</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.groupDirs" title="kafka.utils.ZKGroupDirs">groupDirs</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils;ZKGroupDirs.consumerGroupDir" title="=&gt; String">consumerGroupDir</a> <span title="(x$1: Any)String">+</span>  <span title="String(&quot;/owners&quot;)" class="string">&quot;/owners&quot;</span><span class="delimiter">)</span>.<span title="=&gt; List[String]">toList</span>
      <span class="delimiter">}</span>

      <a href="#kafka.tools.ConsumerOffsetChecker.topicPidMap_=" title="(x$1: scala.collection.immutable.Map[String,Seq[Int]])Unit">topicPidMap</a> = immutable.<span title="(elems: (String, Seq[Int])*)scala.collection.immutable.Map[String,Seq[Int]]">Map</span><span class="delimiter">(</span><a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.getPartitionsForTopics" title="(zkClient: org.I0Itec.zkclient.ZkClient, topics: Seq[String])scala.collection.mutable.Map[String,Seq[Int]]">getPartitionsForTopics</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.topicList" title="List[String]">topicList</a><span class="delimiter">)</span>.<span title="=&gt; Seq[(String, Seq[Int])]">toSeq</span>:_*<span class="delimiter">)</span>
      val <a title="Seq[kafka.common.TopicAndPartition]" id="kafka.tools.ConsumerOffsetChecker.main.topicPartitions">topicPartitions</a> = <a href="#kafka.tools.ConsumerOffsetChecker.topicPidMap_=" title="=&gt; scala.collection.immutable.Map[String,Seq[Int]]">topicPidMap</a>.<span title="(f: ((String, Seq[Int])) =&gt; scala.collection.GenTraversableOnce[kafka.common.TopicAndPartition])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[String,Seq[Int]],kafka.common.TopicAndPartition,scala.collection.immutable.Iterable[kafka.common.TopicAndPartition]])scala.collection.immutable.Iterable[kafka.common.TopicAndPartition]">flatMap</span> <a href="#kafka.tools.ConsumerOffsetChecker.main.topicPartitions.$anonfun.x0$1" title="Seq[kafka.common.TopicAndPartition]" class="delimiter">{</a> case<span class="delimiter">(</span><a title="String" id="kafka.tools.ConsumerOffsetChecker.main.topicPartitions.$anonfun.topic">topic</a>, <a title="Seq[Int]" id="kafka.tools.ConsumerOffsetChecker.main.topicPartitions.$anonfun.partitionSeq">partitionSeq</a><span class="delimiter">)</span> =&gt; <a href="#kafka.tools.ConsumerOffsetChecker.main.topicPartitions.$anonfun.partitionSeq" title="Seq[Int]">partitionSeq</a>.<span title="(f: Int =&gt; kafka.common.TopicAndPartition)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Int],kafka.common.TopicAndPartition,Seq[kafka.common.TopicAndPartition]])Seq[kafka.common.TopicAndPartition]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,kafka.common.TopicAndPartition,Seq[kafka.common.TopicAndPartition]]" class="delimiter">(</span><a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="(topic: String, partition: Int)kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.topicPartitions.$anonfun.topic" title="String">topic</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.topicPartitions.$anonfun.$anonfun.x$2" title="Int">_</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>.<span title="=&gt; Seq[kafka.common.TopicAndPartition]">toSeq</span>
      val <span title="kafka.network.BlockingChannel">channel</span> = <a href="../client/ClientUtils.scala.html#kafka.client.ClientUtils" title="kafka.client.ClientUtils.type">ClientUtils</a>.<a href="../client/ClientUtils.scala.html#kafka.client.ClientUtils.channelToOffsetManager" title="(group: String, zkClient: org.I0Itec.zkclient.ZkClient, socketTimeoutMs: Int, retryBackOffMs: Int)kafka.network.BlockingChannel">channelToOffsetManager</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.group" title="String">group</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.channelSocketTimeoutMs" title="Int">channelSocketTimeoutMs</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.channelRetryBackoffMs" title="Int">channelRetryBackoffMs</a><span class="delimiter">)</span>

      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Sending offset fetch request to coordinator %s:%d.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><span title="kafka.network.BlockingChannel">channel</span>.<a href="../network/BlockingChannel.scala.html#kafka.network;BlockingChannel.host" title="=&gt; String">host</a>, <span title="kafka.network.BlockingChannel">channel</span>.<a href="../network/BlockingChannel.scala.html#kafka.network;BlockingChannel.port" title="=&gt; Int">port</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="kafka.network.BlockingChannel">channel</span>.<a href="../network/BlockingChannel.scala.html#kafka.network;BlockingChannel.send" title="(request: kafka.api.RequestOrResponse)Int">send</a><span class="delimiter">(</span><a href="../api/OffsetFetchRequest.scala.html#kafka.api;OffsetFetchRequest" title="(groupId: String, requestInfo: Seq[kafka.common.TopicAndPartition], versionId: Short, correlationId: Int, clientId: String)kafka.api.OffsetFetchRequest">OffsetFetchRequest</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.group" title="String">group</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.topicPartitions" title="Seq[kafka.common.TopicAndPartition]">topicPartitions</a><span class="delimiter">)</span><span class="delimiter">)</span>
      val <a title="kafka.api.OffsetFetchResponse" id="kafka.tools.ConsumerOffsetChecker.main.offsetFetchResponse">offsetFetchResponse</a> = <a href="../api/OffsetFetchResponse.scala.html#kafka.api.OffsetFetchResponse" title="kafka.api.OffsetFetchResponse.type">OffsetFetchResponse</a>.<a href="../api/OffsetFetchResponse.scala.html#kafka.api.OffsetFetchResponse.readFrom" title="(buffer: java.nio.ByteBuffer)kafka.api.OffsetFetchResponse">readFrom</a><span class="delimiter">(</span><span title="kafka.network.BlockingChannel">channel</span>.<a href="../network/BlockingChannel.scala.html#kafka.network;BlockingChannel.receive" title="()kafka.network.Receive">receive</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../network/Transmission.scala.html#kafka.network;Receive.buffer" title="=&gt; java.nio.ByteBuffer">buffer</a><span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Received offset fetch response %s.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.offsetFetchResponse" title="kafka.api.OffsetFetchResponse">offsetFetchResponse</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="#kafka.tools.ConsumerOffsetChecker.main.offsetFetchResponse" title="kafka.api.OffsetFetchResponse">offsetFetchResponse</a>.<a href="../api/OffsetFetchResponse.scala.html#kafka.api;OffsetFetchResponse.requestInfo" title="=&gt; Map[kafka.common.TopicAndPartition,kafka.common.OffsetMetadataAndError]">requestInfo</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.common.OffsetMetadataAndError)) =&gt; Any)Unit">foreach</span> <a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.x0$2" title="Any" class="delimiter">{</a> case <span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.tools.ConsumerOffsetChecker.main.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="kafka.common.OffsetMetadataAndError" id="kafka.tools.ConsumerOffsetChecker.main.$anonfun.offsetAndMetadata">offsetAndMetadata</a><span class="delimiter">)</span> =&gt;
        if <span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.offsetAndMetadata" title="kafka.common.OffsetMetadataAndError">offsetAndMetadata</a> <span title="(x$1: Any)Boolean">==</span> <a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetMetadataAndError" title="kafka.common.OffsetMetadataAndError.type">OffsetMetadataAndError</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common.OffsetMetadataAndError.NoOffset" title="=&gt; kafka.common.OffsetMetadataAndError">NoOffset</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          val <a title="kafka.utils.ZKGroupTopicDirs" id="kafka.tools.ConsumerOffsetChecker.main.$anonfun.topicDirs">topicDirs</a> = new <a href="../utils/ZkUtils.scala.html#kafka.utils;ZKGroupTopicDirs" title="kafka.utils.ZKGroupTopicDirs">ZKGroupTopicDirs</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.group" title="String">group</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a><span class="delimiter">)</span>
          <span class="comment">// this group may not have migrated off zookeeper for offsets storage (we don't expose the dual-commit option in this tool</span>
          <span class="comment">// (meaning the lag may be off until all the consumers in the group have the same setting for offsets storage)</span>
          try <span class="delimiter">{</span>
            val <a title="Long" id="kafka.tools.ConsumerOffsetChecker.main.$anonfun.offset">offset</a> = <a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.readData" title="(client: org.I0Itec.zkclient.ZkClient, path: String)(String, org.apache.zookeeper.data.Stat)">readData</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.topicDirs" title="kafka.utils.ZKGroupTopicDirs">topicDirs</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils;ZKGroupTopicDirs.consumerOffsetDir" title="=&gt; String">consumerOffsetDir</a> <span title="(x$1: Any)String">+</span> <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;/%d&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">_1</span>.<span title="=&gt; Long">toLong</span>
            <a href="#kafka.tools.ConsumerOffsetChecker.offsetMap" title="=&gt; scala.collection.mutable.Map[kafka.common.TopicAndPartition,Long]">offsetMap</a>.<span title="(key: kafka.common.TopicAndPartition, value: Long)Option[Long]">put</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.offset" title="Long">offset</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> catch <span class="delimiter">{</span>
            case <a title="org.I0Itec.zkclient.exception.ZkNoNodeException" id="kafka.tools.ConsumerOffsetChecker.main.$anonfun.z">z</a>: <span title="org.I0Itec.zkclient.exception.ZkNoNodeException">ZkNoNodeException</span> =&gt;
              if<span class="delimiter">(</span><a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils" title="kafka.utils.ZkUtils.type">ZkUtils</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils.ZkUtils.pathExists" title="(client: org.I0Itec.zkclient.ZkClient, path: String)Boolean">pathExists</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>,<a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.topicDirs" title="kafka.utils.ZKGroupTopicDirs">topicDirs</a>.<a href="../utils/ZkUtils.scala.html#kafka.utils;ZKGroupTopicDirs.consumerOffsetDir" title="=&gt; String">consumerOffsetDir</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#kafka.tools.ConsumerOffsetChecker.offsetMap" title="=&gt; scala.collection.mutable.Map[kafka.common.TopicAndPartition,Long]">offsetMap</a>.<span title="(key: kafka.common.TopicAndPartition, value: Long)Option[Long]">put</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>,-<span title="Long(-1L)" class="int">1</span><span class="delimiter">)</span>
              else
                throw <a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.z" title="org.I0Itec.zkclient.exception.ZkNoNodeException">z</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        else if <span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.offsetAndMetadata" title="kafka.common.OffsetMetadataAndError">offsetAndMetadata</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetMetadataAndError.error" title="=&gt; Short">error</a> <span title="(x: Short)Boolean">==</span> <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a><span class="delimiter">)</span>
          <a href="#kafka.tools.ConsumerOffsetChecker.offsetMap" title="=&gt; scala.collection.mutable.Map[kafka.common.TopicAndPartition,Long]">offsetMap</a>.<span title="(key: kafka.common.TopicAndPartition, value: Long)Option[Long]">put</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.offsetAndMetadata" title="kafka.common.OffsetMetadataAndError">offsetAndMetadata</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetMetadataAndError.offset" title="=&gt; Long">offset</a><span class="delimiter">)</span>
        else <span class="delimiter">{</span>
          <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Could not fetch offset for %s due to %s.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.exceptionFor" title="(code: Short)Throwable">exceptionFor</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.offsetAndMetadata" title="kafka.common.OffsetMetadataAndError">offsetAndMetadata</a>.<a href="../common/OffsetMetadataAndError.scala.html#kafka.common;OffsetMetadataAndError.error" title="=&gt; Short">error</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span title="kafka.network.BlockingChannel">channel</span>.<a href="../network/BlockingChannel.scala.html#kafka.network;BlockingChannel.disconnect" title="()Unit">disconnect</a><span class="delimiter">(</span><span class="delimiter">)</span>

      <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%-15s %-30s %-3s %-15s %-15s %-15s %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><span title="String(&quot;Group&quot;)" class="string">&quot;Group&quot;</span>, <span title="String(&quot;Topic&quot;)" class="string">&quot;Topic&quot;</span>, <span title="String(&quot;Pid&quot;)" class="string">&quot;Pid&quot;</span>, <span title="String(&quot;Offset&quot;)" class="string">&quot;Offset&quot;</span>, <span title="String(&quot;logSize&quot;)" class="string">&quot;logSize&quot;</span>, <span title="String(&quot;Lag&quot;)" class="string">&quot;Lag&quot;</span>, <span title="String(&quot;Owner&quot;)" class="string">&quot;Owner&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.tools.ConsumerOffsetChecker.main.topicList" title="List[String]">topicList</a>.<span title="(implicit ord: scala.math.Ordering[String])List[String]">sorted</span>.<span title="(f: String =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span>
        <a title="String" id="kafka.tools.ConsumerOffsetChecker.main.$anonfun.topic">topic</a> =&gt; <a href="#kafka.tools.ConsumerOffsetChecker.processTopic" title="(zkClient: org.I0Itec.zkclient.ZkClient, group: String, topic: String)Unit">processTopic</a><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.group" title="String">group</a>, <a href="#kafka.tools.ConsumerOffsetChecker.main.$anonfun.topic" title="String">topic</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      if <span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: String)Boolean">has</span><span class="delimiter">(</span><span title="String(&quot;broker-info&quot;)" class="string">&quot;broker-info&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#kafka.tools.ConsumerOffsetChecker.printBrokerInfo" title="()Unit">printBrokerInfo</a><span class="delimiter">(</span><span class="delimiter">)</span>

      for <span class="delimiter">(</span><span class="delimiter">(</span>_, <span title="Option[kafka.consumer.SimpleConsumer]">consumerOpt</span><span class="delimiter">)</span> &lt;- <a href="#kafka.tools.ConsumerOffsetChecker.consumerMap" title="(f: ((Int, Option[kafka.consumer.SimpleConsumer])) =&gt; Unit)Unit">consumerMap</a><span class="delimiter">)</span>
        <span title="Option[kafka.consumer.SimpleConsumer]">consumerOpt</span> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><span title="kafka.consumer.SimpleConsumer">consumer</span><span class="delimiter">)</span> =&gt; <span title="kafka.consumer.SimpleConsumer">consumer</span>.<a href="../consumer/SimpleConsumer.scala.html#kafka.consumer;SimpleConsumer.close" title="()Unit">close</a><span class="delimiter">(</span><span class="delimiter">)</span>
          case <span title="None.type">None</span> =&gt; <span class="comment">// ignore</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    catch <span class="delimiter">{</span>
      case <a title="Throwable" id="kafka.tools.ConsumerOffsetChecker.main.t">t</a>: <span title="Throwable">Throwable</span> =&gt;
        <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Exiting due to: %s.&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.t" title="Throwable">t</a>.<span title="()String">getMessage</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    finally <span class="delimiter">{</span>
      for <span class="delimiter">(</span><span title="Option[kafka.consumer.SimpleConsumer]">consumerOpt</span> &lt;- <a href="#kafka.tools.ConsumerOffsetChecker.consumerMap" title="=&gt; scala.collection.mutable.Map[Int,Option[kafka.consumer.SimpleConsumer]]">consumerMap</a>.<span title="(f: Option[kafka.consumer.SimpleConsumer] =&gt; Unit)Unit">values</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Option[kafka.consumer.SimpleConsumer]">consumerOpt</span> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><span title="kafka.consumer.SimpleConsumer">consumer</span><span class="delimiter">)</span> =&gt; <span title="kafka.consumer.SimpleConsumer">consumer</span>.<a href="../consumer/SimpleConsumer.scala.html#kafka.consumer;SimpleConsumer.close" title="()Unit">close</a><span class="delimiter">(</span><span class="delimiter">)</span>
          case <span title="None.type">None</span> =&gt; <span class="comment">// ignore</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      if <span class="delimiter">(</span><a href="#kafka.tools.ConsumerOffsetChecker.main.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span>
        <a href="#kafka.tools.ConsumerOffsetChecker.main.zkClient" title="org.I0Itec.zkclient.ZkClient">zkClient</a>.<span title="()Unit">close</span><span class="delimiter">(</span><span class="delimiter">)</span>

      if <span class="delimiter">(</span><span title="kafka.network.BlockingChannel">channel</span> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span>
        <span title="kafka.network.BlockingChannel">channel</span>.<a href="../network/BlockingChannel.scala.html#kafka.network;BlockingChannel.disconnect" title="()Unit">disconnect</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
