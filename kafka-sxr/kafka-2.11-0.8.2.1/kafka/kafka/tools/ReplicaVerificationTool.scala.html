<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>kafka/kafka/tools/ReplicaVerificationTool.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package kafka.tools

import joptsimple.OptionParser
import kafka.cluster.Broker
import kafka.message.<span class="delimiter">{</span>MessageSet, MessageAndOffset, ByteBufferMessageSet<span class="delimiter">}</span>
import java.util.concurrent.CountDownLatch
import java.util.concurrent.atomic.AtomicReference
import kafka.client.ClientUtils
import java.util.regex.<span class="delimiter">{</span>PatternSyntaxException, Pattern<span class="delimiter">}</span>
import kafka.api._
import java.text.SimpleDateFormat
import java.util.Date
import kafka.common.<span class="delimiter">{</span>ErrorMapping, TopicAndPartition<span class="delimiter">}</span>
import kafka.utils._
import kafka.consumer.<span class="delimiter">{</span>ConsumerConfig, Whitelist, SimpleConsumer<span class="delimiter">}</span>

<span class="comment">/**
 *  For verifying the consistency among replicas.
 *
 *  1. start a fetcher on every broker.
 *  2. each fetcher does the following
 *    2.1 issues fetch request
 *    2.2 puts the fetched result in a shared buffer
 *    2.3 waits for all other fetchers to finish step 2.2
 *    2.4 one of the fetchers verifies the consistency of fetched results among replicas
 *
 *  The consistency verification is up to the high watermark. The tool reports the
 *  max lag between the verified offset and the high watermark among all partitions.
 *
 *  If a broker goes down, the verification of the partitions on that broker is delayed
 *  until the broker is up again.
 *
 * Caveats:
 * 1. The tools needs all brokers to be up at startup time.
 * 2. The tool doesn't handle out of range offsets.
 */</span>

object <a title="kafka.tools.ReplicaVerificationTool.type" id="kafka.tools.ReplicaVerificationTool">ReplicaVerificationTool</a> extends <a href="../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> <span class="delimiter">{</span>
  val <a title="String" id="kafka.tools.ReplicaVerificationTool.clientId">clientId</a>= <span title="String(&quot;replicaVerificationTool&quot;)" class="string">&quot;replicaVerificationTool&quot;</span>
  val <a title="String" id="kafka.tools.ReplicaVerificationTool.dateFormatString">dateFormatString</a> = <span title="String(&quot;yyyy-MM-dd HH:mm:ss,SSS&quot;)" class="string">&quot;yyyy-MM-dd HH:mm:ss,SSS&quot;</span>
  val <a title="java.text.SimpleDateFormat" id="kafka.tools.ReplicaVerificationTool.dateFormat">dateFormat</a> = new <span title="java.text.SimpleDateFormat">SimpleDateFormat</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.dateFormatString" title="=&gt; String">dateFormatString</a><span class="delimiter">)</span>

  def <a title="()String" id="kafka.tools.ReplicaVerificationTool.getCurrentTimeString">getCurrentTimeString</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#kafka.tools.ReplicaVerificationTool" title="kafka.tools.ReplicaVerificationTool.type">ReplicaVerificationTool</a>.<a href="#kafka.tools.ReplicaVerificationTool.dateFormat" title="=&gt; java.text.SimpleDateFormat">dateFormat</a>.<span title="(x$1: java.util.Date)String">format</span><span class="delimiter">(</span>new <span title="java.util.Date">Date</span><span class="delimiter">(</span><a href="../utils/Time.scala.html#kafka.utils.SystemTime" title="kafka.utils.SystemTime.type">SystemTime</a>.<a href="../utils/Time.scala.html#kafka.utils.SystemTime.milliseconds" title="=&gt; Long">milliseconds</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(args: Array[String])Unit" id="kafka.tools.ReplicaVerificationTool.main">main</a><span class="delimiter">(</span><a title="Array[String]" id="kafka.tools.ReplicaVerificationTool.main.args">args</a>: <span title="Array[String]">Array</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    val <a title="joptsimple.OptionParser" id="kafka.tools.ReplicaVerificationTool.main.parser">parser</a> = new <span title="joptsimple.OptionParser">OptionParser</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[String]" id="kafka.tools.ReplicaVerificationTool.main.brokerListOpt">brokerListOpt</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;broker-list&quot;)" class="string">&quot;broker-list&quot;</span>, <span title="String(&quot;REQUIRED: The list of hostname and port of the server to connect to.&quot;)" class="string">&quot;REQUIRED: The list of hostname and port of the server to connect to.&quot;</span><span class="delimiter">)</span>
                         .<span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span>
                         .<span title="(x$1: String)joptsimple.ArgumentAcceptingOptionSpec[String]">describedAs</span><span class="delimiter">(</span><span title="String(&quot;hostname:port,...,hostname:port&quot;)" class="string">&quot;hostname:port,...,hostname:port&quot;</span><span class="delimiter">)</span>
                         .<span title="(x$1: Class[String])joptsimple.ArgumentAcceptingOptionSpec[String]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[Integer]" id="kafka.tools.ReplicaVerificationTool.main.fetchSizeOpt">fetchSizeOpt</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;fetch-size&quot;)" class="string">&quot;fetch-size&quot;</span>, <span title="String(&quot;The fetch size of each request.&quot;)" class="string">&quot;The fetch size of each request.&quot;</span><span class="delimiter">)</span>
                         .<span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span>
                         .<span title="(x$1: String)joptsimple.ArgumentAcceptingOptionSpec[String]">describedAs</span><span class="delimiter">(</span><span title="String(&quot;bytes&quot;)" class="string">&quot;bytes&quot;</span><span class="delimiter">)</span>
                         .<span title="(x$1: Class[Integer])joptsimple.ArgumentAcceptingOptionSpec[Integer]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[Integer](classOf[java.lang.Integer])" class="delimiter">[</span>java.lang.Integer<span class="delimiter">]</span><span class="delimiter">)</span>
                         .<span title="(x$1: Integer, x$2: Integer*)joptsimple.ArgumentAcceptingOptionSpec[Integer]">defaultsTo</span><span class="delimiter">(</span><a href="../consumer/ConsumerConfig.scala.html#kafka.consumer.ConsumerConfig" title="kafka.consumer.ConsumerConfig.type">ConsumerConfig</a>.<a href="../consumer/ConsumerConfig.scala.html#kafka.consumer.ConsumerConfig.FetchSize" title="implicit scala.Predef.int2Integer : (x: Int)Integer">FetchSize</a><span class="delimiter">)</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[Integer]" id="kafka.tools.ReplicaVerificationTool.main.maxWaitMsOpt">maxWaitMsOpt</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;max-wait-ms&quot;)" class="string">&quot;max-wait-ms&quot;</span>, <span title="String(&quot;The max amount of time each fetch request waits.&quot;)" class="string">&quot;The max amount of time each fetch request waits.&quot;</span><span class="delimiter">)</span>
                         .<span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span>
                         .<span title="(x$1: String)joptsimple.ArgumentAcceptingOptionSpec[String]">describedAs</span><span class="delimiter">(</span><span title="String(&quot;ms&quot;)" class="string">&quot;ms&quot;</span><span class="delimiter">)</span>
                         .<span title="(x$1: Class[Integer])joptsimple.ArgumentAcceptingOptionSpec[Integer]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[Integer](classOf[java.lang.Integer])" class="delimiter">[</span>java.lang.Integer<span class="delimiter">]</span><span class="delimiter">)</span>
                         .<span title="(x$1: Integer, x$2: Integer*)joptsimple.ArgumentAcceptingOptionSpec[Integer]">defaultsTo</span><span class="delimiter">(</span><span title="implicit scala.Predef.int2Integer : (x: Int)Integer" class="int">1000</span><span class="delimiter">)</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[String]" id="kafka.tools.ReplicaVerificationTool.main.topicWhiteListOpt">topicWhiteListOpt</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;topic-white-list&quot;)" class="string">&quot;topic-white-list&quot;</span>, <span title="String(&quot;White list of topics to verify replica consistency. Defaults to all topics.&quot;)" class="string">&quot;White list of topics to verify replica consistency. Defaults to all topics.&quot;</span><span class="delimiter">)</span>
                         .<span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span>
                         .<span title="(x$1: String)joptsimple.ArgumentAcceptingOptionSpec[String]">describedAs</span><span class="delimiter">(</span><span title="String(&quot;Java regex (String)&quot;)" class="string">&quot;Java regex (String)&quot;</span><span class="delimiter">)</span>
                         .<span title="(x$1: Class[String])joptsimple.ArgumentAcceptingOptionSpec[String]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[String](classOf[java.lang.String])" class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>
                         .<span title="(x$1: String, x$2: String*)joptsimple.ArgumentAcceptingOptionSpec[String]">defaultsTo</span><span class="delimiter">(</span><span title="String(&quot;.*&quot;)" class="string">&quot;.*&quot;</span><span class="delimiter">)</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[Long]" id="kafka.tools.ReplicaVerificationTool.main.initialOffsetTimeOpt">initialOffsetTimeOpt</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;time&quot;)" class="string">&quot;time&quot;</span>, <span title="String(&quot;Timestamp for getting the initial offsets.&quot;)" class="string">&quot;Timestamp for getting the initial offsets.&quot;</span><span class="delimiter">)</span>
                           .<span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span>
                           .<span title="(x$1: String)joptsimple.ArgumentAcceptingOptionSpec[String]">describedAs</span><span class="delimiter">(</span><span title="String(&quot;timestamp/-1(latest)/-2(earliest)&quot;)" class="string">&quot;timestamp/-1(latest)/-2(earliest)&quot;</span><span class="delimiter">)</span>
                           .<span title="(x$1: Class[Long])joptsimple.ArgumentAcceptingOptionSpec[Long]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[Long](classOf[java.lang.Long])" class="delimiter">[</span>java.lang.Long<span class="delimiter">]</span><span class="delimiter">)</span>
                           .<span title="(x$1: Long, x$2: Long*)joptsimple.ArgumentAcceptingOptionSpec[Long]">defaultsTo</span><span class="delimiter">(</span>-<span title="implicit scala.Predef.long2Long : (x: Long)Long" class="long">1L</span><span class="delimiter">)</span>
    val <a title="joptsimple.ArgumentAcceptingOptionSpec[Long]" id="kafka.tools.ReplicaVerificationTool.main.reportIntervalOpt">reportIntervalOpt</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String, x$2: String)joptsimple.OptionSpecBuilder">accepts</span><span class="delimiter">(</span><span title="String(&quot;report-interval-ms&quot;)" class="string">&quot;report-interval-ms&quot;</span>, <span title="String(&quot;The reporting interval.&quot;)" class="string">&quot;The reporting interval.&quot;</span><span class="delimiter">)</span>
                         .<span title="()joptsimple.ArgumentAcceptingOptionSpec[String]">withRequiredArg</span>
                         .<span title="(x$1: String)joptsimple.ArgumentAcceptingOptionSpec[String]">describedAs</span><span class="delimiter">(</span><span title="String(&quot;ms&quot;)" class="string">&quot;ms&quot;</span><span class="delimiter">)</span>
                         .<span title="(x$1: Class[Long])joptsimple.ArgumentAcceptingOptionSpec[Long]">ofType</span><span class="delimiter">(</span>classOf<span title="Class[Long](classOf[java.lang.Long])" class="delimiter">[</span>java.lang.Long<span class="delimiter">]</span><span class="delimiter">)</span>
                         .<span title="(x$1: Long, x$2: Long*)joptsimple.ArgumentAcceptingOptionSpec[Long]">defaultsTo</span><span class="delimiter">(</span><span class="int">30</span> <span title="implicit scala.Predef.long2Long : (x: Long)Long">*</span> <span class="long">1000L</span><span class="delimiter">)</span>
                         
   if<span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.args" title="Array[String]">args</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      <a href="../utils/CommandLineUtils.scala.html#kafka.utils.CommandLineUtils" title="kafka.utils.CommandLineUtils.type">CommandLineUtils</a>.<a href="../utils/CommandLineUtils.scala.html#kafka.utils.CommandLineUtils.printUsageAndDie" title="(parser: joptsimple.OptionParser, message: String)Unit">printUsageAndDie</a><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.parser" title="joptsimple.OptionParser">parser</a>, <span title="String(&quot;Validate that all replicas for a set of topics have the same data.&quot;)" class="string">&quot;Validate that all replicas for a set of topics have the same data.&quot;</span><span class="delimiter">)</span>

    val <a title="joptsimple.OptionSet" id="kafka.tools.ReplicaVerificationTool.main.options">options</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.parser" title="joptsimple.OptionParser">parser</a>.<span title="(x$1: String*)joptsimple.OptionSet">parse</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.args" title="Array[String]">args</a> : _*<span class="delimiter">)</span>
    <a href="../utils/CommandLineUtils.scala.html#kafka.utils.CommandLineUtils" title="kafka.utils.CommandLineUtils.type">CommandLineUtils</a>.<a href="../utils/CommandLineUtils.scala.html#kafka.utils.CommandLineUtils.checkRequiredArgs" title="(parser: joptsimple.OptionParser, options: joptsimple.OptionSet, required: joptsimple.OptionSpec[_]*)Unit">checkRequiredArgs</a><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.parser" title="joptsimple.OptionParser">parser</a>, <a href="#kafka.tools.ReplicaVerificationTool.main.options" title="joptsimple.OptionSet">options</a>, <a href="#kafka.tools.ReplicaVerificationTool.main.brokerListOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">brokerListOpt</a><span class="delimiter">)</span>

    val <a title="String" id="kafka.tools.ReplicaVerificationTool.main.regex">regex</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[String])String">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.topicWhiteListOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">topicWhiteListOpt</a><span class="delimiter">)</span>
    val <a title="kafka.consumer.Whitelist" id="kafka.tools.ReplicaVerificationTool.main.topicWhiteListFiler">topicWhiteListFiler</a> = new <a href="../consumer/TopicFilter.scala.html#kafka.consumer;Whitelist" title="kafka.consumer.Whitelist">Whitelist</a><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.regex" title="String">regex</a><span class="delimiter">)</span>

    try <span class="delimiter">{</span>
      <span title="java.util.regex.Pattern.type">Pattern</span>.<span title="(x$1: String)java.util.regex.Pattern">compile</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.regex" title="String">regex</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    catch <span class="delimiter">{</span>
      case <a title="java.util.regex.PatternSyntaxException" id="kafka.tools.ReplicaVerificationTool.main.e">e</a>: <span title="java.util.regex.PatternSyntaxException">PatternSyntaxException</span> =&gt;
        throw new <span title="RuntimeException">RuntimeException</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.regex" title="String">regex</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; is an invalid regex.&quot;)" class="string">&quot; is an invalid regex.&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    val <a title="Int" id="kafka.tools.ReplicaVerificationTool.main.fetchSize">fetchSize</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[Integer])Integer">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.fetchSizeOpt" title="joptsimple.ArgumentAcceptingOptionSpec[Integer]">fetchSizeOpt</a><span class="delimiter">)</span>.<span title="()Int">intValue</span>
    val <a title="Int" id="kafka.tools.ReplicaVerificationTool.main.maxWaitMs">maxWaitMs</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[Integer])Integer">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.maxWaitMsOpt" title="joptsimple.ArgumentAcceptingOptionSpec[Integer]">maxWaitMsOpt</a><span class="delimiter">)</span>.<span title="()Int">intValue</span>
    val <a title="Long" id="kafka.tools.ReplicaVerificationTool.main.initialOffsetTime">initialOffsetTime</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[Long])Long">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.initialOffsetTimeOpt" title="joptsimple.ArgumentAcceptingOptionSpec[Long]">initialOffsetTimeOpt</a><span class="delimiter">)</span>.<span title="()Long">longValue</span>
    val <a title="Long" id="kafka.tools.ReplicaVerificationTool.main.reportInterval">reportInterval</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[Long])Long">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.reportIntervalOpt" title="joptsimple.ArgumentAcceptingOptionSpec[Long]">reportIntervalOpt</a><span class="delimiter">)</span>.<span title="()Long">longValue</span>
    <span class="comment">// getting topic metadata</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="String(&quot;Getting topic metatdata...&quot;)" class="string">&quot;Getting topic metatdata...&quot;</span><span class="delimiter">)</span>
    val <a title="String" id="kafka.tools.ReplicaVerificationTool.main.brokerList">brokerList</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.options" title="joptsimple.OptionSet">options</a>.<span title="(x$1: joptsimple.OptionSpec[String])String">valueOf</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.brokerListOpt" title="joptsimple.ArgumentAcceptingOptionSpec[String]">brokerListOpt</a><span class="delimiter">)</span>
    <a href="../utils/ToolsUtils.scala.html#kafka.utils.ToolsUtils" title="kafka.utils.ToolsUtils.type">ToolsUtils</a>.<a href="../utils/ToolsUtils.scala.html#kafka.utils.ToolsUtils.validatePortOrDie" title="(parser: joptsimple.OptionParser, hostPort: String)Unit">validatePortOrDie</a><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.parser" title="joptsimple.OptionParser">parser</a>,<a href="#kafka.tools.ReplicaVerificationTool.main.brokerList" title="String">brokerList</a><span class="delimiter">)</span>
    val <a title="Seq[kafka.cluster.Broker]" id="kafka.tools.ReplicaVerificationTool.main.metadataTargetBrokers">metadataTargetBrokers</a> = <a href="../client/ClientUtils.scala.html#kafka.client.ClientUtils" title="kafka.client.ClientUtils.type">ClientUtils</a>.<a href="../client/ClientUtils.scala.html#kafka.client.ClientUtils.parseBrokerList" title="(brokerListStr: String)Seq[kafka.cluster.Broker]">parseBrokerList</a><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.brokerList" title="String">brokerList</a><span class="delimiter">)</span>
    val <a title="kafka.api.TopicMetadataResponse" id="kafka.tools.ReplicaVerificationTool.main.topicsMetadataResponse">topicsMetadataResponse</a> = <a href="../client/ClientUtils.scala.html#kafka.client.ClientUtils" title="kafka.client.ClientUtils.type">ClientUtils</a>.<a href="../client/ClientUtils.scala.html#kafka.client.ClientUtils.fetchTopicMetadata(6cf2a5b0cb)" title="(topics: scala.collection.Set[String], brokers: Seq[kafka.cluster.Broker], clientId: String, timeoutMs: Int, correlationId: Int)kafka.api.TopicMetadataResponse">fetchTopicMetadata</a><span class="delimiter">(</span><span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: String*)scala.collection.immutable.Set[String]" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#kafka.tools.ReplicaVerificationTool.main.metadataTargetBrokers" title="Seq[kafka.cluster.Broker]">metadataTargetBrokers</a>, <a href="#kafka.tools.ReplicaVerificationTool.clientId" title="=&gt; String">clientId</a>, <a href="#kafka.tools.ReplicaVerificationTool.main.maxWaitMs" title="Int">maxWaitMs</a><span class="delimiter">)</span>
    val <a title="scala.collection.immutable.Map[Int,kafka.cluster.Broker]" id="kafka.tools.ReplicaVerificationTool.main.brokerMap">brokerMap</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.topicsMetadataResponse" title="kafka.api.TopicMetadataResponse">topicsMetadataResponse</a>.<a href="../api/TopicMetadataResponse.scala.html#kafka.api;TopicMetadataResponse.brokers" title="=&gt; Seq[kafka.cluster.Broker]">brokers</a>.<span title="(f: kafka.cluster.Broker =&gt; (Int, kafka.cluster.Broker))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.cluster.Broker],(Int, kafka.cluster.Broker),Seq[(Int, kafka.cluster.Broker)]])Seq[(Int, kafka.cluster.Broker)]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,(Int, kafka.cluster.Broker),Seq[(Int, kafka.cluster.Broker)]]" class="delimiter">(</span><a title="kafka.cluster.Broker" id="kafka.tools.ReplicaVerificationTool.main.brokerMap.$anonfun.b">b</a> =&gt; <span title="(_1: Int, _2: kafka.cluster.Broker)(Int, kafka.cluster.Broker)" class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.brokerMap.$anonfun.b" title="kafka.cluster.Broker">b</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.id" title="=&gt; Int">id</a>, <a href="#kafka.tools.ReplicaVerificationTool.main.brokerMap.$anonfun.b" title="kafka.cluster.Broker">b</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: &lt;:&lt;[(Int, kafka.cluster.Broker),(Int, kafka.cluster.Broker)])scala.collection.immutable.Map[Int,kafka.cluster.Broker]">toMap</span>
    val <a title="Seq[kafka.api.TopicMetadata]" id="kafka.tools.ReplicaVerificationTool.main.filteredTopicMetadata">filteredTopicMetadata</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.topicsMetadataResponse" title="kafka.api.TopicMetadataResponse">topicsMetadataResponse</a>.<a href="../api/TopicMetadataResponse.scala.html#kafka.api;TopicMetadataResponse.topicsMetadata" title="=&gt; Seq[kafka.api.TopicMetadata]">topicsMetadata</a>.<span title="(p: kafka.api.TopicMetadata =&gt; Boolean)Seq[kafka.api.TopicMetadata]">filter</span><span class="delimiter">(</span>
        <a title="kafka.api.TopicMetadata" id="kafka.tools.ReplicaVerificationTool.main.filteredTopicMetadata.$anonfun.topicMetadata">topicMetadata</a> =&gt; if <span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.topicWhiteListFiler" title="kafka.consumer.Whitelist">topicWhiteListFiler</a>.<a href="../consumer/TopicFilter.scala.html#kafka.consumer;Whitelist.isTopicAllowed" title="(topic: String, excludeInternalTopics: Boolean)Boolean">isTopicAllowed</a><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.filteredTopicMetadata.$anonfun.topicMetadata" title="kafka.api.TopicMetadata">topicMetadata</a>.<a href="../api/TopicMetadata.scala.html#kafka.api;TopicMetadata.topic" title="=&gt; String">topic</a>, excludeInternalTopics = false<span class="delimiter">)</span><span class="delimiter">)</span>
          true
        else
          false
    <span class="delimiter">)</span>
    val <a title="Seq[kafka.tools.TopicPartitionReplica]" id="kafka.tools.ReplicaVerificationTool.main.topicPartitionReplicaList">topicPartitionReplicaList</a>: <span title="Seq[kafka.tools.TopicPartitionReplica]">Seq</span><span class="delimiter">[</span>TopicPartitionReplica<span class="delimiter">]</span> = <a href="#kafka.tools.ReplicaVerificationTool.main.filteredTopicMetadata" title="Seq[kafka.api.TopicMetadata]">filteredTopicMetadata</a>.<span title="(f: kafka.api.TopicMetadata =&gt; scala.collection.GenTraversableOnce[kafka.tools.TopicPartitionReplica])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.api.TopicMetadata],kafka.tools.TopicPartitionReplica,Seq[kafka.tools.TopicPartitionReplica]])Seq[kafka.tools.TopicPartitionReplica]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,kafka.tools.TopicPartitionReplica,Seq[kafka.tools.TopicPartitionReplica]]" class="delimiter">(</span>
      <a title="kafka.api.TopicMetadata" id="kafka.tools.ReplicaVerificationTool.main.topicPartitionReplicaList.$anonfun.topicMetadataResponse">topicMetadataResponse</a> =&gt;
        <a href="#kafka.tools.ReplicaVerificationTool.main.topicPartitionReplicaList.$anonfun.topicMetadataResponse" title="kafka.api.TopicMetadata">topicMetadataResponse</a>.<a href="../api/TopicMetadata.scala.html#kafka.api;TopicMetadata.partitionsMetadata" title="=&gt; Seq[kafka.api.PartitionMetadata]">partitionsMetadata</a>.<span title="(f: kafka.api.PartitionMetadata =&gt; scala.collection.GenTraversableOnce[kafka.tools.TopicPartitionReplica])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.api.PartitionMetadata],kafka.tools.TopicPartitionReplica,Seq[kafka.tools.TopicPartitionReplica]])Seq[kafka.tools.TopicPartitionReplica]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,kafka.tools.TopicPartitionReplica,Seq[kafka.tools.TopicPartitionReplica]]" class="delimiter">(</span>
          <a title="kafka.api.PartitionMetadata" id="kafka.tools.ReplicaVerificationTool.main.topicPartitionReplicaList.$anonfun.$anonfun.partitionMetadata">partitionMetadata</a> =&gt;
            <a href="#kafka.tools.ReplicaVerificationTool.main.topicPartitionReplicaList.$anonfun.$anonfun.partitionMetadata" title="kafka.api.PartitionMetadata">partitionMetadata</a>.<a href="../api/TopicMetadata.scala.html#kafka.api;PartitionMetadata.replicas" title="=&gt; Seq[kafka.cluster.Broker]">replicas</a>.<span title="(f: kafka.cluster.Broker =&gt; kafka.tools.TopicPartitionReplica)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.cluster.Broker],kafka.tools.TopicPartitionReplica,Seq[kafka.tools.TopicPartitionReplica]])Seq[kafka.tools.TopicPartitionReplica]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,kafka.tools.TopicPartitionReplica,Seq[kafka.tools.TopicPartitionReplica]]" class="delimiter">(</span><a title="kafka.cluster.Broker" id="kafka.tools.ReplicaVerificationTool.main.topicPartitionReplicaList.$anonfun.$anonfun.$anonfun.broker">broker</a> =&gt;
              <a href="#kafka.tools.TopicPartitionReplica.readResolve" title="(topic: String, partitionId: Int, replicaId: Int)kafka.tools.TopicPartitionReplica">TopicPartitionReplica</a><span class="delimiter">(</span>topic = <a href="#kafka.tools.ReplicaVerificationTool.main.topicPartitionReplicaList.$anonfun.topicMetadataResponse" title="kafka.api.TopicMetadata">topicMetadataResponse</a>.<a href="../api/TopicMetadata.scala.html#kafka.api;TopicMetadata.topic" title="=&gt; String">topic</a>, partitionId = <a href="#kafka.tools.ReplicaVerificationTool.main.topicPartitionReplicaList.$anonfun.$anonfun.partitionMetadata" title="kafka.api.PartitionMetadata">partitionMetadata</a>.<a href="../api/TopicMetadata.scala.html#kafka.api;PartitionMetadata.partitionId" title="=&gt; Int">partitionId</a>, replicaId = <a href="#kafka.tools.ReplicaVerificationTool.main.topicPartitionReplicaList.$anonfun.$anonfun.$anonfun.broker" title="kafka.cluster.Broker">broker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.id" title="=&gt; Int">id</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>
    <span class="delimiter">)</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Selected topic partitions: &quot;)" class="string">&quot;Selected topic partitions: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools.ReplicaVerificationTool.main.topicPartitionReplicaList" title="Seq[kafka.tools.TopicPartitionReplica]">topicPartitionReplicaList</a><span class="delimiter">)</span>
    val <a title="Map[Int,Seq[kafka.common.TopicAndPartition]]" id="kafka.tools.ReplicaVerificationTool.main.topicAndPartitionsPerBroker">topicAndPartitionsPerBroker</a>: <span title="Map[Int,Seq[kafka.common.TopicAndPartition]]">Map</span><span class="delimiter">[</span>Int, Seq<span class="delimiter">[</span>TopicAndPartition<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#kafka.tools.ReplicaVerificationTool.main.topicPartitionReplicaList" title="Seq[kafka.tools.TopicPartitionReplica]">topicPartitionReplicaList</a>.<span title="(f: kafka.tools.TopicPartitionReplica =&gt; Int)scala.collection.immutable.Map[Int,Seq[kafka.tools.TopicPartitionReplica]]">groupBy</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.topicAndPartitionsPerBroker.$anonfun.x$1" title="kafka.tools.TopicPartitionReplica">_</a>.<a href="#kafka.tools;TopicPartitionReplica.replicaId" title="=&gt; Int">replicaId</a><span class="delimiter">)</span>
      .<span title="(f: ((Int, Seq[kafka.tools.TopicPartitionReplica])) =&gt; (Int, Seq[kafka.common.TopicAndPartition]))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[Int,Seq[kafka.tools.TopicPartitionReplica]],(Int, Seq[kafka.common.TopicAndPartition]),Map[Int,Seq[kafka.common.TopicAndPartition]]])Map[Int,Seq[kafka.common.TopicAndPartition]]">map</span> <a href="#kafka.tools.ReplicaVerificationTool.main.topicAndPartitionsPerBroker.$anonfun.x0$1" title="(Int, Seq[kafka.common.TopicAndPartition])" class="delimiter">{</a> case <span class="delimiter">(</span><a title="Int" id="kafka.tools.ReplicaVerificationTool.main.topicAndPartitionsPerBroker.$anonfun.brokerId">brokerId</a>, <a title="Seq[kafka.tools.TopicPartitionReplica]" id="kafka.tools.ReplicaVerificationTool.main.topicAndPartitionsPerBroker.$anonfun.partitions">partitions</a><span class="delimiter">)</span> =&gt;
               <a href="#kafka.tools.ReplicaVerificationTool.main.topicAndPartitionsPerBroker.$anonfun.brokerId" title="(self: Int)ArrowAssoc[Int]">brokerId</a> <span title="(y: Seq[kafka.common.TopicAndPartition])(Int, Seq[kafka.common.TopicAndPartition])">-&gt;</span> <a href="#kafka.tools.ReplicaVerificationTool.main.topicAndPartitionsPerBroker.$anonfun.partitions" title="Seq[kafka.tools.TopicPartitionReplica]">partitions</a>.<span title="(f: kafka.tools.TopicPartitionReplica =&gt; kafka.common.TopicAndPartition)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.tools.TopicPartitionReplica],kafka.common.TopicAndPartition,Seq[kafka.common.TopicAndPartition]])Seq[kafka.common.TopicAndPartition]">map</span> <a href="#kafka.tools.ReplicaVerificationTool.main.topicAndPartitionsPerBroker.$anonfun.$anonfun.x0$2" title="kafka.common.TopicAndPartition" class="delimiter">{</a> case <a title="kafka.tools.TopicPartitionReplica" id="kafka.tools.ReplicaVerificationTool.main.topicAndPartitionsPerBroker.$anonfun.$anonfun.partition">partition</a> =&gt; new <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.topicAndPartitionsPerBroker.$anonfun.$anonfun.partition" title="kafka.tools.TopicPartitionReplica">partition</a>.<a href="#kafka.tools;TopicPartitionReplica.topic" title="=&gt; String">topic</a>, <a href="#kafka.tools.ReplicaVerificationTool.main.topicAndPartitionsPerBroker.$anonfun.$anonfun.partition" title="kafka.tools.TopicPartitionReplica">partition</a>.<a href="#kafka.tools;TopicPartitionReplica.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span> <span class="delimiter">}</span> <span class="delimiter">}</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Topic partitions per broker: &quot;)" class="string">&quot;Topic partitions per broker: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools.ReplicaVerificationTool.main.topicAndPartitionsPerBroker" title="Map[Int,Seq[kafka.common.TopicAndPartition]]">topicAndPartitionsPerBroker</a><span class="delimiter">)</span>
    val <a title="Map[kafka.common.TopicAndPartition,Int]" id="kafka.tools.ReplicaVerificationTool.main.expectedReplicasPerTopicAndPartition">expectedReplicasPerTopicAndPartition</a>: <span title="Map[kafka.common.TopicAndPartition,Int]">Map</span><span class="delimiter">[</span>TopicAndPartition, Int<span class="delimiter">]</span> =
          <a href="#kafka.tools.ReplicaVerificationTool.main.topicPartitionReplicaList" title="Seq[kafka.tools.TopicPartitionReplica]">topicPartitionReplicaList</a>.<span title="(f: kafka.tools.TopicPartitionReplica =&gt; kafka.common.TopicAndPartition)scala.collection.immutable.Map[kafka.common.TopicAndPartition,Seq[kafka.tools.TopicPartitionReplica]]">groupBy</span><span class="delimiter">(</span><a title="kafka.tools.TopicPartitionReplica" id="kafka.tools.ReplicaVerificationTool.main.expectedReplicasPerTopicAndPartition.$anonfun.replica">replica</a> =&gt; new <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.expectedReplicasPerTopicAndPartition.$anonfun.replica" title="kafka.tools.TopicPartitionReplica">replica</a>.<a href="#kafka.tools;TopicPartitionReplica.topic" title="=&gt; String">topic</a>, <a href="#kafka.tools.ReplicaVerificationTool.main.expectedReplicasPerTopicAndPartition.$anonfun.replica" title="kafka.tools.TopicPartitionReplica">replica</a>.<a href="#kafka.tools;TopicPartitionReplica.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span><span class="delimiter">)</span>
          .<span title="(f: ((kafka.common.TopicAndPartition, Seq[kafka.tools.TopicPartitionReplica])) =&gt; (kafka.common.TopicAndPartition, Int))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[kafka.common.TopicAndPartition,Seq[kafka.tools.TopicPartitionReplica]],(kafka.common.TopicAndPartition, Int),Map[kafka.common.TopicAndPartition,Int]])Map[kafka.common.TopicAndPartition,Int]">map</span> <a href="#kafka.tools.ReplicaVerificationTool.main.expectedReplicasPerTopicAndPartition.$anonfun.x0$3" title="(kafka.common.TopicAndPartition, Int)" class="delimiter">{</a> case <span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.tools.ReplicaVerificationTool.main.expectedReplicasPerTopicAndPartition.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="Seq[kafka.tools.TopicPartitionReplica]" id="kafka.tools.ReplicaVerificationTool.main.expectedReplicasPerTopicAndPartition.$anonfun.replicaSet">replicaSet</a><span class="delimiter">)</span> =&gt; <a href="#kafka.tools.ReplicaVerificationTool.main.expectedReplicasPerTopicAndPartition.$anonfun.topicAndPartition" title="(self: kafka.common.TopicAndPartition)ArrowAssoc[kafka.common.TopicAndPartition]">topicAndPartition</a> <span title="(y: Int)(kafka.common.TopicAndPartition, Int)">-&gt;</span> <a href="#kafka.tools.ReplicaVerificationTool.main.expectedReplicasPerTopicAndPartition.$anonfun.replicaSet" title="Seq[kafka.tools.TopicPartitionReplica]">replicaSet</a>.<span title="=&gt; Int">size</span> <span class="delimiter">}</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Expected replicas per topic partition: &quot;)" class="string">&quot;Expected replicas per topic partition: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools.ReplicaVerificationTool.main.expectedReplicasPerTopicAndPartition" title="Map[kafka.common.TopicAndPartition,Int]">expectedReplicasPerTopicAndPartition</a><span class="delimiter">)</span>
    val <a title="Map[Int,Seq[kafka.common.TopicAndPartition]]" id="kafka.tools.ReplicaVerificationTool.main.leadersPerBroker">leadersPerBroker</a>: <span title="Map[Int,Seq[kafka.common.TopicAndPartition]]">Map</span><span class="delimiter">[</span>Int, Seq<span class="delimiter">[</span>TopicAndPartition<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#kafka.tools.ReplicaVerificationTool.main.filteredTopicMetadata" title="Seq[kafka.api.TopicMetadata]">filteredTopicMetadata</a>.<span title="(f: kafka.api.TopicMetadata =&gt; scala.collection.GenTraversableOnce[(kafka.common.TopicAndPartition, Int)])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.api.TopicMetadata],(kafka.common.TopicAndPartition, Int),Seq[(kafka.common.TopicAndPartition, Int)]])Seq[(kafka.common.TopicAndPartition, Int)]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,(kafka.common.TopicAndPartition, Int),Seq[(kafka.common.TopicAndPartition, Int)]]" class="delimiter">(</span>
      <a title="kafka.api.TopicMetadata" id="kafka.tools.ReplicaVerificationTool.main.leadersPerBroker.$anonfun.topicMetadataResponse">topicMetadataResponse</a> =&gt;
        <a href="#kafka.tools.ReplicaVerificationTool.main.leadersPerBroker.$anonfun.topicMetadataResponse" title="kafka.api.TopicMetadata">topicMetadataResponse</a>.<a href="../api/TopicMetadata.scala.html#kafka.api;TopicMetadata.partitionsMetadata" title="=&gt; Seq[kafka.api.PartitionMetadata]">partitionsMetadata</a>.<span title="(f: kafka.api.PartitionMetadata =&gt; (kafka.common.TopicAndPartition, Int))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.api.PartitionMetadata],(kafka.common.TopicAndPartition, Int),Seq[(kafka.common.TopicAndPartition, Int)]])Seq[(kafka.common.TopicAndPartition, Int)]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,(kafka.common.TopicAndPartition, Int),Seq[(kafka.common.TopicAndPartition, Int)]]" class="delimiter">(</span>
          <a title="kafka.api.PartitionMetadata" id="kafka.tools.ReplicaVerificationTool.main.leadersPerBroker.$anonfun.$anonfun.partitionMetadata">partitionMetadata</a> =&gt;
            <span title="(_1: kafka.common.TopicAndPartition, _2: Int)(kafka.common.TopicAndPartition, Int)" class="delimiter">(</span>new <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.leadersPerBroker.$anonfun.topicMetadataResponse" title="kafka.api.TopicMetadata">topicMetadataResponse</a>.<a href="../api/TopicMetadata.scala.html#kafka.api;TopicMetadata.topic" title="=&gt; String">topic</a>, <a href="#kafka.tools.ReplicaVerificationTool.main.leadersPerBroker.$anonfun.$anonfun.partitionMetadata" title="kafka.api.PartitionMetadata">partitionMetadata</a>.<a href="../api/TopicMetadata.scala.html#kafka.api;PartitionMetadata.partitionId" title="=&gt; Int">partitionId</a><span class="delimiter">)</span>, <a href="#kafka.tools.ReplicaVerificationTool.main.leadersPerBroker.$anonfun.$anonfun.partitionMetadata" title="kafka.api.PartitionMetadata">partitionMetadata</a>.<a href="../api/TopicMetadata.scala.html#kafka.api;PartitionMetadata.leader" title="=&gt; Option[kafka.cluster.Broker]">leader</a>.<span title="=&gt; kafka.cluster.Broker">get</span>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.id" title="=&gt; Int">id</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>.<span title="(f: ((kafka.common.TopicAndPartition, Int)) =&gt; Int)scala.collection.immutable.Map[Int,Seq[(kafka.common.TopicAndPartition, Int)]]">groupBy</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.leadersPerBroker.$anonfun.x$2" title="(kafka.common.TopicAndPartition, Int)">_</a>.<span title="=&gt; Int">_2</span><span class="delimiter">)</span>
     .<span title="(f: Seq[(kafka.common.TopicAndPartition, Int)] =&gt; Seq[kafka.common.TopicAndPartition])scala.collection.immutable.Map[Int,Seq[kafka.common.TopicAndPartition]]">mapValues</span><span class="delimiter">(</span><a title="Seq[(kafka.common.TopicAndPartition, Int)]" id="kafka.tools.ReplicaVerificationTool.main.leadersPerBroker.$anonfun.topicAndPartitionAndLeaderIds">topicAndPartitionAndLeaderIds</a> =&gt; <a href="#kafka.tools.ReplicaVerificationTool.main.leadersPerBroker.$anonfun.topicAndPartitionAndLeaderIds" title="Seq[(kafka.common.TopicAndPartition, Int)]">topicAndPartitionAndLeaderIds</a>.<span title="(f: ((kafka.common.TopicAndPartition, Int)) =&gt; kafka.common.TopicAndPartition)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(kafka.common.TopicAndPartition, Int)],kafka.common.TopicAndPartition,Seq[kafka.common.TopicAndPartition]])Seq[kafka.common.TopicAndPartition]">map</span> <a href="#kafka.tools.ReplicaVerificationTool.main.leadersPerBroker.$anonfun.$anonfun.x0$4" title="kafka.common.TopicAndPartition" class="delimiter">{</a>
        case<span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.tools.ReplicaVerificationTool.main.leadersPerBroker.$anonfun.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="Int" id="kafka.tools.ReplicaVerificationTool.main.leadersPerBroker.$anonfun.$anonfun.leaderId">leaderId</a><span class="delimiter">)</span> =&gt; <a href="#kafka.tools.ReplicaVerificationTool.main.leadersPerBroker.$anonfun.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a> <span class="delimiter">}</span><span class="delimiter">)</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Leaders per broker: &quot;)" class="string">&quot;Leaders per broker: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools.ReplicaVerificationTool.main.leadersPerBroker" title="Map[Int,Seq[kafka.common.TopicAndPartition]]">leadersPerBroker</a><span class="delimiter">)</span>

    val <a title="kafka.tools.ReplicaBuffer" id="kafka.tools.ReplicaVerificationTool.main.replicaBuffer">replicaBuffer</a> = new <a href="#kafka.tools;ReplicaBuffer" title="kafka.tools.ReplicaBuffer">ReplicaBuffer</a><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.expectedReplicasPerTopicAndPartition" title="Map[kafka.common.TopicAndPartition,Int]">expectedReplicasPerTopicAndPartition</a>,
                                          <a href="#kafka.tools.ReplicaVerificationTool.main.leadersPerBroker" title="Map[Int,Seq[kafka.common.TopicAndPartition]]">leadersPerBroker</a>,
                                          <a href="#kafka.tools.ReplicaVerificationTool.main.topicAndPartitionsPerBroker" title="Map[Int,Seq[kafka.common.TopicAndPartition]]">topicAndPartitionsPerBroker</a>.<span title="=&gt; Int">size</span>,
                                          <a href="#kafka.tools.ReplicaVerificationTool.main.brokerMap" title="scala.collection.immutable.Map[Int,kafka.cluster.Broker]">brokerMap</a>,
                                          <a href="#kafka.tools.ReplicaVerificationTool.main.initialOffsetTime" title="Long">initialOffsetTime</a>,
                                          <a href="#kafka.tools.ReplicaVerificationTool.main.reportInterval" title="Long">reportInterval</a><span class="delimiter">)</span>
    <span class="comment">// create all replica fetcher threads</span>
    val <a title="Int" id="kafka.tools.ReplicaVerificationTool.main.verificationBrokerId">verificationBrokerId</a> = <a href="#kafka.tools.ReplicaVerificationTool.main.topicAndPartitionsPerBroker" title="Map[Int,Seq[kafka.common.TopicAndPartition]]">topicAndPartitionsPerBroker</a>.<span title="=&gt; (Int, Seq[kafka.common.TopicAndPartition])">head</span>.<span title="=&gt; Int">_1</span>
    val <a title="Iterable[kafka.tools.ReplicaFetcher]" id="kafka.tools.ReplicaVerificationTool.main.fetcherThreads">fetcherThreads</a>: <span title="Iterable[kafka.tools.ReplicaFetcher]">Iterable</span><span class="delimiter">[</span>ReplicaFetcher<span class="delimiter">]</span> = <a href="#kafka.tools.ReplicaVerificationTool.main.topicAndPartitionsPerBroker" title="Map[Int,Seq[kafka.common.TopicAndPartition]]">topicAndPartitionsPerBroker</a>.<span title="(f: ((Int, Seq[kafka.common.TopicAndPartition])) =&gt; kafka.tools.ReplicaFetcher)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[Int,Seq[kafka.common.TopicAndPartition]],kafka.tools.ReplicaFetcher,Iterable[kafka.tools.ReplicaFetcher]])Iterable[kafka.tools.ReplicaFetcher]">map</span> <a href="#kafka.tools.ReplicaVerificationTool.main.fetcherThreads.$anonfun.x0$5" title="kafka.tools.ReplicaFetcher" class="delimiter">{</a>
      case <span class="delimiter">(</span><a title="Int" id="kafka.tools.ReplicaVerificationTool.main.fetcherThreads.$anonfun.brokerId">brokerId</a>, <a title="Seq[kafka.common.TopicAndPartition]" id="kafka.tools.ReplicaVerificationTool.main.fetcherThreads.$anonfun.topicAndPartitions">topicAndPartitions</a><span class="delimiter">)</span> =&gt;
        new <a href="#kafka.tools;ReplicaFetcher" title="kafka.tools.ReplicaFetcher">ReplicaFetcher</a><span class="delimiter">(</span>name = <span title="String(&quot;ReplicaFetcher-&quot;)" class="string">&quot;ReplicaFetcher-&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools.ReplicaVerificationTool.main.fetcherThreads.$anonfun.brokerId" title="Int">brokerId</a>,
                           sourceBroker = <a href="#kafka.tools.ReplicaVerificationTool.main.brokerMap" title="(key: Int)kafka.cluster.Broker">brokerMap</a><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.fetcherThreads.$anonfun.brokerId" title="Int">brokerId</a><span class="delimiter">)</span>,
                           topicAndPartitions = <a href="#kafka.tools.ReplicaVerificationTool.main.fetcherThreads.$anonfun.topicAndPartitions" title="Seq[kafka.common.TopicAndPartition]">topicAndPartitions</a>,
                           replicaBuffer = <a href="#kafka.tools.ReplicaVerificationTool.main.replicaBuffer" title="kafka.tools.ReplicaBuffer">replicaBuffer</a>,
                           socketTimeout = <span title="Int(30000)" class="int">30000</span>,
                           socketBufferSize = <span title="Int(256000)" class="int">256000</span>,
                           fetchSize = <a href="#kafka.tools.ReplicaVerificationTool.main.fetchSize" title="Int">fetchSize</a>,
                           maxWait = <a href="#kafka.tools.ReplicaVerificationTool.main.maxWaitMs" title="Int">maxWaitMs</a>,
                           minBytes = <span title="Int(1)" class="int">1</span>,
                           doVerification = <span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.fetcherThreads.$anonfun.brokerId" title="Int">brokerId</a> <span title="(x: Int)Boolean">==</span> <a href="#kafka.tools.ReplicaVerificationTool.main.verificationBrokerId" title="Int">verificationBrokerId</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span title="Runtime.type">Runtime</span>.<span title="()Runtime">getRuntime</span>.<span title="(x$1: Thread)Unit">addShutdownHook</span><span class="delimiter">(</span>new <a title="&lt;$anon: Thread&gt; extends Thread" id="kafka.tools.ReplicaVerificationTool.main;$anon">Thread</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      override def <a title="()Unit" id="kafka.tools.ReplicaVerificationTool.main;$anon.run">run</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="../utils/Logging.scala.html#kafka.utils;Logging.info(1729dbc42f)" title="(msg: =&gt; String)Unit">info</a><span class="delimiter">(</span><span title="String(&quot;Stopping all fetchers&quot;)" class="string">&quot;Stopping all fetchers&quot;</span><span class="delimiter">)</span>
        <a href="#kafka.tools.ReplicaVerificationTool.main.fetcherThreads" title="Iterable[kafka.tools.ReplicaFetcher]">fetcherThreads</a>.<span title="(f: kafka.tools.ReplicaFetcher =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main;$anon.run.$anonfun.x$3" title="kafka.tools.ReplicaFetcher">_</a>.<a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread.shutdown" title="()Unit">shutdown</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>
    <a href="#kafka.tools.ReplicaVerificationTool.main.fetcherThreads" title="Iterable[kafka.tools.ReplicaFetcher]">fetcherThreads</a>.<span title="(f: kafka.tools.ReplicaFetcher =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool.main.$anonfun.x$4" title="kafka.tools.ReplicaFetcher">_</a>.<span title="()Unit">start</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool" title="kafka.tools.ReplicaVerificationTool.type">ReplicaVerificationTool</a>.<a href="#kafka.tools.ReplicaVerificationTool.getCurrentTimeString" title="()String">getCurrentTimeString</a><span class="delimiter">(</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;: verification process is started.&quot;)" class="string">&quot;: verification process is started.&quot;</span><span class="delimiter">)</span>

  <span class="delimiter">}</span>
<span class="delimiter">}</span>

private case class <a title="class TopicPartitionReplica extends AnyRef with Product with Serializable" id="kafka.tools.TopicPartitionReplica.readResolve">TopicPartitionReplica</a><a href="#kafka.tools.TopicPartitionReplica.readResolve" title="Product" class="delimiter">(</a><a title="String" id="kafka.tools;TopicPartitionReplica.topic">topic</a>: <span title="String">String</span>,  <a title="Int" id="kafka.tools;TopicPartitionReplica.partitionId">partitionId</a>: <span title="Int">Int</span>,  <a title="Int" id="kafka.tools;TopicPartitionReplica.replicaId">replicaId</a>: <span title="Int">Int</span><span class="delimiter">)</span>

private case class <a title="class ReplicaAndMessageIterator extends AnyRef with Product with Serializable" id="kafka.tools.ReplicaAndMessageIterator.readResolve">ReplicaAndMessageIterator</a><a href="#kafka.tools.ReplicaAndMessageIterator.readResolve" title="Product" class="delimiter">(</a><a title="Int" id="kafka.tools;ReplicaAndMessageIterator.replicaId">replicaId</a>: <span title="Int">Int</span>, <a title="Iterator[kafka.message.MessageAndOffset]" id="kafka.tools;ReplicaAndMessageIterator.iterator">iterator</a>: <span title="Iterator[kafka.message.MessageAndOffset]">Iterator</span><span class="delimiter">[</span>MessageAndOffset<span class="delimiter">]</span><span class="delimiter">)</span>

private case class <a title="class MessageInfo extends AnyRef with Product with Serializable" id="kafka.tools.MessageInfo.readResolve">MessageInfo</a><a href="#kafka.tools.MessageInfo.readResolve" title="Product" class="delimiter">(</a><a title="Int" id="kafka.tools;MessageInfo.replicaId">replicaId</a>: <span title="Int">Int</span>, <a title="Long" id="kafka.tools;MessageInfo.offset">offset</a>: <span title="Long">Long</span>, <a title="Long" id="kafka.tools;MessageInfo.nextOffset">nextOffset</a>: <span title="Long">Long</span>, <a title="Long" id="kafka.tools;MessageInfo.checksum">checksum</a>: <span title="Long">Long</span><span class="delimiter">)</span>

private class <a title="class ReplicaBuffer extends AnyRef with kafka.utils.Logging" id="kafka.tools;ReplicaBuffer">ReplicaBuffer</a><a href="#kafka.tools;ReplicaBuffer" title="kafka.tools.ReplicaBuffer" class="delimiter">(</a><a title="Map[kafka.common.TopicAndPartition,Int]" id="kafka.tools;ReplicaBuffer.expectedReplicasPerTopicAndPartition">expectedReplicasPerTopicAndPartition</a>: <span title="Map[kafka.common.TopicAndPartition,Int]">Map</span><span class="delimiter">[</span>TopicAndPartition, Int<span class="delimiter">]</span>,
                            <a title="Map[Int,Seq[kafka.common.TopicAndPartition]]" id="kafka.tools;ReplicaBuffer.leadersPerBroker">leadersPerBroker</a>: <span title="Map[Int,Seq[kafka.common.TopicAndPartition]]">Map</span><span class="delimiter">[</span>Int, Seq<span class="delimiter">[</span>TopicAndPartition<span class="delimiter">]</span><span class="delimiter">]</span>,
                            <a title="Int" id="kafka.tools;ReplicaBuffer.expectedNumFetchers">expectedNumFetchers</a>: <span title="Int">Int</span>,
                            <a title="Map[Int,kafka.cluster.Broker]" id="kafka.tools;ReplicaBuffer.brokerMap">brokerMap</a>: <span title="Map[Int,kafka.cluster.Broker]">Map</span><span class="delimiter">[</span>Int, Broker<span class="delimiter">]</span>,
                            <a title="Long" id="kafka.tools;ReplicaBuffer.initialOffsetTime">initialOffsetTime</a>: <span title="Long">Long</span>,
                            <a title="Long" id="kafka.tools;ReplicaBuffer.reportInterval">reportInterval</a>: <span title="Long">Long</span><span class="delimiter">)</span> extends <a href="../utils/Logging.scala.html#kafka.utils;Logging" title="kafka.utils.Logging">Logging</a> <span class="delimiter">{</span>
  private val <a title="kafka.utils.Pool[kafka.common.TopicAndPartition,Long]" id="kafka.tools;ReplicaBuffer.fetchOffsetMap">fetchOffsetMap</a> = new <a href="../utils/Pool.scala.html#kafka.utils;Pool" title="kafka.utils.Pool[kafka.common.TopicAndPartition,Long]">Pool</a><span class="delimiter">[</span>TopicAndPartition, Long<span class="delimiter">]</span>
  private val <a title="kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData]]" id="kafka.tools;ReplicaBuffer.messageSetCache">messageSetCache</a> = new <a href="../utils/Pool.scala.html#kafka.utils;Pool" title="kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData]]">Pool</a><span class="delimiter">[</span>TopicAndPartition, Pool<span class="delimiter">[</span>Int, FetchResponsePartitionData<span class="delimiter">]</span><span class="delimiter">]</span>
  private val <a title="java.util.concurrent.atomic.AtomicReference[java.util.concurrent.CountDownLatch]" id="kafka.tools;ReplicaBuffer.fetcherBarrier">fetcherBarrier</a> = new <span title="java.util.concurrent.atomic.AtomicReference[java.util.concurrent.CountDownLatch]">AtomicReference</span><span class="delimiter">(</span>new <span title="java.util.concurrent.CountDownLatch">CountDownLatch</span><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.expectedNumFetchers" title="Int">expectedNumFetchers</a><span class="delimiter">)</span><span class="delimiter">)</span>
  private val <a title="java.util.concurrent.atomic.AtomicReference[java.util.concurrent.CountDownLatch]" id="kafka.tools;ReplicaBuffer.verificationBarrier">verificationBarrier</a> = new <span title="java.util.concurrent.atomic.AtomicReference[java.util.concurrent.CountDownLatch]">AtomicReference</span><span class="delimiter">(</span>new <span title="java.util.concurrent.CountDownLatch">CountDownLatch</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
  @volatile private var <a title="Long" id="kafka.tools;ReplicaBuffer.lastReportTime_=">lastReportTime</a> = <a href="../utils/Time.scala.html#kafka.utils.SystemTime" title="kafka.utils.SystemTime.type">SystemTime</a>.<a href="../utils/Time.scala.html#kafka.utils.SystemTime.milliseconds" title="=&gt; Long">milliseconds</a>
  private var <a title="Long" id="kafka.tools;ReplicaBuffer.maxLag_=">maxLag</a>: <span title="Long">Long</span> = -<span title="Long(-1L)" class="long">1L</span>
  private var <a title="Long" id="kafka.tools;ReplicaBuffer.offsetWithMaxLag_=">offsetWithMaxLag</a>: <span title="Long">Long</span> = -<span title="Long(-1L)" class="long">1L</span>
  private var <a title="kafka.common.TopicAndPartition" id="kafka.tools;ReplicaBuffer.maxLagTopicAndPartition_=">maxLagTopicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a> = null
  <a href="#kafka.tools;ReplicaBuffer.initialize" title="()Unit">initialize</a><span class="delimiter">(</span><span class="delimiter">)</span>

  def <a title="()Unit" id="kafka.tools;ReplicaBuffer.createNewFetcherBarrier">createNewFetcherBarrier</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.tools;ReplicaBuffer.fetcherBarrier" title="=&gt; java.util.concurrent.atomic.AtomicReference[java.util.concurrent.CountDownLatch]">fetcherBarrier</a>.<span title="(x$1: java.util.concurrent.CountDownLatch)Unit">set</span><span class="delimiter">(</span>new <span title="java.util.concurrent.CountDownLatch">CountDownLatch</span><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.expectedNumFetchers" title="Int">expectedNumFetchers</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="()java.util.concurrent.CountDownLatch" id="kafka.tools;ReplicaBuffer.getFetcherBarrier">getFetcherBarrier</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="#kafka.tools;ReplicaBuffer.fetcherBarrier" title="=&gt; java.util.concurrent.atomic.AtomicReference[java.util.concurrent.CountDownLatch]">fetcherBarrier</a>.<span title="()java.util.concurrent.CountDownLatch">get</span><span class="delimiter">(</span><span class="delimiter">)</span>

  def <a title="()Unit" id="kafka.tools;ReplicaBuffer.createNewVerificationBarrier">createNewVerificationBarrier</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.tools;ReplicaBuffer.verificationBarrier" title="=&gt; java.util.concurrent.atomic.AtomicReference[java.util.concurrent.CountDownLatch]">verificationBarrier</a>.<span title="(x$1: java.util.concurrent.CountDownLatch)Unit">set</span><span class="delimiter">(</span>new <span title="java.util.concurrent.CountDownLatch">CountDownLatch</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="()java.util.concurrent.CountDownLatch" id="kafka.tools;ReplicaBuffer.getVerificationBarrier">getVerificationBarrier</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="#kafka.tools;ReplicaBuffer.verificationBarrier" title="=&gt; java.util.concurrent.atomic.AtomicReference[java.util.concurrent.CountDownLatch]">verificationBarrier</a>.<span title="()java.util.concurrent.CountDownLatch">get</span><span class="delimiter">(</span><span class="delimiter">)</span>

  private def <a title="()Unit" id="kafka.tools;ReplicaBuffer.initialize">initialize</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    for <span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.tools;ReplicaBuffer.initialize.$anonfun.topicAndPartition">topicAndPartition</a> &lt;- <a href="#kafka.tools;ReplicaBuffer.expectedReplicasPerTopicAndPartition" title="Map[kafka.common.TopicAndPartition,Int]">expectedReplicasPerTopicAndPartition</a>.<span title="(f: kafka.common.TopicAndPartition =&gt; kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData])Unit">keySet</span><span class="delimiter">)</span>
      <a href="#kafka.tools;ReplicaBuffer.messageSetCache" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData]]">messageSetCache</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.put" title="(k: kafka.common.TopicAndPartition, v: kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData])kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData]">put</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.initialize.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, new <a href="../utils/Pool.scala.html#kafka.utils;Pool" title="kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData]">Pool</a><span class="delimiter">[</span>Int, FetchResponsePartitionData<span class="delimiter">]</span><span class="delimiter">)</span>
    <a href="#kafka.tools;ReplicaBuffer.setInitialOffsets" title="()Unit">setInitialOffsets</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private def <a title="(offsetResponse: kafka.api.OffsetResponse)String" id="kafka.tools;ReplicaBuffer.offsetResponseStringWithError">offsetResponseStringWithError</a><span class="delimiter">(</span><a title="kafka.api.OffsetResponse" id="kafka.tools;ReplicaBuffer.offsetResponseStringWithError.offsetResponse">offsetResponse</a>: <a href="../api/OffsetResponse.scala.html#kafka.api;OffsetResponse" title="kafka.api.OffsetResponse">OffsetResponse</a><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    <a href="#kafka.tools;ReplicaBuffer.offsetResponseStringWithError.offsetResponse" title="kafka.api.OffsetResponse">offsetResponse</a>.<a href="../api/OffsetResponse.scala.html#kafka.api;OffsetResponse.partitionErrorAndOffsets" title="=&gt; Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetsResponse]">partitionErrorAndOffsets</a>.<span title="(p: ((kafka.common.TopicAndPartition, kafka.api.PartitionOffsetsResponse)) =&gt; Boolean)scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetsResponse]">filter</span> <a href="#kafka.tools;ReplicaBuffer.offsetResponseStringWithError.$anonfun.x0$6" title="Boolean" class="delimiter">{</a>
      case <span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.tools;ReplicaBuffer.offsetResponseStringWithError.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="kafka.api.PartitionOffsetsResponse" id="kafka.tools;ReplicaBuffer.offsetResponseStringWithError.$anonfun.partitionOffsetsResponse">partitionOffsetsResponse</a><span class="delimiter">)</span> =&gt; <a href="#kafka.tools;ReplicaBuffer.offsetResponseStringWithError.$anonfun.partitionOffsetsResponse" title="kafka.api.PartitionOffsetsResponse">partitionOffsetsResponse</a>.<a href="../api/OffsetResponse.scala.html#kafka.api;PartitionOffsetsResponse.error" title="=&gt; Short">error</a> <span title="(x: Short)Boolean">!=</span> <a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping" title="kafka.common.ErrorMapping.type">ErrorMapping</a>.<a href="../common/ErrorMapping.scala.html#kafka.common.ErrorMapping.NoError" title="=&gt; Short">NoError</a>
    <span class="delimiter">}</span>.<span title="=&gt; String">mkString</span>
  <span class="delimiter">}</span>

  private def <a title="()Unit" id="kafka.tools;ReplicaBuffer.setInitialOffsets">setInitialOffsets</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    for <span class="delimiter">(</span><span class="delimiter">(</span><a title="Int" id="kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.brokerId">brokerId</a>, <a title="Seq[kafka.common.TopicAndPartition]" id="kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.topicAndPartitions">topicAndPartitions</a><span class="delimiter">)</span> &lt;- <a href="#kafka.tools;ReplicaBuffer.leadersPerBroker" title="(f: ((Int, Seq[kafka.common.TopicAndPartition])) =&gt; Unit)Unit">leadersPerBroker</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="kafka.cluster.Broker" id="kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.broker">broker</a> = <a href="#kafka.tools;ReplicaBuffer.brokerMap" title="(key: Int)kafka.cluster.Broker">brokerMap</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.brokerId" title="Int">brokerId</a><span class="delimiter">)</span>
      val <a title="kafka.consumer.SimpleConsumer" id="kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.consumer">consumer</a> = new <a href="../consumer/SimpleConsumer.scala.html#kafka.consumer;SimpleConsumer" title="kafka.consumer.SimpleConsumer">SimpleConsumer</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.broker" title="kafka.cluster.Broker">broker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.host" title="=&gt; String">host</a>, <a href="#kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.broker" title="kafka.cluster.Broker">broker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.port" title="=&gt; Int">port</a>, <span title="Int(10000)" class="int">10000</span>, <span title="Int(100000)" class="int">100000</span>, <a href="#kafka.tools.ReplicaVerificationTool" title="kafka.tools.ReplicaVerificationTool.type">ReplicaVerificationTool</a>.<a href="#kafka.tools.ReplicaVerificationTool.clientId" title="=&gt; String">clientId</a><span class="delimiter">)</span>
      val <a title="Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetRequestInfo]" id="kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.initialOffsetMap">initialOffsetMap</a>: <span title="Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetRequestInfo]">Map</span><span class="delimiter">[</span>TopicAndPartition, PartitionOffsetRequestInfo<span class="delimiter">]</span> =
        <a href="#kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.topicAndPartitions" title="Seq[kafka.common.TopicAndPartition]">topicAndPartitions</a>.<span title="(f: kafka.common.TopicAndPartition =&gt; (kafka.common.TopicAndPartition, kafka.api.PartitionOffsetRequestInfo))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[kafka.common.TopicAndPartition],(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetRequestInfo),Seq[(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetRequestInfo)]])Seq[(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetRequestInfo)]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetRequestInfo),Seq[(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetRequestInfo)]]" class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.initialOffsetMap.$anonfun.topicAndPartition">topicAndPartition</a> =&gt; <a href="#kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.initialOffsetMap.$anonfun.topicAndPartition" title="(self: kafka.common.TopicAndPartition)ArrowAssoc[kafka.common.TopicAndPartition]">topicAndPartition</a> <span title="(y: kafka.api.PartitionOffsetRequestInfo)(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetRequestInfo)">-&gt;</span> <a href="../api/OffsetRequest.scala.html#kafka.api;PartitionOffsetRequestInfo" title="(time: Long, maxNumOffsets: Int)kafka.api.PartitionOffsetRequestInfo">PartitionOffsetRequestInfo</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.initialOffsetTime" title="Long">initialOffsetTime</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(implicit ev: &lt;:&lt;[(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetRequestInfo),(kafka.common.TopicAndPartition, kafka.api.PartitionOffsetRequestInfo)])scala.collection.immutable.Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetRequestInfo]">toMap</span>
      val <a title="kafka.api.OffsetRequest" id="kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.offsetRequest">offsetRequest</a> = <a href="../api/OffsetRequest.scala.html#kafka.api;OffsetRequest" title="(requestInfo: Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetRequestInfo], versionId: Short, correlationId: Int, clientId: String, replicaId: Int)kafka.api.OffsetRequest">OffsetRequest</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.initialOffsetMap" title="Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetRequestInfo]">initialOffsetMap</a><span class="delimiter">)</span>
      val <a title="kafka.api.OffsetResponse" id="kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.offsetResponse">offsetResponse</a> = <a href="#kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.consumer" title="kafka.consumer.SimpleConsumer">consumer</a>.<a href="../consumer/SimpleConsumer.scala.html#kafka.consumer;SimpleConsumer.getOffsetsBefore" title="(request: kafka.api.OffsetRequest)kafka.api.OffsetResponse">getOffsetsBefore</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.offsetRequest" title="kafka.api.OffsetRequest">offsetRequest</a><span class="delimiter">)</span>
      <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.offsetResponse" title="kafka.api.OffsetResponse">offsetResponse</a>.<a href="../api/OffsetResponse.scala.html#kafka.api;OffsetResponse.hasError" title="=&gt; Boolean">hasError</a>, <a href="#kafka.tools;ReplicaBuffer.offsetResponseStringWithError" title="(offsetResponse: kafka.api.OffsetResponse)String">offsetResponseStringWithError</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.offsetResponse" title="kafka.api.OffsetResponse">offsetResponse</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.offsetResponse" title="kafka.api.OffsetResponse">offsetResponse</a>.<a href="../api/OffsetResponse.scala.html#kafka.api;OffsetResponse.partitionErrorAndOffsets" title="=&gt; Map[kafka.common.TopicAndPartition,kafka.api.PartitionOffsetsResponse]">partitionErrorAndOffsets</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.api.PartitionOffsetsResponse)) =&gt; Long)Unit">foreach</span><a href="#kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.$anonfun.x0$7" title="Long" class="delimiter">{</a>
        case <span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="kafka.api.PartitionOffsetsResponse" id="kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.$anonfun.partitionOffsetResponse">partitionOffsetResponse</a><span class="delimiter">)</span> =&gt;
          <a href="#kafka.tools;ReplicaBuffer.fetchOffsetMap" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,Long]">fetchOffsetMap</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.put" title="(k: kafka.common.TopicAndPartition, v: Long)Long">put</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.tools;ReplicaBuffer.setInitialOffsets.$anonfun.$anonfun.partitionOffsetResponse" title="kafka.api.PartitionOffsetsResponse">partitionOffsetResponse</a>.<a href="../api/OffsetResponse.scala.html#kafka.api;PartitionOffsetsResponse.offsets" title="=&gt; Seq[Long]">offsets</a>.<span title="=&gt; Long">head</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(topicAndPartition: kafka.common.TopicAndPartition, replicaId: Int, partitionData: kafka.api.FetchResponsePartitionData)Unit" id="kafka.tools;ReplicaBuffer.addFetchedData">addFetchedData</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.tools;ReplicaBuffer.addFetchedData.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a>, <a title="Int" id="kafka.tools;ReplicaBuffer.addFetchedData.replicaId">replicaId</a>: <span title="Int">Int</span>, <a title="kafka.api.FetchResponsePartitionData" id="kafka.tools;ReplicaBuffer.addFetchedData.partitionData">partitionData</a>: <a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData" title="kafka.api.FetchResponsePartitionData">FetchResponsePartitionData</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#kafka.tools;ReplicaBuffer.messageSetCache" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData]]">messageSetCache</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.get" title="(key: kafka.common.TopicAndPartition)kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData]">get</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.addFetchedData.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.put" title="(k: Int, v: kafka.api.FetchResponsePartitionData)kafka.api.FetchResponsePartitionData">put</a><span title="Unit" class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.addFetchedData.replicaId" title="Int">replicaId</a>, <a href="#kafka.tools;ReplicaBuffer.addFetchedData.partitionData" title="kafka.api.FetchResponsePartitionData">partitionData</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(topicAndPartition: kafka.common.TopicAndPartition)Long" id="kafka.tools;ReplicaBuffer.getOffset">getOffset</a><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.tools;ReplicaBuffer.getOffset.topicAndPartition">topicAndPartition</a>: <a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition" title="kafka.common.TopicAndPartition">TopicAndPartition</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#kafka.tools;ReplicaBuffer.fetchOffsetMap" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,Long]">fetchOffsetMap</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.get" title="(key: kafka.common.TopicAndPartition)Long">get</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.getOffset.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="()Unit" id="kafka.tools;ReplicaBuffer.verifyCheckSum">verifyCheckSum</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Begin verification&quot;)" class="string">&quot;Begin verification&quot;</span><span class="delimiter">)</span>
    <a href="#kafka.tools;ReplicaBuffer.maxLag_=" title="(x$1: Long)Unit">maxLag</a> = -<span title="Long(-1L)" class="long">1L</span>
    for <span class="delimiter">(</span><span class="delimiter">(</span><a title="kafka.common.TopicAndPartition" id="kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.topicAndPartition">topicAndPartition</a>, <a title="kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData]" id="kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.fetchResponsePerReplica">fetchResponsePerReplica</a><span class="delimiter">)</span> &lt;- <a href="#kafka.tools;ReplicaBuffer.messageSetCache" title="(f: ((kafka.common.TopicAndPartition, kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData])) =&gt; Unit)Unit">messageSetCache</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Verifying &quot;)" class="string">&quot;Verifying &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
      <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.fetchResponsePerReplica" title="kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData]">fetchResponsePerReplica</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.size" title="=&gt; Int">size</a> <span title="(x: Int)Boolean">==</span> <a href="#kafka.tools;ReplicaBuffer.expectedReplicasPerTopicAndPartition" title="(key: kafka.common.TopicAndPartition)Int">expectedReplicasPerTopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>,
            <span title="String(&quot;fetched &quot;)" class="string">&quot;fetched &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.fetchResponsePerReplica" title="kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData]">fetchResponsePerReplica</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.size" title="=&gt; Int">size</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; replicas for &quot;)" class="string">&quot; replicas for &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, but expected &quot;)" class="string">&quot;, but expected &quot;</span>
            <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.expectedReplicasPerTopicAndPartition" title="(key: kafka.common.TopicAndPartition)Int">expectedReplicasPerTopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; replicas&quot;)" class="string">&quot; replicas&quot;</span><span class="delimiter">)</span>
      val <a title="Iterable[(Int, Iterator[kafka.message.MessageAndOffset])]" id="kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.messageIteratorMap">messageIteratorMap</a> = <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.fetchResponsePerReplica" title="kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData]">fetchResponsePerReplica</a>.<span title="(f: ((Int, kafka.api.FetchResponsePartitionData)) =&gt; (Int, Iterator[kafka.message.MessageAndOffset]))(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[(Int, kafka.api.FetchResponsePartitionData)],(Int, Iterator[kafka.message.MessageAndOffset]),Iterable[(Int, Iterator[kafka.message.MessageAndOffset])]])Iterable[(Int, Iterator[kafka.message.MessageAndOffset])]">map</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.messageIteratorMap.$anonfun.x0$8" title="(Int, Iterator[kafka.message.MessageAndOffset])" class="delimiter">{</a>
        case<span class="delimiter">(</span><a title="Int" id="kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.messageIteratorMap.$anonfun.replicaId">replicaId</a>, <a title="kafka.api.FetchResponsePartitionData" id="kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.messageIteratorMap.$anonfun.fetchResponse">fetchResponse</a><span class="delimiter">)</span> =&gt;
          <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.messageIteratorMap.$anonfun.replicaId" title="(self: Int)ArrowAssoc[Int]">replicaId</a> <span title="(y: Iterator[kafka.message.MessageAndOffset])(Int, Iterator[kafka.message.MessageAndOffset])">-&gt;</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.messageIteratorMap.$anonfun.fetchResponse" title="kafka.api.FetchResponsePartitionData">fetchResponse</a>.<a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData.messages" title="=&gt; kafka.message.MessageSet">messages</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="kafka.message.ByteBufferMessageSet" class="delimiter">[</span><a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet" title="kafka.message.ByteBufferMessageSet">ByteBufferMessageSet</a><span class="delimiter">]</span>.<a href="../message/ByteBufferMessageSet.scala.html#kafka.message;ByteBufferMessageSet.shallowIterator" title="=&gt; Iterator[kafka.message.MessageAndOffset]">shallowIterator</a><span class="delimiter">}</span>
      val <a title="Long" id="kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.maxHw">maxHw</a> = <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.fetchResponsePerReplica" title="kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData]">fetchResponsePerReplica</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.values" title="=&gt; Iterable[kafka.api.FetchResponsePartitionData]">values</a>.<span title="(f: kafka.api.FetchResponsePartitionData =&gt; Long)(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[kafka.api.FetchResponsePartitionData],Long,Iterable[Long]])Iterable[Long]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,Long,Iterable[Long]]" class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.maxHw.$anonfun.x$6" title="kafka.api.FetchResponsePartitionData">_</a>.<a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData.hw" title="=&gt; Long">hw</a><span class="delimiter">)</span>.<span title="(implicit cmp: Ordering[Long])Long">max</span>

      <span class="comment">// Iterate one message at a time from every replica, until high watermark is reached.</span>
      var <a title="Boolean" id="kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.isMessageInAllReplicas">isMessageInAllReplicas</a> = true
      while <span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.isMessageInAllReplicas" title="Boolean">isMessageInAllReplicas</a><span class="delimiter">)</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.while$1" title="()Unit" class="delimiter">{</a>
        var <a title="Option[kafka.tools.MessageInfo]" id="kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.messageInfoFromFirstReplicaOpt">messageInfoFromFirstReplicaOpt</a>: <span title="Option[kafka.tools.MessageInfo]">Option</span><span class="delimiter">[</span>MessageInfo<span class="delimiter">]</span> = <span title="None.type">None</span>
        for <span class="delimiter">(</span> <span class="delimiter">(</span><a title="Int" id="kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.replicaId">replicaId</a>, <a title="Iterator[kafka.message.MessageAndOffset]" id="kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageIterator">messageIterator</a><span class="delimiter">)</span> &lt;- <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.messageIteratorMap" title="(f: ((Int, Iterator[kafka.message.MessageAndOffset])) =&gt; Unit)Unit">messageIteratorMap</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          try <span class="delimiter">{</span>
            if <span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageIterator" title="Iterator[kafka.message.MessageAndOffset]">messageIterator</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              val <a title="kafka.message.MessageAndOffset" id="kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageAndOffset">messageAndOffset</a> = <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageIterator" title="Iterator[kafka.message.MessageAndOffset]">messageIterator</a>.<span title="()kafka.message.MessageAndOffset">next</span><span class="delimiter">(</span><span class="delimiter">)</span>

              <span class="comment">// only verify up to the high watermark</span>
              if <span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageAndOffset" title="kafka.message.MessageAndOffset">messageAndOffset</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.offset" title="=&gt; Long">offset</a> <span title="(x: Long)Boolean">&gt;=</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.fetchResponsePerReplica" title="kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData]">fetchResponsePerReplica</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.get" title="(key: Int)kafka.api.FetchResponsePartitionData">get</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.replicaId" title="Int">replicaId</a><span class="delimiter">)</span>.<a href="../api/FetchResponse.scala.html#kafka.api;FetchResponsePartitionData.hw" title="=&gt; Long">hw</a><span class="delimiter">)</span>
                <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.isMessageInAllReplicas" title="Boolean">isMessageInAllReplicas</a> = false
              else <span class="delimiter">{</span>
                <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.messageInfoFromFirstReplicaOpt" title="Option[kafka.tools.MessageInfo]">messageInfoFromFirstReplicaOpt</a> match <span class="delimiter">{</span>
                  case <span title="None.type">None</span> =&gt;
                    <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.messageInfoFromFirstReplicaOpt" title="Option[kafka.tools.MessageInfo]">messageInfoFromFirstReplicaOpt</a> = <span title="(x: kafka.tools.MessageInfo)Some[kafka.tools.MessageInfo]">Some</span><span class="delimiter">(</span>
                      <a href="#kafka.tools.MessageInfo.readResolve" title="(replicaId: Int, offset: Long, nextOffset: Long, checksum: Long)kafka.tools.MessageInfo">MessageInfo</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.replicaId" title="Int">replicaId</a>, <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageAndOffset" title="kafka.message.MessageAndOffset">messageAndOffset</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.offset" title="=&gt; Long">offset</a>,<a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageAndOffset" title="kafka.message.MessageAndOffset">messageAndOffset</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.nextOffset" title="=&gt; Long">nextOffset</a>, <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageAndOffset" title="kafka.message.MessageAndOffset">messageAndOffset</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a>.<a href="../message/Message.scala.html#kafka.message;Message.checksum" title="=&gt; Long">checksum</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  case Some<span class="delimiter">(</span><a title="kafka.tools.MessageInfo" id="kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageInfoFromFirstReplica">messageInfoFromFirstReplica</a><span class="delimiter">)</span> =&gt;
                    if <span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageInfoFromFirstReplica" title="kafka.tools.MessageInfo">messageInfoFromFirstReplica</a>.<a href="#kafka.tools;MessageInfo.offset" title="=&gt; Long">offset</a> <span title="(x: Long)Boolean">!=</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageAndOffset" title="kafka.message.MessageAndOffset">messageAndOffset</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.offset" title="=&gt; Long">offset</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                      <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool" title="kafka.tools.ReplicaVerificationTool.type">ReplicaVerificationTool</a>.<a href="#kafka.tools.ReplicaVerificationTool.getCurrentTimeString" title="()String">getCurrentTimeString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;: partition &quot;)" class="string">&quot;: partition &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>
                        <span title="(x$1: Any)String">+</span> <span title="String(&quot;: replica &quot;)" class="string">&quot;: replica &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageInfoFromFirstReplica" title="kafka.tools.MessageInfo">messageInfoFromFirstReplica</a>.<a href="#kafka.tools;MessageInfo.replicaId" title="=&gt; Int">replicaId</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\'s offset &quot;)" class="string">&quot;'s offset &quot;</span>
                        <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageInfoFromFirstReplica" title="kafka.tools.MessageInfo">messageInfoFromFirstReplica</a>.<a href="#kafka.tools;MessageInfo.offset" title="=&gt; Long">offset</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; doesn\'t match replica &quot;)" class="string">&quot; doesn't match replica &quot;</span>
                        <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.replicaId" title="Int">replicaId</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\'s offset &quot;)" class="string">&quot;'s offset &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageAndOffset" title="kafka.message.MessageAndOffset">messageAndOffset</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.offset" title="=&gt; Long">offset</a><span class="delimiter">)</span>
                      <span title="System.type">System</span>.<span title="(x$1: Int)Unit">exit</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
                    <span class="delimiter">}</span>
                    if <span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageInfoFromFirstReplica" title="kafka.tools.MessageInfo">messageInfoFromFirstReplica</a>.<a href="#kafka.tools;MessageInfo.checksum" title="=&gt; Long">checksum</a> <span title="(x: Long)Boolean">!=</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageAndOffset" title="kafka.message.MessageAndOffset">messageAndOffset</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a>.<a href="../message/Message.scala.html#kafka.message;Message.checksum" title="=&gt; Long">checksum</a><span class="delimiter">)</span>
                      <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool" title="kafka.tools.ReplicaVerificationTool.type">ReplicaVerificationTool</a>.<a href="#kafka.tools.ReplicaVerificationTool.getCurrentTimeString" title="()String">getCurrentTimeString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;: partition &quot;)" class="string">&quot;: partition &quot;</span>
                        <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; has unmatched checksum at offset &quot;)" class="string">&quot; has unmatched checksum at offset &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageAndOffset" title="kafka.message.MessageAndOffset">messageAndOffset</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.offset" title="=&gt; Long">offset</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;; replica &quot;)" class="string">&quot;; replica &quot;</span>
                        <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageInfoFromFirstReplica" title="kafka.tools.MessageInfo">messageInfoFromFirstReplica</a>.<a href="#kafka.tools;MessageInfo.replicaId" title="=&gt; Int">replicaId</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\'s checksum &quot;)" class="string">&quot;'s checksum &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageInfoFromFirstReplica" title="kafka.tools.MessageInfo">messageInfoFromFirstReplica</a>.<a href="#kafka.tools;MessageInfo.checksum" title="=&gt; Long">checksum</a>
                        <span title="(x$1: Any)String">+</span> <span title="String(&quot;; replica &quot;)" class="string">&quot;; replica &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.replicaId" title="Int">replicaId</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\'s checksum &quot;)" class="string">&quot;'s checksum &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.messageAndOffset" title="kafka.message.MessageAndOffset">messageAndOffset</a>.<a href="../message/MessageAndOffset.scala.html#kafka.message;MessageAndOffset.message" title="=&gt; kafka.message.Message">message</a>.<a href="../message/Message.scala.html#kafka.message;Message.checksum" title="=&gt; Long">checksum</a><span class="delimiter">)</span>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span> else
              <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.isMessageInAllReplicas" title="Boolean">isMessageInAllReplicas</a> = false
          <span class="delimiter">}</span> catch <span class="delimiter">{</span>
            case <a title="Throwable" id="kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.t">t</a>: <span title="Throwable">Throwable</span> =&gt;
              throw new <span title="RuntimeException">RuntimeException</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Error in processing replica %d in partition %s at offset %d.&quot;</span>
              .<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.replicaId" title="Int">replicaId</a>, <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.tools;ReplicaBuffer.fetchOffsetMap" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,Long]">fetchOffsetMap</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.get" title="(key: kafka.common.TopicAndPartition)Long">get</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.$anonfun.t" title="Throwable">t</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        if <span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.isMessageInAllReplicas" title="Boolean">isMessageInAllReplicas</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          val <a title="Long" id="kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.nextOffset">nextOffset</a> = <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.messageInfoFromFirstReplicaOpt" title="Option[kafka.tools.MessageInfo]">messageInfoFromFirstReplicaOpt</a>.<span title="=&gt; kafka.tools.MessageInfo">get</span>.<a href="#kafka.tools;MessageInfo.nextOffset" title="=&gt; Long">nextOffset</a>
          <a href="#kafka.tools;ReplicaBuffer.fetchOffsetMap" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,Long]">fetchOffsetMap</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.put" title="(k: kafka.common.TopicAndPartition, v: Long)Long">put</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>, <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.nextOffset" title="Long">nextOffset</a><span class="delimiter">)</span>
          <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.expectedReplicasPerTopicAndPartition" title="(key: kafka.common.TopicAndPartition)Int">expectedReplicasPerTopicAndPartition</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span> <span title="(x: String)String">+</span> <span title="String(&quot; replicas match at offset &quot;)" class="string">&quot; replicas match at offset &quot;</span> <span title="(x$1: Any)String">+</span>
                <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.nextOffset" title="Long">nextOffset</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; for &quot;)" class="string">&quot; for &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      if <span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.maxHw" title="Long">maxHw</a> <span title="(x: Long)Long">-</span> <a href="#kafka.tools;ReplicaBuffer.fetchOffsetMap" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,Long]">fetchOffsetMap</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.get" title="(key: kafka.common.TopicAndPartition)Long">get</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span> <span title="(x: Long)Boolean">&gt;</span> <a href="#kafka.tools;ReplicaBuffer.maxLag_=" title="=&gt; Long">maxLag</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#kafka.tools;ReplicaBuffer.offsetWithMaxLag_=" title="(x$1: Long)Unit">offsetWithMaxLag</a> = <a href="#kafka.tools;ReplicaBuffer.fetchOffsetMap" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,Long]">fetchOffsetMap</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.get" title="(key: kafka.common.TopicAndPartition)Long">get</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a><span class="delimiter">)</span>
        <a href="#kafka.tools;ReplicaBuffer.maxLag_=" title="(x$1: Long)Unit">maxLag</a> = <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.maxHw" title="Long">maxHw</a> <span title="(x: Long)Long">-</span> <a href="#kafka.tools;ReplicaBuffer.offsetWithMaxLag_=" title="=&gt; Long">offsetWithMaxLag</a>
        <a href="#kafka.tools;ReplicaBuffer.maxLagTopicAndPartition_=" title="(x$1: kafka.common.TopicAndPartition)Unit">maxLagTopicAndPartition</a> = <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.topicAndPartition" title="kafka.common.TopicAndPartition">topicAndPartition</a>
      <span class="delimiter">}</span>
      <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.$anonfun.fetchResponsePerReplica" title="kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData]">fetchResponsePerReplica</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.clear" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    val <a title="Long" id="kafka.tools;ReplicaBuffer.verifyCheckSum.currentTimeMs">currentTimeMs</a> = <a href="../utils/Time.scala.html#kafka.utils.SystemTime" title="kafka.utils.SystemTime.type">SystemTime</a>.<a href="../utils/Time.scala.html#kafka.utils.SystemTime.milliseconds" title="=&gt; Long">milliseconds</a>
    if <span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.currentTimeMs" title="Long">currentTimeMs</a> <span title="(x: Long)Long">-</span> <a href="#kafka.tools;ReplicaBuffer.lastReportTime_=" title="=&gt; Long">lastReportTime</a> <span title="(x: Long)Boolean">&gt;</span> <a href="#kafka.tools;ReplicaBuffer.reportInterval" title="Long">reportInterval</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool" title="kafka.tools.ReplicaVerificationTool.type">ReplicaVerificationTool</a>.<a href="#kafka.tools.ReplicaVerificationTool.dateFormat" title="=&gt; java.text.SimpleDateFormat">dateFormat</a>.<span title="(x$1: java.util.Date)String">format</span><span class="delimiter">(</span>new <span title="java.util.Date">Date</span><span class="delimiter">(</span><a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.currentTimeMs" title="Long">currentTimeMs</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;: max lag is &quot;)" class="string">&quot;: max lag is &quot;</span>
        <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.maxLag_=" title="=&gt; Long">maxLag</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; for partition &quot;)" class="string">&quot; for partition &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.maxLagTopicAndPartition_=" title="=&gt; kafka.common.TopicAndPartition">maxLagTopicAndPartition</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; at offset &quot;)" class="string">&quot; at offset &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.offsetWithMaxLag_=" title="=&gt; Long">offsetWithMaxLag</a>
        <span title="(x$1: Any)String">+</span> <span title="String(&quot; among &quot;)" class="string">&quot; among &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaBuffer.messageSetCache" title="=&gt; kafka.utils.Pool[kafka.common.TopicAndPartition,kafka.utils.Pool[Int,kafka.api.FetchResponsePartitionData]]">messageSetCache</a>.<a href="../utils/Pool.scala.html#kafka.utils;Pool.size" title="=&gt; Int">size</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; paritions&quot;)" class="string">&quot; paritions&quot;</span><span class="delimiter">)</span>
      <a href="#kafka.tools;ReplicaBuffer.lastReportTime_=" title="(x$1: Long)Unit">lastReportTime</a> = <a href="#kafka.tools;ReplicaBuffer.verifyCheckSum.currentTimeMs" title="Long">currentTimeMs</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

private class <a title="class ReplicaFetcher extends kafka.utils.ShutdownableThread" id="kafka.tools;ReplicaFetcher">ReplicaFetcher</a><a href="#kafka.tools;ReplicaFetcher" title="kafka.tools.ReplicaFetcher" class="delimiter">(</a><a title="String" id="kafka.tools;ReplicaFetcher.name">name</a>: <span title="String">String</span>, <a title="kafka.cluster.Broker" id="kafka.tools;ReplicaFetcher.sourceBroker">sourceBroker</a>: <a href="../cluster/Broker.scala.html#kafka.cluster;Broker" title="kafka.cluster.Broker">Broker</a>, <a title="Iterable[kafka.common.TopicAndPartition]" id="kafka.tools;ReplicaFetcher.topicAndPartitions">topicAndPartitions</a>: <span title="Iterable[kafka.common.TopicAndPartition]">Iterable</span><span class="delimiter">[</span>TopicAndPartition<span class="delimiter">]</span>,
                             <a title="kafka.tools.ReplicaBuffer" id="kafka.tools;ReplicaFetcher.replicaBuffer">replicaBuffer</a>: <a href="#kafka.tools;ReplicaBuffer" title="kafka.tools.ReplicaBuffer">ReplicaBuffer</a>, <a title="Int" id="kafka.tools;ReplicaFetcher.socketTimeout">socketTimeout</a>: <span title="Int">Int</span>, <a title="Int" id="kafka.tools;ReplicaFetcher.socketBufferSize">socketBufferSize</a>: <span title="Int">Int</span>,
                             <a title="Int" id="kafka.tools;ReplicaFetcher.fetchSize">fetchSize</a>: <span title="Int">Int</span>, <a title="Int" id="kafka.tools;ReplicaFetcher.maxWait">maxWait</a>: <span title="Int">Int</span>, <a title="Int" id="kafka.tools;ReplicaFetcher.minBytes">minBytes</a>: <span title="Int">Int</span>, <a title="Boolean" id="kafka.tools;ReplicaFetcher.doVerification">doVerification</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>
  extends <a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread" title="kafka.utils.ShutdownableThread">ShutdownableThread</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaFetcher.name" title="String">name</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  val <a title="kafka.consumer.SimpleConsumer" id="kafka.tools;ReplicaFetcher.simpleConsumer">simpleConsumer</a> = new <a href="../consumer/SimpleConsumer.scala.html#kafka.consumer;SimpleConsumer" title="kafka.consumer.SimpleConsumer">SimpleConsumer</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaFetcher.sourceBroker" title="kafka.cluster.Broker">sourceBroker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.host" title="=&gt; String">host</a>, <a href="#kafka.tools;ReplicaFetcher.sourceBroker" title="kafka.cluster.Broker">sourceBroker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.port" title="=&gt; Int">port</a>, <a href="#kafka.tools;ReplicaFetcher.socketTimeout" title="Int">socketTimeout</a>, <a href="#kafka.tools;ReplicaFetcher.socketBufferSize" title="Int">socketBufferSize</a>, <a href="#kafka.tools.ReplicaVerificationTool" title="kafka.tools.ReplicaVerificationTool.type">ReplicaVerificationTool</a>.<a href="#kafka.tools.ReplicaVerificationTool.clientId" title="=&gt; String">clientId</a><span class="delimiter">)</span>
  val <a title="kafka.api.FetchRequestBuilder" id="kafka.tools;ReplicaFetcher.fetchRequestBuilder">fetchRequestBuilder</a> = new <a href="../api/FetchRequest.scala.html#kafka.api;FetchRequestBuilder" title="kafka.api.FetchRequestBuilder">FetchRequestBuilder</a><span class="delimiter">(</span><span class="delimiter">)</span>.
          <a href="../api/FetchRequest.scala.html#kafka.api;FetchRequestBuilder.clientId(17e2242513)" title="(clientId: String)kafka.api.FetchRequestBuilder">clientId</a><span class="delimiter">(</span><a href="#kafka.tools.ReplicaVerificationTool" title="kafka.tools.ReplicaVerificationTool.type">ReplicaVerificationTool</a>.<a href="#kafka.tools.ReplicaVerificationTool.clientId" title="=&gt; String">clientId</a><span class="delimiter">)</span>.
          <a href="../api/FetchRequest.scala.html#kafka.api;FetchRequestBuilder.replicaId(7eb26614fa)" title="(replicaId: Int)kafka.api.FetchRequestBuilder">replicaId</a><span class="delimiter">(</span><a href="../api/RequestOrResponse.scala.html#kafka.api.Request" title="kafka.api.Request.type">Request</a>.<a href="../api/RequestOrResponse.scala.html#kafka.api.Request.DebuggingConsumerId" title="=&gt; Int">DebuggingConsumerId</a><span class="delimiter">)</span>.
          <a href="../api/FetchRequest.scala.html#kafka.api;FetchRequestBuilder.maxWait(d4d9aed259)" title="(maxWait: Int)kafka.api.FetchRequestBuilder">maxWait</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaFetcher.maxWait" title="Int">maxWait</a><span class="delimiter">)</span>.
          <a href="../api/FetchRequest.scala.html#kafka.api;FetchRequestBuilder.minBytes(2fa6b5486f)" title="(minBytes: Int)kafka.api.FetchRequestBuilder">minBytes</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaFetcher.minBytes" title="Int">minBytes</a><span class="delimiter">)</span>

  override def <a title="()Unit" id="kafka.tools;ReplicaFetcher.doWork">doWork</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    val <a title="java.util.concurrent.CountDownLatch" id="kafka.tools;ReplicaFetcher.doWork.fetcherBarrier">fetcherBarrier</a> = <a href="#kafka.tools;ReplicaFetcher.replicaBuffer" title="kafka.tools.ReplicaBuffer">replicaBuffer</a>.<a href="#kafka.tools;ReplicaBuffer.getFetcherBarrier" title="()java.util.concurrent.CountDownLatch">getFetcherBarrier</a><span class="delimiter">(</span><span class="delimiter">)</span>
    val <a title="java.util.concurrent.CountDownLatch" id="kafka.tools;ReplicaFetcher.doWork.verificationBarrier">verificationBarrier</a> = <a href="#kafka.tools;ReplicaFetcher.replicaBuffer" title="kafka.tools.ReplicaBuffer">replicaBuffer</a>.<a href="#kafka.tools;ReplicaBuffer.getVerificationBarrier" title="()java.util.concurrent.CountDownLatch">getVerificationBarrier</a><span class="delimiter">(</span><span class="delimiter">)</span>

    for <span class="delimiter">(</span><span title="kafka.common.TopicAndPartition">topicAndPartition</span> &lt;- <a href="#kafka.tools;ReplicaFetcher.topicAndPartitions" title="(f: kafka.common.TopicAndPartition =&gt; kafka.api.FetchRequestBuilder)Unit">topicAndPartitions</a><span class="delimiter">)</span>
      <a href="#kafka.tools;ReplicaFetcher.fetchRequestBuilder" title="=&gt; kafka.api.FetchRequestBuilder">fetchRequestBuilder</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequestBuilder.addFetch" title="(topic: String, partition: Int, offset: Long, fetchSize: Int)kafka.api.FetchRequestBuilder">addFetch</a><span class="delimiter">(</span><span title="kafka.common.TopicAndPartition">topicAndPartition</span>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.topic" title="=&gt; String">topic</a>, <span title="kafka.common.TopicAndPartition">topicAndPartition</span>.<a href="../common/TopicAndPartition.scala.html#kafka.common;TopicAndPartition.partition" title="=&gt; Int">partition</a>,
        <a href="#kafka.tools;ReplicaFetcher.replicaBuffer" title="kafka.tools.ReplicaBuffer">replicaBuffer</a>.<a href="#kafka.tools;ReplicaBuffer.getOffset" title="(topicAndPartition: kafka.common.TopicAndPartition)Long">getOffset</a><span class="delimiter">(</span><span title="kafka.common.TopicAndPartition">topicAndPartition</span><span class="delimiter">)</span>, <a href="#kafka.tools;ReplicaFetcher.fetchSize" title="Int">fetchSize</a><span class="delimiter">)</span>

    val <a title="kafka.api.FetchRequest" id="kafka.tools;ReplicaFetcher.doWork.fetchRequest">fetchRequest</a> = <a href="#kafka.tools;ReplicaFetcher.fetchRequestBuilder" title="=&gt; kafka.api.FetchRequestBuilder">fetchRequestBuilder</a>.<a href="../api/FetchRequest.scala.html#kafka.api;FetchRequestBuilder.build" title="()kafka.api.FetchRequest">build</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Issuing fetch request &quot;)" class="string">&quot;Issuing fetch request &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#kafka.tools;ReplicaFetcher.doWork.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a><span class="delimiter">)</span>

    var <a title="kafka.api.FetchResponse" id="kafka.tools;ReplicaFetcher.doWork.response">response</a>: <a href="../api/FetchResponse.scala.html#kafka.api;FetchResponse" title="kafka.api.FetchResponse">FetchResponse</a> = null
    try <span class="delimiter">{</span>
      <a href="#kafka.tools;ReplicaFetcher.doWork.response" title="kafka.api.FetchResponse">response</a> = <a href="#kafka.tools;ReplicaFetcher.simpleConsumer" title="=&gt; kafka.consumer.SimpleConsumer">simpleConsumer</a>.<a href="../consumer/SimpleConsumer.scala.html#kafka.consumer;SimpleConsumer.fetch" title="(request: kafka.api.FetchRequest)kafka.api.FetchResponse">fetch</a><span class="delimiter">(</span><a href="#kafka.tools;ReplicaFetcher.doWork.fetchRequest" title="kafka.api.FetchRequest">fetchRequest</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> catch <span class="delimiter">{</span>
      case <a title="Throwable" id="kafka.tools;ReplicaFetcher.doWork.t">t</a>: <span title="Throwable">Throwable</span> =&gt;
        if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="../utils/ShutdownableThread.scala.html#kafka.utils;ShutdownableThread.isRunning" title="=&gt; java.util.concurrent.atomic.AtomicBoolean">isRunning</a>.<span title="()Boolean">get</span><span class="delimiter">)</span>
          throw <a href="#kafka.tools;ReplicaFetcher.doWork.t" title="Throwable">t</a>
    <span class="delimiter">}</span>

    if <span class="delimiter">(</span><a href="#kafka.tools;ReplicaFetcher.doWork.response" title="kafka.api.FetchResponse">response</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#kafka.tools;ReplicaFetcher.doWork.response" title="kafka.api.FetchResponse">response</a>.<a href="../api/FetchResponse.scala.html#kafka.api;FetchResponse.data" title="=&gt; Map[kafka.common.TopicAndPartition,kafka.api.FetchResponsePartitionData]">data</a>.<span title="(f: ((kafka.common.TopicAndPartition, kafka.api.FetchResponsePartitionData)) =&gt; Unit)Unit">foreach</span> <a href="#kafka.tools;ReplicaFetcher.doWork.$anonfun.x0$9" title="Unit" class="delimiter">{</a>
        case<span class="delimiter">(</span><span title="kafka.common.TopicAndPartition">topicAndPartition</span>, <a title="kafka.api.FetchResponsePartitionData" id="kafka.tools;ReplicaFetcher.doWork.$anonfun.partitionData">partitionData</a><span class="delimiter">)</span> =&gt;
          <a href="#kafka.tools;ReplicaFetcher.replicaBuffer" title="kafka.tools.ReplicaBuffer">replicaBuffer</a>.<a href="#kafka.tools;ReplicaBuffer.addFetchedData" title="(topicAndPartition: kafka.common.TopicAndPartition, replicaId: Int, partitionData: kafka.api.FetchResponsePartitionData)Unit">addFetchedData</a><span class="delimiter">(</span><span title="kafka.common.TopicAndPartition">topicAndPartition</span>, <a href="#kafka.tools;ReplicaFetcher.sourceBroker" title="kafka.cluster.Broker">sourceBroker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.id" title="=&gt; Int">id</a>, <a href="#kafka.tools;ReplicaFetcher.doWork.$anonfun.partitionData" title="kafka.api.FetchResponsePartitionData">partitionData</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      for <span class="delimiter">(</span><span title="kafka.common.TopicAndPartition">topicAndPartition</span> &lt;- <a href="#kafka.tools;ReplicaFetcher.topicAndPartitions" title="(f: kafka.common.TopicAndPartition =&gt; Unit)Unit">topicAndPartitions</a><span class="delimiter">)</span>
        <a href="#kafka.tools;ReplicaFetcher.replicaBuffer" title="kafka.tools.ReplicaBuffer">replicaBuffer</a>.<a href="#kafka.tools;ReplicaBuffer.addFetchedData" title="(topicAndPartition: kafka.common.TopicAndPartition, replicaId: Int, partitionData: kafka.api.FetchResponsePartitionData)Unit">addFetchedData</a><span class="delimiter">(</span><span title="kafka.common.TopicAndPartition">topicAndPartition</span>, <a href="#kafka.tools;ReplicaFetcher.sourceBroker" title="kafka.cluster.Broker">sourceBroker</a>.<a href="../cluster/Broker.scala.html#kafka.cluster;Broker.id" title="=&gt; Int">id</a>, new <a href="../api/FetchResponse.scala.html#kafka.api.FetchResponsePartitionData" title="kafka.api.FetchResponsePartitionData.type">FetchResponsePartitionData</a><span class="delimiter">(</span>messages = <a href="../message/MessageSet.scala.html#kafka.message.MessageSet" title="kafka.message.MessageSet.type">MessageSet</a>.<a href="../message/MessageSet.scala.html#kafka.message.MessageSet.Empty" title="kafka.message.ByteBufferMessageSet" id="kafka.tools;ReplicaFetcher.doWork.$anonfun.x$9">Empty</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#kafka.tools;ReplicaFetcher.doWork.fetcherBarrier" title="java.util.concurrent.CountDownLatch">fetcherBarrier</a>.<span title="()Unit">countDown</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Done fetching&quot;)" class="string">&quot;Done fetching&quot;</span><span class="delimiter">)</span>

    <span class="comment">// wait for all fetchers to finish</span>
    <a href="#kafka.tools;ReplicaFetcher.doWork.fetcherBarrier" title="java.util.concurrent.CountDownLatch">fetcherBarrier</a>.<span title="()Unit">await</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Ready for verification&quot;)" class="string">&quot;Ready for verification&quot;</span><span class="delimiter">)</span>

    <span class="comment">// one of the fetchers will do the verification</span>
    if <span class="delimiter">(</span><a href="#kafka.tools;ReplicaFetcher.doVerification" title="Boolean">doVerification</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Do verification&quot;)" class="string">&quot;Do verification&quot;</span><span class="delimiter">)</span>
      <a href="#kafka.tools;ReplicaFetcher.replicaBuffer" title="kafka.tools.ReplicaBuffer">replicaBuffer</a>.<a href="#kafka.tools;ReplicaBuffer.verifyCheckSum" title="()Unit">verifyCheckSum</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#kafka.tools;ReplicaFetcher.replicaBuffer" title="kafka.tools.ReplicaBuffer">replicaBuffer</a>.<a href="#kafka.tools;ReplicaBuffer.createNewFetcherBarrier" title="()Unit">createNewFetcherBarrier</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#kafka.tools;ReplicaFetcher.replicaBuffer" title="kafka.tools.ReplicaBuffer">replicaBuffer</a>.<a href="#kafka.tools;ReplicaBuffer.createNewVerificationBarrier" title="()Unit">createNewVerificationBarrier</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Created new barrier&quot;)" class="string">&quot;Created new barrier&quot;</span><span class="delimiter">)</span>
      <a href="#kafka.tools;ReplicaFetcher.doWork.verificationBarrier" title="java.util.concurrent.CountDownLatch">verificationBarrier</a>.<span title="()Unit">countDown</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#kafka.tools;ReplicaFetcher.doWork.verificationBarrier" title="java.util.concurrent.CountDownLatch">verificationBarrier</a>.<span title="()Unit">await</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="../utils/Logging.scala.html#kafka.utils;Logging.debug(1729dbc42f)" title="(msg: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;Done verification&quot;)" class="string">&quot;Done verification&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>
        </pre>
    </body>
</html>
